#!/usr/bin/env node
'use strict';

var require$$0$3 = require('process');
var require$$0$4 = require('crypto');
var require$$0$5 = require('fs/promises');
var require$$0$7 = require('child_process');
var require$$0$6 = require('fs');
var require$$3$1 = require('tty');
var require$$0$b = require('events');
var require$$1$2 = require('https');
var require$$2$2 = require('http');
var require$$3$2 = require('net');
var require$$4$1 = require('tls');
var require$$0$a = require('stream');
var require$$7$1 = require('url');
var require$$0$8 = require('zlib');
var require$$1$1 = require('path');
var require$$2$1 = require('os');
var require$$0$9 = require('buffer');
var require$$5$1 = require('node:fs/promises');
var require$$7$2 = require('node:path');
var require$$5$2 = require('node:process');
var require$$1$3 = require('readline');
var require$$0$c = require('assert');
var require$$0$d = require('util');
var require$$1$4 = require('string_decoder');
var require$$4$2 = require('node:child_process');
var require$$6$1 = require('node:os');

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var cjs$6 = {};

var cjs$5 = {};

var LazySignal = {};

var Event = {};

var Subscribable = {};

var hasRequiredSubscribable;

function requireSubscribable () {
	if (hasRequiredSubscribable) return Subscribable;
	hasRequiredSubscribable = 1;
	Object.defineProperty(Subscribable, "__esModule", { value: true });
	Subscribable.Subscribable = void 0;
	const LazySignal_js_1 = /*@__PURE__*/ requireLazySignal();
	function isSignalLike(value) {
	    return (typeof value === "object" &&
	        value !== null &&
	        typeof value.get === "function" &&
	        typeof value.subscribe === "function");
	}
	/**
	 * Base class for objects that can be subscribed to. Provides common utility methods.
	 */
	let Subscribable$1 = class Subscribable {
	    subscribeWithCleaner(cleaner, listener) {
	        const unsubscribe = this.subscribe(listener);
	        cleaner.register(unsubscribe);
	    }
	    subscribeOnce(listener) {
	        const unsubscribe = this.subscribe(data => {
	            unsubscribe();
	            listener(data);
	        });
	        return unsubscribe;
	    }
	    subscribeOnceWithCleaner(cleaner, listener) {
	        const unsubscribe = this.subscribeOnce(listener);
	        cleaner.register(unsubscribe);
	    }
	    derive(deriver, outputEqualsPredicate = (a, b) => a === b) {
	        if (isSignalLike(this)) {
	            return LazySignal_js_1.LazySignal.deriveFrom([this], deriver);
	        }
	        const thisWithGetter = this;
	        if (thisWithGetter.get !== undefined) {
	            const initialValue = thisWithGetter.get();
	            if (initialValue === LazySignal_js_1.LazySignal.NOT_AVAILABLE) {
	                return LazySignal_js_1.LazySignal.createWithoutInitialValue(setDownstream => {
	                    return thisWithGetter.subscribe(data => {
	                        if ((0, LazySignal_js_1.isAvailable)(data)) {
	                            setDownstream(deriver(data));
	                        }
	                    });
	                });
	            }
	            const thisNarrowed = thisWithGetter;
	            return LazySignal_js_1.LazySignal.create(deriver(thisNarrowed.get()), setDownstream => {
	                return thisNarrowed.subscribe(data => {
	                    setDownstream(deriver(data));
	                });
	            }, outputEqualsPredicate);
	        }
	        return LazySignal_js_1.LazySignal.createWithoutInitialValue(setDownstream => {
	            return this.subscribe(data => {
	                if ((0, LazySignal_js_1.isAvailable)(data)) {
	                    setDownstream(deriver(data));
	                }
	            });
	        }, outputEqualsPredicate);
	    }
	};
	Subscribable.Subscribable = Subscribable$1;
	
	return Subscribable;
}

var hasRequiredEvent;

function requireEvent () {
	if (hasRequiredEvent) return Event;
	hasRequiredEvent = 1;
	Object.defineProperty(Event, "__esModule", { value: true });
	Event.Event = void 0;
	const Subscribable_js_1 = /*@__PURE__*/ requireSubscribable();
	/**
	 * Represents an event that can be subscribed to. Emitted events will trigger all subscribers in the
	 * next microtask. If multiple events are emitted, they will be triggered in the same microtask.
	 */
	let Event$1 = class Event extends Subscribable_js_1.Subscribable {
	    /**
	     * Internal state that tracks whether the event has any subscribers.
	     */
	    constructor() {
	        super();
	        this.subscribers = new Set();
	        /**
	         * Internal callback that is called when the number of subscribers goes from 0 to 1.
	         */
	        this.onSubscribed = null;
	        /**
	         * Internal callback that is called when the number of subscribers goes from 1 to 0.
	         */
	        this.onUnsubscribed = null;
	    }
	    emit(data) {
	        queueMicrotask(() => {
	            for (const subscriber of this.subscribers) {
	                subscriber(data);
	            }
	        });
	    }
	    static create() {
	        const event = new Event();
	        const emitter = data => {
	            event.emit(data);
	        };
	        return [event, emitter];
	    }
	    subscribe(listener) {
	        const previousSize = this.subscribers.size;
	        this.subscribers.add(listener);
	        if (previousSize === 0 && this.subscribers.size === 1) {
	            this.onSubscribed?.();
	        }
	        return () => {
	            const previousSize = this.subscribers.size;
	            this.subscribers.delete(listener);
	            if (previousSize === 1 && this.subscribers.size === 0) {
	                this.onUnsubscribed?.();
	            }
	        };
	    }
	    batch({ minIdleTimeMs = 200, maxBatchTimeMs = 1000, }) {
	        const [batchedEvent, emitBatchedEvent] = Event.create();
	        batchedEvent.onSubscribed = () => {
	            let batch = [];
	            let emitBatchTimeout = null;
	            let firstEventTime = 0;
	            const emitBatch = () => {
	                emitBatchTimeout = null;
	                emitBatchedEvent(batch);
	                batch = [];
	            };
	            batchedEvent.onUnsubscribed = this.subscribe(data => {
	                batch.push(data);
	                if (emitBatchTimeout === null) {
	                    // No scheduled batch
	                    firstEventTime = Date.now();
	                    emitBatchTimeout = setTimeout(emitBatch, Math.min(minIdleTimeMs, maxBatchTimeMs));
	                }
	                else {
	                    // Reschedule emission
	                    clearTimeout(emitBatchTimeout);
	                    const timeSinceFirstEvent = Date.now() - firstEventTime;
	                    emitBatchTimeout = setTimeout(emitBatch, Math.min(minIdleTimeMs, Math.max(0, maxBatchTimeMs - timeSinceFirstEvent)));
	                }
	            });
	        };
	        return batchedEvent;
	    }
	};
	Event.Event = Event$1;
	
	return Event;
}

var Signal = {};

var makePromise = {};

var hasRequiredMakePromise;

function requireMakePromise () {
	if (hasRequiredMakePromise) return makePromise;
	hasRequiredMakePromise = 1;
	Object.defineProperty(makePromise, "__esModule", { value: true });
	makePromise.makePromise = makePromise$1;
	function makePromise$1() {
	    let resolve;
	    let reject;
	    const promise = new Promise((_resolve, _reject) => {
	        resolve = _resolve;
	        reject = _reject;
	    });
	    return { promise, resolve: resolve, reject: reject };
	}
	
	return makePromise;
}

var makeSetter = {};

var cjs$4 = {exports: {}};

var immer_cjs_production;
var hasRequiredImmer_cjs_production;

function requireImmer_cjs_production () {
	if (hasRequiredImmer_cjs_production) return immer_cjs_production;
	hasRequiredImmer_cjs_production = 1;
var ne=Object.defineProperty;var xe=Object.getOwnPropertyDescriptor;var be=Object.getOwnPropertyNames;var Te=Object.prototype.hasOwnProperty;var Ae=(e,t)=>{for(var r in t)ne(e,r,{get:t[r],enumerable:!0});},Ie=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of be(t))!Te.call(e,i)&&i!==r&&ne(e,i,{get:()=>t[i],enumerable:!(n=xe(t,i))||n.enumerable});return e};var De=e=>Ie(ne({},"__esModule",{value:!0}),e);var Be={};Ae(Be,{Immer:()=>J,applyPatches:()=>Ce,castDraft:()=>Ke,castImmutable:()=>ke,createDraft:()=>Re,current:()=>re,finishDraft:()=>ve,freeze:()=>k,immerable:()=>N,isDraft:()=>O,isDraftable:()=>A,nothing:()=>j,original:()=>le,produce:()=>Fe,produceWithPatches:()=>Ne,setAutoFreeze:()=>ze,setUseStrictShallowCopy:()=>je});immer_cjs_production=De(Be);var j=Symbol.for("immer-nothing"),N=Symbol.for("immer-draftable"),u=Symbol.for("immer-state");function h(e,...t){throw new Error(`[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`)}var z=Object.getPrototypeOf;function O(e){return !!e&&!!e[u]}function A(e){return e?ye(e)||Array.isArray(e)||!!e[N]||!!e.constructor?.[N]||v(e)||K(e):!1}var Oe=Object.prototype.constructor.toString();function ye(e){if(!e||typeof e!="object")return !1;let t=z(e);if(t===null)return !0;let r=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return r===Object?!0:typeof r=="function"&&Function.toString.call(r)===Oe}function le(e){return O(e)||h(15,e),e[u].t}function _(e,t){C(e)===0?Reflect.ownKeys(e).forEach(r=>{t(r,e[r],e);}):e.forEach((r,n)=>t(n,r,e));}function C(e){let t=e[u];return t?t.o:Array.isArray(e)?1:v(e)?2:K(e)?3:0}function R(e,t){return C(e)===2?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function X(e,t){return C(e)===2?e.get(t):e[t]}function Q(e,t,r){let n=C(e);n===2?e.set(t,r):n===3?e.add(r):e[t]=r;}function pe(e,t){return e===t?e!==0||1/e===1/t:e!==e&&t!==t}function v(e){return e instanceof Map}function K(e){return e instanceof Set}function T(e){return e.e||e.t}function L(e,t){if(v(e))return new Map(e);if(K(e))return new Set(e);if(Array.isArray(e))return Array.prototype.slice.call(e);let r=ye(e);if(t===!0||t==="class_only"&&!r){let n=Object.getOwnPropertyDescriptors(e);delete n[u];let i=Reflect.ownKeys(n);for(let f=0;f<i.length;f++){let l=i[f],c=n[l];c.writable===!1&&(c.writable=!0,c.configurable=!0),(c.get||c.set)&&(n[l]={configurable:!0,writable:!0,enumerable:c.enumerable,value:e[l]});}return Object.create(z(e),n)}else {let n=z(e);if(n!==null&&r)return {...e};let i=Object.create(n);return Object.assign(i,e)}}function k(e,t=!1){return $(e)||O(e)||!A(e)||(C(e)>1&&(e.set=e.add=e.clear=e.delete=Me),Object.freeze(e),t&&Object.values(e).forEach(r=>k(r,!0))),e}function Me(){h(2);}function $(e){return Object.isFrozen(e)}var ae={};function w(e){let t=ae[e];return t||h(0,e),t}function Y(e,t){ae[e]||(ae[e]=t);}var U;function B(){return U}function _e(e,t){return {a:[],i:e,p:t,P:!0,d:0}}function oe(e,t){t&&(w("Patches"),e.f=[],e.m=[],e.b=t);}function V(e){Z(e),e.a.forEach(we),e.a=null;}function Z(e){e===U&&(U=e.i);}function ie(e){return U=_e(U,e)}function we(e){let t=e[u];t.o===0||t.o===1?t.x():t.h=!0;}function se(e,t){t.d=t.a.length;let r=t.a[0];return e!==void 0&&e!==r?(r[u].s&&(V(t),h(4)),A(e)&&(e=ee(t,e),t.i||te(t,e)),t.f&&w("Patches").T(r[u].t,e,t.f,t.m)):e=ee(t,r,[]),V(t),t.f&&t.b(t.f,t.m),e!==j?e:void 0}function ee(e,t,r){if($(t))return t;let n=t[u];if(!n)return _(t,(i,f)=>de(e,n,t,i,f,r)),t;if(n.n!==e)return t;if(!n.s)return te(e,n.t,!0),n.t;if(!n.c){n.c=!0,n.n.d--;let i=n.e,f=i,l=!1;n.o===3&&(f=new Set(i),i.clear(),l=!0),_(f,(c,b)=>de(e,n,i,c,b,r,l)),te(e,i,!1),r&&e.f&&w("Patches").g(n,r,e.f,e.m);}return n.e}function de(e,t,r,n,i,f,l){if(O(i)){let c=f&&t&&t.o!==3&&!R(t.r,n)?f.concat(n):void 0,b=ee(e,i,c);if(Q(r,n,b),O(b))e.P=!1;else return}else l&&r.add(i);if(A(i)&&!$(i)){if(!e.p.y&&e.d<1)return;ee(e,i),(!t||!t.n.i)&&typeof n!="symbol"&&Object.prototype.propertyIsEnumerable.call(r,n)&&te(e,i);}}function te(e,t,r=!1){!e.i&&e.p.y&&e.P&&k(t,r);}function he(e,t){let r=Array.isArray(e),n={o:r?1:0,n:t?t.n:B(),s:!1,c:!1,r:{},i:t,t:e,u:null,e:null,x:null,l:!1},i=n,f=ue;r&&(i=[n],f=q);let{revoke:l,proxy:c}=Proxy.revocable(i,f);return n.u=c,n.x=l,c}var ue={get(e,t){if(t===u)return e;let r=T(e);if(!R(r,t))return Ee(e,r,t);let n=r[t];return e.c||!A(n)?n:n===ce(e.t,t)?(fe(e),e.e[t]=W(n,e)):n},has(e,t){return t in T(e)},ownKeys(e){return Reflect.ownKeys(T(e))},set(e,t,r){let n=me(T(e),t);if(n?.set)return n.set.call(e.u,r),!0;if(!e.s){let i=ce(T(e),t),f=i?.[u];if(f&&f.t===r)return e.e[t]=r,e.r[t]=!1,!0;if(pe(r,i)&&(r!==void 0||R(e.t,t)))return !0;fe(e),E(e);}return e.e[t]===r&&(r!==void 0||t in e.e)||Number.isNaN(r)&&Number.isNaN(e.e[t])||(e.e[t]=r,e.r[t]=!0),!0},deleteProperty(e,t){return ce(e.t,t)!==void 0||t in e.t?(e.r[t]=!1,fe(e),E(e)):delete e.r[t],e.e&&delete e.e[t],!0},getOwnPropertyDescriptor(e,t){let r=T(e),n=Reflect.getOwnPropertyDescriptor(r,t);return n&&{writable:!0,configurable:e.o!==1||t!=="length",enumerable:n.enumerable,value:r[t]}},defineProperty(){h(11);},getPrototypeOf(e){return z(e.t)},setPrototypeOf(){h(12);}},q={};_(ue,(e,t)=>{q[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)};});q.deleteProperty=function(e,t){return q.set.call(this,e,t,void 0)};q.set=function(e,t,r){return ue.set.call(this,e[0],t,r,e[0])};function ce(e,t){let r=e[u];return (r?T(r):e)[t]}function Ee(e,t,r){let n=me(t,r);return n?"value"in n?n.value:n.get?.call(e.u):void 0}function me(e,t){if(!(t in e))return;let r=z(e);for(;r;){let n=Object.getOwnPropertyDescriptor(r,t);if(n)return n;r=z(r);}}function E(e){e.s||(e.s=!0,e.i&&E(e.i));}function fe(e){e.e||(e.e=L(e.t,e.n.p.S));}var J=class{constructor(t){this.y=!0;this.S=!1;this.produce=(t,r,n)=>{if(typeof t=="function"&&typeof r!="function"){let f=r;r=t;let l=this;return function(b=f,...a){return l.produce(b,o=>r.call(this,o,...a))}}typeof r!="function"&&h(6),n!==void 0&&typeof n!="function"&&h(7);let i;if(A(t)){let f=ie(this),l=W(t,void 0),c=!0;try{i=r(l),c=!1;}finally{c?V(f):Z(f);}return oe(f,n),se(i,f)}else if(!t||typeof t!="object"){if(i=r(t),i===void 0&&(i=t),i===j&&(i=void 0),this.y&&k(i,!0),n){let f=[],l=[];w("Patches").T(t,i,f,l),n(f,l);}return i}else h(1,t);};this.produceWithPatches=(t,r)=>{if(typeof t=="function")return (l,...c)=>this.produceWithPatches(l,b=>t(b,...c));let n,i;return [this.produce(t,r,(l,c)=>{n=l,i=c;}),n,i]};typeof t?.autoFreeze=="boolean"&&this.setAutoFreeze(t.autoFreeze),typeof t?.useStrictShallowCopy=="boolean"&&this.setUseStrictShallowCopy(t.useStrictShallowCopy);}createDraft(t){A(t)||h(8),O(t)&&(t=re(t));let r=ie(this),n=W(t,void 0);return n[u].l=!0,Z(r),n}finishDraft(t,r){let n=t&&t[u];(!n||!n.l)&&h(9);let{n:i}=n;return oe(i,r),se(void 0,i)}setAutoFreeze(t){this.y=t;}setUseStrictShallowCopy(t){this.S=t;}applyPatches(t,r){let n;for(n=r.length-1;n>=0;n--){let f=r[n];if(f.path.length===0&&f.op==="replace"){t=f.value;break}}n>-1&&(r=r.slice(n+1));let i=w("Patches").A;return O(t)?i(t,r):this.produce(t,f=>i(f,r))}};function W(e,t){let r=v(e)?w("MapSet").I(e,t):K(e)?w("MapSet").D(e,t):he(e,t);return (t?t.n:B()).a.push(r),r}function re(e){return O(e)||h(10,e),Se(e)}function Se(e){if(!A(e)||$(e))return e;let t=e[u],r;if(t){if(!t.s)return t.t;t.c=!0,r=L(e,t.n.p.S);}else r=L(e,!0);return _(r,(n,i)=>{Q(r,n,Se(i));}),t&&(t.c=!1),r}function Pe(){class e extends Map{constructor(a,o){super();this[u]={o:2,i:o,n:o?o.n:B(),s:!1,c:!1,e:void 0,r:void 0,t:a,u:this,l:!1,h:!1};}get size(){return T(this[u]).size}has(a){return T(this[u]).has(a)}set(a,o){let p=this[u];return l(p),(!T(p).has(a)||T(p).get(a)!==o)&&(r(p),E(p),p.r.set(a,!0),p.e.set(a,o),p.r.set(a,!0)),this}delete(a){if(!this.has(a))return !1;let o=this[u];return l(o),r(o),E(o),o.t.has(a)?o.r.set(a,!1):o.r.delete(a),o.e.delete(a),!0}clear(){let a=this[u];l(a),T(a).size&&(r(a),E(a),a.r=new Map,_(a.t,o=>{a.r.set(o,!1);}),a.e.clear());}forEach(a,o){let p=this[u];T(p).forEach((s,S,m)=>{a.call(o,this.get(S),S,this);});}get(a){let o=this[u];l(o);let p=T(o).get(a);if(o.c||!A(p)||p!==o.t.get(a))return p;let s=W(p,o);return r(o),o.e.set(a,s),s}keys(){return T(this[u]).keys()}values(){let a=this.keys();return {[Symbol.iterator]:()=>this.values(),next:()=>{let o=a.next();return o.done?o:{done:!1,value:this.get(o.value)}}}}entries(){let a=this.keys();return {[Symbol.iterator]:()=>this.entries(),next:()=>{let o=a.next();if(o.done)return o;let p=this.get(o.value);return {done:!1,value:[o.value,p]}}}}[(Symbol.iterator)](){return this.entries()}}function t(c,b){return new e(c,b)}function r(c){c.e||(c.r=new Map,c.e=new Map(c.t));}class n extends Set{constructor(a,o){super();this[u]={o:3,i:o,n:o?o.n:B(),s:!1,c:!1,e:void 0,t:a,u:this,a:new Map,h:!1,l:!1};}get size(){return T(this[u]).size}has(a){let o=this[u];return l(o),o.e?!!(o.e.has(a)||o.a.has(a)&&o.e.has(o.a.get(a))):o.t.has(a)}add(a){let o=this[u];return l(o),this.has(a)||(f(o),E(o),o.e.add(a)),this}delete(a){if(!this.has(a))return !1;let o=this[u];return l(o),f(o),E(o),o.e.delete(a)||(o.a.has(a)?o.e.delete(o.a.get(a)):!1)}clear(){let a=this[u];l(a),T(a).size&&(f(a),E(a),a.e.clear());}values(){let a=this[u];return l(a),f(a),a.e.values()}entries(){let a=this[u];return l(a),f(a),a.e.entries()}keys(){return this.values()}[(Symbol.iterator)](){return this.values()}forEach(a,o){let p=this.values(),s=p.next();for(;!s.done;)a.call(o,s.value,s.value,this),s=p.next();}}function i(c,b){return new n(c,b)}function f(c){c.e||(c.e=new Set,c.t.forEach(b=>{if(A(b)){let a=W(b,c);c.a.set(b,a),c.e.add(a);}else c.e.add(b);}));}function l(c){c.h&&h(3,JSON.stringify(T(c)));}Y("MapSet",{I:t,D:i});}function ge(){let t="replace",r="add",n="remove";function i(s,S,m,g){switch(s.o){case 0:case 2:return l(s,S,m,g);case 1:return f(s,S,m,g);case 3:return c(s,S,m,g)}}function f(s,S,m,g){let{t:I,r:P}=s,x=s.e;x.length<I.length&&([I,x]=[x,I],[m,g]=[g,m]);for(let y=0;y<I.length;y++)if(P[y]&&x[y]!==I[y]){let d=S.concat([y]);m.push({op:t,path:d,value:p(x[y])}),g.push({op:t,path:d,value:p(I[y])});}for(let y=I.length;y<x.length;y++){let d=S.concat([y]);m.push({op:r,path:d,value:p(x[y])});}for(let y=x.length-1;I.length<=y;--y){let d=S.concat([y]);g.push({op:n,path:d});}}function l(s,S,m,g){let{t:I,e:P}=s;_(s.r,(x,y)=>{let d=X(I,x),H=X(P,x),F=y?R(I,x)?t:r:n;if(d===H&&F===t)return;let D=S.concat(x);m.push(F===n?{op:F,path:D}:{op:F,path:D,value:H}),g.push(F===r?{op:n,path:D}:F===n?{op:r,path:D,value:p(d)}:{op:t,path:D,value:p(d)});});}function c(s,S,m,g){let{t:I,e:P}=s,x=0;I.forEach(y=>{if(!P.has(y)){let d=S.concat([x]);m.push({op:n,path:d,value:y}),g.unshift({op:r,path:d,value:y});}x++;}),x=0,P.forEach(y=>{if(!I.has(y)){let d=S.concat([x]);m.push({op:r,path:d,value:y}),g.unshift({op:n,path:d,value:y});}x++;});}function b(s,S,m,g){m.push({op:t,path:[],value:S===j?void 0:S}),g.push({op:t,path:[],value:s});}function a(s,S){return S.forEach(m=>{let{path:g,op:I}=m,P=s;for(let H=0;H<g.length-1;H++){let F=C(P),D=g[H];typeof D!="string"&&typeof D!="number"&&(D=""+D),(F===0||F===1)&&(D==="__proto__"||D==="constructor")&&h(16+3),typeof P=="function"&&D==="prototype"&&h(16+3),P=X(P,D),typeof P!="object"&&h(16+2,g.join("/"));}let x=C(P),y=o(m.value),d=g[g.length-1];switch(I){case t:switch(x){case 2:return P.set(d,y);case 3:h(16);default:return P[d]=y}case r:switch(x){case 1:return d==="-"?P.push(y):P.splice(d,0,y);case 2:return P.set(d,y);case 3:return P.add(y);default:return P[d]=y}case n:switch(x){case 1:return P.splice(d,1);case 2:return P.delete(d);case 3:return P.delete(m.value);default:return delete P[d]}default:h(16+1,I);}}),s}function o(s){if(!A(s))return s;if(Array.isArray(s))return s.map(o);if(v(s))return new Map(Array.from(s.entries()).map(([m,g])=>[m,o(g)]));if(K(s))return new Set(Array.from(s).map(o));let S=Object.create(z(s));for(let m in s)S[m]=o(s[m]);return R(s,N)&&(S[N]=s[N]),S}function p(s){return O(s)?o(s):s}Y("Patches",{A:a,g:i,T:b});}var M=new J,Fe=M.produce,Ne=M.produceWithPatches.bind(M),ze=M.setAutoFreeze.bind(M),je=M.setUseStrictShallowCopy.bind(M),Ce=M.applyPatches.bind(M),Re=M.createDraft.bind(M),ve=M.finishDraft.bind(M);function Ke(e){return e}function ke(e){return e}Pe();ge();	
	return immer_cjs_production;
}

var immer_cjs_development;
var hasRequiredImmer_cjs_development;

function requireImmer_cjs_development () {
	if (hasRequiredImmer_cjs_development) return immer_cjs_development;
	hasRequiredImmer_cjs_development = 1;
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __export = (target, all) => {
	  for (var name in all)
	    __defProp(target, name, { get: all[name], enumerable: true });
	};
	var __copyProps = (to, from, except, desc) => {
	  if (from && typeof from === "object" || typeof from === "function") {
	    for (let key of __getOwnPropNames(from))
	      if (!__hasOwnProp.call(to, key) && key !== except)
	        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
	  }
	  return to;
	};
	var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

	// src/immer.ts
	var immer_exports = {};
	__export(immer_exports, {
	  Immer: () => Immer2,
	  applyPatches: () => applyPatches,
	  castDraft: () => castDraft,
	  castImmutable: () => castImmutable,
	  createDraft: () => createDraft,
	  current: () => current,
	  finishDraft: () => finishDraft,
	  freeze: () => freeze,
	  immerable: () => DRAFTABLE,
	  isDraft: () => isDraft,
	  isDraftable: () => isDraftable,
	  nothing: () => NOTHING,
	  original: () => original,
	  produce: () => produce,
	  produceWithPatches: () => produceWithPatches,
	  setAutoFreeze: () => setAutoFreeze,
	  setUseStrictShallowCopy: () => setUseStrictShallowCopy
	});
	immer_cjs_development = __toCommonJS(immer_exports);

	// src/utils/env.ts
	var NOTHING = Symbol.for("immer-nothing");
	var DRAFTABLE = Symbol.for("immer-draftable");
	var DRAFT_STATE = Symbol.for("immer-state");

	// src/utils/errors.ts
	var errors = process.env.NODE_ENV !== "production" ? [
	  // All error codes, starting by 0:
	  function(plugin) {
	    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
	  },
	  function(thing) {
	    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
	  },
	  "This object has been frozen and should not be mutated",
	  function(data) {
	    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
	  },
	  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
	  "Immer forbids circular references",
	  "The first or second argument to `produce` must be a function",
	  "The third argument to `produce` must be a function or undefined",
	  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
	  "First argument to `finishDraft` must be a draft returned by `createDraft`",
	  function(thing) {
	    return `'current' expects a draft, got: ${thing}`;
	  },
	  "Object.defineProperty() cannot be used on an Immer draft",
	  "Object.setPrototypeOf() cannot be used on an Immer draft",
	  "Immer only supports deleting array indices",
	  "Immer only supports setting array indices and the 'length' property",
	  function(thing) {
	    return `'original' expects a draft, got: ${thing}`;
	  }
	  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
	  // See Patches.ts for additional errors
	] : [];
	function die(error, ...args) {
	  if (process.env.NODE_ENV !== "production") {
	    const e = errors[error];
	    const msg = typeof e === "function" ? e.apply(null, args) : e;
	    throw new Error(`[Immer] ${msg}`);
	  }
	  throw new Error(
	    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
	  );
	}

	// src/utils/common.ts
	var getPrototypeOf = Object.getPrototypeOf;
	function isDraft(value) {
	  return !!value && !!value[DRAFT_STATE];
	}
	function isDraftable(value) {
	  if (!value)
	    return false;
	  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
	}
	var objectCtorString = Object.prototype.constructor.toString();
	function isPlainObject(value) {
	  if (!value || typeof value !== "object")
	    return false;
	  const proto = getPrototypeOf(value);
	  if (proto === null) {
	    return true;
	  }
	  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
	  if (Ctor === Object)
	    return true;
	  return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
	}
	function original(value) {
	  if (!isDraft(value))
	    die(15, value);
	  return value[DRAFT_STATE].base_;
	}
	function each(obj, iter) {
	  if (getArchtype(obj) === 0 /* Object */) {
	    Reflect.ownKeys(obj).forEach((key) => {
	      iter(key, obj[key], obj);
	    });
	  } else {
	    obj.forEach((entry, index) => iter(index, entry, obj));
	  }
	}
	function getArchtype(thing) {
	  const state = thing[DRAFT_STATE];
	  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;
	}
	function has(thing, prop) {
	  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
	}
	function get(thing, prop) {
	  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];
	}
	function set(thing, propOrOldValue, value) {
	  const t = getArchtype(thing);
	  if (t === 2 /* Map */)
	    thing.set(propOrOldValue, value);
	  else if (t === 3 /* Set */) {
	    thing.add(value);
	  } else
	    thing[propOrOldValue] = value;
	}
	function is(x, y) {
	  if (x === y) {
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    return x !== x && y !== y;
	  }
	}
	function isMap(target) {
	  return target instanceof Map;
	}
	function isSet(target) {
	  return target instanceof Set;
	}
	function latest(state) {
	  return state.copy_ || state.base_;
	}
	function shallowCopy(base, strict) {
	  if (isMap(base)) {
	    return new Map(base);
	  }
	  if (isSet(base)) {
	    return new Set(base);
	  }
	  if (Array.isArray(base))
	    return Array.prototype.slice.call(base);
	  const isPlain = isPlainObject(base);
	  if (strict === true || strict === "class_only" && !isPlain) {
	    const descriptors = Object.getOwnPropertyDescriptors(base);
	    delete descriptors[DRAFT_STATE];
	    let keys = Reflect.ownKeys(descriptors);
	    for (let i = 0; i < keys.length; i++) {
	      const key = keys[i];
	      const desc = descriptors[key];
	      if (desc.writable === false) {
	        desc.writable = true;
	        desc.configurable = true;
	      }
	      if (desc.get || desc.set)
	        descriptors[key] = {
	          configurable: true,
	          writable: true,
	          // could live with !!desc.set as well here...
	          enumerable: desc.enumerable,
	          value: base[key]
	        };
	    }
	    return Object.create(getPrototypeOf(base), descriptors);
	  } else {
	    const proto = getPrototypeOf(base);
	    if (proto !== null && isPlain) {
	      return { ...base };
	    }
	    const obj = Object.create(proto);
	    return Object.assign(obj, base);
	  }
	}
	function freeze(obj, deep = false) {
	  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
	    return obj;
	  if (getArchtype(obj) > 1) {
	    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
	  }
	  Object.freeze(obj);
	  if (deep)
	    Object.values(obj).forEach((value) => freeze(value, true));
	  return obj;
	}
	function dontMutateFrozenCollections() {
	  die(2);
	}
	function isFrozen(obj) {
	  return Object.isFrozen(obj);
	}

	// src/utils/plugins.ts
	var plugins = {};
	function getPlugin(pluginKey) {
	  const plugin = plugins[pluginKey];
	  if (!plugin) {
	    die(0, pluginKey);
	  }
	  return plugin;
	}
	function loadPlugin(pluginKey, implementation) {
	  if (!plugins[pluginKey])
	    plugins[pluginKey] = implementation;
	}

	// src/core/scope.ts
	var currentScope;
	function getCurrentScope() {
	  return currentScope;
	}
	function createScope(parent_, immer_) {
	  return {
	    drafts_: [],
	    parent_,
	    immer_,
	    // Whenever the modified draft contains a draft from another scope, we
	    // need to prevent auto-freezing so the unowned draft can be finalized.
	    canAutoFreeze_: true,
	    unfinalizedDrafts_: 0
	  };
	}
	function usePatchesInScope(scope, patchListener) {
	  if (patchListener) {
	    getPlugin("Patches");
	    scope.patches_ = [];
	    scope.inversePatches_ = [];
	    scope.patchListener_ = patchListener;
	  }
	}
	function revokeScope(scope) {
	  leaveScope(scope);
	  scope.drafts_.forEach(revokeDraft);
	  scope.drafts_ = null;
	}
	function leaveScope(scope) {
	  if (scope === currentScope) {
	    currentScope = scope.parent_;
	  }
	}
	function enterScope(immer2) {
	  return currentScope = createScope(currentScope, immer2);
	}
	function revokeDraft(draft) {
	  const state = draft[DRAFT_STATE];
	  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)
	    state.revoke_();
	  else
	    state.revoked_ = true;
	}

	// src/core/finalize.ts
	function processResult(result, scope) {
	  scope.unfinalizedDrafts_ = scope.drafts_.length;
	  const baseDraft = scope.drafts_[0];
	  const isReplaced = result !== void 0 && result !== baseDraft;
	  if (isReplaced) {
	    if (baseDraft[DRAFT_STATE].modified_) {
	      revokeScope(scope);
	      die(4);
	    }
	    if (isDraftable(result)) {
	      result = finalize(scope, result);
	      if (!scope.parent_)
	        maybeFreeze(scope, result);
	    }
	    if (scope.patches_) {
	      getPlugin("Patches").generateReplacementPatches_(
	        baseDraft[DRAFT_STATE].base_,
	        result,
	        scope.patches_,
	        scope.inversePatches_
	      );
	    }
	  } else {
	    result = finalize(scope, baseDraft, []);
	  }
	  revokeScope(scope);
	  if (scope.patches_) {
	    scope.patchListener_(scope.patches_, scope.inversePatches_);
	  }
	  return result !== NOTHING ? result : void 0;
	}
	function finalize(rootScope, value, path) {
	  if (isFrozen(value))
	    return value;
	  const state = value[DRAFT_STATE];
	  if (!state) {
	    each(
	      value,
	      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
	    );
	    return value;
	  }
	  if (state.scope_ !== rootScope)
	    return value;
	  if (!state.modified_) {
	    maybeFreeze(rootScope, state.base_, true);
	    return state.base_;
	  }
	  if (!state.finalized_) {
	    state.finalized_ = true;
	    state.scope_.unfinalizedDrafts_--;
	    const result = state.copy_;
	    let resultEach = result;
	    let isSet2 = false;
	    if (state.type_ === 3 /* Set */) {
	      resultEach = new Set(result);
	      result.clear();
	      isSet2 = true;
	    }
	    each(
	      resultEach,
	      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
	    );
	    maybeFreeze(rootScope, result, false);
	    if (path && rootScope.patches_) {
	      getPlugin("Patches").generatePatches_(
	        state,
	        path,
	        rootScope.patches_,
	        rootScope.inversePatches_
	      );
	    }
	  }
	  return state.copy_;
	}
	function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
	  if (process.env.NODE_ENV !== "production" && childValue === targetObject)
	    die(5);
	  if (isDraft(childValue)) {
	    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.
	    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
	    const res = finalize(rootScope, childValue, path);
	    set(targetObject, prop, res);
	    if (isDraft(res)) {
	      rootScope.canAutoFreeze_ = false;
	    } else
	      return;
	  } else if (targetIsSet) {
	    targetObject.add(childValue);
	  }
	  if (isDraftable(childValue) && !isFrozen(childValue)) {
	    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
	      return;
	    }
	    finalize(rootScope, childValue);
	    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
	      maybeFreeze(rootScope, childValue);
	  }
	}
	function maybeFreeze(scope, value, deep = false) {
	  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
	    freeze(value, deep);
	  }
	}

	// src/core/proxy.ts
	function createProxyProxy(base, parent) {
	  const isArray = Array.isArray(base);
	  const state = {
	    type_: isArray ? 1 /* Array */ : 0 /* Object */,
	    // Track which produce call this is associated with.
	    scope_: parent ? parent.scope_ : getCurrentScope(),
	    // True for both shallow and deep changes.
	    modified_: false,
	    // Used during finalization.
	    finalized_: false,
	    // Track which properties have been assigned (true) or deleted (false).
	    assigned_: {},
	    // The parent draft state.
	    parent_: parent,
	    // The base state.
	    base_: base,
	    // The base proxy.
	    draft_: null,
	    // set below
	    // The base copy with any updated values.
	    copy_: null,
	    // Called by the `produce` function.
	    revoke_: null,
	    isManual_: false
	  };
	  let target = state;
	  let traps = objectTraps;
	  if (isArray) {
	    target = [state];
	    traps = arrayTraps;
	  }
	  const { revoke, proxy } = Proxy.revocable(target, traps);
	  state.draft_ = proxy;
	  state.revoke_ = revoke;
	  return proxy;
	}
	var objectTraps = {
	  get(state, prop) {
	    if (prop === DRAFT_STATE)
	      return state;
	    const source = latest(state);
	    if (!has(source, prop)) {
	      return readPropFromProto(state, source, prop);
	    }
	    const value = source[prop];
	    if (state.finalized_ || !isDraftable(value)) {
	      return value;
	    }
	    if (value === peek(state.base_, prop)) {
	      prepareCopy(state);
	      return state.copy_[prop] = createProxy(value, state);
	    }
	    return value;
	  },
	  has(state, prop) {
	    return prop in latest(state);
	  },
	  ownKeys(state) {
	    return Reflect.ownKeys(latest(state));
	  },
	  set(state, prop, value) {
	    const desc = getDescriptorFromProto(latest(state), prop);
	    if (desc?.set) {
	      desc.set.call(state.draft_, value);
	      return true;
	    }
	    if (!state.modified_) {
	      const current2 = peek(latest(state), prop);
	      const currentState = current2?.[DRAFT_STATE];
	      if (currentState && currentState.base_ === value) {
	        state.copy_[prop] = value;
	        state.assigned_[prop] = false;
	        return true;
	      }
	      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))
	        return true;
	      prepareCopy(state);
	      markChanged(state);
	    }
	    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
	    (value !== void 0 || prop in state.copy_) || // special case: NaN
	    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
	      return true;
	    state.copy_[prop] = value;
	    state.assigned_[prop] = true;
	    return true;
	  },
	  deleteProperty(state, prop) {
	    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
	      state.assigned_[prop] = false;
	      prepareCopy(state);
	      markChanged(state);
	    } else {
	      delete state.assigned_[prop];
	    }
	    if (state.copy_) {
	      delete state.copy_[prop];
	    }
	    return true;
	  },
	  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
	  // the same guarantee in ES5 mode.
	  getOwnPropertyDescriptor(state, prop) {
	    const owner = latest(state);
	    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
	    if (!desc)
	      return desc;
	    return {
	      writable: true,
	      configurable: state.type_ !== 1 /* Array */ || prop !== "length",
	      enumerable: desc.enumerable,
	      value: owner[prop]
	    };
	  },
	  defineProperty() {
	    die(11);
	  },
	  getPrototypeOf(state) {
	    return getPrototypeOf(state.base_);
	  },
	  setPrototypeOf() {
	    die(12);
	  }
	};
	var arrayTraps = {};
	each(objectTraps, (key, fn) => {
	  arrayTraps[key] = function() {
	    arguments[0] = arguments[0][0];
	    return fn.apply(this, arguments);
	  };
	});
	arrayTraps.deleteProperty = function(state, prop) {
	  if (process.env.NODE_ENV !== "production" && isNaN(parseInt(prop)))
	    die(13);
	  return arrayTraps.set.call(this, state, prop, void 0);
	};
	arrayTraps.set = function(state, prop, value) {
	  if (process.env.NODE_ENV !== "production" && prop !== "length" && isNaN(parseInt(prop)))
	    die(14);
	  return objectTraps.set.call(this, state[0], prop, value, state[0]);
	};
	function peek(draft, prop) {
	  const state = draft[DRAFT_STATE];
	  const source = state ? latest(state) : draft;
	  return source[prop];
	}
	function readPropFromProto(state, source, prop) {
	  const desc = getDescriptorFromProto(source, prop);
	  return desc ? `value` in desc ? desc.value : (
	    // This is a very special case, if the prop is a getter defined by the
	    // prototype, we should invoke it with the draft as context!
	    desc.get?.call(state.draft_)
	  ) : void 0;
	}
	function getDescriptorFromProto(source, prop) {
	  if (!(prop in source))
	    return void 0;
	  let proto = getPrototypeOf(source);
	  while (proto) {
	    const desc = Object.getOwnPropertyDescriptor(proto, prop);
	    if (desc)
	      return desc;
	    proto = getPrototypeOf(proto);
	  }
	  return void 0;
	}
	function markChanged(state) {
	  if (!state.modified_) {
	    state.modified_ = true;
	    if (state.parent_) {
	      markChanged(state.parent_);
	    }
	  }
	}
	function prepareCopy(state) {
	  if (!state.copy_) {
	    state.copy_ = shallowCopy(
	      state.base_,
	      state.scope_.immer_.useStrictShallowCopy_
	    );
	  }
	}

	// src/core/immerClass.ts
	var Immer2 = class {
	  constructor(config) {
	    this.autoFreeze_ = true;
	    this.useStrictShallowCopy_ = false;
	    /**
	     * The `produce` function takes a value and a "recipe function" (whose
	     * return value often depends on the base state). The recipe function is
	     * free to mutate its first argument however it wants. All mutations are
	     * only ever applied to a __copy__ of the base state.
	     *
	     * Pass only a function to create a "curried producer" which relieves you
	     * from passing the recipe function every time.
	     *
	     * Only plain objects and arrays are made mutable. All other objects are
	     * considered uncopyable.
	     *
	     * Note: This function is __bound__ to its `Immer` instance.
	     *
	     * @param {any} base - the initial state
	     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
	     * @param {Function} patchListener - optional function that will be called with all the patches produced here
	     * @returns {any} a new state, or the initial state if nothing was modified
	     */
	    this.produce = (base, recipe, patchListener) => {
	      if (typeof base === "function" && typeof recipe !== "function") {
	        const defaultBase = recipe;
	        recipe = base;
	        const self = this;
	        return function curriedProduce(base2 = defaultBase, ...args) {
	          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
	        };
	      }
	      if (typeof recipe !== "function")
	        die(6);
	      if (patchListener !== void 0 && typeof patchListener !== "function")
	        die(7);
	      let result;
	      if (isDraftable(base)) {
	        const scope = enterScope(this);
	        const proxy = createProxy(base, void 0);
	        let hasError = true;
	        try {
	          result = recipe(proxy);
	          hasError = false;
	        } finally {
	          if (hasError)
	            revokeScope(scope);
	          else
	            leaveScope(scope);
	        }
	        usePatchesInScope(scope, patchListener);
	        return processResult(result, scope);
	      } else if (!base || typeof base !== "object") {
	        result = recipe(base);
	        if (result === void 0)
	          result = base;
	        if (result === NOTHING)
	          result = void 0;
	        if (this.autoFreeze_)
	          freeze(result, true);
	        if (patchListener) {
	          const p = [];
	          const ip = [];
	          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
	          patchListener(p, ip);
	        }
	        return result;
	      } else
	        die(1, base);
	    };
	    this.produceWithPatches = (base, recipe) => {
	      if (typeof base === "function") {
	        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
	      }
	      let patches, inversePatches;
	      const result = this.produce(base, recipe, (p, ip) => {
	        patches = p;
	        inversePatches = ip;
	      });
	      return [result, patches, inversePatches];
	    };
	    if (typeof config?.autoFreeze === "boolean")
	      this.setAutoFreeze(config.autoFreeze);
	    if (typeof config?.useStrictShallowCopy === "boolean")
	      this.setUseStrictShallowCopy(config.useStrictShallowCopy);
	  }
	  createDraft(base) {
	    if (!isDraftable(base))
	      die(8);
	    if (isDraft(base))
	      base = current(base);
	    const scope = enterScope(this);
	    const proxy = createProxy(base, void 0);
	    proxy[DRAFT_STATE].isManual_ = true;
	    leaveScope(scope);
	    return proxy;
	  }
	  finishDraft(draft, patchListener) {
	    const state = draft && draft[DRAFT_STATE];
	    if (!state || !state.isManual_)
	      die(9);
	    const { scope_: scope } = state;
	    usePatchesInScope(scope, patchListener);
	    return processResult(void 0, scope);
	  }
	  /**
	   * Pass true to automatically freeze all copies created by Immer.
	   *
	   * By default, auto-freezing is enabled.
	   */
	  setAutoFreeze(value) {
	    this.autoFreeze_ = value;
	  }
	  /**
	   * Pass true to enable strict shallow copy.
	   *
	   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
	   */
	  setUseStrictShallowCopy(value) {
	    this.useStrictShallowCopy_ = value;
	  }
	  applyPatches(base, patches) {
	    let i;
	    for (i = patches.length - 1; i >= 0; i--) {
	      const patch = patches[i];
	      if (patch.path.length === 0 && patch.op === "replace") {
	        base = patch.value;
	        break;
	      }
	    }
	    if (i > -1) {
	      patches = patches.slice(i + 1);
	    }
	    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
	    if (isDraft(base)) {
	      return applyPatchesImpl(base, patches);
	    }
	    return this.produce(
	      base,
	      (draft) => applyPatchesImpl(draft, patches)
	    );
	  }
	};
	function createProxy(value, parent) {
	  const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
	  const scope = parent ? parent.scope_ : getCurrentScope();
	  scope.drafts_.push(draft);
	  return draft;
	}

	// src/core/current.ts
	function current(value) {
	  if (!isDraft(value))
	    die(10, value);
	  return currentImpl(value);
	}
	function currentImpl(value) {
	  if (!isDraftable(value) || isFrozen(value))
	    return value;
	  const state = value[DRAFT_STATE];
	  let copy;
	  if (state) {
	    if (!state.modified_)
	      return state.base_;
	    state.finalized_ = true;
	    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
	  } else {
	    copy = shallowCopy(value, true);
	  }
	  each(copy, (key, childValue) => {
	    set(copy, key, currentImpl(childValue));
	  });
	  if (state) {
	    state.finalized_ = false;
	  }
	  return copy;
	}

	// src/plugins/mapset.ts
	function enableMapSet() {
	  class DraftMap extends Map {
	    constructor(target, parent) {
	      super();
	      this[DRAFT_STATE] = {
	        type_: 2 /* Map */,
	        parent_: parent,
	        scope_: parent ? parent.scope_ : getCurrentScope(),
	        modified_: false,
	        finalized_: false,
	        copy_: void 0,
	        assigned_: void 0,
	        base_: target,
	        draft_: this,
	        isManual_: false,
	        revoked_: false
	      };
	    }
	    get size() {
	      return latest(this[DRAFT_STATE]).size;
	    }
	    has(key) {
	      return latest(this[DRAFT_STATE]).has(key);
	    }
	    set(key, value) {
	      const state = this[DRAFT_STATE];
	      assertUnrevoked(state);
	      if (!latest(state).has(key) || latest(state).get(key) !== value) {
	        prepareMapCopy(state);
	        markChanged(state);
	        state.assigned_.set(key, true);
	        state.copy_.set(key, value);
	        state.assigned_.set(key, true);
	      }
	      return this;
	    }
	    delete(key) {
	      if (!this.has(key)) {
	        return false;
	      }
	      const state = this[DRAFT_STATE];
	      assertUnrevoked(state);
	      prepareMapCopy(state);
	      markChanged(state);
	      if (state.base_.has(key)) {
	        state.assigned_.set(key, false);
	      } else {
	        state.assigned_.delete(key);
	      }
	      state.copy_.delete(key);
	      return true;
	    }
	    clear() {
	      const state = this[DRAFT_STATE];
	      assertUnrevoked(state);
	      if (latest(state).size) {
	        prepareMapCopy(state);
	        markChanged(state);
	        state.assigned_ = /* @__PURE__ */ new Map();
	        each(state.base_, (key) => {
	          state.assigned_.set(key, false);
	        });
	        state.copy_.clear();
	      }
	    }
	    forEach(cb, thisArg) {
	      const state = this[DRAFT_STATE];
	      latest(state).forEach((_value, key, _map) => {
	        cb.call(thisArg, this.get(key), key, this);
	      });
	    }
	    get(key) {
	      const state = this[DRAFT_STATE];
	      assertUnrevoked(state);
	      const value = latest(state).get(key);
	      if (state.finalized_ || !isDraftable(value)) {
	        return value;
	      }
	      if (value !== state.base_.get(key)) {
	        return value;
	      }
	      const draft = createProxy(value, state);
	      prepareMapCopy(state);
	      state.copy_.set(key, draft);
	      return draft;
	    }
	    keys() {
	      return latest(this[DRAFT_STATE]).keys();
	    }
	    values() {
	      const iterator = this.keys();
	      return {
	        [Symbol.iterator]: () => this.values(),
	        next: () => {
	          const r = iterator.next();
	          if (r.done)
	            return r;
	          const value = this.get(r.value);
	          return {
	            done: false,
	            value
	          };
	        }
	      };
	    }
	    entries() {
	      const iterator = this.keys();
	      return {
	        [Symbol.iterator]: () => this.entries(),
	        next: () => {
	          const r = iterator.next();
	          if (r.done)
	            return r;
	          const value = this.get(r.value);
	          return {
	            done: false,
	            value: [r.value, value]
	          };
	        }
	      };
	    }
	    [(Symbol.iterator)]() {
	      return this.entries();
	    }
	  }
	  function proxyMap_(target, parent) {
	    return new DraftMap(target, parent);
	  }
	  function prepareMapCopy(state) {
	    if (!state.copy_) {
	      state.assigned_ = /* @__PURE__ */ new Map();
	      state.copy_ = new Map(state.base_);
	    }
	  }
	  class DraftSet extends Set {
	    constructor(target, parent) {
	      super();
	      this[DRAFT_STATE] = {
	        type_: 3 /* Set */,
	        parent_: parent,
	        scope_: parent ? parent.scope_ : getCurrentScope(),
	        modified_: false,
	        finalized_: false,
	        copy_: void 0,
	        base_: target,
	        draft_: this,
	        drafts_: /* @__PURE__ */ new Map(),
	        revoked_: false,
	        isManual_: false
	      };
	    }
	    get size() {
	      return latest(this[DRAFT_STATE]).size;
	    }
	    has(value) {
	      const state = this[DRAFT_STATE];
	      assertUnrevoked(state);
	      if (!state.copy_) {
	        return state.base_.has(value);
	      }
	      if (state.copy_.has(value))
	        return true;
	      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))
	        return true;
	      return false;
	    }
	    add(value) {
	      const state = this[DRAFT_STATE];
	      assertUnrevoked(state);
	      if (!this.has(value)) {
	        prepareSetCopy(state);
	        markChanged(state);
	        state.copy_.add(value);
	      }
	      return this;
	    }
	    delete(value) {
	      if (!this.has(value)) {
	        return false;
	      }
	      const state = this[DRAFT_STATE];
	      assertUnrevoked(state);
	      prepareSetCopy(state);
	      markChanged(state);
	      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (
	        /* istanbul ignore next */
	        false
	      ));
	    }
	    clear() {
	      const state = this[DRAFT_STATE];
	      assertUnrevoked(state);
	      if (latest(state).size) {
	        prepareSetCopy(state);
	        markChanged(state);
	        state.copy_.clear();
	      }
	    }
	    values() {
	      const state = this[DRAFT_STATE];
	      assertUnrevoked(state);
	      prepareSetCopy(state);
	      return state.copy_.values();
	    }
	    entries() {
	      const state = this[DRAFT_STATE];
	      assertUnrevoked(state);
	      prepareSetCopy(state);
	      return state.copy_.entries();
	    }
	    keys() {
	      return this.values();
	    }
	    [(Symbol.iterator)]() {
	      return this.values();
	    }
	    forEach(cb, thisArg) {
	      const iterator = this.values();
	      let result = iterator.next();
	      while (!result.done) {
	        cb.call(thisArg, result.value, result.value, this);
	        result = iterator.next();
	      }
	    }
	  }
	  function proxySet_(target, parent) {
	    return new DraftSet(target, parent);
	  }
	  function prepareSetCopy(state) {
	    if (!state.copy_) {
	      state.copy_ = /* @__PURE__ */ new Set();
	      state.base_.forEach((value) => {
	        if (isDraftable(value)) {
	          const draft = createProxy(value, state);
	          state.drafts_.set(value, draft);
	          state.copy_.add(draft);
	        } else {
	          state.copy_.add(value);
	        }
	      });
	    }
	  }
	  function assertUnrevoked(state) {
	    if (state.revoked_)
	      die(3, JSON.stringify(latest(state)));
	  }
	  loadPlugin("MapSet", { proxyMap_, proxySet_ });
	}

	// src/plugins/patches.ts
	function enablePatches() {
	  const errorOffset = 16;
	  if (process.env.NODE_ENV !== "production") {
	    errors.push(
	      'Sets cannot have "replace" patches.',
	      function(op) {
	        return "Unsupported patch operation: " + op;
	      },
	      function(path) {
	        return "Cannot apply patch, path doesn't resolve: " + path;
	      },
	      "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
	    );
	  }
	  const REPLACE = "replace";
	  const ADD = "add";
	  const REMOVE = "remove";
	  function generatePatches_(state, basePath, patches, inversePatches) {
	    switch (state.type_) {
	      case 0 /* Object */:
	      case 2 /* Map */:
	        return generatePatchesFromAssigned(
	          state,
	          basePath,
	          patches,
	          inversePatches
	        );
	      case 1 /* Array */:
	        return generateArrayPatches(state, basePath, patches, inversePatches);
	      case 3 /* Set */:
	        return generateSetPatches(
	          state,
	          basePath,
	          patches,
	          inversePatches
	        );
	    }
	  }
	  function generateArrayPatches(state, basePath, patches, inversePatches) {
	    let { base_, assigned_ } = state;
	    let copy_ = state.copy_;
	    if (copy_.length < base_.length) {
	      [base_, copy_] = [copy_, base_];
	      [patches, inversePatches] = [inversePatches, patches];
	    }
	    for (let i = 0; i < base_.length; i++) {
	      if (assigned_[i] && copy_[i] !== base_[i]) {
	        const path = basePath.concat([i]);
	        patches.push({
	          op: REPLACE,
	          path,
	          // Need to maybe clone it, as it can in fact be the original value
	          // due to the base/copy inversion at the start of this function
	          value: clonePatchValueIfNeeded(copy_[i])
	        });
	        inversePatches.push({
	          op: REPLACE,
	          path,
	          value: clonePatchValueIfNeeded(base_[i])
	        });
	      }
	    }
	    for (let i = base_.length; i < copy_.length; i++) {
	      const path = basePath.concat([i]);
	      patches.push({
	        op: ADD,
	        path,
	        // Need to maybe clone it, as it can in fact be the original value
	        // due to the base/copy inversion at the start of this function
	        value: clonePatchValueIfNeeded(copy_[i])
	      });
	    }
	    for (let i = copy_.length - 1; base_.length <= i; --i) {
	      const path = basePath.concat([i]);
	      inversePatches.push({
	        op: REMOVE,
	        path
	      });
	    }
	  }
	  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
	    const { base_, copy_ } = state;
	    each(state.assigned_, (key, assignedValue) => {
	      const origValue = get(base_, key);
	      const value = get(copy_, key);
	      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
	      if (origValue === value && op === REPLACE)
	        return;
	      const path = basePath.concat(key);
	      patches.push(op === REMOVE ? { op, path } : { op, path, value });
	      inversePatches.push(
	        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }
	      );
	    });
	  }
	  function generateSetPatches(state, basePath, patches, inversePatches) {
	    let { base_, copy_ } = state;
	    let i = 0;
	    base_.forEach((value) => {
	      if (!copy_.has(value)) {
	        const path = basePath.concat([i]);
	        patches.push({
	          op: REMOVE,
	          path,
	          value
	        });
	        inversePatches.unshift({
	          op: ADD,
	          path,
	          value
	        });
	      }
	      i++;
	    });
	    i = 0;
	    copy_.forEach((value) => {
	      if (!base_.has(value)) {
	        const path = basePath.concat([i]);
	        patches.push({
	          op: ADD,
	          path,
	          value
	        });
	        inversePatches.unshift({
	          op: REMOVE,
	          path,
	          value
	        });
	      }
	      i++;
	    });
	  }
	  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
	    patches.push({
	      op: REPLACE,
	      path: [],
	      value: replacement === NOTHING ? void 0 : replacement
	    });
	    inversePatches.push({
	      op: REPLACE,
	      path: [],
	      value: baseValue
	    });
	  }
	  function applyPatches_(draft, patches) {
	    patches.forEach((patch) => {
	      const { path, op } = patch;
	      let base = draft;
	      for (let i = 0; i < path.length - 1; i++) {
	        const parentType = getArchtype(base);
	        let p = path[i];
	        if (typeof p !== "string" && typeof p !== "number") {
	          p = "" + p;
	        }
	        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === "__proto__" || p === "constructor"))
	          die(errorOffset + 3);
	        if (typeof base === "function" && p === "prototype")
	          die(errorOffset + 3);
	        base = get(base, p);
	        if (typeof base !== "object")
	          die(errorOffset + 2, path.join("/"));
	      }
	      const type = getArchtype(base);
	      const value = deepClonePatchValue(patch.value);
	      const key = path[path.length - 1];
	      switch (op) {
	        case REPLACE:
	          switch (type) {
	            case 2 /* Map */:
	              return base.set(key, value);
	            case 3 /* Set */:
	              die(errorOffset);
	            default:
	              return base[key] = value;
	          }
	        case ADD:
	          switch (type) {
	            case 1 /* Array */:
	              return key === "-" ? base.push(value) : base.splice(key, 0, value);
	            case 2 /* Map */:
	              return base.set(key, value);
	            case 3 /* Set */:
	              return base.add(value);
	            default:
	              return base[key] = value;
	          }
	        case REMOVE:
	          switch (type) {
	            case 1 /* Array */:
	              return base.splice(key, 1);
	            case 2 /* Map */:
	              return base.delete(key);
	            case 3 /* Set */:
	              return base.delete(patch.value);
	            default:
	              return delete base[key];
	          }
	        default:
	          die(errorOffset + 1, op);
	      }
	    });
	    return draft;
	  }
	  function deepClonePatchValue(obj) {
	    if (!isDraftable(obj))
	      return obj;
	    if (Array.isArray(obj))
	      return obj.map(deepClonePatchValue);
	    if (isMap(obj))
	      return new Map(
	        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])
	      );
	    if (isSet(obj))
	      return new Set(Array.from(obj).map(deepClonePatchValue));
	    const cloned = Object.create(getPrototypeOf(obj));
	    for (const key in obj)
	      cloned[key] = deepClonePatchValue(obj[key]);
	    if (has(obj, DRAFTABLE))
	      cloned[DRAFTABLE] = obj[DRAFTABLE];
	    return cloned;
	  }
	  function clonePatchValueIfNeeded(obj) {
	    if (isDraft(obj)) {
	      return deepClonePatchValue(obj);
	    } else
	      return obj;
	  }
	  loadPlugin("Patches", {
	    applyPatches_,
	    generatePatches_,
	    generateReplacementPatches_
	  });
	}

	// src/immer.ts
	var immer = new Immer2();
	var produce = immer.produce;
	var produceWithPatches = immer.produceWithPatches.bind(
	  immer
	);
	var setAutoFreeze = immer.setAutoFreeze.bind(immer);
	var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
	var applyPatches = immer.applyPatches.bind(immer);
	var createDraft = immer.createDraft.bind(immer);
	var finishDraft = immer.finishDraft.bind(immer);
	function castDraft(value) {
	  return value;
	}
	function castImmutable(value) {
	  return value;
	}
	enableMapSet();
	enablePatches();
	
	return immer_cjs_development;
}

var hasRequiredCjs$6;

function requireCjs$6 () {
	if (hasRequiredCjs$6) return cjs$4.exports;
	hasRequiredCjs$6 = 1;

	if (process.env.NODE_ENV === 'production') {
	  cjs$4.exports = /*@__PURE__*/ requireImmer_cjs_production();
	} else {
	  cjs$4.exports = /*@__PURE__*/ requireImmer_cjs_development();
	}
	return cjs$4.exports;
}

var hasRequiredMakeSetter;

function requireMakeSetter () {
	if (hasRequiredMakeSetter) return makeSetter;
	hasRequiredMakeSetter = 1;
	Object.defineProperty(makeSetter, "__esModule", { value: true });
	makeSetter.makeSetter = makeSetter$1;
	makeSetter.makeSetterWithPatches = makeSetterWithPatches;
	const immer_with_plugins_1 = /*@__PURE__*/ requireCjs$6();
	const LazySignal_js_1 = /*@__PURE__*/ requireLazySignal();
	/**
	 * Concatenate Writable Tags
	 */
	function cwt(...allTags) {
	    return allTags
	        .filter(tags => tags !== undefined)
	        .reduce((acc, tags) => acc.concat(tags), []);
	}
	/**
	 * Creates a setter function that can be used to update a value.
	 */
	function makeSetter$1(update, prependTagsFn) {
	    const setter = (value, tags) => {
	        update(() => value, cwt(prependTagsFn?.(), tags));
	    };
	    setter.withProducer = (producer, tags) => {
	        update(oldData => {
	            const newData = (0, immer_with_plugins_1.produce)(oldData, producer);
	            if ((0, LazySignal_js_1.isAvailable)(newData)) {
	                return newData;
	            }
	            throw new Error("Cannot update value to NOT_AVAILABLE");
	        }, cwt(prependTagsFn?.(), tags));
	    };
	    setter.withUpdater = (updater, tags) => {
	        update(updater, cwt(prependTagsFn?.(), tags));
	    };
	    setter.withPatchUpdater = (updater, tags) => {
	        update(oldData => {
	            const [newData, _patches] = updater(oldData);
	            return newData;
	        }, cwt(prependTagsFn?.(), tags));
	    };
	    setter.withPatches = (patches, tags) => {
	        update(oldData => {
	            return (0, immer_with_plugins_1.applyPatches)(oldData, patches);
	        }, cwt(prependTagsFn?.(), tags));
	    };
	    setter.withValueAndPatches = (newValue, _patches, tags) => {
	        update(() => newValue, cwt(prependTagsFn?.(), tags));
	    };
	    return setter;
	}
	function makeRootReplacingPatches(value) {
	    return [
	        {
	            op: "replace",
	            path: [],
	            value,
	        },
	    ];
	}
	/**
	 * Creates a setter function that can be used to update a value. This setter will also return the
	 * patches that were applied to the value.
	 */
	function makeSetterWithPatches(update, prependTagsFn) {
	    const setter = (value, tags) => {
	        update(() => [value, makeRootReplacingPatches(value)], cwt(prependTagsFn?.(), tags));
	    };
	    setter.withProducer = (producer, tags) => {
	        update(oldData => {
	            const [newData, patches] = (0, immer_with_plugins_1.produceWithPatches)(oldData, producer);
	            if ((0, LazySignal_js_1.isAvailable)(newData)) {
	                return [newData, patches];
	            }
	            throw new Error("Cannot update value to NOT_AVAILABLE");
	        }, cwt(prependTagsFn?.(), tags));
	    };
	    setter.withUpdater = (updater, tags) => {
	        update(oldData => {
	            const newData = updater(oldData);
	            return [newData, makeRootReplacingPatches(newData)];
	        }, cwt(prependTagsFn?.(), tags));
	    };
	    setter.withPatchUpdater = (updater, tags) => {
	        update(updater, cwt(prependTagsFn?.(), tags));
	    };
	    setter.withPatches = (patches, tags) => {
	        update(oldData => {
	            return [(0, immer_with_plugins_1.applyPatches)(oldData, patches), patches];
	        }, cwt(prependTagsFn?.(), tags));
	    };
	    setter.withValueAndPatches = (newValue, patches, tags) => {
	        update(() => [newValue, patches], cwt(prependTagsFn?.(), tags));
	    };
	    return setter;
	}
	
	return makeSetter;
}

var hasRequiredSignal;

function requireSignal () {
	if (hasRequiredSignal) return Signal;
	hasRequiredSignal = 1;
	Object.defineProperty(Signal, "__esModule", { value: true });
	Signal.Signal = void 0;
	const Subscribable_js_1 = /*@__PURE__*/ requireSubscribable();
	const makePromise_js_1 = /*@__PURE__*/ requireMakePromise();
	const makeSetter_js_1 = /*@__PURE__*/ requireMakeSetter();
	const equals = (a, b) => a === b;
	/**
	 * A signal is a wrapper for a value. It can be used to notify subscribers when the value changes.
	 * For it to work properly, the value should be immutable.
	 *
	 * To create a signal, please use the `Signal.create` static method. It will return a signal
	 * along with a function to update its value.
	 */
	let Signal$1 = class Signal extends Subscribable_js_1.Subscribable {
	    /**
	     * Creates a signal.
	     *
	     * @param value - The initial value of the signal.
	     * @param equalsPredicate - A function to compare two values. The subscribers will only be called
	     * if the value changes according to the `equalsPredicate`. By default, it uses the `===`
	     * operator.
	     * @returns This method returns a tuple with two elements:
	     * - The signal
	     * - A function to update the value
	     **/
	    static create(value, equalsPredicate = equals) {
	        const signal = new Signal(value, equalsPredicate);
	        const update = (updater, tags) => {
	            signal.update(updater, tags);
	        };
	        const setter = (0, makeSetter_js_1.makeSetterWithPatches)(update);
	        return [signal, setter];
	    }
	    static createReadonly(value) {
	        return Signal.create(value)[0];
	    }
	    constructor(value, equalsPredicate) {
	        super();
	        this.value = value;
	        this.equalsPredicate = equalsPredicate;
	        this.subscribers = new Set();
	        this.queuedUpdaters = [];
	        this.isEmitting = false;
	    }
	    /**
	     * Returns the current value of the signal.
	     */
	    get() {
	        return this.value;
	    }
	    pull() {
	        return this.value;
	    }
	    notifyFull(value, patches, tags) {
	        for (const { type, callback } of this.subscribers) {
	            if (type === "full") {
	                callback(value, patches, tags);
	            }
	        }
	    }
	    notifyAll(value, patches, tags) {
	        for (const { type, callback } of this.subscribers) {
	            if (type === "regular") {
	                callback(value);
	            }
	            else {
	                callback(value, patches, tags);
	            }
	        }
	    }
	    notifyAndUpdateIfChanged(value, patches, tags) {
	        // If the value has changed, or if there are any tags that need to be flushed, notify
	        if (!this.equalsPredicate(this.value, value)) {
	            this.value = value;
	            // If the values have changed, notify everyone
	            this.notifyAll(value, patches, tags);
	        }
	        else if (tags.length > 0) {
	            // If values not changed, but there is a tag to be flushed, notify only full subscribers
	            this.notifyFull(value, patches, tags);
	        }
	    }
	    isReplaceRoot(patch) {
	        return patch.path.length === 0 && patch.op === "replace";
	    }
	    update(updater, tags) {
	        this.queuedUpdaters.push([updater, tags]);
	        // Only one concurrent update may emit
	        if (this.isEmitting) {
	            return;
	        }
	        this.isEmitting = true;
	        try {
	            // Outer while is for handling new updates caused by the notify
	            while (this.queuedUpdaters.length > 0) {
	                let value = this.value;
	                let patches = [];
	                const tags = [];
	                // Inner while is for handling multiple updates
	                while (this.queuedUpdaters.length > 0) {
	                    const [updater, newTags] = this.queuedUpdaters.shift();
	                    const [newValue, newPatches] = updater(value);
	                    value = newValue;
	                    // Extremely rudimentary patch merging
	                    const rootReplacerIndex = newPatches.findIndex(this.isReplaceRoot);
	                    if (rootReplacerIndex !== -1) {
	                        patches = newPatches.slice(rootReplacerIndex);
	                    }
	                    else {
	                        patches.push(...newPatches);
	                    }
	                    if (newTags !== undefined) {
	                        tags.push(...newTags);
	                    }
	                }
	                this.notifyAndUpdateIfChanged(value, patches, tags);
	            }
	        }
	        finally {
	            this.isEmitting = false;
	        }
	    }
	    /**
	     * Subscribes to the signal. The callback will be called whenever the value changes. All callbacks
	     * are called synchronously upon updating. It will NOT be immediately called with the current
	     * value. (Use `get()` to get the current value.) Returns a function to unsubscribe.
	     *
	     * Edge cases involving manipulating the signal in the callback:
	     *
	     * - If the callback adds new subscribers, they will also be called within the same update.
	     * - If the callback causes removal of subscribers that have not been called yet, they will no
	     *   longer be called.
	     * - If the callback causes an update of the value, the update will be queued. If multiple updates
	     *   are queued, only the last one will be executed.
	     *
	     * Edge cases involving adding the same callback multiple times.
	     *
	     *  - Callbacks are tracked with a set. Adding the same subscriber will not cause it to be called
	     *    multiple times.
	     */
	    subscribe(callback) {
	        const subscriber = {
	            type: "regular",
	            callback,
	        };
	        this.subscribers.add(subscriber);
	        return () => {
	            this.subscribers.delete(subscriber);
	        };
	    }
	    /**
	     * Subscribes to the signal with the callback and trigger the callback immediately with the
	     * current value.
	     */
	    subscribeAndNow(callback) {
	        const unsubscribe = this.subscribe(callback);
	        callback(this.value);
	        return unsubscribe;
	    }
	    subscribeFull(callback) {
	        const subscriber = {
	            type: "full",
	            callback,
	        };
	        this.subscribers.add(subscriber);
	        return () => {
	            this.subscribers.delete(subscriber);
	        };
	    }
	    /**
	     * Wait until the signal satisfies a predicate. If the predicate is already satisfied, it will
	     * return immediately. Otherwise, it will wait until the signal satisfies the predicate.
	     */
	    async until(predicate) {
	        const current = this.get();
	        if (predicate(current)) {
	            return current;
	        }
	        const { promise, resolve } = (0, makePromise_js_1.makePromise)();
	        const unsubscribe = this.subscribe(data => {
	            if (predicate(data)) {
	                resolve(data);
	                unsubscribe();
	            }
	        });
	        return await promise;
	    }
	};
	Signal.Signal = Signal$1;
	
	return Signal;
}

var hasRequiredLazySignal;

function requireLazySignal () {
	if (hasRequiredLazySignal) return LazySignal;
	hasRequiredLazySignal = 1;
	Object.defineProperty(LazySignal, "__esModule", { value: true });
	LazySignal.LazySignal = void 0;
	LazySignal.isAvailable = isAvailable;
	const Event_js_1 = /*@__PURE__*/ requireEvent();
	const Signal_js_1 = /*@__PURE__*/ requireSignal();
	const Subscribable_js_1 = /*@__PURE__*/ requireSubscribable();
	const makePromise_js_1 = /*@__PURE__*/ requireMakePromise();
	const makeSetter_js_1 = /*@__PURE__*/ requireMakeSetter();
	function isAvailable(data) {
	    return data !== LazySignal$1.NOT_AVAILABLE;
	}
	/**
	 * A lazy signal is a signal that will only subscribe to the upstream when at least one subscriber
	 * is attached. It will unsubscribe from the upstream when the last subscriber is removed.
	 *
	 * A lazy signal can possess a special value "NOT_AVAILABLE", accessible from the static property
	 * {@link LazySignal.NOT_AVAILABLE}. This value is used to indicate that the value is not available
	 * yet. This can happen when the signal is created without an initial value and the upstream has not
	 * emitted a value yet.
	 */
	let LazySignal$1 = class LazySignal extends Subscribable_js_1.Subscribable {
	    static { this.NOT_AVAILABLE = Symbol("notAvailable"); }
	    static create(initialValue, subscribeUpstream, equalsPredicate = (a, b) => a === b) {
	        return new LazySignal(initialValue, subscribeUpstream, equalsPredicate);
	    }
	    static createWithoutInitialValue(subscribeUpstream, equalsPredicate = (a, b) => a === b) {
	        const fullEqualsPredicate = (a, b) => {
	            if (a === LazySignal.NOT_AVAILABLE || b === LazySignal.NOT_AVAILABLE) {
	                return a === b;
	            }
	            return equalsPredicate(a, b);
	        };
	        return new LazySignal(LazySignal.NOT_AVAILABLE, subscribeUpstream, fullEqualsPredicate);
	    }
	    static deriveFrom(sourceSignals, deriver, outputEqualsPredicate) {
	        let fullEqualsPredicate = undefined;
	        if (outputEqualsPredicate !== undefined) {
	            fullEqualsPredicate = (a, b) => {
	                if (a === LazySignal.NOT_AVAILABLE || b === LazySignal.NOT_AVAILABLE) {
	                    return a === b;
	                }
	                return outputEqualsPredicate(a, b);
	            };
	        }
	        const derive = () => {
	            const sourceValues = sourceSignals.map(signal => signal.get());
	            if (sourceValues.some(value => value === LazySignal.NOT_AVAILABLE)) {
	                return LazySignal.NOT_AVAILABLE;
	            }
	            return deriver(...sourceValues);
	        };
	        return new LazySignal(derive(), setDownstream => {
	            const unsubscriber = sourceSignals.map(signal => signal.subscribe(() => {
	                const value = derive();
	                if (isAvailable(value)) {
	                    setDownstream(value);
	                }
	            }));
	            const newValue = derive();
	            if (isAvailable(newValue)) {
	                setDownstream(newValue);
	            }
	            return () => {
	                unsubscriber.forEach(unsub => unsub());
	            };
	        }, fullEqualsPredicate);
	    }
	    static asyncDeriveFrom(strategy, sourceSignals, deriver, outputEqualsPredicate) {
	        let fullEqualsPredicate = undefined;
	        if (outputEqualsPredicate !== undefined) {
	            fullEqualsPredicate = (a, b) => {
	                if (a === LazySignal.NOT_AVAILABLE || b === LazySignal.NOT_AVAILABLE) {
	                    return a === b;
	                }
	                return outputEqualsPredicate(a, b);
	            };
	        }
	        let lastAppliedUpdateId = -1;
	        let lastIssuedUpdateId = -1;
	        return new LazySignal(LazySignal.NOT_AVAILABLE, setDownstream => {
	            const deriveAndUpdate = () => {
	                lastIssuedUpdateId++;
	                const updateId = lastIssuedUpdateId;
	                const sourceValues = sourceSignals.map(signal => signal.get());
	                if (sourceValues.some(value => value === LazySignal.NOT_AVAILABLE)) {
	                    return;
	                }
	                deriver(...sourceValues).then(result => {
	                    if (!isAvailable(result)) {
	                        return;
	                    }
	                    switch (strategy) {
	                        case "eager": {
	                            if (updateId > lastAppliedUpdateId) {
	                                lastAppliedUpdateId = updateId;
	                                setDownstream(result);
	                            }
	                            break;
	                        }
	                        default: {
	                            const exhaustiveCheck = strategy;
	                            throw new Error(`Unknown strategy: ${exhaustiveCheck}`);
	                        }
	                    }
	                });
	            };
	            const unsubscriber = sourceSignals.map(signal => signal.subscribe(() => {
	                deriveAndUpdate();
	            }));
	            deriveAndUpdate();
	            return () => {
	                unsubscriber.forEach(unsub => unsub());
	            };
	        }, fullEqualsPredicate);
	    }
	    constructor(initialValue, subscribeUpstream, equalsPredicate = (a, b) => a === b) {
	        super();
	        this.subscribeUpstream = subscribeUpstream;
	        this.dataIsStale = true;
	        this.upstreamUnsubscribe = null;
	        this.subscribersCount = 0;
	        this.isSubscribedToUpstream = false;
	        this.updateReceivedSynchronousCallbacks = new Set();
	        [this.signal, this.setValue] = Signal_js_1.Signal.create(initialValue, equalsPredicate);
	        [this.updateReceivedEvent, this.emitUpdateReceivedEvent] = Event_js_1.Event.create();
	    }
	    /**
	     * Returns whether the value is currently stale.
	     *
	     * A value is stale whenever the upstream subscription is not active. This can happen in three
	     * cases:
	     *
	     * 1. When no subscriber is attached to this signal, the signal will not subscribe to the
	     *    upstream. In this case, the value is always stale.
	     * 2. When a subscriber is attached, but the upstream has not yet emitted a single value, the
	     *    value is also stale.
	     * 3. When the upstream has emitted an error. In this case, the subscription to the upstream is
	     *    terminated and the value is stale.
	     *
	     * If you wish to get the current value and ensure that it is not stale, use the method
	     * {@link LazySignal#pull}.
	     */
	    isStale() {
	        return this.dataIsStale;
	    }
	    subscribeToUpstream() {
	        this.isSubscribedToUpstream = true;
	        let subscribed = true;
	        let becameStale = false;
	        const unsubscribeFromUpstream = this.subscribeUpstream((0, makeSetter_js_1.makeSetterWithPatches)((updater, tags) => {
	            if (!subscribed) {
	                return;
	            }
	            this.setValue.withPatchUpdater(updater, tags);
	            this.dataIsStale = becameStale;
	            this.emitUpdateReceivedEvent();
	            for (const callback of this.updateReceivedSynchronousCallbacks) {
	                callback();
	            }
	        }), error => {
	            if (!subscribed) {
	                return;
	            }
	            Promise.reject(error); // Prints a global error for now
	            this.dataIsStale = true;
	            this.isSubscribedToUpstream = false;
	            this.upstreamUnsubscribe = null;
	            subscribed = false;
	        });
	        this.upstreamUnsubscribe = () => {
	            if (subscribed) {
	                subscribed = false;
	                becameStale = true;
	                unsubscribeFromUpstream();
	            }
	        };
	    }
	    unsubscribeFromUpstream() {
	        this.isSubscribedToUpstream = false;
	        if (this.upstreamUnsubscribe !== null) {
	            this.upstreamUnsubscribe();
	            this.upstreamUnsubscribe = null;
	            this.dataIsStale = true;
	        }
	    }
	    /**
	     * Gets the current value of the signal. If the value is not available, it will return
	     * {@link LazySignal.NOT_AVAILABLE}. (A value will only be unavailable if the signal is created
	     * without an initial value and the upstream has not emitted a value yet.)
	     *
	     * In addition, the value returned by this method may be stale. Use {@link LazySignal#isStale} to
	     * check if the value is stale.
	     *
	     * If you wish to get the current value and ensure that it is not stale, use the method
	     * {@link LazySignal#pull}.
	     */
	    get() {
	        return this.signal.get();
	    }
	    /**
	     * Pulls the current value of the signal. If the value is stale, it will subscribe and wait for
	     * the next value from the upstream and return it.
	     */
	    async pull() {
	        const { promise, resolve } = (0, makePromise_js_1.makePromise)();
	        if (!this.isStale()) {
	            // If not stale, definitely not "NOT_AVAILABLE"
	            resolve(this.get());
	        }
	        else {
	            const unsubscribe = this.subscribe(() => { });
	            this.updateReceivedEvent.subscribeOnce(() => {
	                resolve(this.get());
	            });
	            promise.then(unsubscribe);
	        }
	        return promise;
	    }
	    /**
	     * If the data is not stale, the callback will be called synchronously with the current value.
	     *
	     * If the data is stale, it will pull the current value and call the callback with the value.
	     */
	    runOnNextFreshData(callback) {
	        if (!this.isStale()) {
	            callback(this.get());
	        }
	        else {
	            let unsubscribe = null;
	            const updateCallback = () => {
	                this.updateReceivedSynchronousCallbacks.delete(updateCallback);
	                callback(this.get());
	                unsubscribe?.();
	            };
	            this.updateReceivedSynchronousCallbacks.add(updateCallback);
	            unsubscribe = this.subscribe(() => { });
	        }
	    }
	    async ensureAvailable() {
	        await this.pull();
	        return this;
	    }
	    subscribe(subscriber) {
	        if (!this.isSubscribedToUpstream) {
	            this.subscribeToUpstream();
	        }
	        this.subscribersCount++;
	        const unsubscribe = this.signal.subscribe(subscriber);
	        let unsubscribeCalled = false;
	        return () => {
	            if (unsubscribeCalled) {
	                return;
	            }
	            unsubscribe();
	            unsubscribeCalled = true;
	            this.subscribersCount--;
	            if (this.subscribersCount === 0 && this.isSubscribedToUpstream) {
	                this.unsubscribeFromUpstream();
	            }
	        };
	    }
	    subscribeFull(subscriber) {
	        if (!this.isSubscribedToUpstream) {
	            this.subscribeToUpstream();
	        }
	        this.subscribersCount++;
	        const unsubscribe = this.signal.subscribeFull(subscriber);
	        let unsubscribeCalled = false;
	        return () => {
	            if (unsubscribeCalled) {
	                return;
	            }
	            unsubscribe();
	            unsubscribeCalled = true;
	            this.subscribersCount--;
	            if (this.subscribersCount === 0 && this.isSubscribedToUpstream) {
	                this.unsubscribeFromUpstream();
	            }
	        };
	    }
	    /**
	     * Subscribes to the signal. Will not cause the signal to subscribe to the upstream.
	     */
	    passiveSubscribe(subscriber) {
	        return this.signal.subscribe(subscriber);
	    }
	    passiveSubscribeFull(subscriber) {
	        return this.signal.subscribeFull(subscriber);
	    }
	    async until(predicate) {
	        const current = this.get();
	        if (isAvailable(current) && predicate(current)) {
	            return current;
	        }
	        const { promise, resolve } = (0, makePromise_js_1.makePromise)();
	        const unsubscribe = this.subscribe(data => {
	            if (isAvailable(data) && predicate(data)) {
	                resolve(data);
	                unsubscribe();
	            }
	        });
	        return await promise;
	    }
	};
	LazySignal.LazySignal = LazySignal$1;
	
	return LazySignal;
}

var apiServerPorts = {};

var hasRequiredApiServerPorts;

function requireApiServerPorts () {
	if (hasRequiredApiServerPorts) return apiServerPorts;
	hasRequiredApiServerPorts = 1;
	Object.defineProperty(apiServerPorts, "__esModule", { value: true });
	apiServerPorts.apiServerPorts = void 0;
	apiServerPorts.apiServerPorts = [41343, 52993, 16141, 39414, 22931];
	
	return apiServerPorts;
}

var BufferedEvent = {};

var hasRequiredBufferedEvent;

function requireBufferedEvent () {
	if (hasRequiredBufferedEvent) return BufferedEvent;
	hasRequiredBufferedEvent = 1;
	Object.defineProperty(BufferedEvent, "__esModule", { value: true });
	BufferedEvent.BufferedEvent = void 0;
	const Event_js_1 = /*@__PURE__*/ requireEvent();
	const Subscribable_js_1 = /*@__PURE__*/ requireSubscribable();
	const waitForNextMicroTask = Symbol();
	/**
	 * A buffered event will buffer events in a queue if no subscribers are present. When a subscriber
	 * is added, all buffered events will trigger sequentially in the next microtask.
	 *
	 * Similar to Event, events are always emitted during the next microtask.
	 *
	 * Attempting to add more than one subscriber will resulting in an error.
	 */
	let BufferedEvent$1 = class BufferedEvent extends Subscribable_js_1.Subscribable {
	    static create() {
	        const event = new BufferedEvent();
	        const emitter = data => {
	            event.emit(data);
	        };
	        return [event, emitter];
	    }
	    constructor() {
	        super();
	        this.subscriber = null;
	        this.queued = [];
	        this.isNotifying = false;
	    }
	    emit(data) {
	        if (this.queued.length === 0 && this.queued.at(-1) !== waitForNextMicroTask) {
	            this.queued.push(waitForNextMicroTask);
	        }
	        this.queued.push(data);
	        if (!this.isNotifying) {
	            this.notifier();
	        }
	    }
	    async notifier() {
	        this.isNotifying = true;
	        while (this.subscriber !== null && this.queued.length > 0) {
	            const data = this.queued.shift();
	            if (data === waitForNextMicroTask) {
	                await Promise.resolve();
	            }
	            else {
	                this.subscriber(data);
	            }
	        }
	        this.isNotifying = false;
	    }
	    subscribe(listener) {
	        if (this.subscriber !== null) {
	            throw new Error("Cannot have more than one subscriber");
	        }
	        this.subscriber = listener;
	        if (!this.isNotifying && this.queued.length > 0) {
	            this.queued = [
	                waitForNextMicroTask,
	                ...this.queued.filter(data => data !== waitForNextMicroTask),
	            ];
	            this.notifier();
	        }
	        return () => {
	            this.subscriber = null;
	        };
	    }
	    /**
	     * Convert this buffered event to an event by stop buffering and triggering events on the new
	     * returned event.
	     */
	    flow() {
	        const [event, emit] = Event_js_1.Event.create();
	        this.subscribe(emit);
	        return event;
	    }
	};
	BufferedEvent.BufferedEvent = BufferedEvent$1;
	
	return BufferedEvent;
}

var CancelEvent = {};

var hasRequiredCancelEvent;

function requireCancelEvent () {
	if (hasRequiredCancelEvent) return CancelEvent;
	hasRequiredCancelEvent = 1;
	Object.defineProperty(CancelEvent, "__esModule", { value: true });
	CancelEvent.CancelEvent = void 0;
	const Subscribable_js_1 = /*@__PURE__*/ requireSubscribable();
	let CancelEvent$1 = class CancelEvent extends Subscribable_js_1.Subscribable {
	    constructor() {
	        super(...arguments);
	        this.canceled = false;
	        this.listeners = new Set();
	    }
	    subscribe(listener) {
	        if (this.canceled) {
	            let callbackCanceled = false;
	            Promise.resolve().then(() => {
	                if (!callbackCanceled) {
	                    listener();
	                }
	            });
	            return () => {
	                callbackCanceled = true;
	            };
	        }
	        this.listeners.add(listener);
	        return () => {
	            this.listeners.delete(listener);
	        };
	    }
	    cancel() {
	        if (this.canceled) {
	            throw new Error("Already canceled");
	        }
	        this.canceled = true;
	        for (const listener of this.listeners) {
	            listener();
	        }
	    }
	};
	CancelEvent.CancelEvent = CancelEvent$1;
	
	return CancelEvent;
}

var Cleaner = {};

var hasRequiredCleaner;

function requireCleaner () {
	if (hasRequiredCleaner) return Cleaner;
	hasRequiredCleaner = 1;
	Object.defineProperty(Cleaner, "__esModule", { value: true });
	Cleaner.Cleaner = void 0;
	let Cleaner$1 = class Cleaner {
	    constructor() {
	        this.eagerCleaned = false;
	        this.disposed = false;
	        this.cleanups = [];
	    }
	    register(fn) {
	        if (this.eagerCleaned) {
	            throw new Error("Cannot register a cleanup after eagerClean() was called.");
	        }
	        if (this.disposed) {
	            throw new Error("Cannot register a cleanup after the Cleaner was disposed.");
	        }
	        this.cleanups.push(fn);
	    }
	    runCleanersInternal() {
	        for (const cleanup of this.cleanups) {
	            cleanup();
	        }
	        // Just to free some memory because why not
	        this.cleanups.length = 0;
	    }
	    [Symbol.dispose]() {
	        if (this.eagerCleaned) {
	            // Already eagerly cleaned. Nothing to do.
	            return;
	        }
	        if (this.disposed) {
	            throw new Error("Cannot dispose a Cleaner that was already disposed.");
	        }
	        this.runCleanersInternal();
	    }
	    eagerClean() {
	        if (this.eagerCleaned) {
	            throw new Error("Cannot call eagerClean() twice.");
	        }
	        if (this.disposed) {
	            throw new Error("Cannot call eagerClean() after the Cleaner was disposed.");
	        }
	        this.eagerCleaned = true;
	        this.runCleanersInternal();
	    }
	};
	Cleaner.Cleaner = Cleaner$1;
	
	return Cleaner;
}

var deepFreeze = {};

var hasRequiredDeepFreeze;

function requireDeepFreeze () {
	if (hasRequiredDeepFreeze) return deepFreeze;
	hasRequiredDeepFreeze = 1;
	Object.defineProperty(deepFreeze, "__esModule", { value: true });
	deepFreeze.deepFreeze = deepFreeze$1;
	function deepFreeze$1(obj) {
	    if (typeof obj !== "object" || obj === null) {
	        return obj;
	    }
	    if (Object.isFrozen(obj)) {
	        return obj;
	    }
	    Object.freeze(obj);
	    for (const key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	            deepFreeze$1(obj[key]);
	        }
	    }
	    return obj;
	}
	
	return deepFreeze;
}

var errorStack = {};

var hasRequiredErrorStack;

function requireErrorStack () {
	if (hasRequiredErrorStack) return errorStack;
	hasRequiredErrorStack = 1;
	var __importDefault = (errorStack && errorStack.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(errorStack, "__esModule", { value: true });
	errorStack.getCurrentStack = getCurrentStack;
	errorStack.changeErrorStackInPlace = changeErrorStackInPlace;
	const process_1 = __importDefault(require$$0$3);
	// Error stack manipulation related functions
	function getCurrentStack(goAbove = 0) {
	    const stack = new Error().stack;
	    if (!stack) {
	        return "";
	    }
	    const lines = stack.split("\n");
	    return lines.slice(2 + goAbove).join("\n");
	}
	function changeErrorStackInPlace(error, newStack) {
	    if (process_1.default.env.LMS_KEEP_INTERNAL_STACK) {
	        return;
	    }
	    const stackContent = error.stack ?? "";
	    error.stack = (stackContent.substring(0, stackContent.indexOf("\n    at ")).trimEnd() +
	        "\n" +
	        newStack).trimEnd();
	}
	
	return errorStack;
}

var fileName = {};

var hasRequiredFileName;

function requireFileName () {
	if (hasRequiredFileName) return fileName;
	hasRequiredFileName = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.doesFileNameIndicateModel = exports.modelExtensions = void 0;
		exports.modelExtensions = [".gguf"];
		const doesFileNameIndicateModel = (path) => {
		    return exports.modelExtensions.some(ext => path.toLowerCase().endsWith(ext));
		};
		exports.doesFileNameIndicateModel = doesFileNameIndicateModel;
		
	} (fileName));
	return fileName;
}

var flattenSignal = {};

var hasRequiredFlattenSignal;

function requireFlattenSignal () {
	if (hasRequiredFlattenSignal) return flattenSignal;
	hasRequiredFlattenSignal = 1;
	Object.defineProperty(flattenSignal, "__esModule", { value: true });
	flattenSignal.flattenSignalOfSignal = flattenSignalOfSignal;
	flattenSignal.flattenSignalOfWritableSignal = flattenSignalOfWritableSignal;
	const LazySignal_js_1 = /*@__PURE__*/ requireLazySignal();
	const makeSetter_js_1 = /*@__PURE__*/ requireMakeSetter();
	/**
	 * Flatten a signal of signals into a single signal.
	 */
	function flattenSignalOfSignal(rootSignal) {
	    return LazySignal_js_1.LazySignal.createWithoutInitialValue(setDownstream => {
	        let unsubscribeInnerSignal = null;
	        const subscribeToInnerSignal = (maybeInnerSignal) => {
	            if (!(0, LazySignal_js_1.isAvailable)(maybeInnerSignal)) {
	                return () => { };
	            }
	            if (unsubscribeInnerSignal !== null) {
	                unsubscribeInnerSignal();
	                unsubscribeInnerSignal = null;
	            }
	            unsubscribeInnerSignal = maybeInnerSignal.subscribeFull((value, patches, tags) => {
	                if (!(0, LazySignal_js_1.isAvailable)(value)) {
	                    return;
	                }
	                setDownstream.withValueAndPatches(value, patches, tags);
	            });
	            const currentValue = maybeInnerSignal.get();
	            if ((0, LazySignal_js_1.isAvailable)(currentValue)) {
	                setDownstream(currentValue);
	            }
	        };
	        const unsubscribeRootSignal = rootSignal.subscribe(subscribeToInnerSignal);
	        subscribeToInnerSignal(rootSignal.get());
	        return () => {
	            if (unsubscribeInnerSignal !== null) {
	                unsubscribeInnerSignal();
	            }
	            unsubscribeRootSignal();
	        };
	    });
	}
	/**
	 * Flatten a signal of writable signals into a single writable signal.
	 */
	function flattenSignalOfWritableSignal(rootSignal) {
	    // eslint-disable-next-line prefer-const
	    let signal;
	    let queuedUpdates = [];
	    let innerSetter = null;
	    const setter = (0, makeSetter_js_1.makeSetterWithPatches)((updater, tags) => {
	        if (innerSetter !== null) {
	            // If currently there is an inner setter, apply the update immediately
	            innerSetter.withPatchUpdater(updater, tags);
	        }
	        else {
	            // Otherwise, queue the update. Pull the signal to apply the update. (Application of queued
	            // updates is done in the inner subscription)
	            queuedUpdates.push({ updater, tags });
	            signal.pull().catch(console.error);
	        }
	    });
	    signal = LazySignal_js_1.LazySignal.createWithoutInitialValue(setDownstream => {
	        let unsubscribeInnerSignal = null;
	        const subscribeToInnerSignal = (maybeInnerSignal) => {
	            if (!(0, LazySignal_js_1.isAvailable)(maybeInnerSignal)) {
	                return () => { };
	            }
	            if (unsubscribeInnerSignal !== null) {
	                unsubscribeInnerSignal();
	                unsubscribeInnerSignal = null;
	            }
	            const maybeUpdateDownstream = (value, patches, tags) => {
	                if (!(0, LazySignal_js_1.isAvailable)(value)) {
	                    return;
	                }
	                if (patches !== undefined) {
	                    setDownstream.withValueAndPatches(value, patches, tags);
	                }
	                else {
	                    setDownstream(value, tags);
	                }
	                const setter = maybeInnerSignal[1];
	                // Apply queued updates
	                if (queuedUpdates.length !== 0) {
	                    const updatesToApply = queuedUpdates;
	                    queuedUpdates = [];
	                    let currentValue = value;
	                    let newPatches = [];
	                    const tags = [];
	                    for (const { updater, tags: newTags } of updatesToApply) {
	                        [currentValue, newPatches] = updater(currentValue);
	                        if (newTags !== undefined) {
	                            tags.push(...newTags);
	                        }
	                        newPatches.push(...newPatches);
	                    }
	                    setter.withValueAndPatches(currentValue, newPatches, tags);
	                }
	                innerSetter = setter;
	            };
	            unsubscribeInnerSignal = maybeInnerSignal[0].subscribeFull(maybeUpdateDownstream);
	            maybeUpdateDownstream(maybeInnerSignal[0].get());
	        };
	        const unsubscribeRootSignal = rootSignal.subscribe(subscribeToInnerSignal);
	        subscribeToInnerSignal(rootSignal.get());
	        return () => {
	            if (unsubscribeInnerSignal !== null) {
	                unsubscribeInnerSignal();
	            }
	            innerSetter = null;
	            unsubscribeRootSignal();
	        };
	    });
	    return [signal, setter];
	}
	
	return flattenSignal;
}

var HandledEvent = {};

var hasRequiredHandledEvent;

function requireHandledEvent () {
	if (hasRequiredHandledEvent) return HandledEvent;
	hasRequiredHandledEvent = 1;
	Object.defineProperty(HandledEvent, "__esModule", { value: true });
	HandledEvent.HandledEvent = void 0;
	const Subscribable_js_1 = /*@__PURE__*/ requireSubscribable();
	/**
	 * Emit events immediately and returns a promise when all handlers are done.
	 *
	 * May cause problems if listeners are added or removed during the event.
	 */
	let HandledEvent$1 = class HandledEvent extends Subscribable_js_1.Subscribable {
	    constructor() {
	        super(...arguments);
	        this.listeners = new Set();
	    }
	    static create() {
	        const event = new HandledEvent();
	        return [event, event.emit.bind(event)];
	    }
	    subscribe(listener) {
	        this.listeners.add(listener);
	        return () => {
	            this.listeners.delete(listener);
	        };
	    }
	    async emit(data) {
	        const promises = [];
	        for (const listener of this.listeners) {
	            promises.push(Promise.resolve(listener(data)));
	        }
	        await Promise.all(promises);
	    }
	};
	HandledEvent.HandledEvent = HandledEvent$1;
	
	return HandledEvent;
}

var makePrettyError = {};

var cjs$3 = {};

var generateRandomBase64 = {};

var hasRequiredGenerateRandomBase64;

function requireGenerateRandomBase64 () {
	if (hasRequiredGenerateRandomBase64) return generateRandomBase64;
	hasRequiredGenerateRandomBase64 = 1;
	Object.defineProperty(generateRandomBase64, "__esModule", { value: true });
	generateRandomBase64.generateRandomBase64 = generateRandomBase64$1;
	const crypto_1 = require$$0$4;
	function generateRandomBase64$1(bytesOfRandomness = 18) {
	    const randomBytesBuffer = (0, crypto_1.randomBytes)(bytesOfRandomness);
	    return randomBytesBuffer.toString("base64");
	}
	
	return generateRandomBase64;
}

var readFileAsBase64 = {};

var hasRequiredReadFileAsBase64;

function requireReadFileAsBase64 () {
	if (hasRequiredReadFileAsBase64) return readFileAsBase64;
	hasRequiredReadFileAsBase64 = 1;
	Object.defineProperty(readFileAsBase64, "__esModule", { value: true });
	readFileAsBase64.readFileAsBase64 = readFileAsBase64$1;
	const promises_1 = require$$0$5;
	async function readFileAsBase64$1(path) {
	    return { success: true, base64: await (0, promises_1.readFile)(path, "base64") };
	}
	
	return readFileAsBase64;
}

var terminalSize = {};

var hasRequiredTerminalSize;

function requireTerminalSize () {
	if (hasRequiredTerminalSize) return terminalSize;
	hasRequiredTerminalSize = 1;
	// This file is vendored from https://www.npmjs.com/package/terminal-size
	// with minimum changes to make it work in TypeScript.
	//
	// Done to support CommonJS
	var __importDefault = (terminalSize && terminalSize.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(terminalSize, "__esModule", { value: true });
	terminalSize.terminalSize = terminalSize$1;
	const child_process_1 = require$$0$7;
	const fs_1 = __importDefault(require$$0$6);
	const process_1 = __importDefault(require$$0$3);
	const tty_1 = __importDefault(require$$3$1);
	const defaultColumns = 80;
	const defaultRows = 24;
	const exec = (command, arguments_, { shell, env } = {}) => (0, child_process_1.execFileSync)(command, arguments_, {
	    encoding: "utf8",
	    stdio: ["ignore", "pipe", "ignore"],
	    timeout: 500,
	    shell,
	    env,
	}).trim();
	const create = (columns, rows) => ({
	    columns: Number.parseInt(columns, 10),
	    rows: Number.parseInt(rows, 10),
	});
	const createIfNotDefault = (maybeColumns, maybeRows) => {
	    const { columns, rows } = create(maybeColumns, maybeRows);
	    if (Number.isNaN(columns) || Number.isNaN(rows)) {
	        return;
	    }
	    if (columns === defaultColumns && rows === defaultRows) {
	        return;
	    }
	    return { columns, rows };
	};
	function terminalSize$1() {
	    const { env, stdout, stderr } = process_1.default;
	    if (stdout?.columns && stdout?.rows) {
	        return create(stdout.columns, stdout.rows);
	    }
	    if (stderr?.columns && stderr?.rows) {
	        return create(stderr.columns, stderr.rows);
	    }
	    // These values are static, so not the first choice.
	    if (env.COLUMNS && env.LINES) {
	        return create(env.COLUMNS, env.LINES);
	    }
	    const fallback = {
	        columns: defaultColumns,
	        rows: defaultRows,
	    };
	    if (process_1.default.platform === "win32") {
	        // We include `tput` for Windows users using Git Bash.
	        return tput() ?? fallback;
	    }
	    if (process_1.default.platform === "darwin") {
	        return devTty() ?? tput() ?? fallback;
	    }
	    return devTty() ?? tput() ?? resize() ?? fallback;
	}
	const devTty = () => {
	    try {
	        // eslint-disable-next-line no-bitwise
	        const flags = process_1.default.platform === "darwin"
	            ? fs_1.default.constants.O_EVTONLY | fs_1.default.constants.O_NONBLOCK
	            : fs_1.default.constants.O_NONBLOCK;
	        // eslint-disable-next-line new-cap
	        const { columns, rows } = tty_1.default.WriteStream(fs_1.default.openSync("/dev/tty", flags));
	        return { columns, rows };
	        // eslint-disable-next-line no-empty
	    }
	    catch { }
	};
	// On macOS, this only returns correct values when stdout is not redirected.
	const tput = () => {
	    try {
	        // `tput` requires the `TERM` environment variable to be set.
	        const columns = exec("tput", ["cols"], { env: { TERM: "dumb", ...process_1.default.env } });
	        const rows = exec("tput", ["lines"], { env: { TERM: "dumb", ...process_1.default.env } });
	        if (columns && rows) {
	            return createIfNotDefault(columns, rows);
	        }
	    }
	    catch {
	        /* empty */
	    }
	};
	// Only exists on Linux.
	const resize = () => {
	    // `resize` is preferred as it works even when all file descriptors are redirected
	    // https://linux.die.net/man/1/resize
	    try {
	        const size = exec("resize", ["-u"]).match(/\d+/g);
	        if (size.length === 2) {
	            return createIfNotDefault(size[0], size[1]);
	        }
	        // eslint-disable-next-line no-empty
	    }
	    catch { }
	};
	
	return terminalSize;
}

var WebSocket = {};

var bufferUtil = {exports: {}};

var constants;
var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;

	constants = {
	  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
	  EMPTY_BUFFER: Buffer.alloc(0),
	  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
	  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
	  kListener: Symbol('kListener'),
	  kStatusCode: Symbol('status-code'),
	  kWebSocket: Symbol('websocket'),
	  NOOP: () => {}
	};
	return constants;
}

var bufferutil = {exports: {}};

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

var nodeGypBuild$2;
var hasRequiredNodeGypBuild$2;

function requireNodeGypBuild$2 () {
	if (hasRequiredNodeGypBuild$2) return nodeGypBuild$2;
	hasRequiredNodeGypBuild$2 = 1;
	var fs = require$$0$6;
	var path = require$$1$1;
	var os = require$$2$1;

	// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'
	var runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : commonjsRequire; // eslint-disable-line

	var abi = process.versions.modules; // TODO: support old node where this is undef
	var runtime = isElectron() ? 'electron' : 'node';
	var arch = os.arch();
	var platform = os.platform();

	nodeGypBuild$2 = load;

	function load (dir) {
	  return runtimeRequire(load.path(dir))
	}

	load.path = function (dir) {
	  dir = path.resolve(dir || '.');

	  try {
	    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_');
	    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD'];
	  } catch (err) {}

	  var release = getFirst(path.join(dir, 'build/Release'), matchBuild);
	  if (release) return release

	  var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild);
	  if (debug) return debug

	  var prebuild = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchPrebuild);
	  if (prebuild) return prebuild

	  var napiRuntime = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapiRuntime);
	  if (napiRuntime) return napiRuntime

	  var napi = getFirst(path.join(dir, 'prebuilds/' + platform + '-' + arch), matchNapi);
	  if (napi) return napi

	  throw new Error('No native build was found for runtime=' + runtime + ' abi=' + abi + ' platform=' + platform + ' arch=' + arch)
	};

	function getFirst (dir, filter) {
	  try {
	    var files = fs.readdirSync(dir).filter(filter);
	    return files[0] && path.join(dir, files[0])
	  } catch (err) {
	    return null
	  }
	}

	function matchNapiRuntime (name) {
	  return name === runtime + '-napi.node'
	}

	function matchNapi (name) {
	  return name === 'node-napi.node'
	}

	function matchPrebuild (name) {
	  var parts = name.split('-');
	  return parts[0] === runtime && parts[1] === abi + '.node'
	}

	function matchBuild (name) {
	  return /\.node$/.test(name)
	}

	function isElectron () {
	  if (process.versions && process.versions.electron) return true
	  if (process.env.ELECTRON_RUN_AS_NODE) return true
	  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'
	}
	return nodeGypBuild$2;
}

var fallback$1;
var hasRequiredFallback$1;

function requireFallback$1 () {
	if (hasRequiredFallback$1) return fallback$1;
	hasRequiredFallback$1 = 1;

	/**
	 * Masks a buffer using the given mask.
	 *
	 * @param {Buffer} source The buffer to mask
	 * @param {Buffer} mask The mask to use
	 * @param {Buffer} output The buffer where to store the result
	 * @param {Number} offset The offset at which to start writing
	 * @param {Number} length The number of bytes to mask.
	 * @public
	 */
	const mask = (source, mask, output, offset, length) => {
	  for (var i = 0; i < length; i++) {
	    output[offset + i] = source[i] ^ mask[i & 3];
	  }
	};

	/**
	 * Unmasks a buffer using the given mask.
	 *
	 * @param {Buffer} buffer The buffer to unmask
	 * @param {Buffer} mask The mask to use
	 * @public
	 */
	const unmask = (buffer, mask) => {
	  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
	  const length = buffer.length;
	  for (var i = 0; i < length; i++) {
	    buffer[i] ^= mask[i & 3];
	  }
	};

	fallback$1 = { mask, unmask };
	return fallback$1;
}

var hasRequiredBufferutil;

function requireBufferutil () {
	if (hasRequiredBufferutil) return bufferutil.exports;
	hasRequiredBufferutil = 1;

	try {
	  bufferutil.exports = requireNodeGypBuild$2()(__dirname);
	} catch (e) {
	  bufferutil.exports = requireFallback$1();
	}
	return bufferutil.exports;
}

var hasRequiredBufferUtil;

function requireBufferUtil () {
	if (hasRequiredBufferUtil) return bufferUtil.exports;
	hasRequiredBufferUtil = 1;

	const { EMPTY_BUFFER } = requireConstants();

	const FastBuffer = Buffer[Symbol.species];

	/**
	 * Merges an array of buffers into a new buffer.
	 *
	 * @param {Buffer[]} list The array of buffers to concat
	 * @param {Number} totalLength The total length of buffers in the list
	 * @return {Buffer} The resulting buffer
	 * @public
	 */
	function concat(list, totalLength) {
	  if (list.length === 0) return EMPTY_BUFFER;
	  if (list.length === 1) return list[0];

	  const target = Buffer.allocUnsafe(totalLength);
	  let offset = 0;

	  for (let i = 0; i < list.length; i++) {
	    const buf = list[i];
	    target.set(buf, offset);
	    offset += buf.length;
	  }

	  if (offset < totalLength) {
	    return new FastBuffer(target.buffer, target.byteOffset, offset);
	  }

	  return target;
	}

	/**
	 * Masks a buffer using the given mask.
	 *
	 * @param {Buffer} source The buffer to mask
	 * @param {Buffer} mask The mask to use
	 * @param {Buffer} output The buffer where to store the result
	 * @param {Number} offset The offset at which to start writing
	 * @param {Number} length The number of bytes to mask.
	 * @public
	 */
	function _mask(source, mask, output, offset, length) {
	  for (let i = 0; i < length; i++) {
	    output[offset + i] = source[i] ^ mask[i & 3];
	  }
	}

	/**
	 * Unmasks a buffer using the given mask.
	 *
	 * @param {Buffer} buffer The buffer to unmask
	 * @param {Buffer} mask The mask to use
	 * @public
	 */
	function _unmask(buffer, mask) {
	  for (let i = 0; i < buffer.length; i++) {
	    buffer[i] ^= mask[i & 3];
	  }
	}

	/**
	 * Converts a buffer to an `ArrayBuffer`.
	 *
	 * @param {Buffer} buf The buffer to convert
	 * @return {ArrayBuffer} Converted buffer
	 * @public
	 */
	function toArrayBuffer(buf) {
	  if (buf.length === buf.buffer.byteLength) {
	    return buf.buffer;
	  }

	  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}

	/**
	 * Converts `data` to a `Buffer`.
	 *
	 * @param {*} data The data to convert
	 * @return {Buffer} The buffer
	 * @throws {TypeError}
	 * @public
	 */
	function toBuffer(data) {
	  toBuffer.readOnly = true;

	  if (Buffer.isBuffer(data)) return data;

	  let buf;

	  if (data instanceof ArrayBuffer) {
	    buf = new FastBuffer(data);
	  } else if (ArrayBuffer.isView(data)) {
	    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
	  } else {
	    buf = Buffer.from(data);
	    toBuffer.readOnly = false;
	  }

	  return buf;
	}

	bufferUtil.exports = {
	  concat,
	  mask: _mask,
	  toArrayBuffer,
	  toBuffer,
	  unmask: _unmask
	};

	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) {
	  try {
	    const bufferUtil$1 = requireBufferutil();

	    bufferUtil.exports.mask = function (source, mask, output, offset, length) {
	      if (length < 48) _mask(source, mask, output, offset, length);
	      else bufferUtil$1.mask(source, mask, output, offset, length);
	    };

	    bufferUtil.exports.unmask = function (buffer, mask) {
	      if (buffer.length < 32) _unmask(buffer, mask);
	      else bufferUtil$1.unmask(buffer, mask);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return bufferUtil.exports;
}

var limiter;
var hasRequiredLimiter;

function requireLimiter () {
	if (hasRequiredLimiter) return limiter;
	hasRequiredLimiter = 1;

	const kDone = Symbol('kDone');
	const kRun = Symbol('kRun');

	/**
	 * A very simple job queue with adjustable concurrency. Adapted from
	 * https://github.com/STRML/async-limiter
	 */
	class Limiter {
	  /**
	   * Creates a new `Limiter`.
	   *
	   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
	   *     to run concurrently
	   */
	  constructor(concurrency) {
	    this[kDone] = () => {
	      this.pending--;
	      this[kRun]();
	    };
	    this.concurrency = concurrency || Infinity;
	    this.jobs = [];
	    this.pending = 0;
	  }

	  /**
	   * Adds a job to the queue.
	   *
	   * @param {Function} job The job to run
	   * @public
	   */
	  add(job) {
	    this.jobs.push(job);
	    this[kRun]();
	  }

	  /**
	   * Removes a job from the queue and runs it if possible.
	   *
	   * @private
	   */
	  [kRun]() {
	    if (this.pending === this.concurrency) return;

	    if (this.jobs.length) {
	      const job = this.jobs.shift();

	      this.pending++;
	      job(this[kDone]);
	    }
	  }
	}

	limiter = Limiter;
	return limiter;
}

var permessageDeflate;
var hasRequiredPermessageDeflate;

function requirePermessageDeflate () {
	if (hasRequiredPermessageDeflate) return permessageDeflate;
	hasRequiredPermessageDeflate = 1;

	const zlib = require$$0$8;

	const bufferUtil = requireBufferUtil();
	const Limiter = requireLimiter();
	const { kStatusCode } = requireConstants();

	const FastBuffer = Buffer[Symbol.species];
	const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
	const kPerMessageDeflate = Symbol('permessage-deflate');
	const kTotalLength = Symbol('total-length');
	const kCallback = Symbol('callback');
	const kBuffers = Symbol('buffers');
	const kError = Symbol('error');

	//
	// We limit zlib concurrency, which prevents severe memory fragmentation
	// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
	// and https://github.com/websockets/ws/issues/1202
	//
	// Intentionally global; it's the global thread pool that's an issue.
	//
	let zlibLimiter;

	/**
	 * permessage-deflate implementation.
	 */
	class PerMessageDeflate {
	  /**
	   * Creates a PerMessageDeflate instance.
	   *
	   * @param {Object} [options] Configuration options
	   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
	   *     for, or request, a custom client window size
	   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
	   *     acknowledge disabling of client context takeover
	   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
	   *     calls to zlib
	   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
	   *     use of a custom server window size
	   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
	   *     disabling of server context takeover
	   * @param {Number} [options.threshold=1024] Size (in bytes) below which
	   *     messages should not be compressed if context takeover is disabled
	   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
	   *     deflate
	   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
	   *     inflate
	   * @param {Boolean} [isServer=false] Create the instance in either server or
	   *     client mode
	   * @param {Number} [maxPayload=0] The maximum allowed message length
	   */
	  constructor(options, isServer, maxPayload) {
	    this._maxPayload = maxPayload | 0;
	    this._options = options || {};
	    this._threshold =
	      this._options.threshold !== undefined ? this._options.threshold : 1024;
	    this._isServer = !!isServer;
	    this._deflate = null;
	    this._inflate = null;

	    this.params = null;

	    if (!zlibLimiter) {
	      const concurrency =
	        this._options.concurrencyLimit !== undefined
	          ? this._options.concurrencyLimit
	          : 10;
	      zlibLimiter = new Limiter(concurrency);
	    }
	  }

	  /**
	   * @type {String}
	   */
	  static get extensionName() {
	    return 'permessage-deflate';
	  }

	  /**
	   * Create an extension negotiation offer.
	   *
	   * @return {Object} Extension parameters
	   * @public
	   */
	  offer() {
	    const params = {};

	    if (this._options.serverNoContextTakeover) {
	      params.server_no_context_takeover = true;
	    }
	    if (this._options.clientNoContextTakeover) {
	      params.client_no_context_takeover = true;
	    }
	    if (this._options.serverMaxWindowBits) {
	      params.server_max_window_bits = this._options.serverMaxWindowBits;
	    }
	    if (this._options.clientMaxWindowBits) {
	      params.client_max_window_bits = this._options.clientMaxWindowBits;
	    } else if (this._options.clientMaxWindowBits == null) {
	      params.client_max_window_bits = true;
	    }

	    return params;
	  }

	  /**
	   * Accept an extension negotiation offer/response.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Object} Accepted configuration
	   * @public
	   */
	  accept(configurations) {
	    configurations = this.normalizeParams(configurations);

	    this.params = this._isServer
	      ? this.acceptAsServer(configurations)
	      : this.acceptAsClient(configurations);

	    return this.params;
	  }

	  /**
	   * Releases all resources used by the extension.
	   *
	   * @public
	   */
	  cleanup() {
	    if (this._inflate) {
	      this._inflate.close();
	      this._inflate = null;
	    }

	    if (this._deflate) {
	      const callback = this._deflate[kCallback];

	      this._deflate.close();
	      this._deflate = null;

	      if (callback) {
	        callback(
	          new Error(
	            'The deflate stream was closed while data was being processed'
	          )
	        );
	      }
	    }
	  }

	  /**
	   *  Accept an extension negotiation offer.
	   *
	   * @param {Array} offers The extension negotiation offers
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsServer(offers) {
	    const opts = this._options;
	    const accepted = offers.find((params) => {
	      if (
	        (opts.serverNoContextTakeover === false &&
	          params.server_no_context_takeover) ||
	        (params.server_max_window_bits &&
	          (opts.serverMaxWindowBits === false ||
	            (typeof opts.serverMaxWindowBits === 'number' &&
	              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
	        (typeof opts.clientMaxWindowBits === 'number' &&
	          !params.client_max_window_bits)
	      ) {
	        return false;
	      }

	      return true;
	    });

	    if (!accepted) {
	      throw new Error('None of the extension offers can be accepted');
	    }

	    if (opts.serverNoContextTakeover) {
	      accepted.server_no_context_takeover = true;
	    }
	    if (opts.clientNoContextTakeover) {
	      accepted.client_no_context_takeover = true;
	    }
	    if (typeof opts.serverMaxWindowBits === 'number') {
	      accepted.server_max_window_bits = opts.serverMaxWindowBits;
	    }
	    if (typeof opts.clientMaxWindowBits === 'number') {
	      accepted.client_max_window_bits = opts.clientMaxWindowBits;
	    } else if (
	      accepted.client_max_window_bits === true ||
	      opts.clientMaxWindowBits === false
	    ) {
	      delete accepted.client_max_window_bits;
	    }

	    return accepted;
	  }

	  /**
	   * Accept the extension negotiation response.
	   *
	   * @param {Array} response The extension negotiation response
	   * @return {Object} Accepted configuration
	   * @private
	   */
	  acceptAsClient(response) {
	    const params = response[0];

	    if (
	      this._options.clientNoContextTakeover === false &&
	      params.client_no_context_takeover
	    ) {
	      throw new Error('Unexpected parameter "client_no_context_takeover"');
	    }

	    if (!params.client_max_window_bits) {
	      if (typeof this._options.clientMaxWindowBits === 'number') {
	        params.client_max_window_bits = this._options.clientMaxWindowBits;
	      }
	    } else if (
	      this._options.clientMaxWindowBits === false ||
	      (typeof this._options.clientMaxWindowBits === 'number' &&
	        params.client_max_window_bits > this._options.clientMaxWindowBits)
	    ) {
	      throw new Error(
	        'Unexpected or invalid parameter "client_max_window_bits"'
	      );
	    }

	    return params;
	  }

	  /**
	   * Normalize parameters.
	   *
	   * @param {Array} configurations The extension negotiation offers/reponse
	   * @return {Array} The offers/response with normalized parameters
	   * @private
	   */
	  normalizeParams(configurations) {
	    configurations.forEach((params) => {
	      Object.keys(params).forEach((key) => {
	        let value = params[key];

	        if (value.length > 1) {
	          throw new Error(`Parameter "${key}" must have only a single value`);
	        }

	        value = value[0];

	        if (key === 'client_max_window_bits') {
	          if (value !== true) {
	            const num = +value;
	            if (!Number.isInteger(num) || num < 8 || num > 15) {
	              throw new TypeError(
	                `Invalid value for parameter "${key}": ${value}`
	              );
	            }
	            value = num;
	          } else if (!this._isServer) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else if (key === 'server_max_window_bits') {
	          const num = +value;
	          if (!Number.isInteger(num) || num < 8 || num > 15) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	          value = num;
	        } else if (
	          key === 'client_no_context_takeover' ||
	          key === 'server_no_context_takeover'
	        ) {
	          if (value !== true) {
	            throw new TypeError(
	              `Invalid value for parameter "${key}": ${value}`
	            );
	          }
	        } else {
	          throw new Error(`Unknown parameter "${key}"`);
	        }

	        params[key] = value;
	      });
	    });

	    return configurations;
	  }

	  /**
	   * Decompress data. Concurrency limited.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  decompress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._decompress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Compress data. Concurrency limited.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @public
	   */
	  compress(data, fin, callback) {
	    zlibLimiter.add((done) => {
	      this._compress(data, fin, (err, result) => {
	        done();
	        callback(err, result);
	      });
	    });
	  }

	  /**
	   * Decompress data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _decompress(data, fin, callback) {
	    const endpoint = this._isServer ? 'client' : 'server';

	    if (!this._inflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._inflate = zlib.createInflateRaw({
	        ...this._options.zlibInflateOptions,
	        windowBits
	      });
	      this._inflate[kPerMessageDeflate] = this;
	      this._inflate[kTotalLength] = 0;
	      this._inflate[kBuffers] = [];
	      this._inflate.on('error', inflateOnError);
	      this._inflate.on('data', inflateOnData);
	    }

	    this._inflate[kCallback] = callback;

	    this._inflate.write(data);
	    if (fin) this._inflate.write(TRAILER);

	    this._inflate.flush(() => {
	      const err = this._inflate[kError];

	      if (err) {
	        this._inflate.close();
	        this._inflate = null;
	        callback(err);
	        return;
	      }

	      const data = bufferUtil.concat(
	        this._inflate[kBuffers],
	        this._inflate[kTotalLength]
	      );

	      if (this._inflate._readableState.endEmitted) {
	        this._inflate.close();
	        this._inflate = null;
	      } else {
	        this._inflate[kTotalLength] = 0;
	        this._inflate[kBuffers] = [];

	        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	          this._inflate.reset();
	        }
	      }

	      callback(null, data);
	    });
	  }

	  /**
	   * Compress data.
	   *
	   * @param {(Buffer|String)} data Data to compress
	   * @param {Boolean} fin Specifies whether or not this is the last fragment
	   * @param {Function} callback Callback
	   * @private
	   */
	  _compress(data, fin, callback) {
	    const endpoint = this._isServer ? 'server' : 'client';

	    if (!this._deflate) {
	      const key = `${endpoint}_max_window_bits`;
	      const windowBits =
	        typeof this.params[key] !== 'number'
	          ? zlib.Z_DEFAULT_WINDOWBITS
	          : this.params[key];

	      this._deflate = zlib.createDeflateRaw({
	        ...this._options.zlibDeflateOptions,
	        windowBits
	      });

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      this._deflate.on('data', deflateOnData);
	    }

	    this._deflate[kCallback] = callback;

	    this._deflate.write(data);
	    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
	      if (!this._deflate) {
	        //
	        // The deflate stream was closed while data was being processed.
	        //
	        return;
	      }

	      let data = bufferUtil.concat(
	        this._deflate[kBuffers],
	        this._deflate[kTotalLength]
	      );

	      if (fin) {
	        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
	      }

	      //
	      // Ensure that the callback will not be called again in
	      // `PerMessageDeflate#cleanup()`.
	      //
	      this._deflate[kCallback] = null;

	      this._deflate[kTotalLength] = 0;
	      this._deflate[kBuffers] = [];

	      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
	        this._deflate.reset();
	      }

	      callback(null, data);
	    });
	  }
	}

	permessageDeflate = PerMessageDeflate;

	/**
	 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function deflateOnData(chunk) {
	  this[kBuffers].push(chunk);
	  this[kTotalLength] += chunk.length;
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function inflateOnData(chunk) {
	  this[kTotalLength] += chunk.length;

	  if (
	    this[kPerMessageDeflate]._maxPayload < 1 ||
	    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
	  ) {
	    this[kBuffers].push(chunk);
	    return;
	  }

	  this[kError] = new RangeError('Max payload size exceeded');
	  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
	  this[kError][kStatusCode] = 1009;
	  this.removeListener('data', inflateOnData);
	  this.reset();
	}

	/**
	 * The listener of the `zlib.InflateRaw` stream `'error'` event.
	 *
	 * @param {Error} err The emitted error
	 * @private
	 */
	function inflateOnError(err) {
	  //
	  // There is no need to call `Zlib#close()` as the handle is automatically
	  // closed when an error is emitted.
	  //
	  this[kPerMessageDeflate]._inflate = null;
	  err[kStatusCode] = 1007;
	  this[kCallback](err);
	}
	return permessageDeflate;
}

var validation = {exports: {}};

var utf8Validate = {exports: {}};

var nodeGypBuild$1 = {exports: {}};

var nodeGypBuild;
var hasRequiredNodeGypBuild$1;

function requireNodeGypBuild$1 () {
	if (hasRequiredNodeGypBuild$1) return nodeGypBuild;
	hasRequiredNodeGypBuild$1 = 1;
	var fs = require$$0$6;
	var path = require$$1$1;
	var os = require$$2$1;

	// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'
	var runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : commonjsRequire; // eslint-disable-line

	var vars = (process.config && process.config.variables) || {};
	var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
	var abi = process.versions.modules; // TODO: support old node where this is undef
	var runtime = isElectron() ? 'electron' : (isNwjs() ? 'node-webkit' : 'node');

	var arch = process.env.npm_config_arch || os.arch();
	var platform = process.env.npm_config_platform || os.platform();
	var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc');
	var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || '';
	var uv = (process.versions.uv || '').split('.')[0];

	nodeGypBuild = load;

	function load (dir) {
	  return runtimeRequire(load.resolve(dir))
	}

	load.resolve = load.path = function (dir) {
	  dir = path.resolve(dir || '.');

	  try {
	    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_');
	    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD'];
	  } catch (err) {}

	  if (!prebuildsOnly) {
	    var release = getFirst(path.join(dir, 'build/Release'), matchBuild);
	    if (release) return release

	    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild);
	    if (debug) return debug
	  }

	  var prebuild = resolve(dir);
	  if (prebuild) return prebuild

	  var nearby = resolve(path.dirname(process.execPath));
	  if (nearby) return nearby

	  var target = [
	    'platform=' + platform,
	    'arch=' + arch,
	    'runtime=' + runtime,
	    'abi=' + abi,
	    'uv=' + uv,
	    armv ? 'armv=' + armv : '',
	    'libc=' + libc,
	    'node=' + process.versions.node,
	    process.versions.electron ? 'electron=' + process.versions.electron : '',
	    typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line
	  ].filter(Boolean).join(' ');

	  throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n')

	  function resolve (dir) {
	    // Find matching "prebuilds/<platform>-<arch>" directory
	    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple);
	    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
	    if (!tuple) return

	    // Find most specific flavor first
	    var prebuilds = path.join(dir, 'prebuilds', tuple.name);
	    var parsed = readdirSync(prebuilds).map(parseTags);
	    var candidates = parsed.filter(matchTags(runtime, abi));
	    var winner = candidates.sort(compareTags(runtime))[0];
	    if (winner) return path.join(prebuilds, winner.file)
	  }
	};

	function readdirSync (dir) {
	  try {
	    return fs.readdirSync(dir)
	  } catch (err) {
	    return []
	  }
	}

	function getFirst (dir, filter) {
	  var files = readdirSync(dir).filter(filter);
	  return files[0] && path.join(dir, files[0])
	}

	function matchBuild (name) {
	  return /\.node$/.test(name)
	}

	function parseTuple (name) {
	  // Example: darwin-x64+arm64
	  var arr = name.split('-');
	  if (arr.length !== 2) return

	  var platform = arr[0];
	  var architectures = arr[1].split('+');

	  if (!platform) return
	  if (!architectures.length) return
	  if (!architectures.every(Boolean)) return

	  return { name, platform, architectures }
	}

	function matchTuple (platform, arch) {
	  return function (tuple) {
	    if (tuple == null) return false
	    if (tuple.platform !== platform) return false
	    return tuple.architectures.includes(arch)
	  }
	}

	function compareTuples (a, b) {
	  // Prefer single-arch prebuilds over multi-arch
	  return a.architectures.length - b.architectures.length
	}

	function parseTags (file) {
	  var arr = file.split('.');
	  var extension = arr.pop();
	  var tags = { file: file, specificity: 0 };

	  if (extension !== 'node') return

	  for (var i = 0; i < arr.length; i++) {
	    var tag = arr[i];

	    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
	      tags.runtime = tag;
	    } else if (tag === 'napi') {
	      tags.napi = true;
	    } else if (tag.slice(0, 3) === 'abi') {
	      tags.abi = tag.slice(3);
	    } else if (tag.slice(0, 2) === 'uv') {
	      tags.uv = tag.slice(2);
	    } else if (tag.slice(0, 4) === 'armv') {
	      tags.armv = tag.slice(4);
	    } else if (tag === 'glibc' || tag === 'musl') {
	      tags.libc = tag;
	    } else {
	      continue
	    }

	    tags.specificity++;
	  }

	  return tags
	}

	function matchTags (runtime, abi) {
	  return function (tags) {
	    if (tags == null) return false
	    if (tags.runtime && tags.runtime !== runtime && !runtimeAgnostic(tags)) return false
	    if (tags.abi && tags.abi !== abi && !tags.napi) return false
	    if (tags.uv && tags.uv !== uv) return false
	    if (tags.armv && tags.armv !== armv) return false
	    if (tags.libc && tags.libc !== libc) return false

	    return true
	  }
	}

	function runtimeAgnostic (tags) {
	  return tags.runtime === 'node' && tags.napi
	}

	function compareTags (runtime) {
	  // Precedence: non-agnostic runtime, abi over napi, then by specificity.
	  return function (a, b) {
	    if (a.runtime !== b.runtime) {
	      return a.runtime === runtime ? -1 : 1
	    } else if (a.abi !== b.abi) {
	      return a.abi ? -1 : 1
	    } else if (a.specificity !== b.specificity) {
	      return a.specificity > b.specificity ? -1 : 1
	    } else {
	      return 0
	    }
	  }
	}

	function isNwjs () {
	  return !!(process.versions && process.versions.nw)
	}

	function isElectron () {
	  if (process.versions && process.versions.electron) return true
	  if (process.env.ELECTRON_RUN_AS_NODE) return true
	  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'
	}

	function isAlpine (platform) {
	  return platform === 'linux' && fs.existsSync('/etc/alpine-release')
	}

	// Exposed for unit tests
	// TODO: move to lib
	load.parseTags = parseTags;
	load.matchTags = matchTags;
	load.compareTags = compareTags;
	load.parseTuple = parseTuple;
	load.matchTuple = matchTuple;
	load.compareTuples = compareTuples;
	return nodeGypBuild;
}

var hasRequiredNodeGypBuild;

function requireNodeGypBuild () {
	if (hasRequiredNodeGypBuild) return nodeGypBuild$1.exports;
	hasRequiredNodeGypBuild = 1;
	const runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : commonjsRequire; // eslint-disable-line
	if (typeof runtimeRequire.addon === 'function') { // if the platform supports native resolving prefer that
	  nodeGypBuild$1.exports = runtimeRequire.addon.bind(runtimeRequire);
	} else { // else use the runtime version here
	  nodeGypBuild$1.exports = requireNodeGypBuild$1();
	}
	return nodeGypBuild$1.exports;
}

var fallback;
var hasRequiredFallback;

function requireFallback () {
	if (hasRequiredFallback) return fallback;
	hasRequiredFallback = 1;

	/**
	 * Checks if a given buffer contains only correct UTF-8.
	 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	 * Markus Kuhn.
	 *
	 * @param {Buffer} buf The buffer to check
	 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	 * @public
	 */
	function isValidUTF8(buf) {
	  const len = buf.length;
	  let i = 0;

	  while (i < len) {
	    if ((buf[i] & 0x80) === 0x00) {  // 0xxxxxxx
	      i++;
	    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx
	      if (
	        i + 1 === len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i] & 0xfe) === 0xc0  // overlong
	      ) {
	        return false;
	      }

	      i += 2;
	    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 2 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong
	        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0  // surrogate (U+D800 - U+DFFF)
	      ) {
	        return false;
	      }

	      i += 3;
	    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 3 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i + 3] & 0xc0) !== 0x80 ||
	        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong
	        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF
	      ) {
	        return false;
	      }

	      i += 4;
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	fallback = isValidUTF8;
	return fallback;
}

var hasRequiredUtf8Validate;

function requireUtf8Validate () {
	if (hasRequiredUtf8Validate) return utf8Validate.exports;
	hasRequiredUtf8Validate = 1;

	try {
	  utf8Validate.exports = requireNodeGypBuild()(__dirname);
	} catch (e) {
	  utf8Validate.exports = requireFallback();
	}
	return utf8Validate.exports;
}

var hasRequiredValidation;

function requireValidation () {
	if (hasRequiredValidation) return validation.exports;
	hasRequiredValidation = 1;

	const { isUtf8 } = require$$0$9;

	//
	// Allowed token characters:
	//
	// '!', '#', '$', '%', '&', ''', '*', '+', '-',
	// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
	//
	// tokenChars[32] === 0 // ' '
	// tokenChars[33] === 1 // '!'
	// tokenChars[34] === 0 // '"'
	// ...
	//
	// prettier-ignore
	const tokenChars = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
	  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
	  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
	];

	/**
	 * Checks if a status code is allowed in a close frame.
	 *
	 * @param {Number} code The status code
	 * @return {Boolean} `true` if the status code is valid, else `false`
	 * @public
	 */
	function isValidStatusCode(code) {
	  return (
	    (code >= 1000 &&
	      code <= 1014 &&
	      code !== 1004 &&
	      code !== 1005 &&
	      code !== 1006) ||
	    (code >= 3000 && code <= 4999)
	  );
	}

	/**
	 * Checks if a given buffer contains only correct UTF-8.
	 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	 * Markus Kuhn.
	 *
	 * @param {Buffer} buf The buffer to check
	 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	 * @public
	 */
	function _isValidUTF8(buf) {
	  const len = buf.length;
	  let i = 0;

	  while (i < len) {
	    if ((buf[i] & 0x80) === 0) {
	      // 0xxxxxxx
	      i++;
	    } else if ((buf[i] & 0xe0) === 0xc0) {
	      // 110xxxxx 10xxxxxx
	      if (
	        i + 1 === len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i] & 0xfe) === 0xc0 // Overlong
	      ) {
	        return false;
	      }

	      i += 2;
	    } else if ((buf[i] & 0xf0) === 0xe0) {
	      // 1110xxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 2 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
	        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
	      ) {
	        return false;
	      }

	      i += 3;
	    } else if ((buf[i] & 0xf8) === 0xf0) {
	      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
	      if (
	        i + 3 >= len ||
	        (buf[i + 1] & 0xc0) !== 0x80 ||
	        (buf[i + 2] & 0xc0) !== 0x80 ||
	        (buf[i + 3] & 0xc0) !== 0x80 ||
	        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
	        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
	        buf[i] > 0xf4 // > U+10FFFF
	      ) {
	        return false;
	      }

	      i += 4;
	    } else {
	      return false;
	    }
	  }

	  return true;
	}

	validation.exports = {
	  isValidStatusCode,
	  isValidUTF8: _isValidUTF8,
	  tokenChars
	};

	if (isUtf8) {
	  validation.exports.isValidUTF8 = function (buf) {
	    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	  };
	} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
	  try {
	    const isValidUTF8 = requireUtf8Validate();

	    validation.exports.isValidUTF8 = function (buf) {
	      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
	    };
	  } catch (e) {
	    // Continue regardless of the error.
	  }
	}
	return validation.exports;
}

var receiver;
var hasRequiredReceiver;

function requireReceiver () {
	if (hasRequiredReceiver) return receiver;
	hasRequiredReceiver = 1;

	const { Writable } = require$$0$a;

	const PerMessageDeflate = requirePermessageDeflate();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  kStatusCode,
	  kWebSocket
	} = requireConstants();
	const { concat, toArrayBuffer, unmask } = requireBufferUtil();
	const { isValidStatusCode, isValidUTF8 } = requireValidation();

	const FastBuffer = Buffer[Symbol.species];
	const promise = Promise.resolve();

	//
	// `queueMicrotask()` is not available in Node.js < 11.
	//
	const queueTask =
	  typeof queueMicrotask === 'function' ? queueMicrotask : queueMicrotaskShim;

	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;

	/**
	 * HyBi Receiver implementation.
	 *
	 * @extends Writable
	 */
	class Receiver extends Writable {
	  /**
	   * Creates a Receiver instance.
	   *
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {String} [options.binaryType=nodebuffer] The type for binary data
	   * @param {Object} [options.extensions] An object containing the negotiated
	   *     extensions
	   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
	   *     client or server mode
	   * @param {Number} [options.maxPayload=0] The maximum allowed message length
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   */
	  constructor(options = {}) {
	    super();

	    this._allowSynchronousEvents = !!options.allowSynchronousEvents;
	    this._binaryType = options.binaryType || BINARY_TYPES[0];
	    this._extensions = options.extensions || {};
	    this._isServer = !!options.isServer;
	    this._maxPayload = options.maxPayload | 0;
	    this._skipUTF8Validation = !!options.skipUTF8Validation;
	    this[kWebSocket] = undefined;

	    this._bufferedBytes = 0;
	    this._buffers = [];

	    this._compressed = false;
	    this._payloadLength = 0;
	    this._mask = undefined;
	    this._fragmented = 0;
	    this._masked = false;
	    this._fin = false;
	    this._opcode = 0;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragments = [];

	    this._errored = false;
	    this._loop = false;
	    this._state = GET_INFO;
	  }

	  /**
	   * Implements `Writable.prototype._write()`.
	   *
	   * @param {Buffer} chunk The chunk of data to write
	   * @param {String} encoding The character encoding of `chunk`
	   * @param {Function} cb Callback
	   * @private
	   */
	  _write(chunk, encoding, cb) {
	    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

	    this._bufferedBytes += chunk.length;
	    this._buffers.push(chunk);
	    this.startLoop(cb);
	  }

	  /**
	   * Consumes `n` bytes from the buffered data.
	   *
	   * @param {Number} n The number of bytes to consume
	   * @return {Buffer} The consumed bytes
	   * @private
	   */
	  consume(n) {
	    this._bufferedBytes -= n;

	    if (n === this._buffers[0].length) return this._buffers.shift();

	    if (n < this._buffers[0].length) {
	      const buf = this._buffers[0];
	      this._buffers[0] = new FastBuffer(
	        buf.buffer,
	        buf.byteOffset + n,
	        buf.length - n
	      );

	      return new FastBuffer(buf.buffer, buf.byteOffset, n);
	    }

	    const dst = Buffer.allocUnsafe(n);

	    do {
	      const buf = this._buffers[0];
	      const offset = dst.length - n;

	      if (n >= buf.length) {
	        dst.set(this._buffers.shift(), offset);
	      } else {
	        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
	        this._buffers[0] = new FastBuffer(
	          buf.buffer,
	          buf.byteOffset + n,
	          buf.length - n
	        );
	      }

	      n -= buf.length;
	    } while (n > 0);

	    return dst;
	  }

	  /**
	   * Starts the parsing loop.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  startLoop(cb) {
	    this._loop = true;

	    do {
	      switch (this._state) {
	        case GET_INFO:
	          this.getInfo(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_16:
	          this.getPayloadLength16(cb);
	          break;
	        case GET_PAYLOAD_LENGTH_64:
	          this.getPayloadLength64(cb);
	          break;
	        case GET_MASK:
	          this.getMask();
	          break;
	        case GET_DATA:
	          this.getData(cb);
	          break;
	        case INFLATING:
	        case DEFER_EVENT:
	          this._loop = false;
	          return;
	      }
	    } while (this._loop);

	    if (!this._errored) cb();
	  }

	  /**
	   * Reads the first two bytes of a frame.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getInfo(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(2);

	    if ((buf[0] & 0x30) !== 0x00) {
	      const error = this.createError(
	        RangeError,
	        'RSV2 and RSV3 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_2_3'
	      );

	      cb(error);
	      return;
	    }

	    const compressed = (buf[0] & 0x40) === 0x40;

	    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
	      const error = this.createError(
	        RangeError,
	        'RSV1 must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_RSV_1'
	      );

	      cb(error);
	      return;
	    }

	    this._fin = (buf[0] & 0x80) === 0x80;
	    this._opcode = buf[0] & 0x0f;
	    this._payloadLength = buf[1] & 0x7f;

	    if (this._opcode === 0x00) {
	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (!this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          'invalid opcode 0',
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._opcode = this._fragmented;
	    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
	      if (this._fragmented) {
	        const error = this.createError(
	          RangeError,
	          `invalid opcode ${this._opcode}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_OPCODE'
	        );

	        cb(error);
	        return;
	      }

	      this._compressed = compressed;
	    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
	      if (!this._fin) {
	        const error = this.createError(
	          RangeError,
	          'FIN must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_FIN'
	        );

	        cb(error);
	        return;
	      }

	      if (compressed) {
	        const error = this.createError(
	          RangeError,
	          'RSV1 must be clear',
	          true,
	          1002,
	          'WS_ERR_UNEXPECTED_RSV_1'
	        );

	        cb(error);
	        return;
	      }

	      if (
	        this._payloadLength > 0x7d ||
	        (this._opcode === 0x08 && this._payloadLength === 1)
	      ) {
	        const error = this.createError(
	          RangeError,
	          `invalid payload length ${this._payloadLength}`,
	          true,
	          1002,
	          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    } else {
	      const error = this.createError(
	        RangeError,
	        `invalid opcode ${this._opcode}`,
	        true,
	        1002,
	        'WS_ERR_INVALID_OPCODE'
	      );

	      cb(error);
	      return;
	    }

	    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
	    this._masked = (buf[1] & 0x80) === 0x80;

	    if (this._isServer) {
	      if (!this._masked) {
	        const error = this.createError(
	          RangeError,
	          'MASK must be set',
	          true,
	          1002,
	          'WS_ERR_EXPECTED_MASK'
	        );

	        cb(error);
	        return;
	      }
	    } else if (this._masked) {
	      const error = this.createError(
	        RangeError,
	        'MASK must be clear',
	        true,
	        1002,
	        'WS_ERR_UNEXPECTED_MASK'
	      );

	      cb(error);
	      return;
	    }

	    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
	    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
	    else this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+16).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength16(cb) {
	    if (this._bufferedBytes < 2) {
	      this._loop = false;
	      return;
	    }

	    this._payloadLength = this.consume(2).readUInt16BE(0);
	    this.haveLength(cb);
	  }

	  /**
	   * Gets extended payload length (7+64).
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getPayloadLength64(cb) {
	    if (this._bufferedBytes < 8) {
	      this._loop = false;
	      return;
	    }

	    const buf = this.consume(8);
	    const num = buf.readUInt32BE(0);

	    //
	    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
	    // if payload length is greater than this number.
	    //
	    if (num > Math.pow(2, 53 - 32) - 1) {
	      const error = this.createError(
	        RangeError,
	        'Unsupported WebSocket frame: payload length > 2^53 - 1',
	        false,
	        1009,
	        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
	      );

	      cb(error);
	      return;
	    }

	    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
	    this.haveLength(cb);
	  }

	  /**
	   * Payload length has been read.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  haveLength(cb) {
	    if (this._payloadLength && this._opcode < 0x08) {
	      this._totalPayloadLength += this._payloadLength;
	      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
	        const error = this.createError(
	          RangeError,
	          'Max payload size exceeded',
	          false,
	          1009,
	          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	        );

	        cb(error);
	        return;
	      }
	    }

	    if (this._masked) this._state = GET_MASK;
	    else this._state = GET_DATA;
	  }

	  /**
	   * Reads mask bytes.
	   *
	   * @private
	   */
	  getMask() {
	    if (this._bufferedBytes < 4) {
	      this._loop = false;
	      return;
	    }

	    this._mask = this.consume(4);
	    this._state = GET_DATA;
	  }

	  /**
	   * Reads data bytes.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  getData(cb) {
	    let data = EMPTY_BUFFER;

	    if (this._payloadLength) {
	      if (this._bufferedBytes < this._payloadLength) {
	        this._loop = false;
	        return;
	      }

	      data = this.consume(this._payloadLength);

	      if (
	        this._masked &&
	        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
	      ) {
	        unmask(data, this._mask);
	      }
	    }

	    if (this._opcode > 0x07) {
	      this.controlMessage(data, cb);
	      return;
	    }

	    if (this._compressed) {
	      this._state = INFLATING;
	      this.decompress(data, cb);
	      return;
	    }

	    if (data.length) {
	      //
	      // This message is not compressed so its length is the sum of the payload
	      // length of all fragments.
	      //
	      this._messageLength = this._totalPayloadLength;
	      this._fragments.push(data);
	    }

	    this.dataMessage(cb);
	  }

	  /**
	   * Decompresses data.
	   *
	   * @param {Buffer} data Compressed data
	   * @param {Function} cb Callback
	   * @private
	   */
	  decompress(data, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
	      if (err) return cb(err);

	      if (buf.length) {
	        this._messageLength += buf.length;
	        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
	          const error = this.createError(
	            RangeError,
	            'Max payload size exceeded',
	            false,
	            1009,
	            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
	          );

	          cb(error);
	          return;
	        }

	        this._fragments.push(buf);
	      }

	      this.dataMessage(cb);
	      if (this._state === GET_INFO) this.startLoop(cb);
	    });
	  }

	  /**
	   * Handles a data message.
	   *
	   * @param {Function} cb Callback
	   * @private
	   */
	  dataMessage(cb) {
	    if (!this._fin) {
	      this._state = GET_INFO;
	      return;
	    }

	    const messageLength = this._messageLength;
	    const fragments = this._fragments;

	    this._totalPayloadLength = 0;
	    this._messageLength = 0;
	    this._fragmented = 0;
	    this._fragments = [];

	    if (this._opcode === 2) {
	      let data;

	      if (this._binaryType === 'nodebuffer') {
	        data = concat(fragments, messageLength);
	      } else if (this._binaryType === 'arraybuffer') {
	        data = toArrayBuffer(concat(fragments, messageLength));
	      } else {
	        data = fragments;
	      }

	      //
	      // If the state is `INFLATING`, it means that the frame data was
	      // decompressed asynchronously, so there is no need to defer the event
	      // as it will be emitted asynchronously anyway.
	      //
	      if (this._state === INFLATING || this._allowSynchronousEvents) {
	        this.emit('message', data, true);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        queueTask(() => {
	          this.emit('message', data, true);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    } else {
	      const buf = concat(fragments, messageLength);

	      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	        const error = this.createError(
	          Error,
	          'invalid UTF-8 sequence',
	          true,
	          1007,
	          'WS_ERR_INVALID_UTF8'
	        );

	        cb(error);
	        return;
	      }

	      if (this._state === INFLATING || this._allowSynchronousEvents) {
	        this.emit('message', buf, false);
	        this._state = GET_INFO;
	      } else {
	        this._state = DEFER_EVENT;
	        queueTask(() => {
	          this.emit('message', buf, false);
	          this._state = GET_INFO;
	          this.startLoop(cb);
	        });
	      }
	    }
	  }

	  /**
	   * Handles a control message.
	   *
	   * @param {Buffer} data Data to handle
	   * @return {(Error|RangeError|undefined)} A possible error
	   * @private
	   */
	  controlMessage(data, cb) {
	    if (this._opcode === 0x08) {
	      if (data.length === 0) {
	        this._loop = false;
	        this.emit('conclude', 1005, EMPTY_BUFFER);
	        this.end();
	      } else {
	        const code = data.readUInt16BE(0);

	        if (!isValidStatusCode(code)) {
	          const error = this.createError(
	            RangeError,
	            `invalid status code ${code}`,
	            true,
	            1002,
	            'WS_ERR_INVALID_CLOSE_CODE'
	          );

	          cb(error);
	          return;
	        }

	        const buf = new FastBuffer(
	          data.buffer,
	          data.byteOffset + 2,
	          data.length - 2
	        );

	        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
	          const error = this.createError(
	            Error,
	            'invalid UTF-8 sequence',
	            true,
	            1007,
	            'WS_ERR_INVALID_UTF8'
	          );

	          cb(error);
	          return;
	        }

	        this._loop = false;
	        this.emit('conclude', code, buf);
	        this.end();
	      }

	      this._state = GET_INFO;
	      return;
	    }

	    if (this._allowSynchronousEvents) {
	      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	      this._state = GET_INFO;
	    } else {
	      this._state = DEFER_EVENT;
	      queueTask(() => {
	        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
	        this._state = GET_INFO;
	        this.startLoop(cb);
	      });
	    }
	  }

	  /**
	   * Builds an error object.
	   *
	   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
	   * @param {String} message The error message
	   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
	   *     `message`
	   * @param {Number} statusCode The status code
	   * @param {String} errorCode The exposed error code
	   * @return {(Error|RangeError)} The error
	   * @private
	   */
	  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
	    this._loop = false;
	    this._errored = true;

	    const err = new ErrorCtor(
	      prefix ? `Invalid WebSocket frame: ${message}` : message
	    );

	    Error.captureStackTrace(err, this.createError);
	    err.code = errorCode;
	    err[kStatusCode] = statusCode;
	    return err;
	  }
	}

	receiver = Receiver;

	/**
	 * A shim for `queueMicrotask()`.
	 *
	 * @param {Function} cb Callback
	 */
	function queueMicrotaskShim(cb) {
	  promise.then(cb).catch(throwErrorNextTick);
	}

	/**
	 * Throws an error.
	 *
	 * @param {Error} err The error to throw
	 * @private
	 */
	function throwError(err) {
	  throw err;
	}

	/**
	 * Throws an error in the next tick.
	 *
	 * @param {Error} err The error to throw
	 * @private
	 */
	function throwErrorNextTick(err) {
	  process.nextTick(throwError, err);
	}
	return receiver;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */

var sender;
var hasRequiredSender;

function requireSender () {
	if (hasRequiredSender) return sender;
	hasRequiredSender = 1;
	const { randomFillSync } = require$$0$4;

	const PerMessageDeflate = requirePermessageDeflate();
	const { EMPTY_BUFFER } = requireConstants();
	const { isValidStatusCode } = requireValidation();
	const { mask: applyMask, toBuffer } = requireBufferUtil();

	const kByteLength = Symbol('kByteLength');
	const maskBuffer = Buffer.alloc(4);

	/**
	 * HyBi Sender implementation.
	 */
	class Sender {
	  /**
	   * Creates a Sender instance.
	   *
	   * @param {Duplex} socket The connection socket
	   * @param {Object} [extensions] An object containing the negotiated extensions
	   * @param {Function} [generateMask] The function used to generate the masking
	   *     key
	   */
	  constructor(socket, extensions, generateMask) {
	    this._extensions = extensions || {};

	    if (generateMask) {
	      this._generateMask = generateMask;
	      this._maskBuffer = Buffer.alloc(4);
	    }

	    this._socket = socket;

	    this._firstFragment = true;
	    this._compress = false;

	    this._bufferedBytes = 0;
	    this._deflating = false;
	    this._queue = [];
	  }

	  /**
	   * Frames a piece of data according to the HyBi WebSocket protocol.
	   *
	   * @param {(Buffer|String)} data The data to frame
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @return {(Buffer|String)[]} The framed data
	   * @public
	   */
	  static frame(data, options) {
	    let mask;
	    let merge = false;
	    let offset = 2;
	    let skipMasking = false;

	    if (options.mask) {
	      mask = options.maskBuffer || maskBuffer;

	      if (options.generateMask) {
	        options.generateMask(mask);
	      } else {
	        randomFillSync(mask, 0, 4);
	      }

	      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
	      offset = 6;
	    }

	    let dataLength;

	    if (typeof data === 'string') {
	      if (
	        (!options.mask || skipMasking) &&
	        options[kByteLength] !== undefined
	      ) {
	        dataLength = options[kByteLength];
	      } else {
	        data = Buffer.from(data);
	        dataLength = data.length;
	      }
	    } else {
	      dataLength = data.length;
	      merge = options.mask && options.readOnly && !skipMasking;
	    }

	    let payloadLength = dataLength;

	    if (dataLength >= 65536) {
	      offset += 8;
	      payloadLength = 127;
	    } else if (dataLength > 125) {
	      offset += 2;
	      payloadLength = 126;
	    }

	    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

	    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
	    if (options.rsv1) target[0] |= 0x40;

	    target[1] = payloadLength;

	    if (payloadLength === 126) {
	      target.writeUInt16BE(dataLength, 2);
	    } else if (payloadLength === 127) {
	      target[2] = target[3] = 0;
	      target.writeUIntBE(dataLength, 4, 6);
	    }

	    if (!options.mask) return [target, data];

	    target[1] |= 0x80;
	    target[offset - 4] = mask[0];
	    target[offset - 3] = mask[1];
	    target[offset - 2] = mask[2];
	    target[offset - 1] = mask[3];

	    if (skipMasking) return [target, data];

	    if (merge) {
	      applyMask(data, mask, target, offset, dataLength);
	      return [target];
	    }

	    applyMask(data, mask, data, 0, dataLength);
	    return [target, data];
	  }

	  /**
	   * Sends a close message to the other peer.
	   *
	   * @param {Number} [code] The status code component of the body
	   * @param {(String|Buffer)} [data] The message component of the body
	   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  close(code, data, mask, cb) {
	    let buf;

	    if (code === undefined) {
	      buf = EMPTY_BUFFER;
	    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
	      throw new TypeError('First argument must be a valid error code number');
	    } else if (data === undefined || !data.length) {
	      buf = Buffer.allocUnsafe(2);
	      buf.writeUInt16BE(code, 0);
	    } else {
	      const length = Buffer.byteLength(data);

	      if (length > 123) {
	        throw new RangeError('The message must not be greater than 123 bytes');
	      }

	      buf = Buffer.allocUnsafe(2 + length);
	      buf.writeUInt16BE(code, 0);

	      if (typeof data === 'string') {
	        buf.write(data, 2);
	      } else {
	        buf.set(data, 2);
	      }
	    }

	    const options = {
	      [kByteLength]: buf.length,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x08,
	      readOnly: false,
	      rsv1: false
	    };

	    if (this._deflating) {
	      this.enqueue([this.dispatch, buf, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(buf, options), cb);
	    }
	  }

	  /**
	   * Sends a ping message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  ping(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x09,
	      readOnly,
	      rsv1: false
	    };

	    if (this._deflating) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a pong message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  pong(data, mask, cb) {
	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (byteLength > 125) {
	      throw new RangeError('The data size must not be greater than 125 bytes');
	    }

	    const options = {
	      [kByteLength]: byteLength,
	      fin: true,
	      generateMask: this._generateMask,
	      mask,
	      maskBuffer: this._maskBuffer,
	      opcode: 0x0a,
	      readOnly,
	      rsv1: false
	    };

	    if (this._deflating) {
	      this.enqueue([this.dispatch, data, false, options, cb]);
	    } else {
	      this.sendFrame(Sender.frame(data, options), cb);
	    }
	  }

	  /**
	   * Sends a data message to the other peer.
	   *
	   * @param {*} data The message to send
	   * @param {Object} options Options object
	   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
	   *     or text
	   * @param {Boolean} [options.compress=false] Specifies whether or not to
	   *     compress `data`
	   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Function} [cb] Callback
	   * @public
	   */
	  send(data, options, cb) {
	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
	    let opcode = options.binary ? 2 : 1;
	    let rsv1 = options.compress;

	    let byteLength;
	    let readOnly;

	    if (typeof data === 'string') {
	      byteLength = Buffer.byteLength(data);
	      readOnly = false;
	    } else {
	      data = toBuffer(data);
	      byteLength = data.length;
	      readOnly = toBuffer.readOnly;
	    }

	    if (this._firstFragment) {
	      this._firstFragment = false;
	      if (
	        rsv1 &&
	        perMessageDeflate &&
	        perMessageDeflate.params[
	          perMessageDeflate._isServer
	            ? 'server_no_context_takeover'
	            : 'client_no_context_takeover'
	        ]
	      ) {
	        rsv1 = byteLength >= perMessageDeflate._threshold;
	      }
	      this._compress = rsv1;
	    } else {
	      rsv1 = false;
	      opcode = 0;
	    }

	    if (options.fin) this._firstFragment = true;

	    if (perMessageDeflate) {
	      const opts = {
	        [kByteLength]: byteLength,
	        fin: options.fin,
	        generateMask: this._generateMask,
	        mask: options.mask,
	        maskBuffer: this._maskBuffer,
	        opcode,
	        readOnly,
	        rsv1
	      };

	      if (this._deflating) {
	        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
	      } else {
	        this.dispatch(data, this._compress, opts, cb);
	      }
	    } else {
	      this.sendFrame(
	        Sender.frame(data, {
	          [kByteLength]: byteLength,
	          fin: options.fin,
	          generateMask: this._generateMask,
	          mask: options.mask,
	          maskBuffer: this._maskBuffer,
	          opcode,
	          readOnly,
	          rsv1: false
	        }),
	        cb
	      );
	    }
	  }

	  /**
	   * Dispatches a message.
	   *
	   * @param {(Buffer|String)} data The message to send
	   * @param {Boolean} [compress=false] Specifies whether or not to compress
	   *     `data`
	   * @param {Object} options Options object
	   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
	   *     FIN bit
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
	   *     `data`
	   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
	   *     key
	   * @param {Number} options.opcode The opcode
	   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
	   *     modified
	   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
	   *     RSV1 bit
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  dispatch(data, compress, options, cb) {
	    if (!compress) {
	      this.sendFrame(Sender.frame(data, options), cb);
	      return;
	    }

	    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

	    this._bufferedBytes += options[kByteLength];
	    this._deflating = true;
	    perMessageDeflate.compress(data, options.fin, (_, buf) => {
	      if (this._socket.destroyed) {
	        const err = new Error(
	          'The socket was closed while data was being compressed'
	        );

	        if (typeof cb === 'function') cb(err);

	        for (let i = 0; i < this._queue.length; i++) {
	          const params = this._queue[i];
	          const callback = params[params.length - 1];

	          if (typeof callback === 'function') callback(err);
	        }

	        return;
	      }

	      this._bufferedBytes -= options[kByteLength];
	      this._deflating = false;
	      options.readOnly = false;
	      this.sendFrame(Sender.frame(buf, options), cb);
	      this.dequeue();
	    });
	  }

	  /**
	   * Executes queued send operations.
	   *
	   * @private
	   */
	  dequeue() {
	    while (!this._deflating && this._queue.length) {
	      const params = this._queue.shift();

	      this._bufferedBytes -= params[3][kByteLength];
	      Reflect.apply(params[0], this, params.slice(1));
	    }
	  }

	  /**
	   * Enqueues a send operation.
	   *
	   * @param {Array} params Send operation parameters.
	   * @private
	   */
	  enqueue(params) {
	    this._bufferedBytes += params[3][kByteLength];
	    this._queue.push(params);
	  }

	  /**
	   * Sends a frame.
	   *
	   * @param {Buffer[]} list The frame to send
	   * @param {Function} [cb] Callback
	   * @private
	   */
	  sendFrame(list, cb) {
	    if (list.length === 2) {
	      this._socket.cork();
	      this._socket.write(list[0]);
	      this._socket.write(list[1], cb);
	      this._socket.uncork();
	    } else {
	      this._socket.write(list[0], cb);
	    }
	  }
	}

	sender = Sender;
	return sender;
}

var eventTarget;
var hasRequiredEventTarget;

function requireEventTarget () {
	if (hasRequiredEventTarget) return eventTarget;
	hasRequiredEventTarget = 1;

	const { kForOnEventAttribute, kListener } = requireConstants();

	const kCode = Symbol('kCode');
	const kData = Symbol('kData');
	const kError = Symbol('kError');
	const kMessage = Symbol('kMessage');
	const kReason = Symbol('kReason');
	const kTarget = Symbol('kTarget');
	const kType = Symbol('kType');
	const kWasClean = Symbol('kWasClean');

	/**
	 * Class representing an event.
	 */
	class Event {
	  /**
	   * Create a new `Event`.
	   *
	   * @param {String} type The name of the event
	   * @throws {TypeError} If the `type` argument is not specified
	   */
	  constructor(type) {
	    this[kTarget] = null;
	    this[kType] = type;
	  }

	  /**
	   * @type {*}
	   */
	  get target() {
	    return this[kTarget];
	  }

	  /**
	   * @type {String}
	   */
	  get type() {
	    return this[kType];
	  }
	}

	Object.defineProperty(Event.prototype, 'target', { enumerable: true });
	Object.defineProperty(Event.prototype, 'type', { enumerable: true });

	/**
	 * Class representing a close event.
	 *
	 * @extends Event
	 */
	class CloseEvent extends Event {
	  /**
	   * Create a new `CloseEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {Number} [options.code=0] The status code explaining why the
	   *     connection was closed
	   * @param {String} [options.reason=''] A human-readable string explaining why
	   *     the connection was closed
	   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
	   *     connection was cleanly closed
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kCode] = options.code === undefined ? 0 : options.code;
	    this[kReason] = options.reason === undefined ? '' : options.reason;
	    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
	  }

	  /**
	   * @type {Number}
	   */
	  get code() {
	    return this[kCode];
	  }

	  /**
	   * @type {String}
	   */
	  get reason() {
	    return this[kReason];
	  }

	  /**
	   * @type {Boolean}
	   */
	  get wasClean() {
	    return this[kWasClean];
	  }
	}

	Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

	/**
	 * Class representing an error event.
	 *
	 * @extends Event
	 */
	class ErrorEvent extends Event {
	  /**
	   * Create a new `ErrorEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.error=null] The error that generated this event
	   * @param {String} [options.message=''] The error message
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kError] = options.error === undefined ? null : options.error;
	    this[kMessage] = options.message === undefined ? '' : options.message;
	  }

	  /**
	   * @type {*}
	   */
	  get error() {
	    return this[kError];
	  }

	  /**
	   * @type {String}
	   */
	  get message() {
	    return this[kMessage];
	  }
	}

	Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

	/**
	 * Class representing a message event.
	 *
	 * @extends Event
	 */
	class MessageEvent extends Event {
	  /**
	   * Create a new `MessageEvent`.
	   *
	   * @param {String} type The name of the event
	   * @param {Object} [options] A dictionary object that allows for setting
	   *     attributes via object members of the same name
	   * @param {*} [options.data=null] The message content
	   */
	  constructor(type, options = {}) {
	    super(type);

	    this[kData] = options.data === undefined ? null : options.data;
	  }

	  /**
	   * @type {*}
	   */
	  get data() {
	    return this[kData];
	  }
	}

	Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

	/**
	 * This provides methods for emulating the `EventTarget` interface. It's not
	 * meant to be used directly.
	 *
	 * @mixin
	 */
	const EventTarget = {
	  /**
	   * Register an event listener.
	   *
	   * @param {String} type A string representing the event type to listen for
	   * @param {(Function|Object)} handler The listener to add
	   * @param {Object} [options] An options object specifies characteristics about
	   *     the event listener
	   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
	   *     listener should be invoked at most once after being added. If `true`,
	   *     the listener would be automatically removed when invoked.
	   * @public
	   */
	  addEventListener(type, handler, options = {}) {
	    for (const listener of this.listeners(type)) {
	      if (
	        !options[kForOnEventAttribute] &&
	        listener[kListener] === handler &&
	        !listener[kForOnEventAttribute]
	      ) {
	        return;
	      }
	    }

	    let wrapper;

	    if (type === 'message') {
	      wrapper = function onMessage(data, isBinary) {
	        const event = new MessageEvent('message', {
	          data: isBinary ? data : data.toString()
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'close') {
	      wrapper = function onClose(code, message) {
	        const event = new CloseEvent('close', {
	          code,
	          reason: message.toString(),
	          wasClean: this._closeFrameReceived && this._closeFrameSent
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'error') {
	      wrapper = function onError(error) {
	        const event = new ErrorEvent('error', {
	          error,
	          message: error.message
	        });

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else if (type === 'open') {
	      wrapper = function onOpen() {
	        const event = new Event('open');

	        event[kTarget] = this;
	        callListener(handler, this, event);
	      };
	    } else {
	      return;
	    }

	    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
	    wrapper[kListener] = handler;

	    if (options.once) {
	      this.once(type, wrapper);
	    } else {
	      this.on(type, wrapper);
	    }
	  },

	  /**
	   * Remove an event listener.
	   *
	   * @param {String} type A string representing the event type to remove
	   * @param {(Function|Object)} handler The listener to remove
	   * @public
	   */
	  removeEventListener(type, handler) {
	    for (const listener of this.listeners(type)) {
	      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
	        this.removeListener(type, listener);
	        break;
	      }
	    }
	  }
	};

	eventTarget = {
	  CloseEvent,
	  ErrorEvent,
	  Event,
	  EventTarget,
	  MessageEvent
	};

	/**
	 * Call an event listener
	 *
	 * @param {(Function|Object)} listener The listener to call
	 * @param {*} thisArg The value to use as `this`` when calling the listener
	 * @param {Event} event The event to pass to the listener
	 * @private
	 */
	function callListener(listener, thisArg, event) {
	  if (typeof listener === 'object' && listener.handleEvent) {
	    listener.handleEvent.call(listener, event);
	  } else {
	    listener.call(thisArg, event);
	  }
	}
	return eventTarget;
}

var extension;
var hasRequiredExtension;

function requireExtension () {
	if (hasRequiredExtension) return extension;
	hasRequiredExtension = 1;

	const { tokenChars } = requireValidation();

	/**
	 * Adds an offer to the map of extension offers or a parameter to the map of
	 * parameters.
	 *
	 * @param {Object} dest The map of extension offers or parameters
	 * @param {String} name The extension or parameter name
	 * @param {(Object|Boolean|String)} elem The extension parameters or the
	 *     parameter value
	 * @private
	 */
	function push(dest, name, elem) {
	  if (dest[name] === undefined) dest[name] = [elem];
	  else dest[name].push(elem);
	}

	/**
	 * Parses the `Sec-WebSocket-Extensions` header into an object.
	 *
	 * @param {String} header The field value of the header
	 * @return {Object} The parsed object
	 * @public
	 */
	function parse(header) {
	  const offers = Object.create(null);
	  let params = Object.create(null);
	  let mustUnescape = false;
	  let isEscaping = false;
	  let inQuotes = false;
	  let extensionName;
	  let paramName;
	  let start = -1;
	  let code = -1;
	  let end = -1;
	  let i = 0;

	  for (; i < header.length; i++) {
	    code = header.charCodeAt(i);

	    if (extensionName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (
	        i !== 0 &&
	        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	      ) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        const name = header.slice(start, end);
	        if (code === 0x2c) {
	          push(offers, name, params);
	          params = Object.create(null);
	        } else {
	          extensionName = name;
	        }

	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else if (paramName === undefined) {
	      if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (code === 0x20 || code === 0x09) {
	        if (end === -1 && start !== -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        push(params, header.slice(start, end), true);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        start = end = -1;
	      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
	        paramName = header.slice(start, i);
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    } else {
	      //
	      // The value of a quoted-string after unescaping must conform to the
	      // token ABNF, so only token characters are valid.
	      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
	      //
	      if (isEscaping) {
	        if (tokenChars[code] !== 1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	        if (start === -1) start = i;
	        else if (!mustUnescape) mustUnescape = true;
	        isEscaping = false;
	      } else if (inQuotes) {
	        if (tokenChars[code] === 1) {
	          if (start === -1) start = i;
	        } else if (code === 0x22 /* '"' */ && start !== -1) {
	          inQuotes = false;
	          end = i;
	        } else if (code === 0x5c /* '\' */) {
	          isEscaping = true;
	        } else {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }
	      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
	        inQuotes = true;
	      } else if (end === -1 && tokenChars[code] === 1) {
	        if (start === -1) start = i;
	      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
	        if (end === -1) end = i;
	      } else if (code === 0x3b || code === 0x2c) {
	        if (start === -1) {
	          throw new SyntaxError(`Unexpected character at index ${i}`);
	        }

	        if (end === -1) end = i;
	        let value = header.slice(start, end);
	        if (mustUnescape) {
	          value = value.replace(/\\/g, '');
	          mustUnescape = false;
	        }
	        push(params, paramName, value);
	        if (code === 0x2c) {
	          push(offers, extensionName, params);
	          params = Object.create(null);
	          extensionName = undefined;
	        }

	        paramName = undefined;
	        start = end = -1;
	      } else {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }
	    }
	  }

	  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  if (end === -1) end = i;
	  const token = header.slice(start, end);
	  if (extensionName === undefined) {
	    push(offers, token, params);
	  } else {
	    if (paramName === undefined) {
	      push(params, token, true);
	    } else if (mustUnescape) {
	      push(params, paramName, token.replace(/\\/g, ''));
	    } else {
	      push(params, paramName, token);
	    }
	    push(offers, extensionName, params);
	  }

	  return offers;
	}

	/**
	 * Builds the `Sec-WebSocket-Extensions` header field value.
	 *
	 * @param {Object} extensions The map of extensions and parameters to format
	 * @return {String} A string representing the given object
	 * @public
	 */
	function format(extensions) {
	  return Object.keys(extensions)
	    .map((extension) => {
	      let configurations = extensions[extension];
	      if (!Array.isArray(configurations)) configurations = [configurations];
	      return configurations
	        .map((params) => {
	          return [extension]
	            .concat(
	              Object.keys(params).map((k) => {
	                let values = params[k];
	                if (!Array.isArray(values)) values = [values];
	                return values
	                  .map((v) => (v === true ? k : `${k}=${v}`))
	                  .join('; ');
	              })
	            )
	            .join('; ');
	        })
	        .join(', ');
	    })
	    .join(', ');
	}

	extension = { format, parse };
	return extension;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$" }] */

var websocket;
var hasRequiredWebsocket;

function requireWebsocket () {
	if (hasRequiredWebsocket) return websocket;
	hasRequiredWebsocket = 1;

	const EventEmitter = require$$0$b;
	const https = require$$1$2;
	const http = require$$2$2;
	const net = require$$3$2;
	const tls = require$$4$1;
	const { randomBytes, createHash } = require$$0$4;
	const { URL } = require$$7$1;

	const PerMessageDeflate = requirePermessageDeflate();
	const Receiver = requireReceiver();
	const Sender = requireSender();
	const {
	  BINARY_TYPES,
	  EMPTY_BUFFER,
	  GUID,
	  kForOnEventAttribute,
	  kListener,
	  kStatusCode,
	  kWebSocket,
	  NOOP
	} = requireConstants();
	const {
	  EventTarget: { addEventListener, removeEventListener }
	} = requireEventTarget();
	const { format, parse } = requireExtension();
	const { toBuffer } = requireBufferUtil();

	const closeTimeout = 30 * 1000;
	const kAborted = Symbol('kAborted');
	const protocolVersions = [8, 13];
	const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

	/**
	 * Class representing a WebSocket.
	 *
	 * @extends EventEmitter
	 */
	class WebSocket extends EventEmitter {
	  /**
	   * Create a new `WebSocket`.
	   *
	   * @param {(String|URL)} address The URL to which to connect
	   * @param {(String|String[])} [protocols] The subprotocols
	   * @param {Object} [options] Connection options
	   */
	  constructor(address, protocols, options) {
	    super();

	    this._binaryType = BINARY_TYPES[0];
	    this._closeCode = 1006;
	    this._closeFrameReceived = false;
	    this._closeFrameSent = false;
	    this._closeMessage = EMPTY_BUFFER;
	    this._closeTimer = null;
	    this._extensions = {};
	    this._paused = false;
	    this._protocol = '';
	    this._readyState = WebSocket.CONNECTING;
	    this._receiver = null;
	    this._sender = null;
	    this._socket = null;

	    if (address !== null) {
	      this._bufferedAmount = 0;
	      this._isServer = false;
	      this._redirects = 0;

	      if (protocols === undefined) {
	        protocols = [];
	      } else if (!Array.isArray(protocols)) {
	        if (typeof protocols === 'object' && protocols !== null) {
	          options = protocols;
	          protocols = [];
	        } else {
	          protocols = [protocols];
	        }
	      }

	      initAsClient(this, address, protocols, options);
	    } else {
	      this._autoPong = options.autoPong;
	      this._isServer = true;
	    }
	  }

	  /**
	   * This deviates from the WHATWG interface since ws doesn't support the
	   * required default "blob" type (instead we define a custom "nodebuffer"
	   * type).
	   *
	   * @type {String}
	   */
	  get binaryType() {
	    return this._binaryType;
	  }

	  set binaryType(type) {
	    if (!BINARY_TYPES.includes(type)) return;

	    this._binaryType = type;

	    //
	    // Allow to change `binaryType` on the fly.
	    //
	    if (this._receiver) this._receiver._binaryType = type;
	  }

	  /**
	   * @type {Number}
	   */
	  get bufferedAmount() {
	    if (!this._socket) return this._bufferedAmount;

	    return this._socket._writableState.length + this._sender._bufferedBytes;
	  }

	  /**
	   * @type {String}
	   */
	  get extensions() {
	    return Object.keys(this._extensions).join();
	  }

	  /**
	   * @type {Boolean}
	   */
	  get isPaused() {
	    return this._paused;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onclose() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onerror() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onopen() {
	    return null;
	  }

	  /**
	   * @type {Function}
	   */
	  /* istanbul ignore next */
	  get onmessage() {
	    return null;
	  }

	  /**
	   * @type {String}
	   */
	  get protocol() {
	    return this._protocol;
	  }

	  /**
	   * @type {Number}
	   */
	  get readyState() {
	    return this._readyState;
	  }

	  /**
	   * @type {String}
	   */
	  get url() {
	    return this._url;
	  }

	  /**
	   * Set up the socket and the internal resources.
	   *
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Object} options Options object
	   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Function} [options.generateMask] The function used to generate the
	   *     masking key
	   * @param {Number} [options.maxPayload=0] The maximum allowed message size
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @private
	   */
	  setSocket(socket, head, options) {
	    const receiver = new Receiver({
	      allowSynchronousEvents: options.allowSynchronousEvents,
	      binaryType: this.binaryType,
	      extensions: this._extensions,
	      isServer: this._isServer,
	      maxPayload: options.maxPayload,
	      skipUTF8Validation: options.skipUTF8Validation
	    });

	    this._sender = new Sender(socket, this._extensions, options.generateMask);
	    this._receiver = receiver;
	    this._socket = socket;

	    receiver[kWebSocket] = this;
	    socket[kWebSocket] = this;

	    receiver.on('conclude', receiverOnConclude);
	    receiver.on('drain', receiverOnDrain);
	    receiver.on('error', receiverOnError);
	    receiver.on('message', receiverOnMessage);
	    receiver.on('ping', receiverOnPing);
	    receiver.on('pong', receiverOnPong);

	    //
	    // These methods may not be available if `socket` is just a `Duplex`.
	    //
	    if (socket.setTimeout) socket.setTimeout(0);
	    if (socket.setNoDelay) socket.setNoDelay();

	    if (head.length > 0) socket.unshift(head);

	    socket.on('close', socketOnClose);
	    socket.on('data', socketOnData);
	    socket.on('end', socketOnEnd);
	    socket.on('error', socketOnError);

	    this._readyState = WebSocket.OPEN;
	    this.emit('open');
	  }

	  /**
	   * Emit the `'close'` event.
	   *
	   * @private
	   */
	  emitClose() {
	    if (!this._socket) {
	      this._readyState = WebSocket.CLOSED;
	      this.emit('close', this._closeCode, this._closeMessage);
	      return;
	    }

	    if (this._extensions[PerMessageDeflate.extensionName]) {
	      this._extensions[PerMessageDeflate.extensionName].cleanup();
	    }

	    this._receiver.removeAllListeners();
	    this._readyState = WebSocket.CLOSED;
	    this.emit('close', this._closeCode, this._closeMessage);
	  }

	  /**
	   * Start a closing handshake.
	   *
	   *          +----------+   +-----------+   +----------+
	   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
	   *    |     +----------+   +-----------+   +----------+     |
	   *          +----------+   +-----------+         |
	   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
	   *          +----------+   +-----------+   |
	   *    |           |                        |   +---+        |
	   *                +------------------------+-->|fin| - - - -
	   *    |         +---+                      |   +---+
	   *     - - - - -|fin|<---------------------+
	   *              +---+
	   *
	   * @param {Number} [code] Status code explaining why the connection is closing
	   * @param {(String|Buffer)} [data] The reason why the connection is
	   *     closing
	   * @public
	   */
	  close(code, data) {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this.readyState === WebSocket.CLOSING) {
	      if (
	        this._closeFrameSent &&
	        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
	      ) {
	        this._socket.end();
	      }

	      return;
	    }

	    this._readyState = WebSocket.CLOSING;
	    this._sender.close(code, data, !this._isServer, (err) => {
	      //
	      // This error is handled by the `'error'` listener on the socket. We only
	      // want to know if the close frame has been sent here.
	      //
	      if (err) return;

	      this._closeFrameSent = true;

	      if (
	        this._closeFrameReceived ||
	        this._receiver._writableState.errorEmitted
	      ) {
	        this._socket.end();
	      }
	    });

	    //
	    // Specify a timeout for the closing handshake to complete.
	    //
	    this._closeTimer = setTimeout(
	      this._socket.destroy.bind(this._socket),
	      closeTimeout
	    );
	  }

	  /**
	   * Pause the socket.
	   *
	   * @public
	   */
	  pause() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = true;
	    this._socket.pause();
	  }

	  /**
	   * Send a ping.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the ping is sent
	   * @public
	   */
	  ping(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Send a pong.
	   *
	   * @param {*} [data] The data to send
	   * @param {Boolean} [mask] Indicates whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when the pong is sent
	   * @public
	   */
	  pong(data, mask, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof data === 'function') {
	      cb = data;
	      data = mask = undefined;
	    } else if (typeof mask === 'function') {
	      cb = mask;
	      mask = undefined;
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    if (mask === undefined) mask = !this._isServer;
	    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
	  }

	  /**
	   * Resume the socket.
	   *
	   * @public
	   */
	  resume() {
	    if (
	      this.readyState === WebSocket.CONNECTING ||
	      this.readyState === WebSocket.CLOSED
	    ) {
	      return;
	    }

	    this._paused = false;
	    if (!this._receiver._writableState.needDrain) this._socket.resume();
	  }

	  /**
	   * Send a data message.
	   *
	   * @param {*} data The message to send
	   * @param {Object} [options] Options object
	   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
	   *     text
	   * @param {Boolean} [options.compress] Specifies whether or not to compress
	   *     `data`
	   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
	   *     last one
	   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
	   * @param {Function} [cb] Callback which is executed when data is written out
	   * @public
	   */
	  send(data, options, cb) {
	    if (this.readyState === WebSocket.CONNECTING) {
	      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
	    }

	    if (typeof options === 'function') {
	      cb = options;
	      options = {};
	    }

	    if (typeof data === 'number') data = data.toString();

	    if (this.readyState !== WebSocket.OPEN) {
	      sendAfterClose(this, data, cb);
	      return;
	    }

	    const opts = {
	      binary: typeof data !== 'string',
	      mask: !this._isServer,
	      compress: true,
	      fin: true,
	      ...options
	    };

	    if (!this._extensions[PerMessageDeflate.extensionName]) {
	      opts.compress = false;
	    }

	    this._sender.send(data || EMPTY_BUFFER, opts, cb);
	  }

	  /**
	   * Forcibly close the connection.
	   *
	   * @public
	   */
	  terminate() {
	    if (this.readyState === WebSocket.CLOSED) return;
	    if (this.readyState === WebSocket.CONNECTING) {
	      const msg = 'WebSocket was closed before the connection was established';
	      abortHandshake(this, this._req, msg);
	      return;
	    }

	    if (this._socket) {
	      this._readyState = WebSocket.CLOSING;
	      this._socket.destroy();
	    }
	  }
	}

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} CONNECTING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
	  enumerable: true,
	  value: readyStates.indexOf('CONNECTING')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} OPEN
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'OPEN', {
	  enumerable: true,
	  value: readyStates.indexOf('OPEN')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSING
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSING', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSING')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket
	 */
	Object.defineProperty(WebSocket, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	/**
	 * @constant {Number} CLOSED
	 * @memberof WebSocket.prototype
	 */
	Object.defineProperty(WebSocket.prototype, 'CLOSED', {
	  enumerable: true,
	  value: readyStates.indexOf('CLOSED')
	});

	[
	  'binaryType',
	  'bufferedAmount',
	  'extensions',
	  'isPaused',
	  'protocol',
	  'readyState',
	  'url'
	].forEach((property) => {
	  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
	});

	//
	// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
	// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
	//
	['open', 'error', 'close', 'message'].forEach((method) => {
	  Object.defineProperty(WebSocket.prototype, `on${method}`, {
	    enumerable: true,
	    get() {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) return listener[kListener];
	      }

	      return null;
	    },
	    set(handler) {
	      for (const listener of this.listeners(method)) {
	        if (listener[kForOnEventAttribute]) {
	          this.removeListener(method, listener);
	          break;
	        }
	      }

	      if (typeof handler !== 'function') return;

	      this.addEventListener(method, handler, {
	        [kForOnEventAttribute]: true
	      });
	    }
	  });
	});

	WebSocket.prototype.addEventListener = addEventListener;
	WebSocket.prototype.removeEventListener = removeEventListener;

	websocket = WebSocket;

	/**
	 * Initialize a WebSocket client.
	 *
	 * @param {WebSocket} websocket The client to initialize
	 * @param {(String|URL)} address The URL to which to connect
	 * @param {Array} protocols The subprotocols
	 * @param {Object} [options] Connection options
	 * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether any
	 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	 *     times in the same tick
	 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	 *     automatically send a pong in response to a ping
	 * @param {Function} [options.finishRequest] A function which can be used to
	 *     customize the headers of each http request before it is sent
	 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
	 *     redirects
	 * @param {Function} [options.generateMask] The function used to generate the
	 *     masking key
	 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	 *     handshake request
	 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	 *     size
	 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
	 *     allowed
	 * @param {String} [options.origin] Value of the `Origin` or
	 *     `Sec-WebSocket-Origin` header
	 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	 *     permessage-deflate
	 * @param {Number} [options.protocolVersion=13] Value of the
	 *     `Sec-WebSocket-Version` header
	 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	 *     not to skip UTF-8 validation for text and close messages
	 * @private
	 */
	function initAsClient(websocket, address, protocols, options) {
	  const opts = {
	    allowSynchronousEvents: false,
	    autoPong: true,
	    protocolVersion: protocolVersions[1],
	    maxPayload: 100 * 1024 * 1024,
	    skipUTF8Validation: false,
	    perMessageDeflate: true,
	    followRedirects: false,
	    maxRedirects: 10,
	    ...options,
	    createConnection: undefined,
	    socketPath: undefined,
	    hostname: undefined,
	    protocol: undefined,
	    timeout: undefined,
	    method: 'GET',
	    host: undefined,
	    path: undefined,
	    port: undefined
	  };

	  websocket._autoPong = opts.autoPong;

	  if (!protocolVersions.includes(opts.protocolVersion)) {
	    throw new RangeError(
	      `Unsupported protocol version: ${opts.protocolVersion} ` +
	        `(supported versions: ${protocolVersions.join(', ')})`
	    );
	  }

	  let parsedUrl;

	  if (address instanceof URL) {
	    parsedUrl = address;
	  } else {
	    try {
	      parsedUrl = new URL(address);
	    } catch (e) {
	      throw new SyntaxError(`Invalid URL: ${address}`);
	    }
	  }

	  if (parsedUrl.protocol === 'http:') {
	    parsedUrl.protocol = 'ws:';
	  } else if (parsedUrl.protocol === 'https:') {
	    parsedUrl.protocol = 'wss:';
	  }

	  websocket._url = parsedUrl.href;

	  const isSecure = parsedUrl.protocol === 'wss:';
	  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
	  let invalidUrlMessage;

	  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
	    invalidUrlMessage =
	      'The URL\'s protocol must be one of "ws:", "wss:", ' +
	      '"http:", "https", or "ws+unix:"';
	  } else if (isIpcUrl && !parsedUrl.pathname) {
	    invalidUrlMessage = "The URL's pathname is empty";
	  } else if (parsedUrl.hash) {
	    invalidUrlMessage = 'The URL contains a fragment identifier';
	  }

	  if (invalidUrlMessage) {
	    const err = new SyntaxError(invalidUrlMessage);

	    if (websocket._redirects === 0) {
	      throw err;
	    } else {
	      emitErrorAndClose(websocket, err);
	      return;
	    }
	  }

	  const defaultPort = isSecure ? 443 : 80;
	  const key = randomBytes(16).toString('base64');
	  const request = isSecure ? https.request : http.request;
	  const protocolSet = new Set();
	  let perMessageDeflate;

	  opts.createConnection = isSecure ? tlsConnect : netConnect;
	  opts.defaultPort = opts.defaultPort || defaultPort;
	  opts.port = parsedUrl.port || defaultPort;
	  opts.host = parsedUrl.hostname.startsWith('[')
	    ? parsedUrl.hostname.slice(1, -1)
	    : parsedUrl.hostname;
	  opts.headers = {
	    ...opts.headers,
	    'Sec-WebSocket-Version': opts.protocolVersion,
	    'Sec-WebSocket-Key': key,
	    Connection: 'Upgrade',
	    Upgrade: 'websocket'
	  };
	  opts.path = parsedUrl.pathname + parsedUrl.search;
	  opts.timeout = opts.handshakeTimeout;

	  if (opts.perMessageDeflate) {
	    perMessageDeflate = new PerMessageDeflate(
	      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
	      false,
	      opts.maxPayload
	    );
	    opts.headers['Sec-WebSocket-Extensions'] = format({
	      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
	    });
	  }
	  if (protocols.length) {
	    for (const protocol of protocols) {
	      if (
	        typeof protocol !== 'string' ||
	        !subprotocolRegex.test(protocol) ||
	        protocolSet.has(protocol)
	      ) {
	        throw new SyntaxError(
	          'An invalid or duplicated subprotocol was specified'
	        );
	      }

	      protocolSet.add(protocol);
	    }

	    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
	  }
	  if (opts.origin) {
	    if (opts.protocolVersion < 13) {
	      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
	    } else {
	      opts.headers.Origin = opts.origin;
	    }
	  }
	  if (parsedUrl.username || parsedUrl.password) {
	    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
	  }

	  if (isIpcUrl) {
	    const parts = opts.path.split(':');

	    opts.socketPath = parts[0];
	    opts.path = parts[1];
	  }

	  let req;

	  if (opts.followRedirects) {
	    if (websocket._redirects === 0) {
	      websocket._originalIpc = isIpcUrl;
	      websocket._originalSecure = isSecure;
	      websocket._originalHostOrSocketPath = isIpcUrl
	        ? opts.socketPath
	        : parsedUrl.host;

	      const headers = options && options.headers;

	      //
	      // Shallow copy the user provided options so that headers can be changed
	      // without mutating the original object.
	      //
	      options = { ...options, headers: {} };

	      if (headers) {
	        for (const [key, value] of Object.entries(headers)) {
	          options.headers[key.toLowerCase()] = value;
	        }
	      }
	    } else if (websocket.listenerCount('redirect') === 0) {
	      const isSameHost = isIpcUrl
	        ? websocket._originalIpc
	          ? opts.socketPath === websocket._originalHostOrSocketPath
	          : false
	        : websocket._originalIpc
	          ? false
	          : parsedUrl.host === websocket._originalHostOrSocketPath;

	      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
	        //
	        // Match curl 7.77.0 behavior and drop the following headers. These
	        // headers are also dropped when following a redirect to a subdomain.
	        //
	        delete opts.headers.authorization;
	        delete opts.headers.cookie;

	        if (!isSameHost) delete opts.headers.host;

	        opts.auth = undefined;
	      }
	    }

	    //
	    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
	    // If the `Authorization` header is set, then there is nothing to do as it
	    // will take precedence.
	    //
	    if (opts.auth && !options.headers.authorization) {
	      options.headers.authorization =
	        'Basic ' + Buffer.from(opts.auth).toString('base64');
	    }

	    req = websocket._req = request(opts);

	    if (websocket._redirects) {
	      //
	      // Unlike what is done for the `'upgrade'` event, no early exit is
	      // triggered here if the user calls `websocket.close()` or
	      // `websocket.terminate()` from a listener of the `'redirect'` event. This
	      // is because the user can also call `request.destroy()` with an error
	      // before calling `websocket.close()` or `websocket.terminate()` and this
	      // would result in an error being emitted on the `request` object with no
	      // `'error'` event listeners attached.
	      //
	      websocket.emit('redirect', websocket.url, req);
	    }
	  } else {
	    req = websocket._req = request(opts);
	  }

	  if (opts.timeout) {
	    req.on('timeout', () => {
	      abortHandshake(websocket, req, 'Opening handshake has timed out');
	    });
	  }

	  req.on('error', (err) => {
	    if (req === null || req[kAborted]) return;

	    req = websocket._req = null;
	    emitErrorAndClose(websocket, err);
	  });

	  req.on('response', (res) => {
	    const location = res.headers.location;
	    const statusCode = res.statusCode;

	    if (
	      location &&
	      opts.followRedirects &&
	      statusCode >= 300 &&
	      statusCode < 400
	    ) {
	      if (++websocket._redirects > opts.maxRedirects) {
	        abortHandshake(websocket, req, 'Maximum redirects exceeded');
	        return;
	      }

	      req.abort();

	      let addr;

	      try {
	        addr = new URL(location, address);
	      } catch (e) {
	        const err = new SyntaxError(`Invalid URL: ${location}`);
	        emitErrorAndClose(websocket, err);
	        return;
	      }

	      initAsClient(websocket, addr, protocols, options);
	    } else if (!websocket.emit('unexpected-response', req, res)) {
	      abortHandshake(
	        websocket,
	        req,
	        `Unexpected server response: ${res.statusCode}`
	      );
	    }
	  });

	  req.on('upgrade', (res, socket, head) => {
	    websocket.emit('upgrade', res);

	    //
	    // The user may have closed the connection from a listener of the
	    // `'upgrade'` event.
	    //
	    if (websocket.readyState !== WebSocket.CONNECTING) return;

	    req = websocket._req = null;

	    if (res.headers.upgrade.toLowerCase() !== 'websocket') {
	      abortHandshake(websocket, socket, 'Invalid Upgrade header');
	      return;
	    }

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    if (res.headers['sec-websocket-accept'] !== digest) {
	      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
	      return;
	    }

	    const serverProt = res.headers['sec-websocket-protocol'];
	    let protError;

	    if (serverProt !== undefined) {
	      if (!protocolSet.size) {
	        protError = 'Server sent a subprotocol but none was requested';
	      } else if (!protocolSet.has(serverProt)) {
	        protError = 'Server sent an invalid subprotocol';
	      }
	    } else if (protocolSet.size) {
	      protError = 'Server sent no subprotocol';
	    }

	    if (protError) {
	      abortHandshake(websocket, socket, protError);
	      return;
	    }

	    if (serverProt) websocket._protocol = serverProt;

	    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

	    if (secWebSocketExtensions !== undefined) {
	      if (!perMessageDeflate) {
	        const message =
	          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
	          'was requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      let extensions;

	      try {
	        extensions = parse(secWebSocketExtensions);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      const extensionNames = Object.keys(extensions);

	      if (
	        extensionNames.length !== 1 ||
	        extensionNames[0] !== PerMessageDeflate.extensionName
	      ) {
	        const message = 'Server indicated an extension that was not requested';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      try {
	        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Extensions header';
	        abortHandshake(websocket, socket, message);
	        return;
	      }

	      websocket._extensions[PerMessageDeflate.extensionName] =
	        perMessageDeflate;
	    }

	    websocket.setSocket(socket, head, {
	      allowSynchronousEvents: opts.allowSynchronousEvents,
	      generateMask: opts.generateMask,
	      maxPayload: opts.maxPayload,
	      skipUTF8Validation: opts.skipUTF8Validation
	    });
	  });

	  if (opts.finishRequest) {
	    opts.finishRequest(req, websocket);
	  } else {
	    req.end();
	  }
	}

	/**
	 * Emit the `'error'` and `'close'` events.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {Error} The error to emit
	 * @private
	 */
	function emitErrorAndClose(websocket, err) {
	  websocket._readyState = WebSocket.CLOSING;
	  websocket.emit('error', err);
	  websocket.emitClose();
	}

	/**
	 * Create a `net.Socket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {net.Socket} The newly created socket used to start the connection
	 * @private
	 */
	function netConnect(options) {
	  options.path = options.socketPath;
	  return net.connect(options);
	}

	/**
	 * Create a `tls.TLSSocket` and initiate a connection.
	 *
	 * @param {Object} options Connection options
	 * @return {tls.TLSSocket} The newly created socket used to start the connection
	 * @private
	 */
	function tlsConnect(options) {
	  options.path = undefined;

	  if (!options.servername && options.servername !== '') {
	    options.servername = net.isIP(options.host) ? '' : options.host;
	  }

	  return tls.connect(options);
	}

	/**
	 * Abort the handshake and emit an error.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	 *     abort or the socket to destroy
	 * @param {String} message The error message
	 * @private
	 */
	function abortHandshake(websocket, stream, message) {
	  websocket._readyState = WebSocket.CLOSING;

	  const err = new Error(message);
	  Error.captureStackTrace(err, abortHandshake);

	  if (stream.setHeader) {
	    stream[kAborted] = true;
	    stream.abort();

	    if (stream.socket && !stream.socket.destroyed) {
	      //
	      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
	      // called after the request completed. See
	      // https://github.com/websockets/ws/issues/1869.
	      //
	      stream.socket.destroy();
	    }

	    process.nextTick(emitErrorAndClose, websocket, err);
	  } else {
	    stream.destroy(err);
	    stream.once('error', websocket.emit.bind(websocket, 'error'));
	    stream.once('close', websocket.emitClose.bind(websocket));
	  }
	}

	/**
	 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
	 *
	 * @param {WebSocket} websocket The WebSocket instance
	 * @param {*} [data] The data to send
	 * @param {Function} [cb] Callback
	 * @private
	 */
	function sendAfterClose(websocket, data, cb) {
	  if (data) {
	    const length = toBuffer(data).length;

	    //
	    // The `_bufferedAmount` property is used only when the peer is a client and
	    // the opening handshake fails. Under these circumstances, in fact, the
	    // `setSocket()` method is not called, so the `_socket` and `_sender`
	    // properties are set to `null`.
	    //
	    if (websocket._socket) websocket._sender._bufferedBytes += length;
	    else websocket._bufferedAmount += length;
	  }

	  if (cb) {
	    const err = new Error(
	      `WebSocket is not open: readyState ${websocket.readyState} ` +
	        `(${readyStates[websocket.readyState]})`
	    );
	    process.nextTick(cb, err);
	  }
	}

	/**
	 * The listener of the `Receiver` `'conclude'` event.
	 *
	 * @param {Number} code The status code
	 * @param {Buffer} reason The reason for closing
	 * @private
	 */
	function receiverOnConclude(code, reason) {
	  const websocket = this[kWebSocket];

	  websocket._closeFrameReceived = true;
	  websocket._closeMessage = reason;
	  websocket._closeCode = code;

	  if (websocket._socket[kWebSocket] === undefined) return;

	  websocket._socket.removeListener('data', socketOnData);
	  process.nextTick(resume, websocket._socket);

	  if (code === 1005) websocket.close();
	  else websocket.close(code, reason);
	}

	/**
	 * The listener of the `Receiver` `'drain'` event.
	 *
	 * @private
	 */
	function receiverOnDrain() {
	  const websocket = this[kWebSocket];

	  if (!websocket.isPaused) websocket._socket.resume();
	}

	/**
	 * The listener of the `Receiver` `'error'` event.
	 *
	 * @param {(RangeError|Error)} err The emitted error
	 * @private
	 */
	function receiverOnError(err) {
	  const websocket = this[kWebSocket];

	  if (websocket._socket[kWebSocket] !== undefined) {
	    websocket._socket.removeListener('data', socketOnData);

	    //
	    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
	    // https://github.com/websockets/ws/issues/1940.
	    //
	    process.nextTick(resume, websocket._socket);

	    websocket.close(err[kStatusCode]);
	  }

	  websocket.emit('error', err);
	}

	/**
	 * The listener of the `Receiver` `'finish'` event.
	 *
	 * @private
	 */
	function receiverOnFinish() {
	  this[kWebSocket].emitClose();
	}

	/**
	 * The listener of the `Receiver` `'message'` event.
	 *
	 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
	 * @param {Boolean} isBinary Specifies whether the message is binary or not
	 * @private
	 */
	function receiverOnMessage(data, isBinary) {
	  this[kWebSocket].emit('message', data, isBinary);
	}

	/**
	 * The listener of the `Receiver` `'ping'` event.
	 *
	 * @param {Buffer} data The data included in the ping frame
	 * @private
	 */
	function receiverOnPing(data) {
	  const websocket = this[kWebSocket];

	  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
	  websocket.emit('ping', data);
	}

	/**
	 * The listener of the `Receiver` `'pong'` event.
	 *
	 * @param {Buffer} data The data included in the pong frame
	 * @private
	 */
	function receiverOnPong(data) {
	  this[kWebSocket].emit('pong', data);
	}

	/**
	 * Resume a readable stream
	 *
	 * @param {Readable} stream The readable stream
	 * @private
	 */
	function resume(stream) {
	  stream.resume();
	}

	/**
	 * The listener of the socket `'close'` event.
	 *
	 * @private
	 */
	function socketOnClose() {
	  const websocket = this[kWebSocket];

	  this.removeListener('close', socketOnClose);
	  this.removeListener('data', socketOnData);
	  this.removeListener('end', socketOnEnd);

	  websocket._readyState = WebSocket.CLOSING;

	  let chunk;

	  //
	  // The close frame might not have been received or the `'end'` event emitted,
	  // for example, if the socket was destroyed due to an error. Ensure that the
	  // `receiver` stream is closed after writing any remaining buffered data to
	  // it. If the readable side of the socket is in flowing mode then there is no
	  // buffered data as everything has been already written and `readable.read()`
	  // will return `null`. If instead, the socket is paused, any possible buffered
	  // data will be read as a single chunk.
	  //
	  if (
	    !this._readableState.endEmitted &&
	    !websocket._closeFrameReceived &&
	    !websocket._receiver._writableState.errorEmitted &&
	    (chunk = websocket._socket.read()) !== null
	  ) {
	    websocket._receiver.write(chunk);
	  }

	  websocket._receiver.end();

	  this[kWebSocket] = undefined;

	  clearTimeout(websocket._closeTimer);

	  if (
	    websocket._receiver._writableState.finished ||
	    websocket._receiver._writableState.errorEmitted
	  ) {
	    websocket.emitClose();
	  } else {
	    websocket._receiver.on('error', receiverOnFinish);
	    websocket._receiver.on('finish', receiverOnFinish);
	  }
	}

	/**
	 * The listener of the socket `'data'` event.
	 *
	 * @param {Buffer} chunk A chunk of data
	 * @private
	 */
	function socketOnData(chunk) {
	  if (!this[kWebSocket]._receiver.write(chunk)) {
	    this.pause();
	  }
	}

	/**
	 * The listener of the socket `'end'` event.
	 *
	 * @private
	 */
	function socketOnEnd() {
	  const websocket = this[kWebSocket];

	  websocket._readyState = WebSocket.CLOSING;
	  websocket._receiver.end();
	  this.end();
	}

	/**
	 * The listener of the socket `'error'` event.
	 *
	 * @private
	 */
	function socketOnError() {
	  const websocket = this[kWebSocket];

	  this.removeListener('error', socketOnError);
	  this.on('error', NOOP);

	  if (websocket) {
	    websocket._readyState = WebSocket.CLOSING;
	    this.destroy();
	  }
	}
	return websocket;
}

var stream$1;
var hasRequiredStream$1;

function requireStream$1 () {
	if (hasRequiredStream$1) return stream$1;
	hasRequiredStream$1 = 1;

	const { Duplex } = require$$0$a;

	/**
	 * Emits the `'close'` event on a stream.
	 *
	 * @param {Duplex} stream The stream.
	 * @private
	 */
	function emitClose(stream) {
	  stream.emit('close');
	}

	/**
	 * The listener of the `'end'` event.
	 *
	 * @private
	 */
	function duplexOnEnd() {
	  if (!this.destroyed && this._writableState.finished) {
	    this.destroy();
	  }
	}

	/**
	 * The listener of the `'error'` event.
	 *
	 * @param {Error} err The error
	 * @private
	 */
	function duplexOnError(err) {
	  this.removeListener('error', duplexOnError);
	  this.destroy();
	  if (this.listenerCount('error') === 0) {
	    // Do not suppress the throwing behavior.
	    this.emit('error', err);
	  }
	}

	/**
	 * Wraps a `WebSocket` in a duplex stream.
	 *
	 * @param {WebSocket} ws The `WebSocket` to wrap
	 * @param {Object} [options] The options for the `Duplex` constructor
	 * @return {Duplex} The duplex stream
	 * @public
	 */
	function createWebSocketStream(ws, options) {
	  let terminateOnDestroy = true;

	  const duplex = new Duplex({
	    ...options,
	    autoDestroy: false,
	    emitClose: false,
	    objectMode: false,
	    writableObjectMode: false
	  });

	  ws.on('message', function message(msg, isBinary) {
	    const data =
	      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

	    if (!duplex.push(data)) ws.pause();
	  });

	  ws.once('error', function error(err) {
	    if (duplex.destroyed) return;

	    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
	    //
	    // - If the `'error'` event is emitted before the `'open'` event, then
	    //   `ws.terminate()` is a noop as no socket is assigned.
	    // - Otherwise, the error is re-emitted by the listener of the `'error'`
	    //   event of the `Receiver` object. The listener already closes the
	    //   connection by calling `ws.close()`. This allows a close frame to be
	    //   sent to the other peer. If `ws.terminate()` is called right after this,
	    //   then the close frame might not be sent.
	    terminateOnDestroy = false;
	    duplex.destroy(err);
	  });

	  ws.once('close', function close() {
	    if (duplex.destroyed) return;

	    duplex.push(null);
	  });

	  duplex._destroy = function (err, callback) {
	    if (ws.readyState === ws.CLOSED) {
	      callback(err);
	      process.nextTick(emitClose, duplex);
	      return;
	    }

	    let called = false;

	    ws.once('error', function error(err) {
	      called = true;
	      callback(err);
	    });

	    ws.once('close', function close() {
	      if (!called) callback(err);
	      process.nextTick(emitClose, duplex);
	    });

	    if (terminateOnDestroy) ws.terminate();
	  };

	  duplex._final = function (callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._final(callback);
	      });
	      return;
	    }

	    // If the value of the `_socket` property is `null` it means that `ws` is a
	    // client websocket and the handshake failed. In fact, when this happens, a
	    // socket is never assigned to the websocket. Wait for the `'error'` event
	    // that will be emitted by the websocket.
	    if (ws._socket === null) return;

	    if (ws._socket._writableState.finished) {
	      callback();
	      if (duplex._readableState.endEmitted) duplex.destroy();
	    } else {
	      ws._socket.once('finish', function finish() {
	        // `duplex` is not destroyed here because the `'end'` event will be
	        // emitted on `duplex` after this `'finish'` event. The EOF signaling
	        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
	        callback();
	      });
	      ws.close();
	    }
	  };

	  duplex._read = function () {
	    if (ws.isPaused) ws.resume();
	  };

	  duplex._write = function (chunk, encoding, callback) {
	    if (ws.readyState === ws.CONNECTING) {
	      ws.once('open', function open() {
	        duplex._write(chunk, encoding, callback);
	      });
	      return;
	    }

	    ws.send(chunk, callback);
	  };

	  duplex.on('end', duplexOnEnd);
	  duplex.on('error', duplexOnError);
	  return duplex;
	}

	stream$1 = createWebSocketStream;
	return stream$1;
}

var subprotocol;
var hasRequiredSubprotocol;

function requireSubprotocol () {
	if (hasRequiredSubprotocol) return subprotocol;
	hasRequiredSubprotocol = 1;

	const { tokenChars } = requireValidation();

	/**
	 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	 *
	 * @param {String} header The field value of the header
	 * @return {Set} The subprotocol names
	 * @public
	 */
	function parse(header) {
	  const protocols = new Set();
	  let start = -1;
	  let end = -1;
	  let i = 0;

	  for (i; i < header.length; i++) {
	    const code = header.charCodeAt(i);

	    if (end === -1 && tokenChars[code] === 1) {
	      if (start === -1) start = i;
	    } else if (
	      i !== 0 &&
	      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
	    ) {
	      if (end === -1 && start !== -1) end = i;
	    } else if (code === 0x2c /* ',' */) {
	      if (start === -1) {
	        throw new SyntaxError(`Unexpected character at index ${i}`);
	      }

	      if (end === -1) end = i;

	      const protocol = header.slice(start, end);

	      if (protocols.has(protocol)) {
	        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	      }

	      protocols.add(protocol);
	      start = end = -1;
	    } else {
	      throw new SyntaxError(`Unexpected character at index ${i}`);
	    }
	  }

	  if (start === -1 || end !== -1) {
	    throw new SyntaxError('Unexpected end of input');
	  }

	  const protocol = header.slice(start, i);

	  if (protocols.has(protocol)) {
	    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
	  }

	  protocols.add(protocol);
	  return protocols;
	}

	subprotocol = { parse };
	return subprotocol;
}

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$" }] */

var websocketServer;
var hasRequiredWebsocketServer;

function requireWebsocketServer () {
	if (hasRequiredWebsocketServer) return websocketServer;
	hasRequiredWebsocketServer = 1;

	const EventEmitter = require$$0$b;
	const http = require$$2$2;
	const { createHash } = require$$0$4;

	const extension = requireExtension();
	const PerMessageDeflate = requirePermessageDeflate();
	const subprotocol = requireSubprotocol();
	const WebSocket = requireWebsocket();
	const { GUID, kWebSocket } = requireConstants();

	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;

	/**
	 * Class representing a WebSocket server.
	 *
	 * @extends EventEmitter
	 */
	class WebSocketServer extends EventEmitter {
	  /**
	   * Create a `WebSocketServer` instance.
	   *
	   * @param {Object} options Configuration options
	   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
	   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
	   *     multiple times in the same tick
	   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
	   *     automatically send a pong in response to a ping
	   * @param {Number} [options.backlog=511] The maximum length of the queue of
	   *     pending connections
	   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
	   *     track clients
	   * @param {Function} [options.handleProtocols] A hook to handle protocols
	   * @param {String} [options.host] The hostname where to bind the server
	   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
	   *     size
	   * @param {Boolean} [options.noServer=false] Enable no server mode
	   * @param {String} [options.path] Accept only connections matching this path
	   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
	   *     permessage-deflate
	   * @param {Number} [options.port] The port where to bind the server
	   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
	   *     server to use
	   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	   *     not to skip UTF-8 validation for text and close messages
	   * @param {Function} [options.verifyClient] A hook to reject connections
	   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
	   *     class to use. It must be the `WebSocket` class or class that extends it
	   * @param {Function} [callback] A listener for the `listening` event
	   */
	  constructor(options, callback) {
	    super();

	    options = {
	      allowSynchronousEvents: false,
	      autoPong: true,
	      maxPayload: 100 * 1024 * 1024,
	      skipUTF8Validation: false,
	      perMessageDeflate: false,
	      handleProtocols: null,
	      clientTracking: true,
	      verifyClient: null,
	      noServer: false,
	      backlog: null, // use default (511 as implemented in net.js)
	      server: null,
	      host: null,
	      path: null,
	      port: null,
	      WebSocket,
	      ...options
	    };

	    if (
	      (options.port == null && !options.server && !options.noServer) ||
	      (options.port != null && (options.server || options.noServer)) ||
	      (options.server && options.noServer)
	    ) {
	      throw new TypeError(
	        'One and only one of the "port", "server", or "noServer" options ' +
	          'must be specified'
	      );
	    }

	    if (options.port != null) {
	      this._server = http.createServer((req, res) => {
	        const body = http.STATUS_CODES[426];

	        res.writeHead(426, {
	          'Content-Length': body.length,
	          'Content-Type': 'text/plain'
	        });
	        res.end(body);
	      });
	      this._server.listen(
	        options.port,
	        options.host,
	        options.backlog,
	        callback
	      );
	    } else if (options.server) {
	      this._server = options.server;
	    }

	    if (this._server) {
	      const emitConnection = this.emit.bind(this, 'connection');

	      this._removeListeners = addListeners(this._server, {
	        listening: this.emit.bind(this, 'listening'),
	        error: this.emit.bind(this, 'error'),
	        upgrade: (req, socket, head) => {
	          this.handleUpgrade(req, socket, head, emitConnection);
	        }
	      });
	    }

	    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
	    if (options.clientTracking) {
	      this.clients = new Set();
	      this._shouldEmitClose = false;
	    }

	    this.options = options;
	    this._state = RUNNING;
	  }

	  /**
	   * Returns the bound address, the address family name, and port of the server
	   * as reported by the operating system if listening on an IP socket.
	   * If the server is listening on a pipe or UNIX domain socket, the name is
	   * returned as a string.
	   *
	   * @return {(Object|String|null)} The address of the server
	   * @public
	   */
	  address() {
	    if (this.options.noServer) {
	      throw new Error('The server is operating in "noServer" mode');
	    }

	    if (!this._server) return null;
	    return this._server.address();
	  }

	  /**
	   * Stop the server from accepting new connections and emit the `'close'` event
	   * when all existing connections are closed.
	   *
	   * @param {Function} [cb] A one-time listener for the `'close'` event
	   * @public
	   */
	  close(cb) {
	    if (this._state === CLOSED) {
	      if (cb) {
	        this.once('close', () => {
	          cb(new Error('The server is not running'));
	        });
	      }

	      process.nextTick(emitClose, this);
	      return;
	    }

	    if (cb) this.once('close', cb);

	    if (this._state === CLOSING) return;
	    this._state = CLOSING;

	    if (this.options.noServer || this.options.server) {
	      if (this._server) {
	        this._removeListeners();
	        this._removeListeners = this._server = null;
	      }

	      if (this.clients) {
	        if (!this.clients.size) {
	          process.nextTick(emitClose, this);
	        } else {
	          this._shouldEmitClose = true;
	        }
	      } else {
	        process.nextTick(emitClose, this);
	      }
	    } else {
	      const server = this._server;

	      this._removeListeners();
	      this._removeListeners = this._server = null;

	      //
	      // The HTTP/S server was created internally. Close it, and rely on its
	      // `'close'` event.
	      //
	      server.close(() => {
	        emitClose(this);
	      });
	    }
	  }

	  /**
	   * See if a given request should be handled by this server instance.
	   *
	   * @param {http.IncomingMessage} req Request object to inspect
	   * @return {Boolean} `true` if the request is valid, else `false`
	   * @public
	   */
	  shouldHandle(req) {
	    if (this.options.path) {
	      const index = req.url.indexOf('?');
	      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

	      if (pathname !== this.options.path) return false;
	    }

	    return true;
	  }

	  /**
	   * Handle a HTTP Upgrade request.
	   *
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @public
	   */
	  handleUpgrade(req, socket, head, cb) {
	    socket.on('error', socketOnError);

	    const key = req.headers['sec-websocket-key'];
	    const version = +req.headers['sec-websocket-version'];

	    if (req.method !== 'GET') {
	      const message = 'Invalid HTTP method';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
	      return;
	    }

	    if (req.headers.upgrade.toLowerCase() !== 'websocket') {
	      const message = 'Invalid Upgrade header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (!key || !keyRegex.test(key)) {
	      const message = 'Missing or invalid Sec-WebSocket-Key header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (version !== 8 && version !== 13) {
	      const message = 'Missing or invalid Sec-WebSocket-Version header';
	      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	      return;
	    }

	    if (!this.shouldHandle(req)) {
	      abortHandshake(socket, 400);
	      return;
	    }

	    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
	    let protocols = new Set();

	    if (secWebSocketProtocol !== undefined) {
	      try {
	        protocols = subprotocol.parse(secWebSocketProtocol);
	      } catch (err) {
	        const message = 'Invalid Sec-WebSocket-Protocol header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
	    const extensions = {};

	    if (
	      this.options.perMessageDeflate &&
	      secWebSocketExtensions !== undefined
	    ) {
	      const perMessageDeflate = new PerMessageDeflate(
	        this.options.perMessageDeflate,
	        true,
	        this.options.maxPayload
	      );

	      try {
	        const offers = extension.parse(secWebSocketExtensions);

	        if (offers[PerMessageDeflate.extensionName]) {
	          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
	          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
	        }
	      } catch (err) {
	        const message =
	          'Invalid or unacceptable Sec-WebSocket-Extensions header';
	        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
	        return;
	      }
	    }

	    //
	    // Optionally call external client verification handler.
	    //
	    if (this.options.verifyClient) {
	      const info = {
	        origin:
	          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
	        secure: !!(req.socket.authorized || req.socket.encrypted),
	        req
	      };

	      if (this.options.verifyClient.length === 2) {
	        this.options.verifyClient(info, (verified, code, message, headers) => {
	          if (!verified) {
	            return abortHandshake(socket, code || 401, message, headers);
	          }

	          this.completeUpgrade(
	            extensions,
	            key,
	            protocols,
	            req,
	            socket,
	            head,
	            cb
	          );
	        });
	        return;
	      }

	      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
	    }

	    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
	  }

	  /**
	   * Upgrade the connection to WebSocket.
	   *
	   * @param {Object} extensions The accepted extensions
	   * @param {String} key The value of the `Sec-WebSocket-Key` header
	   * @param {Set} protocols The subprotocols
	   * @param {http.IncomingMessage} req The request object
	   * @param {Duplex} socket The network socket between the server and client
	   * @param {Buffer} head The first packet of the upgraded stream
	   * @param {Function} cb Callback
	   * @throws {Error} If called more than once with the same socket
	   * @private
	   */
	  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
	    //
	    // Destroy the socket if the client has already sent a FIN packet.
	    //
	    if (!socket.readable || !socket.writable) return socket.destroy();

	    if (socket[kWebSocket]) {
	      throw new Error(
	        'server.handleUpgrade() was called more than once with the same ' +
	          'socket, possibly due to a misconfiguration'
	      );
	    }

	    if (this._state > RUNNING) return abortHandshake(socket, 503);

	    const digest = createHash('sha1')
	      .update(key + GUID)
	      .digest('base64');

	    const headers = [
	      'HTTP/1.1 101 Switching Protocols',
	      'Upgrade: websocket',
	      'Connection: Upgrade',
	      `Sec-WebSocket-Accept: ${digest}`
	    ];

	    const ws = new this.options.WebSocket(null, undefined, this.options);

	    if (protocols.size) {
	      //
	      // Optionally call external protocol selection handler.
	      //
	      const protocol = this.options.handleProtocols
	        ? this.options.handleProtocols(protocols, req)
	        : protocols.values().next().value;

	      if (protocol) {
	        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
	        ws._protocol = protocol;
	      }
	    }

	    if (extensions[PerMessageDeflate.extensionName]) {
	      const params = extensions[PerMessageDeflate.extensionName].params;
	      const value = extension.format({
	        [PerMessageDeflate.extensionName]: [params]
	      });
	      headers.push(`Sec-WebSocket-Extensions: ${value}`);
	      ws._extensions = extensions;
	    }

	    //
	    // Allow external modification/inspection of handshake headers.
	    //
	    this.emit('headers', headers, req);

	    socket.write(headers.concat('\r\n').join('\r\n'));
	    socket.removeListener('error', socketOnError);

	    ws.setSocket(socket, head, {
	      allowSynchronousEvents: this.options.allowSynchronousEvents,
	      maxPayload: this.options.maxPayload,
	      skipUTF8Validation: this.options.skipUTF8Validation
	    });

	    if (this.clients) {
	      this.clients.add(ws);
	      ws.on('close', () => {
	        this.clients.delete(ws);

	        if (this._shouldEmitClose && !this.clients.size) {
	          process.nextTick(emitClose, this);
	        }
	      });
	    }

	    cb(ws, req);
	  }
	}

	websocketServer = WebSocketServer;

	/**
	 * Add event listeners on an `EventEmitter` using a map of <event, listener>
	 * pairs.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @param {Object.<String, Function>} map The listeners to add
	 * @return {Function} A function that will remove the added listeners when
	 *     called
	 * @private
	 */
	function addListeners(server, map) {
	  for (const event of Object.keys(map)) server.on(event, map[event]);

	  return function removeListeners() {
	    for (const event of Object.keys(map)) {
	      server.removeListener(event, map[event]);
	    }
	  };
	}

	/**
	 * Emit a `'close'` event on an `EventEmitter`.
	 *
	 * @param {EventEmitter} server The event emitter
	 * @private
	 */
	function emitClose(server) {
	  server._state = CLOSED;
	  server.emit('close');
	}

	/**
	 * Handle socket errors.
	 *
	 * @private
	 */
	function socketOnError() {
	  this.destroy();
	}

	/**
	 * Close the connection when preconditions are not fulfilled.
	 *
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} [message] The HTTP response body
	 * @param {Object} [headers] Additional HTTP response headers
	 * @private
	 */
	function abortHandshake(socket, code, message, headers) {
	  //
	  // The socket is writable unless the user destroyed or ended it before calling
	  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
	  // error. Handling this does not make much sense as the worst that can happen
	  // is that some of the data written by the user might be discarded due to the
	  // call to `socket.end()` below, which triggers an `'error'` event that in
	  // turn causes the socket to be destroyed.
	  //
	  message = message || http.STATUS_CODES[code];
	  headers = {
	    Connection: 'close',
	    'Content-Type': 'text/html',
	    'Content-Length': Buffer.byteLength(message),
	    ...headers
	  };

	  socket.once('finish', socket.destroy);

	  socket.end(
	    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
	      Object.keys(headers)
	        .map((h) => `${h}: ${headers[h]}`)
	        .join('\r\n') +
	      '\r\n\r\n' +
	      message
	  );
	}

	/**
	 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	 * one listener for it, otherwise call `abortHandshake()`.
	 *
	 * @param {WebSocketServer} server The WebSocket server
	 * @param {http.IncomingMessage} req The request object
	 * @param {Duplex} socket The socket of the upgrade request
	 * @param {Number} code The HTTP response status code
	 * @param {String} message The HTTP response body
	 * @private
	 */
	function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
	  if (server.listenerCount('wsClientError')) {
	    const err = new Error(message);
	    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

	    server.emit('wsClientError', err, socket, req);
	  } else {
	    abortHandshake(socket, code, message);
	  }
	}
	return websocketServer;
}

var ws;
var hasRequiredWs;

function requireWs () {
	if (hasRequiredWs) return ws;
	hasRequiredWs = 1;

	const WebSocket = requireWebsocket();

	WebSocket.createWebSocketStream = requireStream$1();
	WebSocket.Server = requireWebsocketServer();
	WebSocket.Receiver = requireReceiver();
	WebSocket.Sender = requireSender();

	WebSocket.WebSocket = WebSocket;
	WebSocket.WebSocketServer = WebSocket.Server;

	ws = WebSocket;
	return ws;
}

var hasRequiredWebSocket;

function requireWebSocket () {
	if (hasRequiredWebSocket) return WebSocket;
	hasRequiredWebSocket = 1;
	var __importDefault = (WebSocket && WebSocket.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(WebSocket, "__esModule", { value: true });
	WebSocket.WebSocket = void 0;
	const ws_1 = __importDefault(requireWs());
	WebSocket.WebSocket = ws_1.default;
	
	return WebSocket;
}

var hasRequiredCjs$5;

function requireCjs$5 () {
	if (hasRequiredCjs$5) return cjs$3;
	hasRequiredCjs$5 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.WebSocket = exports.terminalSize = exports.readFileAsBase64 = exports.generateRandomBase64 = void 0;
		var generateRandomBase64_js_1 = /*@__PURE__*/ requireGenerateRandomBase64();
		Object.defineProperty(exports, "generateRandomBase64", { enumerable: true, get: function () { return generateRandomBase64_js_1.generateRandomBase64; } });
		var readFileAsBase64_js_1 = /*@__PURE__*/ requireReadFileAsBase64();
		Object.defineProperty(exports, "readFileAsBase64", { enumerable: true, get: function () { return readFileAsBase64_js_1.readFileAsBase64; } });
		var terminalSize_js_1 = /*@__PURE__*/ requireTerminalSize();
		Object.defineProperty(exports, "terminalSize", { enumerable: true, get: function () { return terminalSize_js_1.terminalSize; } });
		var WebSocket_js_1 = /*@__PURE__*/ requireWebSocket();
		Object.defineProperty(exports, "WebSocket", { enumerable: true, get: function () { return WebSocket_js_1.WebSocket; } });
		
	} (cjs$3));
	return cjs$3;
}

var boxen = {exports: {}};

var stringWidth = {exports: {}};

var ansiRegex;
var hasRequiredAnsiRegex;

function requireAnsiRegex () {
	if (hasRequiredAnsiRegex) return ansiRegex;
	hasRequiredAnsiRegex = 1;

	ansiRegex = ({onlyFirst = false} = {}) => {
		const pattern = [
			'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
			'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
		].join('|');

		return new RegExp(pattern, onlyFirst ? undefined : 'g');
	};
	return ansiRegex;
}

var stripAnsi;
var hasRequiredStripAnsi;

function requireStripAnsi () {
	if (hasRequiredStripAnsi) return stripAnsi;
	hasRequiredStripAnsi = 1;
	const ansiRegex = requireAnsiRegex();

	stripAnsi = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
	return stripAnsi;
}

var isFullwidthCodePoint = {exports: {}};

/* eslint-disable yoda */

var hasRequiredIsFullwidthCodePoint;

function requireIsFullwidthCodePoint () {
	if (hasRequiredIsFullwidthCodePoint) return isFullwidthCodePoint.exports;
	hasRequiredIsFullwidthCodePoint = 1;

	const isFullwidthCodePoint$1 = codePoint => {
		if (Number.isNaN(codePoint)) {
			return false;
		}

		// Code points are derived from:
		// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
		if (
			codePoint >= 0x1100 && (
				codePoint <= 0x115F || // Hangul Jamo
				codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
				codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
				// CJK Radicals Supplement .. Enclosed CJK Letters and Months
				(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||
				// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
				(0x3250 <= codePoint && codePoint <= 0x4DBF) ||
				// CJK Unified Ideographs .. Yi Radicals
				(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||
				// Hangul Jamo Extended-A
				(0xA960 <= codePoint && codePoint <= 0xA97C) ||
				// Hangul Syllables
				(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
				// CJK Compatibility Ideographs
				(0xF900 <= codePoint && codePoint <= 0xFAFF) ||
				// Vertical Forms
				(0xFE10 <= codePoint && codePoint <= 0xFE19) ||
				// CJK Compatibility Forms .. Small Form Variants
				(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||
				// Halfwidth and Fullwidth Forms
				(0xFF01 <= codePoint && codePoint <= 0xFF60) ||
				(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||
				// Kana Supplement
				(0x1B000 <= codePoint && codePoint <= 0x1B001) ||
				// Enclosed Ideographic Supplement
				(0x1F200 <= codePoint && codePoint <= 0x1F251) ||
				// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
				(0x20000 <= codePoint && codePoint <= 0x3FFFD)
			)
		) {
			return true;
		}

		return false;
	};

	isFullwidthCodePoint.exports = isFullwidthCodePoint$1;
	isFullwidthCodePoint.exports.default = isFullwidthCodePoint$1;
	return isFullwidthCodePoint.exports;
}

var emojiRegex;
var hasRequiredEmojiRegex;

function requireEmojiRegex () {
	if (hasRequiredEmojiRegex) return emojiRegex;
	hasRequiredEmojiRegex = 1;

	emojiRegex = function () {
	  // https://mths.be/emoji
	  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
	};
	return emojiRegex;
}

var hasRequiredStringWidth;

function requireStringWidth () {
	if (hasRequiredStringWidth) return stringWidth.exports;
	hasRequiredStringWidth = 1;
	const stripAnsi = requireStripAnsi();
	const isFullwidthCodePoint = requireIsFullwidthCodePoint();
	const emojiRegex = requireEmojiRegex();

	const stringWidth$1 = string => {
		if (typeof string !== 'string' || string.length === 0) {
			return 0;
		}

		string = stripAnsi(string);

		if (string.length === 0) {
			return 0;
		}

		string = string.replace(emojiRegex(), '  ');

		let width = 0;

		for (let i = 0; i < string.length; i++) {
			const code = string.codePointAt(i);

			// Ignore control characters
			if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
				continue;
			}

			// Ignore combining characters
			if (code >= 0x300 && code <= 0x36F) {
				continue;
			}

			// Surrogates
			if (code > 0xFFFF) {
				i++;
			}

			width += isFullwidthCodePoint(code) ? 2 : 1;
		}

		return width;
	};

	stringWidth.exports = stringWidth$1;
	// TODO: remove this in the next major version
	stringWidth.exports.default = stringWidth$1;
	return stringWidth.exports;
}

var ansiStyles = {exports: {}};

var colorName;
var hasRequiredColorName;

function requireColorName () {
	if (hasRequiredColorName) return colorName;
	hasRequiredColorName = 1;

	colorName = {
		"aliceblue": [240, 248, 255],
		"antiquewhite": [250, 235, 215],
		"aqua": [0, 255, 255],
		"aquamarine": [127, 255, 212],
		"azure": [240, 255, 255],
		"beige": [245, 245, 220],
		"bisque": [255, 228, 196],
		"black": [0, 0, 0],
		"blanchedalmond": [255, 235, 205],
		"blue": [0, 0, 255],
		"blueviolet": [138, 43, 226],
		"brown": [165, 42, 42],
		"burlywood": [222, 184, 135],
		"cadetblue": [95, 158, 160],
		"chartreuse": [127, 255, 0],
		"chocolate": [210, 105, 30],
		"coral": [255, 127, 80],
		"cornflowerblue": [100, 149, 237],
		"cornsilk": [255, 248, 220],
		"crimson": [220, 20, 60],
		"cyan": [0, 255, 255],
		"darkblue": [0, 0, 139],
		"darkcyan": [0, 139, 139],
		"darkgoldenrod": [184, 134, 11],
		"darkgray": [169, 169, 169],
		"darkgreen": [0, 100, 0],
		"darkgrey": [169, 169, 169],
		"darkkhaki": [189, 183, 107],
		"darkmagenta": [139, 0, 139],
		"darkolivegreen": [85, 107, 47],
		"darkorange": [255, 140, 0],
		"darkorchid": [153, 50, 204],
		"darkred": [139, 0, 0],
		"darksalmon": [233, 150, 122],
		"darkseagreen": [143, 188, 143],
		"darkslateblue": [72, 61, 139],
		"darkslategray": [47, 79, 79],
		"darkslategrey": [47, 79, 79],
		"darkturquoise": [0, 206, 209],
		"darkviolet": [148, 0, 211],
		"deeppink": [255, 20, 147],
		"deepskyblue": [0, 191, 255],
		"dimgray": [105, 105, 105],
		"dimgrey": [105, 105, 105],
		"dodgerblue": [30, 144, 255],
		"firebrick": [178, 34, 34],
		"floralwhite": [255, 250, 240],
		"forestgreen": [34, 139, 34],
		"fuchsia": [255, 0, 255],
		"gainsboro": [220, 220, 220],
		"ghostwhite": [248, 248, 255],
		"gold": [255, 215, 0],
		"goldenrod": [218, 165, 32],
		"gray": [128, 128, 128],
		"green": [0, 128, 0],
		"greenyellow": [173, 255, 47],
		"grey": [128, 128, 128],
		"honeydew": [240, 255, 240],
		"hotpink": [255, 105, 180],
		"indianred": [205, 92, 92],
		"indigo": [75, 0, 130],
		"ivory": [255, 255, 240],
		"khaki": [240, 230, 140],
		"lavender": [230, 230, 250],
		"lavenderblush": [255, 240, 245],
		"lawngreen": [124, 252, 0],
		"lemonchiffon": [255, 250, 205],
		"lightblue": [173, 216, 230],
		"lightcoral": [240, 128, 128],
		"lightcyan": [224, 255, 255],
		"lightgoldenrodyellow": [250, 250, 210],
		"lightgray": [211, 211, 211],
		"lightgreen": [144, 238, 144],
		"lightgrey": [211, 211, 211],
		"lightpink": [255, 182, 193],
		"lightsalmon": [255, 160, 122],
		"lightseagreen": [32, 178, 170],
		"lightskyblue": [135, 206, 250],
		"lightslategray": [119, 136, 153],
		"lightslategrey": [119, 136, 153],
		"lightsteelblue": [176, 196, 222],
		"lightyellow": [255, 255, 224],
		"lime": [0, 255, 0],
		"limegreen": [50, 205, 50],
		"linen": [250, 240, 230],
		"magenta": [255, 0, 255],
		"maroon": [128, 0, 0],
		"mediumaquamarine": [102, 205, 170],
		"mediumblue": [0, 0, 205],
		"mediumorchid": [186, 85, 211],
		"mediumpurple": [147, 112, 219],
		"mediumseagreen": [60, 179, 113],
		"mediumslateblue": [123, 104, 238],
		"mediumspringgreen": [0, 250, 154],
		"mediumturquoise": [72, 209, 204],
		"mediumvioletred": [199, 21, 133],
		"midnightblue": [25, 25, 112],
		"mintcream": [245, 255, 250],
		"mistyrose": [255, 228, 225],
		"moccasin": [255, 228, 181],
		"navajowhite": [255, 222, 173],
		"navy": [0, 0, 128],
		"oldlace": [253, 245, 230],
		"olive": [128, 128, 0],
		"olivedrab": [107, 142, 35],
		"orange": [255, 165, 0],
		"orangered": [255, 69, 0],
		"orchid": [218, 112, 214],
		"palegoldenrod": [238, 232, 170],
		"palegreen": [152, 251, 152],
		"paleturquoise": [175, 238, 238],
		"palevioletred": [219, 112, 147],
		"papayawhip": [255, 239, 213],
		"peachpuff": [255, 218, 185],
		"peru": [205, 133, 63],
		"pink": [255, 192, 203],
		"plum": [221, 160, 221],
		"powderblue": [176, 224, 230],
		"purple": [128, 0, 128],
		"rebeccapurple": [102, 51, 153],
		"red": [255, 0, 0],
		"rosybrown": [188, 143, 143],
		"royalblue": [65, 105, 225],
		"saddlebrown": [139, 69, 19],
		"salmon": [250, 128, 114],
		"sandybrown": [244, 164, 96],
		"seagreen": [46, 139, 87],
		"seashell": [255, 245, 238],
		"sienna": [160, 82, 45],
		"silver": [192, 192, 192],
		"skyblue": [135, 206, 235],
		"slateblue": [106, 90, 205],
		"slategray": [112, 128, 144],
		"slategrey": [112, 128, 144],
		"snow": [255, 250, 250],
		"springgreen": [0, 255, 127],
		"steelblue": [70, 130, 180],
		"tan": [210, 180, 140],
		"teal": [0, 128, 128],
		"thistle": [216, 191, 216],
		"tomato": [255, 99, 71],
		"turquoise": [64, 224, 208],
		"violet": [238, 130, 238],
		"wheat": [245, 222, 179],
		"white": [255, 255, 255],
		"whitesmoke": [245, 245, 245],
		"yellow": [255, 255, 0],
		"yellowgreen": [154, 205, 50]
	};
	return colorName;
}

/* MIT license */

var conversions;
var hasRequiredConversions;

function requireConversions () {
	if (hasRequiredConversions) return conversions;
	hasRequiredConversions = 1;
	/* eslint-disable no-mixed-operators */
	const cssKeywords = requireColorName();

	// NOTE: conversions should only return primitive values (i.e. arrays, or
	//       values that give correct `typeof` results).
	//       do not use box values types (i.e. Number(), String(), etc.)

	const reverseKeywords = {};
	for (const key of Object.keys(cssKeywords)) {
		reverseKeywords[cssKeywords[key]] = key;
	}

	const convert = {
		rgb: {channels: 3, labels: 'rgb'},
		hsl: {channels: 3, labels: 'hsl'},
		hsv: {channels: 3, labels: 'hsv'},
		hwb: {channels: 3, labels: 'hwb'},
		cmyk: {channels: 4, labels: 'cmyk'},
		xyz: {channels: 3, labels: 'xyz'},
		lab: {channels: 3, labels: 'lab'},
		lch: {channels: 3, labels: 'lch'},
		hex: {channels: 1, labels: ['hex']},
		keyword: {channels: 1, labels: ['keyword']},
		ansi16: {channels: 1, labels: ['ansi16']},
		ansi256: {channels: 1, labels: ['ansi256']},
		hcg: {channels: 3, labels: ['h', 'c', 'g']},
		apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
		gray: {channels: 1, labels: ['gray']}
	};

	conversions = convert;

	// Hide .channels and .labels properties
	for (const model of Object.keys(convert)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		const {channels, labels} = convert[model];
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}

	convert.rgb.hsl = function (rgb) {
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const min = Math.min(r, g, b);
		const max = Math.max(r, g, b);
		const delta = max - min;
		let h;
		let s;

		if (max === min) {
			h = 0;
		} else if (r === max) {
			h = (g - b) / delta;
		} else if (g === max) {
			h = 2 + (b - r) / delta;
		} else if (b === max) {
			h = 4 + (r - g) / delta;
		}

		h = Math.min(h * 60, 360);

		if (h < 0) {
			h += 360;
		}

		const l = (min + max) / 2;

		if (max === min) {
			s = 0;
		} else if (l <= 0.5) {
			s = delta / (max + min);
		} else {
			s = delta / (2 - max - min);
		}

		return [h, s * 100, l * 100];
	};

	convert.rgb.hsv = function (rgb) {
		let rdif;
		let gdif;
		let bdif;
		let h;
		let s;

		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const v = Math.max(r, g, b);
		const diff = v - Math.min(r, g, b);
		const diffc = function (c) {
			return (v - c) / 6 / diff + 1 / 2;
		};

		if (diff === 0) {
			h = 0;
			s = 0;
		} else {
			s = diff / v;
			rdif = diffc(r);
			gdif = diffc(g);
			bdif = diffc(b);

			if (r === v) {
				h = bdif - gdif;
			} else if (g === v) {
				h = (1 / 3) + rdif - bdif;
			} else if (b === v) {
				h = (2 / 3) + gdif - rdif;
			}

			if (h < 0) {
				h += 1;
			} else if (h > 1) {
				h -= 1;
			}
		}

		return [
			h * 360,
			s * 100,
			v * 100
		];
	};

	convert.rgb.hwb = function (rgb) {
		const r = rgb[0];
		const g = rgb[1];
		let b = rgb[2];
		const h = convert.rgb.hsl(rgb)[0];
		const w = 1 / 255 * Math.min(r, Math.min(g, b));

		b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

		return [h, w * 100, b * 100];
	};

	convert.rgb.cmyk = function (rgb) {
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;

		const k = Math.min(1 - r, 1 - g, 1 - b);
		const c = (1 - r - k) / (1 - k) || 0;
		const m = (1 - g - k) / (1 - k) || 0;
		const y = (1 - b - k) / (1 - k) || 0;

		return [c * 100, m * 100, y * 100, k * 100];
	};

	function comparativeDistance(x, y) {
		/*
			See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
		*/
		return (
			((x[0] - y[0]) ** 2) +
			((x[1] - y[1]) ** 2) +
			((x[2] - y[2]) ** 2)
		);
	}

	convert.rgb.keyword = function (rgb) {
		const reversed = reverseKeywords[rgb];
		if (reversed) {
			return reversed;
		}

		let currentClosestDistance = Infinity;
		let currentClosestKeyword;

		for (const keyword of Object.keys(cssKeywords)) {
			const value = cssKeywords[keyword];

			// Compute comparative distance
			const distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}

		return currentClosestKeyword;
	};

	convert.keyword.rgb = function (keyword) {
		return cssKeywords[keyword];
	};

	convert.rgb.xyz = function (rgb) {
		let r = rgb[0] / 255;
		let g = rgb[1] / 255;
		let b = rgb[2] / 255;

		// Assume sRGB
		r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
		g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
		b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

		const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
		const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
		const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

		return [x * 100, y * 100, z * 100];
	};

	convert.rgb.lab = function (rgb) {
		const xyz = convert.rgb.xyz(rgb);
		let x = xyz[0];
		let y = xyz[1];
		let z = xyz[2];

		x /= 95.047;
		y /= 100;
		z /= 108.883;

		x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
		y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
		z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

		const l = (116 * y) - 16;
		const a = 500 * (x - y);
		const b = 200 * (y - z);

		return [l, a, b];
	};

	convert.hsl.rgb = function (hsl) {
		const h = hsl[0] / 360;
		const s = hsl[1] / 100;
		const l = hsl[2] / 100;
		let t2;
		let t3;
		let val;

		if (s === 0) {
			val = l * 255;
			return [val, val, val];
		}

		if (l < 0.5) {
			t2 = l * (1 + s);
		} else {
			t2 = l + s - l * s;
		}

		const t1 = 2 * l - t2;

		const rgb = [0, 0, 0];
		for (let i = 0; i < 3; i++) {
			t3 = h + 1 / 3 * -(i - 1);
			if (t3 < 0) {
				t3++;
			}

			if (t3 > 1) {
				t3--;
			}

			if (6 * t3 < 1) {
				val = t1 + (t2 - t1) * 6 * t3;
			} else if (2 * t3 < 1) {
				val = t2;
			} else if (3 * t3 < 2) {
				val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
			} else {
				val = t1;
			}

			rgb[i] = val * 255;
		}

		return rgb;
	};

	convert.hsl.hsv = function (hsl) {
		const h = hsl[0];
		let s = hsl[1] / 100;
		let l = hsl[2] / 100;
		let smin = s;
		const lmin = Math.max(l, 0.01);

		l *= 2;
		s *= (l <= 1) ? l : 2 - l;
		smin *= lmin <= 1 ? lmin : 2 - lmin;
		const v = (l + s) / 2;
		const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

		return [h, sv * 100, v * 100];
	};

	convert.hsv.rgb = function (hsv) {
		const h = hsv[0] / 60;
		const s = hsv[1] / 100;
		let v = hsv[2] / 100;
		const hi = Math.floor(h) % 6;

		const f = h - Math.floor(h);
		const p = 255 * v * (1 - s);
		const q = 255 * v * (1 - (s * f));
		const t = 255 * v * (1 - (s * (1 - f)));
		v *= 255;

		switch (hi) {
			case 0:
				return [v, t, p];
			case 1:
				return [q, v, p];
			case 2:
				return [p, v, t];
			case 3:
				return [p, q, v];
			case 4:
				return [t, p, v];
			case 5:
				return [v, p, q];
		}
	};

	convert.hsv.hsl = function (hsv) {
		const h = hsv[0];
		const s = hsv[1] / 100;
		const v = hsv[2] / 100;
		const vmin = Math.max(v, 0.01);
		let sl;
		let l;

		l = (2 - s) * v;
		const lmin = (2 - s) * vmin;
		sl = s * vmin;
		sl /= (lmin <= 1) ? lmin : 2 - lmin;
		sl = sl || 0;
		l /= 2;

		return [h, sl * 100, l * 100];
	};

	// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
	convert.hwb.rgb = function (hwb) {
		const h = hwb[0] / 360;
		let wh = hwb[1] / 100;
		let bl = hwb[2] / 100;
		const ratio = wh + bl;
		let f;

		// Wh + bl cant be > 1
		if (ratio > 1) {
			wh /= ratio;
			bl /= ratio;
		}

		const i = Math.floor(6 * h);
		const v = 1 - bl;
		f = 6 * h - i;

		if ((i & 0x01) !== 0) {
			f = 1 - f;
		}

		const n = wh + f * (v - wh); // Linear interpolation

		let r;
		let g;
		let b;
		/* eslint-disable max-statements-per-line,no-multi-spaces */
		switch (i) {
			default:
			case 6:
			case 0: r = v;  g = n;  b = wh; break;
			case 1: r = n;  g = v;  b = wh; break;
			case 2: r = wh; g = v;  b = n; break;
			case 3: r = wh; g = n;  b = v; break;
			case 4: r = n;  g = wh; b = v; break;
			case 5: r = v;  g = wh; b = n; break;
		}
		/* eslint-enable max-statements-per-line,no-multi-spaces */

		return [r * 255, g * 255, b * 255];
	};

	convert.cmyk.rgb = function (cmyk) {
		const c = cmyk[0] / 100;
		const m = cmyk[1] / 100;
		const y = cmyk[2] / 100;
		const k = cmyk[3] / 100;

		const r = 1 - Math.min(1, c * (1 - k) + k);
		const g = 1 - Math.min(1, m * (1 - k) + k);
		const b = 1 - Math.min(1, y * (1 - k) + k);

		return [r * 255, g * 255, b * 255];
	};

	convert.xyz.rgb = function (xyz) {
		const x = xyz[0] / 100;
		const y = xyz[1] / 100;
		const z = xyz[2] / 100;
		let r;
		let g;
		let b;

		r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
		g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
		b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

		// Assume sRGB
		r = r > 0.0031308
			? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
			: r * 12.92;

		g = g > 0.0031308
			? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
			: g * 12.92;

		b = b > 0.0031308
			? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
			: b * 12.92;

		r = Math.min(Math.max(0, r), 1);
		g = Math.min(Math.max(0, g), 1);
		b = Math.min(Math.max(0, b), 1);

		return [r * 255, g * 255, b * 255];
	};

	convert.xyz.lab = function (xyz) {
		let x = xyz[0];
		let y = xyz[1];
		let z = xyz[2];

		x /= 95.047;
		y /= 100;
		z /= 108.883;

		x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
		y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
		z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

		const l = (116 * y) - 16;
		const a = 500 * (x - y);
		const b = 200 * (y - z);

		return [l, a, b];
	};

	convert.lab.xyz = function (lab) {
		const l = lab[0];
		const a = lab[1];
		const b = lab[2];
		let x;
		let y;
		let z;

		y = (l + 16) / 116;
		x = a / 500 + y;
		z = y - b / 200;

		const y2 = y ** 3;
		const x2 = x ** 3;
		const z2 = z ** 3;
		y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
		x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
		z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

		x *= 95.047;
		y *= 100;
		z *= 108.883;

		return [x, y, z];
	};

	convert.lab.lch = function (lab) {
		const l = lab[0];
		const a = lab[1];
		const b = lab[2];
		let h;

		const hr = Math.atan2(b, a);
		h = hr * 360 / 2 / Math.PI;

		if (h < 0) {
			h += 360;
		}

		const c = Math.sqrt(a * a + b * b);

		return [l, c, h];
	};

	convert.lch.lab = function (lch) {
		const l = lch[0];
		const c = lch[1];
		const h = lch[2];

		const hr = h / 360 * 2 * Math.PI;
		const a = c * Math.cos(hr);
		const b = c * Math.sin(hr);

		return [l, a, b];
	};

	convert.rgb.ansi16 = function (args, saturation = null) {
		const [r, g, b] = args;
		let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

		value = Math.round(value / 50);

		if (value === 0) {
			return 30;
		}

		let ansi = 30
			+ ((Math.round(b / 255) << 2)
			| (Math.round(g / 255) << 1)
			| Math.round(r / 255));

		if (value === 2) {
			ansi += 60;
		}

		return ansi;
	};

	convert.hsv.ansi16 = function (args) {
		// Optimization here; we already know the value and don't need to get
		// it converted for us.
		return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
	};

	convert.rgb.ansi256 = function (args) {
		const r = args[0];
		const g = args[1];
		const b = args[2];

		// We use the extended greyscale palette here, with the exception of
		// black and white. normal palette only has 4 greyscale shades.
		if (r === g && g === b) {
			if (r < 8) {
				return 16;
			}

			if (r > 248) {
				return 231;
			}

			return Math.round(((r - 8) / 247) * 24) + 232;
		}

		const ansi = 16
			+ (36 * Math.round(r / 255 * 5))
			+ (6 * Math.round(g / 255 * 5))
			+ Math.round(b / 255 * 5);

		return ansi;
	};

	convert.ansi16.rgb = function (args) {
		let color = args % 10;

		// Handle greyscale
		if (color === 0 || color === 7) {
			if (args > 50) {
				color += 3.5;
			}

			color = color / 10.5 * 255;

			return [color, color, color];
		}

		const mult = (~~(args > 50) + 1) * 0.5;
		const r = ((color & 1) * mult) * 255;
		const g = (((color >> 1) & 1) * mult) * 255;
		const b = (((color >> 2) & 1) * mult) * 255;

		return [r, g, b];
	};

	convert.ansi256.rgb = function (args) {
		// Handle greyscale
		if (args >= 232) {
			const c = (args - 232) * 10 + 8;
			return [c, c, c];
		}

		args -= 16;

		let rem;
		const r = Math.floor(args / 36) / 5 * 255;
		const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
		const b = (rem % 6) / 5 * 255;

		return [r, g, b];
	};

	convert.rgb.hex = function (args) {
		const integer = ((Math.round(args[0]) & 0xFF) << 16)
			+ ((Math.round(args[1]) & 0xFF) << 8)
			+ (Math.round(args[2]) & 0xFF);

		const string = integer.toString(16).toUpperCase();
		return '000000'.substring(string.length) + string;
	};

	convert.hex.rgb = function (args) {
		const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
		if (!match) {
			return [0, 0, 0];
		}

		let colorString = match[0];

		if (match[0].length === 3) {
			colorString = colorString.split('').map(char => {
				return char + char;
			}).join('');
		}

		const integer = parseInt(colorString, 16);
		const r = (integer >> 16) & 0xFF;
		const g = (integer >> 8) & 0xFF;
		const b = integer & 0xFF;

		return [r, g, b];
	};

	convert.rgb.hcg = function (rgb) {
		const r = rgb[0] / 255;
		const g = rgb[1] / 255;
		const b = rgb[2] / 255;
		const max = Math.max(Math.max(r, g), b);
		const min = Math.min(Math.min(r, g), b);
		const chroma = (max - min);
		let grayscale;
		let hue;

		if (chroma < 1) {
			grayscale = min / (1 - chroma);
		} else {
			grayscale = 0;
		}

		if (chroma <= 0) {
			hue = 0;
		} else
		if (max === r) {
			hue = ((g - b) / chroma) % 6;
		} else
		if (max === g) {
			hue = 2 + (b - r) / chroma;
		} else {
			hue = 4 + (r - g) / chroma;
		}

		hue /= 6;
		hue %= 1;

		return [hue * 360, chroma * 100, grayscale * 100];
	};

	convert.hsl.hcg = function (hsl) {
		const s = hsl[1] / 100;
		const l = hsl[2] / 100;

		const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

		let f = 0;
		if (c < 1.0) {
			f = (l - 0.5 * c) / (1.0 - c);
		}

		return [hsl[0], c * 100, f * 100];
	};

	convert.hsv.hcg = function (hsv) {
		const s = hsv[1] / 100;
		const v = hsv[2] / 100;

		const c = s * v;
		let f = 0;

		if (c < 1.0) {
			f = (v - c) / (1 - c);
		}

		return [hsv[0], c * 100, f * 100];
	};

	convert.hcg.rgb = function (hcg) {
		const h = hcg[0] / 360;
		const c = hcg[1] / 100;
		const g = hcg[2] / 100;

		if (c === 0.0) {
			return [g * 255, g * 255, g * 255];
		}

		const pure = [0, 0, 0];
		const hi = (h % 1) * 6;
		const v = hi % 1;
		const w = 1 - v;
		let mg = 0;

		/* eslint-disable max-statements-per-line */
		switch (Math.floor(hi)) {
			case 0:
				pure[0] = 1; pure[1] = v; pure[2] = 0; break;
			case 1:
				pure[0] = w; pure[1] = 1; pure[2] = 0; break;
			case 2:
				pure[0] = 0; pure[1] = 1; pure[2] = v; break;
			case 3:
				pure[0] = 0; pure[1] = w; pure[2] = 1; break;
			case 4:
				pure[0] = v; pure[1] = 0; pure[2] = 1; break;
			default:
				pure[0] = 1; pure[1] = 0; pure[2] = w;
		}
		/* eslint-enable max-statements-per-line */

		mg = (1.0 - c) * g;

		return [
			(c * pure[0] + mg) * 255,
			(c * pure[1] + mg) * 255,
			(c * pure[2] + mg) * 255
		];
	};

	convert.hcg.hsv = function (hcg) {
		const c = hcg[1] / 100;
		const g = hcg[2] / 100;

		const v = c + g * (1.0 - c);
		let f = 0;

		if (v > 0.0) {
			f = c / v;
		}

		return [hcg[0], f * 100, v * 100];
	};

	convert.hcg.hsl = function (hcg) {
		const c = hcg[1] / 100;
		const g = hcg[2] / 100;

		const l = g * (1.0 - c) + 0.5 * c;
		let s = 0;

		if (l > 0.0 && l < 0.5) {
			s = c / (2 * l);
		} else
		if (l >= 0.5 && l < 1.0) {
			s = c / (2 * (1 - l));
		}

		return [hcg[0], s * 100, l * 100];
	};

	convert.hcg.hwb = function (hcg) {
		const c = hcg[1] / 100;
		const g = hcg[2] / 100;
		const v = c + g * (1.0 - c);
		return [hcg[0], (v - c) * 100, (1 - v) * 100];
	};

	convert.hwb.hcg = function (hwb) {
		const w = hwb[1] / 100;
		const b = hwb[2] / 100;
		const v = 1 - b;
		const c = v - w;
		let g = 0;

		if (c < 1) {
			g = (v - c) / (1 - c);
		}

		return [hwb[0], c * 100, g * 100];
	};

	convert.apple.rgb = function (apple) {
		return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
	};

	convert.rgb.apple = function (rgb) {
		return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
	};

	convert.gray.rgb = function (args) {
		return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
	};

	convert.gray.hsl = function (args) {
		return [0, 0, args[0]];
	};

	convert.gray.hsv = convert.gray.hsl;

	convert.gray.hwb = function (gray) {
		return [0, 100, gray[0]];
	};

	convert.gray.cmyk = function (gray) {
		return [0, 0, 0, gray[0]];
	};

	convert.gray.lab = function (gray) {
		return [gray[0], 0, 0];
	};

	convert.gray.hex = function (gray) {
		const val = Math.round(gray[0] / 100 * 255) & 0xFF;
		const integer = (val << 16) + (val << 8) + val;

		const string = integer.toString(16).toUpperCase();
		return '000000'.substring(string.length) + string;
	};

	convert.rgb.gray = function (rgb) {
		const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
		return [val / 255 * 100];
	};
	return conversions;
}

var route;
var hasRequiredRoute;

function requireRoute () {
	if (hasRequiredRoute) return route;
	hasRequiredRoute = 1;
	const conversions = requireConversions();

	/*
		This function routes a model to all other models.

		all functions that are routed have a property `.conversion` attached
		to the returned synthetic function. This property is an array
		of strings, each with the steps in between the 'from' and 'to'
		color models (inclusive).

		conversions that are not possible simply are not included.
	*/

	function buildGraph() {
		const graph = {};
		// https://jsperf.com/object-keys-vs-for-in-with-closure/3
		const models = Object.keys(conversions);

		for (let len = models.length, i = 0; i < len; i++) {
			graph[models[i]] = {
				// http://jsperf.com/1-vs-infinity
				// micro-opt, but this is simple.
				distance: -1,
				parent: null
			};
		}

		return graph;
	}

	// https://en.wikipedia.org/wiki/Breadth-first_search
	function deriveBFS(fromModel) {
		const graph = buildGraph();
		const queue = [fromModel]; // Unshift -> queue -> pop

		graph[fromModel].distance = 0;

		while (queue.length) {
			const current = queue.pop();
			const adjacents = Object.keys(conversions[current]);

			for (let len = adjacents.length, i = 0; i < len; i++) {
				const adjacent = adjacents[i];
				const node = graph[adjacent];

				if (node.distance === -1) {
					node.distance = graph[current].distance + 1;
					node.parent = current;
					queue.unshift(adjacent);
				}
			}
		}

		return graph;
	}

	function link(from, to) {
		return function (args) {
			return to(from(args));
		};
	}

	function wrapConversion(toModel, graph) {
		const path = [graph[toModel].parent, toModel];
		let fn = conversions[graph[toModel].parent][toModel];

		let cur = graph[toModel].parent;
		while (graph[cur].parent) {
			path.unshift(graph[cur].parent);
			fn = link(conversions[graph[cur].parent][cur], fn);
			cur = graph[cur].parent;
		}

		fn.conversion = path;
		return fn;
	}

	route = function (fromModel) {
		const graph = deriveBFS(fromModel);
		const conversion = {};

		const models = Object.keys(graph);
		for (let len = models.length, i = 0; i < len; i++) {
			const toModel = models[i];
			const node = graph[toModel];

			if (node.parent === null) {
				// No possible conversion, or this node is the source model.
				continue;
			}

			conversion[toModel] = wrapConversion(toModel, graph);
		}

		return conversion;
	};
	return route;
}

var colorConvert;
var hasRequiredColorConvert;

function requireColorConvert () {
	if (hasRequiredColorConvert) return colorConvert;
	hasRequiredColorConvert = 1;
	const conversions = requireConversions();
	const route = requireRoute();

	const convert = {};

	const models = Object.keys(conversions);

	function wrapRaw(fn) {
		const wrappedFn = function (...args) {
			const arg0 = args[0];
			if (arg0 === undefined || arg0 === null) {
				return arg0;
			}

			if (arg0.length > 1) {
				args = arg0;
			}

			return fn(args);
		};

		// Preserve .conversion property if there is one
		if ('conversion' in fn) {
			wrappedFn.conversion = fn.conversion;
		}

		return wrappedFn;
	}

	function wrapRounded(fn) {
		const wrappedFn = function (...args) {
			const arg0 = args[0];

			if (arg0 === undefined || arg0 === null) {
				return arg0;
			}

			if (arg0.length > 1) {
				args = arg0;
			}

			const result = fn(args);

			// We're assuming the result is an array here.
			// see notice in conversions.js; don't use box types
			// in conversion functions.
			if (typeof result === 'object') {
				for (let len = result.length, i = 0; i < len; i++) {
					result[i] = Math.round(result[i]);
				}
			}

			return result;
		};

		// Preserve .conversion property if there is one
		if ('conversion' in fn) {
			wrappedFn.conversion = fn.conversion;
		}

		return wrappedFn;
	}

	models.forEach(fromModel => {
		convert[fromModel] = {};

		Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
		Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

		const routes = route(fromModel);
		const routeModels = Object.keys(routes);

		routeModels.forEach(toModel => {
			const fn = routes[toModel];

			convert[fromModel][toModel] = wrapRounded(fn);
			convert[fromModel][toModel].raw = wrapRaw(fn);
		});
	});

	colorConvert = convert;
	return colorConvert;
}

ansiStyles.exports;

var hasRequiredAnsiStyles;

function requireAnsiStyles () {
	if (hasRequiredAnsiStyles) return ansiStyles.exports;
	hasRequiredAnsiStyles = 1;
	(function (module) {

		const wrapAnsi16 = (fn, offset) => (...args) => {
			const code = fn(...args);
			return `\u001B[${code + offset}m`;
		};

		const wrapAnsi256 = (fn, offset) => (...args) => {
			const code = fn(...args);
			return `\u001B[${38 + offset};5;${code}m`;
		};

		const wrapAnsi16m = (fn, offset) => (...args) => {
			const rgb = fn(...args);
			return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
		};

		const ansi2ansi = n => n;
		const rgb2rgb = (r, g, b) => [r, g, b];

		const setLazyProperty = (object, property, get) => {
			Object.defineProperty(object, property, {
				get: () => {
					const value = get();

					Object.defineProperty(object, property, {
						value,
						enumerable: true,
						configurable: true
					});

					return value;
				},
				enumerable: true,
				configurable: true
			});
		};

		/** @type {typeof import('color-convert')} */
		let colorConvert;
		const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
			if (colorConvert === undefined) {
				colorConvert = requireColorConvert();
			}

			const offset = isBackground ? 10 : 0;
			const styles = {};

			for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
				const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
				if (sourceSpace === targetSpace) {
					styles[name] = wrap(identity, offset);
				} else if (typeof suite === 'object') {
					styles[name] = wrap(suite[targetSpace], offset);
				}
			}

			return styles;
		};

		function assembleStyles() {
			const codes = new Map();
			const styles = {
				modifier: {
					reset: [0, 0],
					// 21 isn't widely supported and 22 does the same thing
					bold: [1, 22],
					dim: [2, 22],
					italic: [3, 23],
					underline: [4, 24],
					inverse: [7, 27],
					hidden: [8, 28],
					strikethrough: [9, 29]
				},
				color: {
					black: [30, 39],
					red: [31, 39],
					green: [32, 39],
					yellow: [33, 39],
					blue: [34, 39],
					magenta: [35, 39],
					cyan: [36, 39],
					white: [37, 39],

					// Bright color
					blackBright: [90, 39],
					redBright: [91, 39],
					greenBright: [92, 39],
					yellowBright: [93, 39],
					blueBright: [94, 39],
					magentaBright: [95, 39],
					cyanBright: [96, 39],
					whiteBright: [97, 39]
				},
				bgColor: {
					bgBlack: [40, 49],
					bgRed: [41, 49],
					bgGreen: [42, 49],
					bgYellow: [43, 49],
					bgBlue: [44, 49],
					bgMagenta: [45, 49],
					bgCyan: [46, 49],
					bgWhite: [47, 49],

					// Bright color
					bgBlackBright: [100, 49],
					bgRedBright: [101, 49],
					bgGreenBright: [102, 49],
					bgYellowBright: [103, 49],
					bgBlueBright: [104, 49],
					bgMagentaBright: [105, 49],
					bgCyanBright: [106, 49],
					bgWhiteBright: [107, 49]
				}
			};

			// Alias bright black as gray (and grey)
			styles.color.gray = styles.color.blackBright;
			styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
			styles.color.grey = styles.color.blackBright;
			styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

			for (const [groupName, group] of Object.entries(styles)) {
				for (const [styleName, style] of Object.entries(group)) {
					styles[styleName] = {
						open: `\u001B[${style[0]}m`,
						close: `\u001B[${style[1]}m`
					};

					group[styleName] = styles[styleName];

					codes.set(style[0], style[1]);
				}

				Object.defineProperty(styles, groupName, {
					value: group,
					enumerable: false
				});
			}

			Object.defineProperty(styles, 'codes', {
				value: codes,
				enumerable: false
			});

			styles.color.close = '\u001B[39m';
			styles.bgColor.close = '\u001B[49m';

			setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
			setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
			setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
			setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
			setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
			setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

			return styles;
		}

		// Make the export immutable
		Object.defineProperty(module, 'exports', {
			enumerable: true,
			get: assembleStyles
		}); 
	} (ansiStyles));
	return ansiStyles.exports;
}

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag () {
	if (hasRequiredHasFlag) return hasFlag;
	hasRequiredHasFlag = 1;

	hasFlag = (flag, argv = process.argv) => {
		const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf('--');
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
	return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;

function requireSupportsColor () {
	if (hasRequiredSupportsColor) return supportsColor_1;
	hasRequiredSupportsColor = 1;
	const os = require$$2$1;
	const tty = require$$3$1;
	const hasFlag = requireHasFlag();

	const {env} = process;

	let forceColor;
	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false') ||
		hasFlag('color=never')) {
		forceColor = 0;
	} else if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		forceColor = 1;
	}

	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			forceColor = 1;
		} else if (env.FORCE_COLOR === 'false') {
			forceColor = 0;
		} else {
			forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
		}
	}

	function translateLevel(level) {
		if (level === 0) {
			return false;
		}

		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}

	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) {
			return 0;
		}

		if (hasFlag('color=16m') ||
			hasFlag('color=full') ||
			hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}

		if (haveStream && !streamIsTTY && forceColor === undefined) {
			return 0;
		}

		const min = forceColor || 0;

		if (env.TERM === 'dumb') {
			return min;
		}

		if (process.platform === 'win32') {
			// Windows 10 build 10586 is the first Windows release that supports 256 colors.
			// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
			const osRelease = os.release().split('.');
			if (
				Number(osRelease[0]) >= 10 &&
				Number(osRelease[2]) >= 10586
			) {
				return Number(osRelease[2]) >= 14931 ? 3 : 2;
			}

			return 1;
		}

		if ('CI' in env) {
			if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
				return 1;
			}

			return min;
		}

		if ('TEAMCITY_VERSION' in env) {
			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		}

		if (env.COLORTERM === 'truecolor') {
			return 3;
		}

		if ('TERM_PROGRAM' in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

			switch (env.TERM_PROGRAM) {
				case 'iTerm.app':
					return version >= 3 ? 3 : 2;
				case 'Apple_Terminal':
					return 2;
				// No default
			}
		}

		if (/-256(color)?$/i.test(env.TERM)) {
			return 2;
		}

		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
			return 1;
		}

		if ('COLORTERM' in env) {
			return 1;
		}

		return min;
	}

	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}

	supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty.isatty(2)))
	};
	return supportsColor_1;
}

var util$1;
var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;

	const stringReplaceAll = (string, substring, replacer) => {
		let index = string.indexOf(substring);
		if (index === -1) {
			return string;
		}

		const substringLength = substring.length;
		let endIndex = 0;
		let returnValue = '';
		do {
			returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
			endIndex = index + substringLength;
			index = string.indexOf(substring, endIndex);
		} while (index !== -1);

		returnValue += string.substr(endIndex);
		return returnValue;
	};

	const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
		let endIndex = 0;
		let returnValue = '';
		do {
			const gotCR = string[index - 1] === '\r';
			returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
			endIndex = index + 1;
			index = string.indexOf('\n', endIndex);
		} while (index !== -1);

		returnValue += string.substr(endIndex);
		return returnValue;
	};

	util$1 = {
		stringReplaceAll,
		stringEncaseCRLFWithFirstIndex
	};
	return util$1;
}

var templates;
var hasRequiredTemplates;

function requireTemplates () {
	if (hasRequiredTemplates) return templates;
	hasRequiredTemplates = 1;
	const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
	const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
	const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
	const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;

	const ESCAPES = new Map([
		['n', '\n'],
		['r', '\r'],
		['t', '\t'],
		['b', '\b'],
		['f', '\f'],
		['v', '\v'],
		['0', '\0'],
		['\\', '\\'],
		['e', '\u001B'],
		['a', '\u0007']
	]);

	function unescape(c) {
		const u = c[0] === 'u';
		const bracket = c[1] === '{';

		if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
			return String.fromCharCode(parseInt(c.slice(1), 16));
		}

		if (u && bracket) {
			return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
		}

		return ESCAPES.get(c) || c;
	}

	function parseArguments(name, arguments_) {
		const results = [];
		const chunks = arguments_.trim().split(/\s*,\s*/g);
		let matches;

		for (const chunk of chunks) {
			const number = Number(chunk);
			if (!Number.isNaN(number)) {
				results.push(number);
			} else if ((matches = chunk.match(STRING_REGEX))) {
				results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
			} else {
				throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
			}
		}

		return results;
	}

	function parseStyle(style) {
		STYLE_REGEX.lastIndex = 0;

		const results = [];
		let matches;

		while ((matches = STYLE_REGEX.exec(style)) !== null) {
			const name = matches[1];

			if (matches[2]) {
				const args = parseArguments(name, matches[2]);
				results.push([name].concat(args));
			} else {
				results.push([name]);
			}
		}

		return results;
	}

	function buildStyle(chalk, styles) {
		const enabled = {};

		for (const layer of styles) {
			for (const style of layer.styles) {
				enabled[style[0]] = layer.inverse ? null : style.slice(1);
			}
		}

		let current = chalk;
		for (const [styleName, styles] of Object.entries(enabled)) {
			if (!Array.isArray(styles)) {
				continue;
			}

			if (!(styleName in current)) {
				throw new Error(`Unknown Chalk style: ${styleName}`);
			}

			current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
		}

		return current;
	}

	templates = (chalk, temporary) => {
		const styles = [];
		const chunks = [];
		let chunk = [];

		// eslint-disable-next-line max-params
		temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
			if (escapeCharacter) {
				chunk.push(unescape(escapeCharacter));
			} else if (style) {
				const string = chunk.join('');
				chunk = [];
				chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
				styles.push({inverse, styles: parseStyle(style)});
			} else if (close) {
				if (styles.length === 0) {
					throw new Error('Found extraneous } in Chalk template literal');
				}

				chunks.push(buildStyle(chalk, styles)(chunk.join('')));
				chunk = [];
				styles.pop();
			} else {
				chunk.push(character);
			}
		});

		chunks.push(chunk.join(''));

		if (styles.length > 0) {
			const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
			throw new Error(errMessage);
		}

		return chunks.join('');
	};
	return templates;
}

var source;
var hasRequiredSource;

function requireSource () {
	if (hasRequiredSource) return source;
	hasRequiredSource = 1;
	const ansiStyles = requireAnsiStyles();
	const {stdout: stdoutColor, stderr: stderrColor} = requireSupportsColor();
	const {
		stringReplaceAll,
		stringEncaseCRLFWithFirstIndex
	} = requireUtil$1();

	const {isArray} = Array;

	// `supportsColor.level`  `ansiStyles.color[name]` mapping
	const levelMapping = [
		'ansi',
		'ansi',
		'ansi256',
		'ansi16m'
	];

	const styles = Object.create(null);

	const applyOptions = (object, options = {}) => {
		if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
			throw new Error('The `level` option should be an integer from 0 to 3');
		}

		// Detect level if not set manually
		const colorLevel = stdoutColor ? stdoutColor.level : 0;
		object.level = options.level === undefined ? colorLevel : options.level;
	};

	class ChalkClass {
		constructor(options) {
			// eslint-disable-next-line no-constructor-return
			return chalkFactory(options);
		}
	}

	const chalkFactory = options => {
		const chalk = {};
		applyOptions(chalk, options);

		chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

		Object.setPrototypeOf(chalk, Chalk.prototype);
		Object.setPrototypeOf(chalk.template, chalk);

		chalk.template.constructor = () => {
			throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
		};

		chalk.template.Instance = ChalkClass;

		return chalk.template;
	};

	function Chalk(options) {
		return chalkFactory(options);
	}

	for (const [styleName, style] of Object.entries(ansiStyles)) {
		styles[styleName] = {
			get() {
				const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
				Object.defineProperty(this, styleName, {value: builder});
				return builder;
			}
		};
	}

	styles.visible = {
		get() {
			const builder = createBuilder(this, this._styler, true);
			Object.defineProperty(this, 'visible', {value: builder});
			return builder;
		}
	};

	const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

	for (const model of usedModels) {
		styles[model] = {
			get() {
				const {level} = this;
				return function (...arguments_) {
					const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
					return createBuilder(this, styler, this._isEmpty);
				};
			}
		};
	}

	for (const model of usedModels) {
		const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
		styles[bgModel] = {
			get() {
				const {level} = this;
				return function (...arguments_) {
					const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
					return createBuilder(this, styler, this._isEmpty);
				};
			}
		};
	}

	const proto = Object.defineProperties(() => {}, {
		...styles,
		level: {
			enumerable: true,
			get() {
				return this._generator.level;
			},
			set(level) {
				this._generator.level = level;
			}
		}
	});

	const createStyler = (open, close, parent) => {
		let openAll;
		let closeAll;
		if (parent === undefined) {
			openAll = open;
			closeAll = close;
		} else {
			openAll = parent.openAll + open;
			closeAll = close + parent.closeAll;
		}

		return {
			open,
			close,
			openAll,
			closeAll,
			parent
		};
	};

	const createBuilder = (self, _styler, _isEmpty) => {
		const builder = (...arguments_) => {
			if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
				// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`
				return applyStyle(builder, chalkTag(builder, ...arguments_));
			}

			// Single argument is hot path, implicit coercion is faster than anything
			// eslint-disable-next-line no-implicit-coercion
			return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
		};

		// We alter the prototype because we must return a function, but there is
		// no way to create a function with a different prototype
		Object.setPrototypeOf(builder, proto);

		builder._generator = self;
		builder._styler = _styler;
		builder._isEmpty = _isEmpty;

		return builder;
	};

	const applyStyle = (self, string) => {
		if (self.level <= 0 || !string) {
			return self._isEmpty ? '' : string;
		}

		let styler = self._styler;

		if (styler === undefined) {
			return string;
		}

		const {openAll, closeAll} = styler;
		if (string.indexOf('\u001B') !== -1) {
			while (styler !== undefined) {
				// Replace any instances already present with a re-opening code
				// otherwise only the part of the string until said closing code
				// will be colored, and the rest will simply be 'plain'.
				string = stringReplaceAll(string, styler.close, styler.open);

				styler = styler.parent;
			}
		}

		// We can move both next actions out of loop, because remaining actions in loop won't have
		// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
		// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
		const lfIndex = string.indexOf('\n');
		if (lfIndex !== -1) {
			string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
		}

		return openAll + string + closeAll;
	};

	let template;
	const chalkTag = (chalk, ...strings) => {
		const [firstString] = strings;

		if (!isArray(firstString) || !isArray(firstString.raw)) {
			// If chalk() was called by itself or with a string,
			// return the string itself as a string.
			return strings.join(' ');
		}

		const arguments_ = strings.slice(1);
		const parts = [firstString.raw[0]];

		for (let i = 1; i < firstString.length; i++) {
			parts.push(
				String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
				String(firstString.raw[i])
			);
		}

		if (template === undefined) {
			template = requireTemplates();
		}

		return template(chalk, parts.join(''));
	};

	Object.defineProperties(Chalk.prototype, styles);

	const chalk = Chalk(); // eslint-disable-line new-cap
	chalk.supportsColor = stdoutColor;
	chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
	chalk.stderr.supportsColor = stderrColor;

	source = chalk;
	return source;
}

var widestLine = {exports: {}};

var hasRequiredWidestLine;

function requireWidestLine () {
	if (hasRequiredWidestLine) return widestLine.exports;
	hasRequiredWidestLine = 1;
	const stringWidth = requireStringWidth();

	const widestLine$1 = input => {
		let max = 0;

		for (const line of input.split('\n')) {
			max = Math.max(max, stringWidth(line));
		}

		return max;
	};

	widestLine.exports = widestLine$1;
	// TODO: remove this in the next major version
	widestLine.exports.default = widestLine$1;
	return widestLine.exports;
}

var cliBoxes = {exports: {}};

var single$1 = {
	topLeft: "",
	topRight: "",
	bottomRight: "",
	bottomLeft: "",
	vertical: "",
	horizontal: ""
};
var double = {
	topLeft: "",
	topRight: "",
	bottomRight: "",
	bottomLeft: "",
	vertical: "",
	horizontal: ""
};
var round = {
	topLeft: "",
	topRight: "",
	bottomRight: "",
	bottomLeft: "",
	vertical: "",
	horizontal: ""
};
var bold = {
	topLeft: "",
	topRight: "",
	bottomRight: "",
	bottomLeft: "",
	vertical: "",
	horizontal: ""
};
var singleDouble = {
	topLeft: "",
	topRight: "",
	bottomRight: "",
	bottomLeft: "",
	vertical: "",
	horizontal: ""
};
var doubleSingle = {
	topLeft: "",
	topRight: "",
	bottomRight: "",
	bottomLeft: "",
	vertical: "",
	horizontal: ""
};
var classic = {
	topLeft: "+",
	topRight: "+",
	bottomRight: "+",
	bottomLeft: "+",
	vertical: "|",
	horizontal: "-"
};
var require$$0$2 = {
	single: single$1,
	double: double,
	round: round,
	bold: bold,
	singleDouble: singleDouble,
	doubleSingle: doubleSingle,
	classic: classic
};

var hasRequiredCliBoxes;

function requireCliBoxes () {
	if (hasRequiredCliBoxes) return cliBoxes.exports;
	hasRequiredCliBoxes = 1;
	const cliBoxes$1 = require$$0$2;

	cliBoxes.exports = cliBoxes$1;
	// TODO: Remove this for the next major release
	cliBoxes.exports.default = cliBoxes$1;
	return cliBoxes.exports;
}

var camelcase = {exports: {}};

var hasRequiredCamelcase;

function requireCamelcase () {
	if (hasRequiredCamelcase) return camelcase.exports;
	hasRequiredCamelcase = 1;

	const UPPERCASE = /[\p{Lu}]/u;
	const LOWERCASE = /[\p{Ll}]/u;
	const LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
	const IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
	const SEPARATORS = /[_.\- ]+/;

	const LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);
	const SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');
	const NUMBERS_AND_IDENTIFIER = new RegExp('\\d+' + IDENTIFIER.source, 'gu');

	const preserveCamelCase = (string, toLowerCase, toUpperCase) => {
		let isLastCharLower = false;
		let isLastCharUpper = false;
		let isLastLastCharUpper = false;

		for (let i = 0; i < string.length; i++) {
			const character = string[i];

			if (isLastCharLower && UPPERCASE.test(character)) {
				string = string.slice(0, i) + '-' + string.slice(i);
				isLastCharLower = false;
				isLastLastCharUpper = isLastCharUpper;
				isLastCharUpper = true;
				i++;
			} else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
				string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
				isLastLastCharUpper = isLastCharUpper;
				isLastCharUpper = false;
				isLastCharLower = true;
			} else {
				isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
				isLastLastCharUpper = isLastCharUpper;
				isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
			}
		}

		return string;
	};

	const preserveConsecutiveUppercase = (input, toLowerCase) => {
		LEADING_CAPITAL.lastIndex = 0;

		return input.replace(LEADING_CAPITAL, m1 => toLowerCase(m1));
	};

	const postProcess = (input, toUpperCase) => {
		SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
		NUMBERS_AND_IDENTIFIER.lastIndex = 0;

		return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier))
			.replace(NUMBERS_AND_IDENTIFIER, m => toUpperCase(m));
	};

	const camelCase = (input, options) => {
		if (!(typeof input === 'string' || Array.isArray(input))) {
			throw new TypeError('Expected the input to be `string | string[]`');
		}

		options = {
			pascalCase: false,
			preserveConsecutiveUppercase: false,
			...options
		};

		if (Array.isArray(input)) {
			input = input.map(x => x.trim())
				.filter(x => x.length)
				.join('-');
		} else {
			input = input.trim();
		}

		if (input.length === 0) {
			return '';
		}

		const toLowerCase = options.locale === false ?
			string => string.toLowerCase() :
			string => string.toLocaleLowerCase(options.locale);
		const toUpperCase = options.locale === false ?
			string => string.toUpperCase() :
			string => string.toLocaleUpperCase(options.locale);

		if (input.length === 1) {
			return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
		}

		const hasUpperCase = input !== toLowerCase(input);

		if (hasUpperCase) {
			input = preserveCamelCase(input, toLowerCase, toUpperCase);
		}

		input = input.replace(LEADING_SEPARATORS, '');

		if (options.preserveConsecutiveUppercase) {
			input = preserveConsecutiveUppercase(input, toLowerCase);
		} else {
			input = toLowerCase(input);
		}

		if (options.pascalCase) {
			input = toUpperCase(input.charAt(0)) + input.slice(1);
		}

		return postProcess(input, toUpperCase);
	};

	camelcase.exports = camelCase;
	// TODO: Remove this for the next major release
	camelcase.exports.default = camelCase;
	return camelcase.exports;
}

var ansiAlign_1;
var hasRequiredAnsiAlign;

function requireAnsiAlign () {
	if (hasRequiredAnsiAlign) return ansiAlign_1;
	hasRequiredAnsiAlign = 1;

	const stringWidth = requireStringWidth();

	function ansiAlign (text, opts) {
	  if (!text) return text

	  opts = opts || {};
	  const align = opts.align || 'center';

	  // short-circuit `align: 'left'` as no-op
	  if (align === 'left') return text

	  const split = opts.split || '\n';
	  const pad = opts.pad || ' ';
	  const widthDiffFn = align !== 'right' ? halfDiff : fullDiff;

	  let returnString = false;
	  if (!Array.isArray(text)) {
	    returnString = true;
	    text = String(text).split(split);
	  }

	  let width;
	  let maxWidth = 0;
	  text = text.map(function (str) {
	    str = String(str);
	    width = stringWidth(str);
	    maxWidth = Math.max(width, maxWidth);
	    return {
	      str,
	      width
	    }
	  }).map(function (obj) {
	    return new Array(widthDiffFn(maxWidth, obj.width) + 1).join(pad) + obj.str
	  });

	  return returnString ? text.join(split) : text
	}

	ansiAlign.left = function left (text) {
	  return ansiAlign(text, { align: 'left' })
	};

	ansiAlign.center = function center (text) {
	  return ansiAlign(text, { align: 'center' })
	};

	ansiAlign.right = function right (text) {
	  return ansiAlign(text, { align: 'right' })
	};

	ansiAlign_1 = ansiAlign;

	function halfDiff (maxWidth, curWidth) {
	  return Math.floor((maxWidth - curWidth) / 2)
	}

	function fullDiff (maxWidth, curWidth) {
	  return maxWidth - curWidth
	}
	return ansiAlign_1;
}

var wrapAnsi_1$1;
var hasRequiredWrapAnsi$1;

function requireWrapAnsi$1 () {
	if (hasRequiredWrapAnsi$1) return wrapAnsi_1$1;
	hasRequiredWrapAnsi$1 = 1;
	const stringWidth = requireStringWidth();
	const stripAnsi = requireStripAnsi();
	const ansiStyles = requireAnsiStyles();

	const ESCAPES = new Set([
		'\u001B',
		'\u009B'
	]);

	const END_CODE = 39;

	const ANSI_ESCAPE_BELL = '\u0007';
	const ANSI_CSI = '[';
	const ANSI_OSC = ']';
	const ANSI_SGR_TERMINATOR = 'm';
	const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;

	const wrapAnsi = code => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
	const wrapAnsiHyperlink = uri => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;

	// Calculate the length of words split on ' ', ignoring
	// the extra characters added by ansi escape codes
	const wordLengths = string => string.split(' ').map(character => stringWidth(character));

	// Wrap a long word across multiple rows
	// Ansi escape codes do not count towards length
	const wrapWord = (rows, word, columns) => {
		const characters = [...word];

		let isInsideEscape = false;
		let isInsideLinkEscape = false;
		let visible = stringWidth(stripAnsi(rows[rows.length - 1]));

		for (const [index, character] of characters.entries()) {
			const characterLength = stringWidth(character);

			if (visible + characterLength <= columns) {
				rows[rows.length - 1] += character;
			} else {
				rows.push(character);
				visible = 0;
			}

			if (ESCAPES.has(character)) {
				isInsideEscape = true;
				isInsideLinkEscape = characters.slice(index + 1).join('').startsWith(ANSI_ESCAPE_LINK);
			}

			if (isInsideEscape) {
				if (isInsideLinkEscape) {
					if (character === ANSI_ESCAPE_BELL) {
						isInsideEscape = false;
						isInsideLinkEscape = false;
					}
				} else if (character === ANSI_SGR_TERMINATOR) {
					isInsideEscape = false;
				}

				continue;
			}

			visible += characterLength;

			if (visible === columns && index < characters.length - 1) {
				rows.push('');
				visible = 0;
			}
		}

		// It's possible that the last row we copy over is only
		// ansi escape characters, handle this edge-case
		if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
			rows[rows.length - 2] += rows.pop();
		}
	};

	// Trims spaces from a string ignoring invisible sequences
	const stringVisibleTrimSpacesRight = string => {
		const words = string.split(' ');
		let last = words.length;

		while (last > 0) {
			if (stringWidth(words[last - 1]) > 0) {
				break;
			}

			last--;
		}

		if (last === words.length) {
			return string;
		}

		return words.slice(0, last).join(' ') + words.slice(last).join('');
	};

	// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
	//
	// 'hard' will never allow a string to take up more than columns characters
	//
	// 'soft' allows long words to expand past the column length
	const exec = (string, columns, options = {}) => {
		if (options.trim !== false && string.trim() === '') {
			return '';
		}

		let returnValue = '';
		let escapeCode;
		let escapeUrl;

		const lengths = wordLengths(string);
		let rows = [''];

		for (const [index, word] of string.split(' ').entries()) {
			if (options.trim !== false) {
				rows[rows.length - 1] = rows[rows.length - 1].trimStart();
			}

			let rowLength = stringWidth(rows[rows.length - 1]);

			if (index !== 0) {
				if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
					// If we start with a new word but the current row length equals the length of the columns, add a new row
					rows.push('');
					rowLength = 0;
				}

				if (rowLength > 0 || options.trim === false) {
					rows[rows.length - 1] += ' ';
					rowLength++;
				}
			}

			// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
			if (options.hard && lengths[index] > columns) {
				const remainingColumns = (columns - rowLength);
				const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
				const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
				if (breaksStartingNextLine < breaksStartingThisLine) {
					rows.push('');
				}

				wrapWord(rows, word, columns);
				continue;
			}

			if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
				if (options.wordWrap === false && rowLength < columns) {
					wrapWord(rows, word, columns);
					continue;
				}

				rows.push('');
			}

			if (rowLength + lengths[index] > columns && options.wordWrap === false) {
				wrapWord(rows, word, columns);
				continue;
			}

			rows[rows.length - 1] += word;
		}

		if (options.trim !== false) {
			rows = rows.map(stringVisibleTrimSpacesRight);
		}

		const pre = [...rows.join('\n')];

		for (const [index, character] of pre.entries()) {
			returnValue += character;

			if (ESCAPES.has(character)) {
				const {groups} = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join('')) || {groups: {}};
				if (groups.code !== undefined) {
					const code = Number.parseFloat(groups.code);
					escapeCode = code === END_CODE ? undefined : code;
				} else if (groups.uri !== undefined) {
					escapeUrl = groups.uri.length === 0 ? undefined : groups.uri;
				}
			}

			const code = ansiStyles.codes.get(Number(escapeCode));

			if (pre[index + 1] === '\n') {
				if (escapeUrl) {
					returnValue += wrapAnsiHyperlink('');
				}

				if (escapeCode && code) {
					returnValue += wrapAnsi(code);
				}
			} else if (character === '\n') {
				if (escapeCode && code) {
					returnValue += wrapAnsi(escapeCode);
				}

				if (escapeUrl) {
					returnValue += wrapAnsiHyperlink(escapeUrl);
				}
			}
		}

		return returnValue;
	};

	// For each newline, invoke the method separately
	wrapAnsi_1$1 = (string, columns, options) => {
		return String(string)
			.normalize()
			.replace(/\r\n/g, '\n')
			.split('\n')
			.map(line => exec(line, columns, options))
			.join('\n');
	};
	return wrapAnsi_1$1;
}

var hasRequiredBoxen;

function requireBoxen () {
	if (hasRequiredBoxen) return boxen.exports;
	hasRequiredBoxen = 1;
	const stringWidth = requireStringWidth();
	const chalk = requireSource();
	const widestLine = requireWidestLine();
	const cliBoxes = requireCliBoxes();
	const camelCase = requireCamelcase();
	const ansiAlign = requireAnsiAlign();
	const wrapAnsi = requireWrapAnsi$1();

	const NL = '\n';
	const PAD = ' ';

	const terminalColumns = () => {
		const {env, stdout, stderr} = process;

		if (stdout && stdout.columns) {
			return stdout.columns;
		}

		if (stderr && stderr.columns) {
			return stderr.columns;
		}

		if (env.COLUMNS) {
			return Number.parseInt(env.COLUMNS, 10);
		}

		return 80;
	};

	const getObject = detail => {
		return typeof detail === 'number' ? {
			top: detail,
			right: detail * 3,
			bottom: detail,
			left: detail * 3
		} : {
			top: 0,
			right: 0,
			bottom: 0,
			left: 0,
			...detail
		};
	};

	const getBorderChars = borderStyle => {
		const sides = [
			'topLeft',
			'topRight',
			'bottomRight',
			'bottomLeft',
			'vertical',
			'horizontal'
		];

		let chararacters;

		if (typeof borderStyle === 'string') {
			chararacters = cliBoxes[borderStyle];

			if (!chararacters) {
				throw new TypeError(`Invalid border style: ${borderStyle}`);
			}
		} else {
			for (const side of sides) {
				if (!borderStyle[side] || typeof borderStyle[side] !== 'string') {
					throw new TypeError(`Invalid border style: ${side}`);
				}
			}

			chararacters = borderStyle;
		}

		return chararacters;
	};

	const makeTitle = (text, horizontal, alignement) => {
		let title = '';

		const textWidth = stringWidth(text);

		switch (alignement) {
			case 'left':
				title = text + horizontal.slice(textWidth);
				break;
			case 'right':
				title = horizontal.slice(textWidth) + text;
				break;
			default:
				horizontal = horizontal.slice(textWidth);

				if (horizontal.length % 2 === 1) { // This is needed in case the length is odd
					horizontal = horizontal.slice(Math.floor(horizontal.length / 2));
					title = horizontal.slice(1) + text + horizontal; // We reduce the left part of one character to avoid the bar to go beyond its limit
				} else {
					horizontal = horizontal.slice(horizontal.length / 2);
					title = horizontal + text + horizontal;
				}

				break;
		}

		return title;
	};

	const makeContentText = (text, padding, columns, align) => {
		text = ansiAlign(text, {align});
		let lines = text.split(NL);
		const textWidth = widestLine(text);

		const max = columns - padding.left - padding.right;

		if (textWidth > max) {
			const newLines = [];
			for (const line of lines) {
				const createdLines = wrapAnsi(line, max, {hard: true});
				const alignedLines = ansiAlign(createdLines, {align});
				const alignedLinesArray = alignedLines.split('\n');
				const longestLength = Math.max(...alignedLinesArray.map(s => stringWidth(s)));

				for (const alignedLine of alignedLinesArray) {
					let paddedLine;
					switch (align) {
						case 'center':
							paddedLine = PAD.repeat((max - longestLength) / 2) + alignedLine;
							break;
						case 'right':
							paddedLine = PAD.repeat(max - longestLength) + alignedLine;
							break;
						default:
							paddedLine = alignedLine;
							break;
					}

					newLines.push(paddedLine);
				}
			}

			lines = newLines;
		}

		if (align === 'center' && textWidth < max) {
			lines = lines.map(line => PAD.repeat((max - textWidth) / 2) + line);
		} else if (align === 'right' && textWidth < max) {
			lines = lines.map(line => PAD.repeat(max - textWidth) + line);
		}

		const paddingLeft = PAD.repeat(padding.left);
		const paddingRight = PAD.repeat(padding.right);

		lines = lines.map(line => paddingLeft + line + paddingRight);

		lines = lines.map(line => {
			if (columns - stringWidth(line) > 0) {
				switch (align) {
					case 'center':
						return line + PAD.repeat(columns - stringWidth(line));
					case 'right':
						return line + PAD.repeat(columns - stringWidth(line));
					default:
						return line + PAD.repeat(columns - stringWidth(line));
				}
			}

			return line;
		});

		if (padding.top > 0) {
			lines = new Array(padding.top).fill(PAD.repeat(columns)).concat(lines);
		}

		if (padding.bottom > 0) {
			lines = lines.concat(new Array(padding.bottom).fill(PAD.repeat(columns)));
		}

		return lines.join(NL);
	};

	const isHex = color => color.match(/^#(?:[0-f]{3}){1,2}$/i);
	const isColorValid = color => typeof color === 'string' && ((chalk[color]) || isHex(color));
	const getColorFn = color => isHex(color) ? chalk.hex(color) : chalk[color];
	const getBGColorFn = color => isHex(color) ? chalk.bgHex(color) : chalk[camelCase(['bg', color])];

	boxen.exports = (text, options) => {
		options = {
			padding: 0,
			borderStyle: 'single',
			dimBorder: false,
			textAlignment: 'left',
			float: 'left',
			titleAlignment: 'left',
			...options
		};

		// This option is deprecated
		if (options.align) {
			options.textAlignment = options.align;
		}

		const BORDERS_WIDTH = 2;

		if (options.borderColor && !isColorValid(options.borderColor)) {
			throw new Error(`${options.borderColor} is not a valid borderColor`);
		}

		if (options.backgroundColor && !isColorValid(options.backgroundColor)) {
			throw new Error(`${options.backgroundColor} is not a valid backgroundColor`);
		}

		const chars = getBorderChars(options.borderStyle);
		const padding = getObject(options.padding);
		const margin = getObject(options.margin);

		const colorizeBorder = border => {
			const newBorder = options.borderColor ? getColorFn(options.borderColor)(border) : border;
			return options.dimBorder ? chalk.dim(newBorder) : newBorder;
		};

		const colorizeContent = content => options.backgroundColor ? getBGColorFn(options.backgroundColor)(content) : content;

		const columns = terminalColumns() - 1;

		let contentWidth = widestLine(wrapAnsi(text, columns - BORDERS_WIDTH, {hard: true, trim: false})) + padding.left + padding.right;

		// This prevents the title bar to exceed the console's width
		let title = options.title && options.title.slice(0, columns - 4 - margin.left - margin.right);

		if (title) {
			title = ` ${title} `;
			// Make the box larger to fit a larger title
			if (stringWidth(title) > contentWidth) {
				contentWidth = stringWidth(title);
			}
		}

		if ((margin.left && margin.right) && contentWidth + BORDERS_WIDTH + margin.left + margin.right > columns) {
			// Let's assume we have margins: left = 3, right = 5, in total = 8
			const spaceForMargins = columns - contentWidth - BORDERS_WIDTH;
			// Let's assume we have space = 4
			const multiplier = spaceForMargins / (margin.left + margin.right);
			// Here: multiplier = 4/8 = 0.5
			margin.left = Math.max(0, Math.floor(margin.left * multiplier));
			margin.right = Math.max(0, Math.floor(margin.right * multiplier));
			// Left: 3 * 0.5 = 1.5 -> 1
			// Right: 6 * 0.5 = 3
		}

		// Prevent content from exceeding the console's width
		contentWidth = Math.min(contentWidth, columns - BORDERS_WIDTH - margin.left - margin.right);

		text = makeContentText(text, padding, contentWidth, options.textAlignment);

		let marginLeft = PAD.repeat(margin.left);

		if (options.float === 'center') {
			const marginWidth = Math.max((columns - contentWidth - BORDERS_WIDTH) / 2, 0);
			marginLeft = PAD.repeat(marginWidth);
		} else if (options.float === 'right') {
			const marginWidth = Math.max(columns - contentWidth - margin.right - BORDERS_WIDTH, 0);
			marginLeft = PAD.repeat(marginWidth);
		}

		const horizontal = chars.horizontal.repeat(contentWidth);
		const top = colorizeBorder(NL.repeat(margin.top) + marginLeft + chars.topLeft + (title ? makeTitle(title, horizontal, options.titleAlignment) : horizontal) + chars.topRight);
		const bottom = colorizeBorder(marginLeft + chars.bottomLeft + horizontal + chars.bottomRight + NL.repeat(margin.bottom));
		const side = colorizeBorder(chars.vertical);

		const LINE_SEPARATOR = NL;

		const lines = text.split(NL);

		const middle = lines.map(line => {
			return marginLeft + side + colorizeContent(line) + side;
		}).join(LINE_SEPARATOR);

		return top + LINE_SEPARATOR + middle + LINE_SEPARATOR + bottom;
	};

	boxen.exports._borderStyles = cliBoxes;
	return boxen.exports;
}

var hasRequiredMakePrettyError;

function requireMakePrettyError () {
	if (hasRequiredMakePrettyError) return makePrettyError;
	hasRequiredMakePrettyError = 1;
	var __importDefault = (makePrettyError && makePrettyError.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(makePrettyError, "__esModule", { value: true });
	makePrettyError.makeTitledPrettyError = makeTitledPrettyError;
	makePrettyError.makePrettyError = makePrettyError$1;
	const lms_isomorphic_1 = /*@__PURE__*/ requireCjs$5();
	const boxen_1 = __importDefault(requireBoxen());
	const chalk_1 = __importDefault(requireSource());
	const process_1 = __importDefault(require$$0$3);
	const errorStack_js_1 = /*@__PURE__*/ requireErrorStack();
	function makeTitledPrettyError(title, content, stack) {
	    return makePrettyError$1(chalk_1.default.redBright(title) + "\n\n" + content, stack);
	}
	function makePrettyError$1(content, stack) {
	    if (process_1.default.browser || process_1.default.env.LMS_NO_FANCY_ERRORS || (0, lms_isomorphic_1.terminalSize)().columns < 80) {
	        const error = new Error(content);
	        if (stack === undefined) {
	            (0, errorStack_js_1.changeErrorStackInPlace)(error, "");
	        }
	        else {
	            (0, errorStack_js_1.changeErrorStackInPlace)(error, stack);
	        }
	        return error;
	    }
	    else {
	        if (stack !== undefined) {
	            content +=
	                "\n\n\n " + chalk_1.default.bgWhite.black("  </> STACK TRACE  ") + "\n\n" + chalk_1.default.gray(stack);
	        }
	        const error = new Error("\n" + (0, boxen_1.default)(content, { padding: 1, margin: 1, borderColor: "redBright", title: "Error" }));
	        Object.defineProperty(error, "lmstudioRawError", { value: content, enumerable: false });
	        (0, errorStack_js_1.changeErrorStackInPlace)(error, "");
	        return error;
	    }
	}
	
	return makePrettyError;
}

var MaybeMutable = {};

var text = {};

var hasRequiredText;

function requireText () {
	if (hasRequiredText) return text;
	hasRequiredText = 1;
	Object.defineProperty(text, "__esModule", { value: true });
	text.text = text$1;
	/**
	 * A cache for avoiding recompiling the same template strings.
	 *
	 * The cached value is a string with 2N + 1 elements, where N is the number of variables in the
	 * template.
	 */
	const compiledTemplatesCache = new WeakMap();
	/**
	 * A string literal tag function that does the following:
	 *
	 * - Removes leading new lines
	 * - Removes trailing new lines and whitespace
	 * - Removes common indentation from the start of each line (Empty lines are ignored)
	 * - Single newlines are replaced with a space + extra whitespace is removed
	 *
	 * Note: Only spaces are considered.
	 */
	function text$1(strings, ...values) {
	    if (values.length + 1 !== strings.length) {
	        throw new Error("text called with the wrong number of arguments.");
	    }
	    let compiled = compiledTemplatesCache.get(strings);
	    if (compiled === undefined) {
	        compiled = compile(strings);
	        compiledTemplatesCache.set(strings, compiled);
	    }
	    // We can modify the array in place because JavaScript is single-threaded and the array is not
	    // being accessed by any other code.
	    for (let i = 0; i < values.length; i++) {
	        if (typeof values[i] === "object") {
	            if (typeof values[i].stack === "string") {
	                compiled[i * 2 + 1] = values[i].stack;
	            }
	            else {
	                try {
	                    compiled[i * 2 + 1] = JSON.stringify(values[i]);
	                }
	                catch (error) {
	                    compiled[i * 2 + 1] = "[Object failed to stringify]";
	                }
	            }
	        }
	        else {
	            compiled[i * 2 + 1] = String(values[i]);
	        }
	    }
	    return compiled.join("");
	}
	function removeLeadingNewlines(input) {
	    return input.replace(/^\n+/, "");
	}
	function removeTrailingNewlinesAndWhitespace(input) {
	    return input.replace(/[\n ]+$/, "");
	}
	function removeLeadingWhitespace(input) {
	    return input.replace(/^ +/, "");
	}
	function removeTrailingWhitespace(input) {
	    return input.replace(/ +$/, "");
	}
	function breakIntoLines(strings) {
	    const lines = [];
	    let currentLine = [];
	    for (const string of strings) {
	        let prevNewlineIndex = -1;
	        let nextNewlineIndex;
	        while ((nextNewlineIndex = string.indexOf("\n", prevNewlineIndex + 1)) !== -1) {
	            currentLine.push(string.substring(prevNewlineIndex + 1, nextNewlineIndex));
	            lines.push(currentLine);
	            currentLine = [];
	            prevNewlineIndex = nextNewlineIndex;
	        }
	        currentLine.push(string.substring(prevNewlineIndex + 1));
	    }
	    lines.push(currentLine);
	    return lines;
	}
	/**
	 * Returns the number of spaces at the start of the string. If the string only contains spaces,
	 * returns infinity.
	 */
	function countStringIndentations(string) {
	    let count = 0;
	    for (const char of string) {
	        if (char === " ") {
	            count++;
	        }
	        else {
	            return count;
	        }
	    }
	    return Infinity;
	}
	function countLineIndentations(line) {
	    const firstPart = line[0];
	    const firstPartIndentation = countStringIndentations(firstPart);
	    if (firstPartIndentation === Infinity) {
	        if (line.length === 1) {
	            return Infinity;
	        }
	        else {
	            // If there is a variable after it, the length of indentation is the same as the length of the
	            // first part.
	            return firstPart.length;
	        }
	    }
	    return firstPartIndentation;
	}
	function findMaxCommonIndentation(lines) {
	    let minIndentation = Infinity;
	    for (const line of lines) {
	        minIndentation = Math.min(minIndentation, countLineIndentations(line));
	    }
	    return minIndentation;
	}
	function removeIndentation(line, indentation) {
	    if (line.length < indentation) {
	        return "";
	    }
	    return line.slice(indentation);
	}
	function removeAllIndentation(lines, indentation) {
	    for (const line of lines) {
	        line[0] = removeIndentation(line[0], indentation);
	    }
	}
	function isEmptyLine(line) {
	    if (line.length !== 1) {
	        return false;
	    }
	    for (const char of line[0]) {
	        if (char !== " ") {
	            return false;
	        }
	    }
	    return true;
	}
	function mergeLines(lines) {
	    const linesAreEmpty = lines.map(isEmptyLine);
	    const paragraphs = [];
	    let currentParagraph = [];
	    for (let i = 0; i < lines.length; i++) {
	        if (linesAreEmpty[i]) {
	            if (currentParagraph.length !== 0) {
	                paragraphs.push(currentParagraph);
	                currentParagraph = [];
	            }
	            continue;
	        }
	        if (currentParagraph.length !== 0) {
	            const last = removeTrailingWhitespace(currentParagraph[currentParagraph.length - 1]);
	            const next = removeLeadingWhitespace(lines[i][0]);
	            currentParagraph[currentParagraph.length - 1] = last + " " + next;
	            currentParagraph.push(...lines[i].slice(1));
	        }
	        else {
	            currentParagraph.push(...lines[i]);
	        }
	    }
	    if (currentParagraph.length !== 0) {
	        paragraphs.push(currentParagraph);
	    }
	    return paragraphs;
	}
	function mergeParagraphs(paragraphs) {
	    const result = [];
	    if (paragraphs.length === 0) {
	        return [""];
	    }
	    result.push(...paragraphs[0]);
	    for (let i = 1; i < paragraphs.length; i++) {
	        result[result.length - 1] += "\n\n" + paragraphs[i][0];
	        result.push(...paragraphs[i].slice(1));
	    }
	    return result;
	}
	function addHolesForVariables(strings) {
	    const result = [];
	    for (let i = 0; i < strings.length; i++) {
	        result.push(strings[i]);
	        if (i < strings.length - 1) {
	            result.push("");
	        }
	    }
	    return result;
	}
	function compile(readonlyStrings) {
	    const strings = [...readonlyStrings];
	    strings[0] = removeLeadingNewlines(strings[0]);
	    strings[strings.length - 1] = removeTrailingNewlinesAndWhitespace(strings[strings.length - 1]);
	    const lines = breakIntoLines(strings);
	    const commonIndentation = findMaxCommonIndentation(lines);
	    removeAllIndentation(lines, commonIndentation);
	    const paragraphs = mergeLines(lines);
	    return addHolesForVariables(mergeParagraphs(paragraphs));
	}
	
	return text;
}

var hasRequiredMaybeMutable;

function requireMaybeMutable () {
	if (hasRequiredMaybeMutable) return MaybeMutable;
	hasRequiredMaybeMutable = 1;
	Object.defineProperty(MaybeMutable, "__esModule", { value: true });
	MaybeMutable.MaybeMutable = void 0;
	MaybeMutable.accessMaybeMutableInternals = accessMaybeMutableInternals;
	const text_js_1 = /*@__PURE__*/ requireText();
	/**
	 * Represents some underlying data that may or may not be mutable.
	 *
	 * @public
	 */
	let MaybeMutable$1 = class MaybeMutable {
	    constructor(data, mutable) {
	        this.data = data;
	        this.mutable = mutable;
	    }
	    /**
	     * Gets the underlying data without any access control. Only used internally.
	     *
	     * @internal
	     */
	    _internalGetData() {
	        return this.data;
	    }
	    /**
	     * If this instance is mutable, return as is.
	     *
	     * If this instance is immutable, return a mutable copy.
	     *
	     * Very easy to misuse, thus internal only for now.
	     *
	     * @internal
	     */
	    _internalToMutable() {
	        if (this.mutable) {
	            return this;
	        }
	        return this.asMutableCopy();
	    }
	    asMutableCopy() {
	        return this.create(this.cloneData(this.data), true);
	    }
	    asImmutableCopy() {
	        if (this.mutable) {
	            return this.create(this.cloneData(this.data), false);
	        }
	        return this;
	    }
	    guardMutable() {
	        if (!this.mutable) {
	            throw new Error((0, text_js_1.text) `
        Cannot modify immutable ${this.getClassName()} instance. Use asMutableCopy() to get a
        mutable copy.
      `);
	        }
	    }
	};
	MaybeMutable.MaybeMutable = MaybeMutable$1;
	function accessMaybeMutableInternals(maybeMutable) {
	    return maybeMutable;
	}
	
	return MaybeMutable;
}

var OWLSignal = {};

var hasRequiredOWLSignal;

function requireOWLSignal () {
	if (hasRequiredOWLSignal) return OWLSignal;
	hasRequiredOWLSignal = 1;
	Object.defineProperty(OWLSignal, "__esModule", { value: true });
	OWLSignal.OWLSignal = void 0;
	const Event_js_1 = /*@__PURE__*/ requireEvent();
	const LazySignal_js_1 = /*@__PURE__*/ requireLazySignal();
	const makePromise_js_1 = /*@__PURE__*/ requireMakePromise();
	const makeSetter_js_1 = /*@__PURE__*/ requireMakeSetter();
	const Signal_js_1 = /*@__PURE__*/ requireSignal();
	const Subscribable_js_1 = /*@__PURE__*/ requireSubscribable();
	/**
	 * OWLSignal - Optimistic Writable Lazy Signal
	 *
	 * - Signal: It is a signal, i.e. an observable that remembers its current value
	 * - Lazy: It is lazy, i.e. it does not subscribe to the upstream until a subscriber is attached
	 * - Writable: It is writable, i.e. it has a setter to update its value
	 * - Optimistic: It is optimistic, i.e. it updates its value optimistically and then waits for the
	 *   upstream to confirm the update
	 *   - Once the setter is called, the value is updated optimistically and all subscribers are
	 *     notified synchronously
	 *
	 * Guarantees:
	 *
	 * - The OWLSignal is designed for single-writer multiple-reader scenarios, as the coordination of
	 *   writes are tracked inside the OWLSignal. If there are multiple writers for the same data (i.e.
	 *   multiple OWLSignal backed by the same upstream), there are no strong guarantees. For example,
	 *   two updaters may read the same value, update it, and write it back to the upstream, causing one
	 *   of the updates to be lost. The following guarantees are provided for single-writer scenarios:
	 * - The updates are applied in the order they are received, and each updater is guaranteed to see
	 *   all updates that were applied before it.
	 * - If there are updaters [u_0, u_1, ..., u_n], for any read-only reader, there exists a time t
	 *   where the reader will see the updates [u_0, u_1, ..., u_t] in the order they were applied. This
	 *   also applies to the writer itself.
	 */
	let OWLSignal$1 = class OWLSignal extends Subscribable_js_1.Subscribable {
	    static { this.NOT_AVAILABLE = LazySignal_js_1.LazySignal.NOT_AVAILABLE; }
	    applyOptimisticUpdates(data) {
	        for (const update of this.queuedUpdates) {
	            [data] = update.updater(data);
	        }
	        return data;
	    }
	    updateOptimisticValue(tags) {
	        const innerValue = this.innerSignal.get();
	        if (!(0, LazySignal_js_1.isAvailable)(innerValue)) {
	            return;
	        }
	        this.setOuterSignal(this.applyOptimisticUpdates(innerValue), tags);
	    }
	    constructor(initialValue, subscribeUpstream, writeUpstream, equalsPredicate) {
	        super();
	        this.writeUpstream = writeUpstream;
	        this.isWriteLoopRunning = false;
	        /**
	         * We have a passive subscription to the inner signal to update the optimistic value whenever the
	         * inner signal changes.
	         *
	         * However, if the content changes are caused by a write, we want to update the inner value,
	         * remove the optimistic update, and apply the remaining optimistic updates all at once.
	         *
	         * Therefore, when a write is ongoing, we set this flag to true to prevent the passive
	         * subscription from updating the optimistic value. We will handle the updates within the write
	         * loop.
	         */
	        this.isSubscriptionHandledByWriteLoop = false;
	        /**
	         * A queue of updates to apply optimistically.
	         */
	        this.queuedUpdates = [];
	        this.currentEnsureAvailablePromise = null;
	        [this.writeErrorEvent, this.emitWriteErrorEvent] = Event_js_1.Event.create();
	        [this.outerSignal, this.setOuterSignal] = Signal_js_1.Signal.create(initialValue, equalsPredicate);
	        this.innerSignal = LazySignal_js_1.LazySignal.create(initialValue, subscribeUpstream, equalsPredicate);
	        this.innerSignal.passiveSubscribeFull((_data, _patches, tags) => {
	            if (this.isSubscriptionHandledByWriteLoop) {
	                return;
	            }
	            this.updateOptimisticValue(tags);
	        });
	    }
	    static create(initialValue, subscribeUpstream, 
	    /**
	     * Returns true if the update is sent to the upstream (thus should wait for the upstream to
	     * confirm. Returns false if the update is not sent and the update should be dropped.
	     */
	    writeUpstream, equalsPredicate = (a, b) => a === b) {
	        const signal = new OWLSignal(initialValue, subscribeUpstream, writeUpstream, equalsPredicate);
	        const setSignal = (0, makeSetter_js_1.makeSetterWithPatches)(signal.update.bind(signal));
	        const emitError = (tags, error) => signal.emitWriteErrorEvent({ tags, error });
	        return [signal, setSignal, emitError];
	    }
	    static createWithoutInitialValue(subscribeUpstream, writeUpstream, equalsPredicate = (a, b) => a === b) {
	        const fullEqualsPredicate = (a, b) => {
	            if (a === OWLSignal.NOT_AVAILABLE || b === OWLSignal.NOT_AVAILABLE) {
	                return a === b;
	            }
	            return equalsPredicate(a, b);
	        };
	        return OWLSignal.create(OWLSignal.NOT_AVAILABLE, subscribeUpstream, writeUpstream, fullEqualsPredicate);
	    }
	    async update(updater, tags) {
	        const { promise, reject, resolve } = (0, makePromise_js_1.makePromise)();
	        this.queuedUpdates.push({
	            updater,
	            tags: tags ?? [],
	            resolve,
	            reject,
	        });
	        this.updateOptimisticValue();
	        this.ensureWriteLoop();
	        return promise;
	    }
	    /**
	     * Starts the write loop if it is not already running.
	     */
	    ensureWriteLoop() {
	        if (!this.isWriteLoopRunning) {
	            this.writeLoop(); // This is not expected to error, if it does, just default behavior
	        }
	    }
	    /**
	     * The main write loop, it will keep running until there are no more updates to process.
	     */
	    async writeLoop() {
	        const unsubscribe = this.innerSignal.subscribe(() => { });
	        this.isWriteLoopRunning = true;
	        if (this.isStale()) {
	            await this.innerSignal.pull();
	        }
	        while (this.queuedUpdates.length > 0) {
	            const numQueuedUpdatesToHandle = this.queuedUpdates.length;
	            const updater = (data) => {
	                const patches = [];
	                for (let i = 0; i < numQueuedUpdatesToHandle; i++) {
	                    const [newData, newPatches] = this.queuedUpdates[i].updater(data);
	                    data = newData;
	                    patches.push(...newPatches);
	                }
	                return [data, patches];
	            };
	            const resolve = () => {
	                for (let i = 0; i < numQueuedUpdatesToHandle; i++) {
	                    this.queuedUpdates[i].resolve();
	                }
	            };
	            const reject = (error) => {
	                for (let i = 0; i < numQueuedUpdatesToHandle; i++) {
	                    this.queuedUpdates[i].reject(error);
	                }
	            };
	            const queuedUpdateTags = this.queuedUpdates.flatMap(update => update.tags);
	            const tag = Date.now() + "-" + Math.random();
	            await new Promise(nextStep => {
	                this.isSubscriptionHandledByWriteLoop = true;
	                const unsubscribeArray = [];
	                const settle = () => {
	                    this.isSubscriptionHandledByWriteLoop = false;
	                    unsubscribeArray.forEach(unsubscribe => unsubscribe());
	                    nextStep();
	                };
	                unsubscribeArray.push(this.innerSignal.subscribeFull((_data, _patches, tags) => {
	                    if (!this.isSubscriptionHandledByWriteLoop) {
	                        return;
	                    }
	                    if (tags?.includes(tag)) {
	                        settle();
	                        resolve();
	                        // If this update is caused by the write, we need to remove the optimistic update
	                        // and apply the remaining optimistic updates
	                        this.queuedUpdates.splice(0, numQueuedUpdatesToHandle);
	                        this.updateOptimisticValue(tags.filter(t => t !== tag));
	                    }
	                    else {
	                        // This update is not caused by the write, simply update the optimistic value
	                        // as normal
	                        this.updateOptimisticValue(tags);
	                    }
	                }));
	                unsubscribeArray.push(this.writeErrorEvent.subscribe(({ tags, error }) => {
	                    if (!this.isSubscriptionHandledByWriteLoop) {
	                        return;
	                    }
	                    if (tags.includes(tag)) {
	                        settle();
	                        reject(error);
	                        this.queuedUpdates.splice(0, numQueuedUpdatesToHandle);
	                    }
	                }));
	                // At this point, we know the data is available, because upon entering the write loop, we
	                // ensure that the data is available by pulling. Hence, we can safely cast the data to
	                // StripNotAvailable<TData>.
	                const sent = this.writeUpstream(...updater(this.innerSignal.get()), [tag, ...queuedUpdateTags]);
	                if (!sent) {
	                    settle();
	                    resolve();
	                    this.queuedUpdates.splice(0, numQueuedUpdatesToHandle);
	                    this.updateOptimisticValue(queuedUpdateTags.filter(t => t !== tag));
	                }
	            });
	        }
	        this.isWriteLoopRunning = false;
	        unsubscribe();
	    }
	    /**
	     * Returns whether the value is currently stale.
	     *
	     * A value is stale whenever the upstream subscription is not active. This can happen in three
	     * cases:
	     *
	     * 1. When no subscriber is attached to this signal, the signal will not subscribe to the
	     *    upstream. In this case, the value is always stale.
	     * 2. When a subscriber is attached, but the upstream has not yet emitted a single value, the
	     *    value is also stale.
	     * 3. When the upstream has emitted an error. In this case, the subscription to the upstream is
	     *    terminated and the value is stale.
	     *
	     * If you wish to get the current value and ensure that it is not stale, use the method
	     * {@link OWLSignal#pull}.
	     */
	    isStale() {
	        return this.innerSignal.isStale();
	    }
	    /**
	     * Gets the current value of the signal. If the value is not available, it will return
	     * {@link OWLSignal.NOT_AVAILABLE}. (A value will only be unavailable if the signal is created
	     * without an initial value and the upstream has not emitted a value yet.)
	     *
	     * In addition, the value returned by this method may be stale. Use {@link OWLSignal#isStale} to
	     * check if the value is stale.
	     *
	     * If you wish to get the current value and ensure that it is not stale, use the method
	     * {@link OWLSignal#pull}.
	     */
	    get() {
	        return this.outerSignal.get();
	    }
	    /**
	     * Gets the current value of the signal pessimistically. If the value is not available, it will
	     * return {@link OWLSignal.NOT_AVAILABLE}. (A value will only be unavailable if the signal is
	     * created without an initial value and the upstream has not emitted a value yet.)
	     */
	    getPessimistic() {
	        return this.innerSignal.get();
	    }
	    /**
	     * Pulls the current value of the signal. If the value is stale, it will subscribe and wait for
	     * the next value from the upstream and return it.
	     *
	     * You must also provide an `optimistic` flag. If `optimistic` is true, the pending optimistic
	     * updates will be applied to the value before returning it.
	     */
	    async pull({ optimistic = true } = {}) {
	        if (optimistic) {
	            return this.applyOptimisticUpdates(await this.innerSignal.pull());
	        }
	        else {
	            return this.innerSignal.pull();
	        }
	    }
	    async ensureAvailable() {
	        if (this.currentEnsureAvailablePromise === null) {
	            this.currentEnsureAvailablePromise = (async () => {
	                await this.innerSignal.pull();
	                return this;
	            })();
	        }
	        return this.currentEnsureAvailablePromise;
	    }
	    subscribe(subscriber) {
	        const unsubscribeOuter = this.outerSignal.subscribe(subscriber);
	        const unsubscribeInner = this.innerSignal.subscribe(() => { });
	        return () => {
	            unsubscribeOuter();
	            unsubscribeInner();
	        };
	    }
	    subscribeFull(subscriber) {
	        const unsubscribeOuter = this.outerSignal.subscribeFull(subscriber);
	        const unsubscribeInner = this.innerSignal.subscribeFull(() => { });
	        return () => {
	            unsubscribeOuter();
	            unsubscribeInner();
	        };
	    }
	};
	OWLSignal.OWLSignal = OWLSignal$1;
	
	return OWLSignal;
}

var parseFileIdentifier = {};

var hasRequiredParseFileIdentifier;

function requireParseFileIdentifier () {
	if (hasRequiredParseFileIdentifier) return parseFileIdentifier;
	hasRequiredParseFileIdentifier = 1;
	Object.defineProperty(parseFileIdentifier, "__esModule", { value: true });
	parseFileIdentifier.parseFileIdentifier = parseFileIdentifier$1;
	function parseFileIdentifier$1(fileIdentifier) {
	    if (!fileIdentifier.includes(":")) {
	        fileIdentifier = `local:${fileIdentifier}`;
	    }
	    const colonIndex = fileIdentifier.indexOf(":");
	    const namespace = fileIdentifier.slice(0, colonIndex);
	    const content = fileIdentifier.slice(colonIndex + 1);
	    switch (namespace) {
	        case "local": {
	            if (content.includes("/") || content.includes("\\") || content.length === 0) {
	                throw new Error(`Invalid local file name: ${content}.`);
	            }
	            return {
	                type: "local",
	                fileName: content,
	            };
	        }
	        case "base64": {
	            return {
	                type: "base64",
	                base64Data: content,
	            };
	        }
	        default: {
	            throw new Error(`Unknown file identifier namespace: ${namespace}.`);
	        }
	    }
	}
	
	return parseFileIdentifier;
}

var promisifyAbortSignal = {};

var hasRequiredPromisifyAbortSignal;

function requirePromisifyAbortSignal () {
	if (hasRequiredPromisifyAbortSignal) return promisifyAbortSignal;
	hasRequiredPromisifyAbortSignal = 1;
	Object.defineProperty(promisifyAbortSignal, "__esModule", { value: true });
	promisifyAbortSignal.promisifyAbortSignal = promisifyAbortSignal$1;
	promisifyAbortSignal.raceWithAbortSignal = raceWithAbortSignal;
	function promisifyAbortSignal$1(abortSignal) {
	    return new Promise((_resolve, reject) => {
	        if (abortSignal.aborted) {
	            reject(abortSignal.reason);
	            return;
	        }
	        abortSignal.addEventListener("abort", () => {
	            reject(abortSignal.reason);
	        }, { once: true });
	    });
	}
	function raceWithAbortSignal(promise, abortSignal) {
	    return Promise.race([promise, promisifyAbortSignal$1(abortSignal)]);
	}
	
	return promisifyAbortSignal;
}

var removeUndefinedValues = {};

var hasRequiredRemoveUndefinedValues;

function requireRemoveUndefinedValues () {
	if (hasRequiredRemoveUndefinedValues) return removeUndefinedValues;
	hasRequiredRemoveUndefinedValues = 1;
	Object.defineProperty(removeUndefinedValues, "__esModule", { value: true });
	removeUndefinedValues.removeUndefinedValues = removeUndefinedValues$1;
	/**
	 * Removes properties with `undefined` values from an object.
	 *
	 * This function can be useful in scenarios where you want to ensure that an object does not contain
	 * any `undefined` values. For example, when the resulting value is used to overwrite some default
	 * values.
	 *
	 * Note: This function does not mutate the original object. It returns a new object that does not
	 * include the `undefined` values.
	 *
	 * @param obj - The object from which to remove `undefined` values.
	 * @returns A new object that does not include the `undefined` values.
	 * @example
	 * ```typescript
	 * const obj = { a: 1, b: undefined, c: 'test' };
	 * const result = removeUndefinedValues(obj);
	 * console.log(result); // { a: 1, c: 'test' }
	 * ```
	 */
	function removeUndefinedValues$1(obj) {
	    return Object.fromEntries(Object.entries(obj).filter(([_, v]) => v !== undefined));
	}
	
	return removeUndefinedValues;
}

var resultTypes = {};

var cjs$2 = {};

var lib$1 = {};

var external = {};

var errors$1 = {};

var en = {};

var util = {};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
		var util;
		(function (util) {
		    util.assertEqual = (val) => val;
		    function assertIs(_arg) { }
		    util.assertIs = assertIs;
		    function assertNever(_x) {
		        throw new Error();
		    }
		    util.assertNever = assertNever;
		    util.arrayToEnum = (items) => {
		        const obj = {};
		        for (const item of items) {
		            obj[item] = item;
		        }
		        return obj;
		    };
		    util.getValidEnumValues = (obj) => {
		        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
		        const filtered = {};
		        for (const k of validKeys) {
		            filtered[k] = obj[k];
		        }
		        return util.objectValues(filtered);
		    };
		    util.objectValues = (obj) => {
		        return util.objectKeys(obj).map(function (e) {
		            return obj[e];
		        });
		    };
		    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
		        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
		        : (object) => {
		            const keys = [];
		            for (const key in object) {
		                if (Object.prototype.hasOwnProperty.call(object, key)) {
		                    keys.push(key);
		                }
		            }
		            return keys;
		        };
		    util.find = (arr, checker) => {
		        for (const item of arr) {
		            if (checker(item))
		                return item;
		        }
		        return undefined;
		    };
		    util.isInteger = typeof Number.isInteger === "function"
		        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
		        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
		    function joinValues(array, separator = " | ") {
		        return array
		            .map((val) => (typeof val === "string" ? `'${val}'` : val))
		            .join(separator);
		    }
		    util.joinValues = joinValues;
		    util.jsonStringifyReplacer = (_, value) => {
		        if (typeof value === "bigint") {
		            return value.toString();
		        }
		        return value;
		    };
		})(util || (exports.util = util = {}));
		var objectUtil;
		(function (objectUtil) {
		    objectUtil.mergeShapes = (first, second) => {
		        return {
		            ...first,
		            ...second, // second overwrites first
		        };
		    };
		})(objectUtil || (exports.objectUtil = objectUtil = {}));
		exports.ZodParsedType = util.arrayToEnum([
		    "string",
		    "nan",
		    "number",
		    "integer",
		    "float",
		    "boolean",
		    "date",
		    "bigint",
		    "symbol",
		    "function",
		    "undefined",
		    "null",
		    "array",
		    "object",
		    "unknown",
		    "promise",
		    "void",
		    "never",
		    "map",
		    "set",
		]);
		const getParsedType = (data) => {
		    const t = typeof data;
		    switch (t) {
		        case "undefined":
		            return exports.ZodParsedType.undefined;
		        case "string":
		            return exports.ZodParsedType.string;
		        case "number":
		            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
		        case "boolean":
		            return exports.ZodParsedType.boolean;
		        case "function":
		            return exports.ZodParsedType.function;
		        case "bigint":
		            return exports.ZodParsedType.bigint;
		        case "symbol":
		            return exports.ZodParsedType.symbol;
		        case "object":
		            if (Array.isArray(data)) {
		                return exports.ZodParsedType.array;
		            }
		            if (data === null) {
		                return exports.ZodParsedType.null;
		            }
		            if (data.then &&
		                typeof data.then === "function" &&
		                data.catch &&
		                typeof data.catch === "function") {
		                return exports.ZodParsedType.promise;
		            }
		            if (typeof Map !== "undefined" && data instanceof Map) {
		                return exports.ZodParsedType.map;
		            }
		            if (typeof Set !== "undefined" && data instanceof Set) {
		                return exports.ZodParsedType.set;
		            }
		            if (typeof Date !== "undefined" && data instanceof Date) {
		                return exports.ZodParsedType.date;
		            }
		            return exports.ZodParsedType.object;
		        default:
		            return exports.ZodParsedType.unknown;
		    }
		};
		exports.getParsedType = getParsedType; 
	} (util));
	return util;
}

var ZodError = {};

var hasRequiredZodError;

function requireZodError () {
	if (hasRequiredZodError) return ZodError;
	hasRequiredZodError = 1;
	Object.defineProperty(ZodError, "__esModule", { value: true });
	ZodError.ZodError = ZodError.quotelessJson = ZodError.ZodIssueCode = void 0;
	const util_1 = /*@__PURE__*/ requireUtil();
	ZodError.ZodIssueCode = util_1.util.arrayToEnum([
	    "invalid_type",
	    "invalid_literal",
	    "custom",
	    "invalid_union",
	    "invalid_union_discriminator",
	    "invalid_enum_value",
	    "unrecognized_keys",
	    "invalid_arguments",
	    "invalid_return_type",
	    "invalid_date",
	    "invalid_string",
	    "too_small",
	    "too_big",
	    "invalid_intersection_types",
	    "not_multiple_of",
	    "not_finite",
	]);
	const quotelessJson = (obj) => {
	    const json = JSON.stringify(obj, null, 2);
	    return json.replace(/"([^"]+)":/g, "$1:");
	};
	ZodError.quotelessJson = quotelessJson;
	let ZodError$1 = class ZodError extends Error {
	    get errors() {
	        return this.issues;
	    }
	    constructor(issues) {
	        super();
	        this.issues = [];
	        this.addIssue = (sub) => {
	            this.issues = [...this.issues, sub];
	        };
	        this.addIssues = (subs = []) => {
	            this.issues = [...this.issues, ...subs];
	        };
	        const actualProto = new.target.prototype;
	        if (Object.setPrototypeOf) {
	            // eslint-disable-next-line ban/ban
	            Object.setPrototypeOf(this, actualProto);
	        }
	        else {
	            this.__proto__ = actualProto;
	        }
	        this.name = "ZodError";
	        this.issues = issues;
	    }
	    format(_mapper) {
	        const mapper = _mapper ||
	            function (issue) {
	                return issue.message;
	            };
	        const fieldErrors = { _errors: [] };
	        const processError = (error) => {
	            for (const issue of error.issues) {
	                if (issue.code === "invalid_union") {
	                    issue.unionErrors.map(processError);
	                }
	                else if (issue.code === "invalid_return_type") {
	                    processError(issue.returnTypeError);
	                }
	                else if (issue.code === "invalid_arguments") {
	                    processError(issue.argumentsError);
	                }
	                else if (issue.path.length === 0) {
	                    fieldErrors._errors.push(mapper(issue));
	                }
	                else {
	                    let curr = fieldErrors;
	                    let i = 0;
	                    while (i < issue.path.length) {
	                        const el = issue.path[i];
	                        const terminal = i === issue.path.length - 1;
	                        if (!terminal) {
	                            curr[el] = curr[el] || { _errors: [] };
	                            // if (typeof el === "string") {
	                            //   curr[el] = curr[el] || { _errors: [] };
	                            // } else if (typeof el === "number") {
	                            //   const errorArray: any = [];
	                            //   errorArray._errors = [];
	                            //   curr[el] = curr[el] || errorArray;
	                            // }
	                        }
	                        else {
	                            curr[el] = curr[el] || { _errors: [] };
	                            curr[el]._errors.push(mapper(issue));
	                        }
	                        curr = curr[el];
	                        i++;
	                    }
	                }
	            }
	        };
	        processError(this);
	        return fieldErrors;
	    }
	    static assert(value) {
	        if (!(value instanceof ZodError)) {
	            throw new Error(`Not a ZodError: ${value}`);
	        }
	    }
	    toString() {
	        return this.message;
	    }
	    get message() {
	        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
	    }
	    get isEmpty() {
	        return this.issues.length === 0;
	    }
	    flatten(mapper = (issue) => issue.message) {
	        const fieldErrors = {};
	        const formErrors = [];
	        for (const sub of this.issues) {
	            if (sub.path.length > 0) {
	                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
	                fieldErrors[sub.path[0]].push(mapper(sub));
	            }
	            else {
	                formErrors.push(mapper(sub));
	            }
	        }
	        return { formErrors, fieldErrors };
	    }
	    get formErrors() {
	        return this.flatten();
	    }
	};
	ZodError.ZodError = ZodError$1;
	ZodError$1.create = (issues) => {
	    const error = new ZodError$1(issues);
	    return error;
	};
	return ZodError;
}

var hasRequiredEn;

function requireEn () {
	if (hasRequiredEn) return en;
	hasRequiredEn = 1;
	Object.defineProperty(en, "__esModule", { value: true });
	const util_1 = /*@__PURE__*/ requireUtil();
	const ZodError_1 = /*@__PURE__*/ requireZodError();
	const errorMap = (issue, _ctx) => {
	    let message;
	    switch (issue.code) {
	        case ZodError_1.ZodIssueCode.invalid_type:
	            if (issue.received === util_1.ZodParsedType.undefined) {
	                message = "Required";
	            }
	            else {
	                message = `Expected ${issue.expected}, received ${issue.received}`;
	            }
	            break;
	        case ZodError_1.ZodIssueCode.invalid_literal:
	            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
	            break;
	        case ZodError_1.ZodIssueCode.unrecognized_keys:
	            message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
	            break;
	        case ZodError_1.ZodIssueCode.invalid_union:
	            message = `Invalid input`;
	            break;
	        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
	            message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
	            break;
	        case ZodError_1.ZodIssueCode.invalid_enum_value:
	            message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
	            break;
	        case ZodError_1.ZodIssueCode.invalid_arguments:
	            message = `Invalid function arguments`;
	            break;
	        case ZodError_1.ZodIssueCode.invalid_return_type:
	            message = `Invalid function return type`;
	            break;
	        case ZodError_1.ZodIssueCode.invalid_date:
	            message = `Invalid date`;
	            break;
	        case ZodError_1.ZodIssueCode.invalid_string:
	            if (typeof issue.validation === "object") {
	                if ("includes" in issue.validation) {
	                    message = `Invalid input: must include "${issue.validation.includes}"`;
	                    if (typeof issue.validation.position === "number") {
	                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
	                    }
	                }
	                else if ("startsWith" in issue.validation) {
	                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
	                }
	                else if ("endsWith" in issue.validation) {
	                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
	                }
	                else {
	                    util_1.util.assertNever(issue.validation);
	                }
	            }
	            else if (issue.validation !== "regex") {
	                message = `Invalid ${issue.validation}`;
	            }
	            else {
	                message = "Invalid";
	            }
	            break;
	        case ZodError_1.ZodIssueCode.too_small:
	            if (issue.type === "array")
	                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
	            else if (issue.type === "string")
	                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
	            else if (issue.type === "number")
	                message = `Number must be ${issue.exact
	                    ? `exactly equal to `
	                    : issue.inclusive
	                        ? `greater than or equal to `
	                        : `greater than `}${issue.minimum}`;
	            else if (issue.type === "date")
	                message = `Date must be ${issue.exact
	                    ? `exactly equal to `
	                    : issue.inclusive
	                        ? `greater than or equal to `
	                        : `greater than `}${new Date(Number(issue.minimum))}`;
	            else
	                message = "Invalid input";
	            break;
	        case ZodError_1.ZodIssueCode.too_big:
	            if (issue.type === "array")
	                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
	            else if (issue.type === "string")
	                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
	            else if (issue.type === "number")
	                message = `Number must be ${issue.exact
	                    ? `exactly`
	                    : issue.inclusive
	                        ? `less than or equal to`
	                        : `less than`} ${issue.maximum}`;
	            else if (issue.type === "bigint")
	                message = `BigInt must be ${issue.exact
	                    ? `exactly`
	                    : issue.inclusive
	                        ? `less than or equal to`
	                        : `less than`} ${issue.maximum}`;
	            else if (issue.type === "date")
	                message = `Date must be ${issue.exact
	                    ? `exactly`
	                    : issue.inclusive
	                        ? `smaller than or equal to`
	                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
	            else
	                message = "Invalid input";
	            break;
	        case ZodError_1.ZodIssueCode.custom:
	            message = `Invalid input`;
	            break;
	        case ZodError_1.ZodIssueCode.invalid_intersection_types:
	            message = `Intersection results could not be merged`;
	            break;
	        case ZodError_1.ZodIssueCode.not_multiple_of:
	            message = `Number must be a multiple of ${issue.multipleOf}`;
	            break;
	        case ZodError_1.ZodIssueCode.not_finite:
	            message = "Number must be finite";
	            break;
	        default:
	            message = _ctx.defaultError;
	            util_1.util.assertNever(issue);
	    }
	    return { message };
	};
	en.default = errorMap;
	return en;
}

var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$1;
	hasRequiredErrors$1 = 1;
	var __importDefault = (errors$1 && errors$1.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(errors$1, "__esModule", { value: true });
	errors$1.getErrorMap = errors$1.setErrorMap = errors$1.defaultErrorMap = void 0;
	const en_1 = __importDefault(/*@__PURE__*/ requireEn());
	errors$1.defaultErrorMap = en_1.default;
	let overrideErrorMap = en_1.default;
	function setErrorMap(map) {
	    overrideErrorMap = map;
	}
	errors$1.setErrorMap = setErrorMap;
	function getErrorMap() {
	    return overrideErrorMap;
	}
	errors$1.getErrorMap = getErrorMap;
	return errors$1;
}

var parseUtil = {};

var hasRequiredParseUtil;

function requireParseUtil () {
	if (hasRequiredParseUtil) return parseUtil;
	hasRequiredParseUtil = 1;
	(function (exports) {
		var __importDefault = (parseUtil && parseUtil.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
		const errors_1 = /*@__PURE__*/ requireErrors$1();
		const en_1 = __importDefault(/*@__PURE__*/ requireEn());
		const makeIssue = (params) => {
		    const { data, path, errorMaps, issueData } = params;
		    const fullPath = [...path, ...(issueData.path || [])];
		    const fullIssue = {
		        ...issueData,
		        path: fullPath,
		    };
		    if (issueData.message !== undefined) {
		        return {
		            ...issueData,
		            path: fullPath,
		            message: issueData.message,
		        };
		    }
		    let errorMessage = "";
		    const maps = errorMaps
		        .filter((m) => !!m)
		        .slice()
		        .reverse();
		    for (const map of maps) {
		        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
		    }
		    return {
		        ...issueData,
		        path: fullPath,
		        message: errorMessage,
		    };
		};
		exports.makeIssue = makeIssue;
		exports.EMPTY_PATH = [];
		function addIssueToContext(ctx, issueData) {
		    const overrideMap = (0, errors_1.getErrorMap)();
		    const issue = (0, exports.makeIssue)({
		        issueData: issueData,
		        data: ctx.data,
		        path: ctx.path,
		        errorMaps: [
		            ctx.common.contextualErrorMap, // contextual error map is first priority
		            ctx.schemaErrorMap, // then schema-bound map if available
		            overrideMap, // then global override map
		            overrideMap === en_1.default ? undefined : en_1.default, // then global default map
		        ].filter((x) => !!x),
		    });
		    ctx.common.issues.push(issue);
		}
		exports.addIssueToContext = addIssueToContext;
		class ParseStatus {
		    constructor() {
		        this.value = "valid";
		    }
		    dirty() {
		        if (this.value === "valid")
		            this.value = "dirty";
		    }
		    abort() {
		        if (this.value !== "aborted")
		            this.value = "aborted";
		    }
		    static mergeArray(status, results) {
		        const arrayValue = [];
		        for (const s of results) {
		            if (s.status === "aborted")
		                return exports.INVALID;
		            if (s.status === "dirty")
		                status.dirty();
		            arrayValue.push(s.value);
		        }
		        return { status: status.value, value: arrayValue };
		    }
		    static async mergeObjectAsync(status, pairs) {
		        const syncPairs = [];
		        for (const pair of pairs) {
		            const key = await pair.key;
		            const value = await pair.value;
		            syncPairs.push({
		                key,
		                value,
		            });
		        }
		        return ParseStatus.mergeObjectSync(status, syncPairs);
		    }
		    static mergeObjectSync(status, pairs) {
		        const finalObject = {};
		        for (const pair of pairs) {
		            const { key, value } = pair;
		            if (key.status === "aborted")
		                return exports.INVALID;
		            if (value.status === "aborted")
		                return exports.INVALID;
		            if (key.status === "dirty")
		                status.dirty();
		            if (value.status === "dirty")
		                status.dirty();
		            if (key.value !== "__proto__" &&
		                (typeof value.value !== "undefined" || pair.alwaysSet)) {
		                finalObject[key.value] = value.value;
		            }
		        }
		        return { status: status.value, value: finalObject };
		    }
		}
		exports.ParseStatus = ParseStatus;
		exports.INVALID = Object.freeze({
		    status: "aborted",
		});
		const DIRTY = (value) => ({ status: "dirty", value });
		exports.DIRTY = DIRTY;
		const OK = (value) => ({ status: "valid", value });
		exports.OK = OK;
		const isAborted = (x) => x.status === "aborted";
		exports.isAborted = isAborted;
		const isDirty = (x) => x.status === "dirty";
		exports.isDirty = isDirty;
		const isValid = (x) => x.status === "valid";
		exports.isValid = isValid;
		const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
		exports.isAsync = isAsync; 
	} (parseUtil));
	return parseUtil;
}

var typeAliases = {};

var hasRequiredTypeAliases;

function requireTypeAliases () {
	if (hasRequiredTypeAliases) return typeAliases;
	hasRequiredTypeAliases = 1;
	Object.defineProperty(typeAliases, "__esModule", { value: true });
	return typeAliases;
}

var types$1 = {};

var errorUtil = {};

var hasRequiredErrorUtil;

function requireErrorUtil () {
	if (hasRequiredErrorUtil) return errorUtil;
	hasRequiredErrorUtil = 1;
	Object.defineProperty(errorUtil, "__esModule", { value: true });
	errorUtil.errorUtil = void 0;
	var errorUtil$1;
	(function (errorUtil) {
	    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
	    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
	})(errorUtil$1 || (errorUtil.errorUtil = errorUtil$1 = {}));
	return errorUtil;
}

var hasRequiredTypes$1;

function requireTypes$1 () {
	if (hasRequiredTypes$1) return types$1;
	hasRequiredTypes$1 = 1;
	var __classPrivateFieldGet = (types$1 && types$1.__classPrivateFieldGet) || function (receiver, state, kind, f) {
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var __classPrivateFieldSet = (types$1 && types$1.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
	    if (kind === "m") throw new TypeError("Private method is not writable");
	    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
	};
	var _ZodEnum_cache, _ZodNativeEnum_cache;
	Object.defineProperty(types$1, "__esModule", { value: true });
	types$1.boolean = types$1.bigint = types$1.array = types$1.any = types$1.coerce = types$1.ZodFirstPartyTypeKind = types$1.late = types$1.ZodSchema = types$1.Schema = types$1.custom = types$1.ZodReadonly = types$1.ZodPipeline = types$1.ZodBranded = types$1.BRAND = types$1.ZodNaN = types$1.ZodCatch = types$1.ZodDefault = types$1.ZodNullable = types$1.ZodOptional = types$1.ZodTransformer = types$1.ZodEffects = types$1.ZodPromise = types$1.ZodNativeEnum = types$1.ZodEnum = types$1.ZodLiteral = types$1.ZodLazy = types$1.ZodFunction = types$1.ZodSet = types$1.ZodMap = types$1.ZodRecord = types$1.ZodTuple = types$1.ZodIntersection = types$1.ZodDiscriminatedUnion = types$1.ZodUnion = types$1.ZodObject = types$1.ZodArray = types$1.ZodVoid = types$1.ZodNever = types$1.ZodUnknown = types$1.ZodAny = types$1.ZodNull = types$1.ZodUndefined = types$1.ZodSymbol = types$1.ZodDate = types$1.ZodBoolean = types$1.ZodBigInt = types$1.ZodNumber = types$1.ZodString = types$1.datetimeRegex = types$1.ZodType = void 0;
	types$1.NEVER = types$1.void = types$1.unknown = types$1.union = types$1.undefined = types$1.tuple = types$1.transformer = types$1.symbol = types$1.string = types$1.strictObject = types$1.set = types$1.record = types$1.promise = types$1.preprocess = types$1.pipeline = types$1.ostring = types$1.optional = types$1.onumber = types$1.oboolean = types$1.object = types$1.number = types$1.nullable = types$1.null = types$1.never = types$1.nativeEnum = types$1.nan = types$1.map = types$1.literal = types$1.lazy = types$1.intersection = types$1.instanceof = types$1.function = types$1.enum = types$1.effect = types$1.discriminatedUnion = types$1.date = void 0;
	const errors_1 = /*@__PURE__*/ requireErrors$1();
	const errorUtil_1 = /*@__PURE__*/ requireErrorUtil();
	const parseUtil_1 = /*@__PURE__*/ requireParseUtil();
	const util_1 = /*@__PURE__*/ requireUtil();
	const ZodError_1 = /*@__PURE__*/ requireZodError();
	class ParseInputLazyPath {
	    constructor(parent, value, path, key) {
	        this._cachedPath = [];
	        this.parent = parent;
	        this.data = value;
	        this._path = path;
	        this._key = key;
	    }
	    get path() {
	        if (!this._cachedPath.length) {
	            if (this._key instanceof Array) {
	                this._cachedPath.push(...this._path, ...this._key);
	            }
	            else {
	                this._cachedPath.push(...this._path, this._key);
	            }
	        }
	        return this._cachedPath;
	    }
	}
	const handleResult = (ctx, result) => {
	    if ((0, parseUtil_1.isValid)(result)) {
	        return { success: true, data: result.value };
	    }
	    else {
	        if (!ctx.common.issues.length) {
	            throw new Error("Validation failed but no issues detected.");
	        }
	        return {
	            success: false,
	            get error() {
	                if (this._error)
	                    return this._error;
	                const error = new ZodError_1.ZodError(ctx.common.issues);
	                this._error = error;
	                return this._error;
	            },
	        };
	    }
	};
	function processCreateParams(params) {
	    if (!params)
	        return {};
	    const { errorMap, invalid_type_error, required_error, description } = params;
	    if (errorMap && (invalid_type_error || required_error)) {
	        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
	    }
	    if (errorMap)
	        return { errorMap: errorMap, description };
	    const customMap = (iss, ctx) => {
	        var _a, _b;
	        const { message } = params;
	        if (iss.code === "invalid_enum_value") {
	            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
	        }
	        if (typeof ctx.data === "undefined") {
	            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
	        }
	        if (iss.code !== "invalid_type")
	            return { message: ctx.defaultError };
	        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
	    };
	    return { errorMap: customMap, description };
	}
	class ZodType {
	    get description() {
	        return this._def.description;
	    }
	    _getType(input) {
	        return (0, util_1.getParsedType)(input.data);
	    }
	    _getOrReturnCtx(input, ctx) {
	        return (ctx || {
	            common: input.parent.common,
	            data: input.data,
	            parsedType: (0, util_1.getParsedType)(input.data),
	            schemaErrorMap: this._def.errorMap,
	            path: input.path,
	            parent: input.parent,
	        });
	    }
	    _processInputParams(input) {
	        return {
	            status: new parseUtil_1.ParseStatus(),
	            ctx: {
	                common: input.parent.common,
	                data: input.data,
	                parsedType: (0, util_1.getParsedType)(input.data),
	                schemaErrorMap: this._def.errorMap,
	                path: input.path,
	                parent: input.parent,
	            },
	        };
	    }
	    _parseSync(input) {
	        const result = this._parse(input);
	        if ((0, parseUtil_1.isAsync)(result)) {
	            throw new Error("Synchronous parse encountered promise.");
	        }
	        return result;
	    }
	    _parseAsync(input) {
	        const result = this._parse(input);
	        return Promise.resolve(result);
	    }
	    parse(data, params) {
	        const result = this.safeParse(data, params);
	        if (result.success)
	            return result.data;
	        throw result.error;
	    }
	    safeParse(data, params) {
	        var _a;
	        const ctx = {
	            common: {
	                issues: [],
	                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
	                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
	            },
	            path: (params === null || params === void 0 ? void 0 : params.path) || [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: (0, util_1.getParsedType)(data),
	        };
	        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
	        return handleResult(ctx, result);
	    }
	    "~validate"(data) {
	        var _a, _b;
	        const ctx = {
	            common: {
	                issues: [],
	                async: !!this["~standard"].async,
	            },
	            path: [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: (0, util_1.getParsedType)(data),
	        };
	        if (!this["~standard"].async) {
	            try {
	                const result = this._parseSync({ data, path: [], parent: ctx });
	                return (0, parseUtil_1.isValid)(result)
	                    ? {
	                        value: result.value,
	                    }
	                    : {
	                        issues: ctx.common.issues,
	                    };
	            }
	            catch (err) {
	                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
	                    this["~standard"].async = true;
	                }
	                ctx.common = {
	                    issues: [],
	                    async: true,
	                };
	            }
	        }
	        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_1.isValid)(result)
	            ? {
	                value: result.value,
	            }
	            : {
	                issues: ctx.common.issues,
	            });
	    }
	    async parseAsync(data, params) {
	        const result = await this.safeParseAsync(data, params);
	        if (result.success)
	            return result.data;
	        throw result.error;
	    }
	    async safeParseAsync(data, params) {
	        const ctx = {
	            common: {
	                issues: [],
	                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
	                async: true,
	            },
	            path: (params === null || params === void 0 ? void 0 : params.path) || [],
	            schemaErrorMap: this._def.errorMap,
	            parent: null,
	            data,
	            parsedType: (0, util_1.getParsedType)(data),
	        };
	        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
	        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult)
	            ? maybeAsyncResult
	            : Promise.resolve(maybeAsyncResult));
	        return handleResult(ctx, result);
	    }
	    refine(check, message) {
	        const getIssueProperties = (val) => {
	            if (typeof message === "string" || typeof message === "undefined") {
	                return { message };
	            }
	            else if (typeof message === "function") {
	                return message(val);
	            }
	            else {
	                return message;
	            }
	        };
	        return this._refinement((val, ctx) => {
	            const result = check(val);
	            const setError = () => ctx.addIssue({
	                code: ZodError_1.ZodIssueCode.custom,
	                ...getIssueProperties(val),
	            });
	            if (typeof Promise !== "undefined" && result instanceof Promise) {
	                return result.then((data) => {
	                    if (!data) {
	                        setError();
	                        return false;
	                    }
	                    else {
	                        return true;
	                    }
	                });
	            }
	            if (!result) {
	                setError();
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	    }
	    refinement(check, refinementData) {
	        return this._refinement((val, ctx) => {
	            if (!check(val)) {
	                ctx.addIssue(typeof refinementData === "function"
	                    ? refinementData(val, ctx)
	                    : refinementData);
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	    }
	    _refinement(refinement) {
	        return new ZodEffects({
	            schema: this,
	            typeName: ZodFirstPartyTypeKind.ZodEffects,
	            effect: { type: "refinement", refinement },
	        });
	    }
	    superRefine(refinement) {
	        return this._refinement(refinement);
	    }
	    constructor(def) {
	        /** Alias of safeParseAsync */
	        this.spa = this.safeParseAsync;
	        this._def = def;
	        this.parse = this.parse.bind(this);
	        this.safeParse = this.safeParse.bind(this);
	        this.parseAsync = this.parseAsync.bind(this);
	        this.safeParseAsync = this.safeParseAsync.bind(this);
	        this.spa = this.spa.bind(this);
	        this.refine = this.refine.bind(this);
	        this.refinement = this.refinement.bind(this);
	        this.superRefine = this.superRefine.bind(this);
	        this.optional = this.optional.bind(this);
	        this.nullable = this.nullable.bind(this);
	        this.nullish = this.nullish.bind(this);
	        this.array = this.array.bind(this);
	        this.promise = this.promise.bind(this);
	        this.or = this.or.bind(this);
	        this.and = this.and.bind(this);
	        this.transform = this.transform.bind(this);
	        this.brand = this.brand.bind(this);
	        this.default = this.default.bind(this);
	        this.catch = this.catch.bind(this);
	        this.describe = this.describe.bind(this);
	        this.pipe = this.pipe.bind(this);
	        this.readonly = this.readonly.bind(this);
	        this.isNullable = this.isNullable.bind(this);
	        this.isOptional = this.isOptional.bind(this);
	        this["~standard"] = {
	            version: 1,
	            vendor: "zod",
	            validate: (data) => this["~validate"](data),
	        };
	    }
	    optional() {
	        return ZodOptional.create(this, this._def);
	    }
	    nullable() {
	        return ZodNullable.create(this, this._def);
	    }
	    nullish() {
	        return this.nullable().optional();
	    }
	    array() {
	        return ZodArray.create(this);
	    }
	    promise() {
	        return ZodPromise.create(this, this._def);
	    }
	    or(option) {
	        return ZodUnion.create([this, option], this._def);
	    }
	    and(incoming) {
	        return ZodIntersection.create(this, incoming, this._def);
	    }
	    transform(transform) {
	        return new ZodEffects({
	            ...processCreateParams(this._def),
	            schema: this,
	            typeName: ZodFirstPartyTypeKind.ZodEffects,
	            effect: { type: "transform", transform },
	        });
	    }
	    default(def) {
	        const defaultValueFunc = typeof def === "function" ? def : () => def;
	        return new ZodDefault({
	            ...processCreateParams(this._def),
	            innerType: this,
	            defaultValue: defaultValueFunc,
	            typeName: ZodFirstPartyTypeKind.ZodDefault,
	        });
	    }
	    brand() {
	        return new ZodBranded({
	            typeName: ZodFirstPartyTypeKind.ZodBranded,
	            type: this,
	            ...processCreateParams(this._def),
	        });
	    }
	    catch(def) {
	        const catchValueFunc = typeof def === "function" ? def : () => def;
	        return new ZodCatch({
	            ...processCreateParams(this._def),
	            innerType: this,
	            catchValue: catchValueFunc,
	            typeName: ZodFirstPartyTypeKind.ZodCatch,
	        });
	    }
	    describe(description) {
	        const This = this.constructor;
	        return new This({
	            ...this._def,
	            description,
	        });
	    }
	    pipe(target) {
	        return ZodPipeline.create(this, target);
	    }
	    readonly() {
	        return ZodReadonly.create(this);
	    }
	    isOptional() {
	        return this.safeParse(undefined).success;
	    }
	    isNullable() {
	        return this.safeParse(null).success;
	    }
	}
	types$1.ZodType = ZodType;
	types$1.Schema = ZodType;
	types$1.ZodSchema = ZodType;
	const cuidRegex = /^c[^\s-]{8,}$/i;
	const cuid2Regex = /^[0-9a-z]+$/;
	const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
	// const uuidRegex =
	//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
	const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
	const nanoidRegex = /^[a-z0-9_-]{21}$/i;
	const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
	const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
	// from https://stackoverflow.com/a/46181/1550155
	// old version: too slow, didn't support unicode
	// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
	//old email regex
	// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
	// eslint-disable-next-line
	// const emailRegex =
	//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
	// const emailRegex =
	//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
	// const emailRegex =
	//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
	const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
	// const emailRegex =
	//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
	// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
	const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
	let emojiRegex;
	// faster, simpler, safer
	const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
	const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
	// const ipv6Regex =
	// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
	const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
	const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
	// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
	const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
	// https://base64.guru/standards/base64url
	const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
	// simple
	// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
	// no leap year validation
	// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
	// with leap year validation
	const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
	const dateRegex = new RegExp(`^${dateRegexSource}$`);
	function timeRegexSource(args) {
	    // let regex = `\\d{2}:\\d{2}:\\d{2}`;
	    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
	    if (args.precision) {
	        regex = `${regex}\\.\\d{${args.precision}}`;
	    }
	    else if (args.precision == null) {
	        regex = `${regex}(\\.\\d+)?`;
	    }
	    return regex;
	}
	function timeRegex(args) {
	    return new RegExp(`^${timeRegexSource(args)}$`);
	}
	// Adapted from https://stackoverflow.com/a/3143231
	function datetimeRegex(args) {
	    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
	    const opts = [];
	    opts.push(args.local ? `Z?` : `Z`);
	    if (args.offset)
	        opts.push(`([+-]\\d{2}:?\\d{2})`);
	    regex = `${regex}(${opts.join("|")})`;
	    return new RegExp(`^${regex}$`);
	}
	types$1.datetimeRegex = datetimeRegex;
	function isValidIP(ip, version) {
	    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
	        return true;
	    }
	    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
	        return true;
	    }
	    return false;
	}
	function isValidJWT(jwt, alg) {
	    if (!jwtRegex.test(jwt))
	        return false;
	    try {
	        const [header] = jwt.split(".");
	        // Convert base64url to base64
	        const base64 = header
	            .replace(/-/g, "+")
	            .replace(/_/g, "/")
	            .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
	        const decoded = JSON.parse(atob(base64));
	        if (typeof decoded !== "object" || decoded === null)
	            return false;
	        if (!decoded.typ || !decoded.alg)
	            return false;
	        if (alg && decoded.alg !== alg)
	            return false;
	        return true;
	    }
	    catch (_a) {
	        return false;
	    }
	}
	function isValidCidr(ip, version) {
	    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
	        return true;
	    }
	    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
	        return true;
	    }
	    return false;
	}
	class ZodString extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = String(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.string) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.string,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const status = new parseUtil_1.ParseStatus();
	        let ctx = undefined;
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                if (input.data.length < check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_small,
	                        minimum: check.value,
	                        type: "string",
	                        inclusive: true,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                if (input.data.length > check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_big,
	                        maximum: check.value,
	                        type: "string",
	                        inclusive: true,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "length") {
	                const tooBig = input.data.length > check.value;
	                const tooSmall = input.data.length < check.value;
	                if (tooBig || tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    if (tooBig) {
	                        (0, parseUtil_1.addIssueToContext)(ctx, {
	                            code: ZodError_1.ZodIssueCode.too_big,
	                            maximum: check.value,
	                            type: "string",
	                            inclusive: true,
	                            exact: true,
	                            message: check.message,
	                        });
	                    }
	                    else if (tooSmall) {
	                        (0, parseUtil_1.addIssueToContext)(ctx, {
	                            code: ZodError_1.ZodIssueCode.too_small,
	                            minimum: check.value,
	                            type: "string",
	                            inclusive: true,
	                            exact: true,
	                            message: check.message,
	                        });
	                    }
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "email") {
	                if (!emailRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "email",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "emoji") {
	                if (!emojiRegex) {
	                    emojiRegex = new RegExp(_emojiRegex, "u");
	                }
	                if (!emojiRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "emoji",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "uuid") {
	                if (!uuidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "uuid",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "nanoid") {
	                if (!nanoidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "nanoid",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cuid") {
	                if (!cuidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "cuid",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cuid2") {
	                if (!cuid2Regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "cuid2",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "ulid") {
	                if (!ulidRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "ulid",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "url") {
	                try {
	                    new URL(input.data);
	                }
	                catch (_a) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "url",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "regex") {
	                check.regex.lastIndex = 0;
	                const testResult = check.regex.test(input.data);
	                if (!testResult) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "regex",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "trim") {
	                input.data = input.data.trim();
	            }
	            else if (check.kind === "includes") {
	                if (!input.data.includes(check.value, check.position)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        validation: { includes: check.value, position: check.position },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "toLowerCase") {
	                input.data = input.data.toLowerCase();
	            }
	            else if (check.kind === "toUpperCase") {
	                input.data = input.data.toUpperCase();
	            }
	            else if (check.kind === "startsWith") {
	                if (!input.data.startsWith(check.value)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        validation: { startsWith: check.value },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "endsWith") {
	                if (!input.data.endsWith(check.value)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        validation: { endsWith: check.value },
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "datetime") {
	                const regex = datetimeRegex(check);
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        validation: "datetime",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "date") {
	                const regex = dateRegex;
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        validation: "date",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "time") {
	                const regex = timeRegex(check);
	                if (!regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        validation: "time",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "duration") {
	                if (!durationRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "duration",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "ip") {
	                if (!isValidIP(input.data, check.version)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "ip",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "jwt") {
	                if (!isValidJWT(input.data, check.alg)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "jwt",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "cidr") {
	                if (!isValidCidr(input.data, check.version)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "cidr",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "base64") {
	                if (!base64Regex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "base64",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "base64url") {
	                if (!base64urlRegex.test(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        validation: "base64url",
	                        code: ZodError_1.ZodIssueCode.invalid_string,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_1.util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    _regex(regex, validation, message) {
	        return this.refinement((data) => regex.test(data), {
	            validation,
	            code: ZodError_1.ZodIssueCode.invalid_string,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    _addCheck(check) {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    email(message) {
	        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    url(message) {
	        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    emoji(message) {
	        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    uuid(message) {
	        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    nanoid(message) {
	        return this._addCheck({ kind: "nanoid", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    cuid(message) {
	        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    cuid2(message) {
	        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    ulid(message) {
	        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    base64(message) {
	        return this._addCheck({ kind: "base64", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    base64url(message) {
	        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
	        return this._addCheck({
	            kind: "base64url",
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    jwt(options) {
	        return this._addCheck({ kind: "jwt", ...errorUtil_1.errorUtil.errToObj(options) });
	    }
	    ip(options) {
	        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
	    }
	    cidr(options) {
	        return this._addCheck({ kind: "cidr", ...errorUtil_1.errorUtil.errToObj(options) });
	    }
	    datetime(options) {
	        var _a, _b;
	        if (typeof options === "string") {
	            return this._addCheck({
	                kind: "datetime",
	                precision: null,
	                offset: false,
	                local: false,
	                message: options,
	            });
	        }
	        return this._addCheck({
	            kind: "datetime",
	            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
	            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
	            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
	            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
	        });
	    }
	    date(message) {
	        return this._addCheck({ kind: "date", message });
	    }
	    time(options) {
	        if (typeof options === "string") {
	            return this._addCheck({
	                kind: "time",
	                precision: null,
	                message: options,
	            });
	        }
	        return this._addCheck({
	            kind: "time",
	            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
	            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
	        });
	    }
	    duration(message) {
	        return this._addCheck({ kind: "duration", ...errorUtil_1.errorUtil.errToObj(message) });
	    }
	    regex(regex, message) {
	        return this._addCheck({
	            kind: "regex",
	            regex: regex,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    includes(value, options) {
	        return this._addCheck({
	            kind: "includes",
	            value: value,
	            position: options === null || options === void 0 ? void 0 : options.position,
	            ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
	        });
	    }
	    startsWith(value, message) {
	        return this._addCheck({
	            kind: "startsWith",
	            value: value,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    endsWith(value, message) {
	        return this._addCheck({
	            kind: "endsWith",
	            value: value,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    min(minLength, message) {
	        return this._addCheck({
	            kind: "min",
	            value: minLength,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    max(maxLength, message) {
	        return this._addCheck({
	            kind: "max",
	            value: maxLength,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    length(len, message) {
	        return this._addCheck({
	            kind: "length",
	            value: len,
	            ...errorUtil_1.errorUtil.errToObj(message),
	        });
	    }
	    /**
	     * Equivalent to `.min(1)`
	     */
	    nonempty(message) {
	        return this.min(1, errorUtil_1.errorUtil.errToObj(message));
	    }
	    trim() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "trim" }],
	        });
	    }
	    toLowerCase() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "toLowerCase" }],
	        });
	    }
	    toUpperCase() {
	        return new ZodString({
	            ...this._def,
	            checks: [...this._def.checks, { kind: "toUpperCase" }],
	        });
	    }
	    get isDatetime() {
	        return !!this._def.checks.find((ch) => ch.kind === "datetime");
	    }
	    get isDate() {
	        return !!this._def.checks.find((ch) => ch.kind === "date");
	    }
	    get isTime() {
	        return !!this._def.checks.find((ch) => ch.kind === "time");
	    }
	    get isDuration() {
	        return !!this._def.checks.find((ch) => ch.kind === "duration");
	    }
	    get isEmail() {
	        return !!this._def.checks.find((ch) => ch.kind === "email");
	    }
	    get isURL() {
	        return !!this._def.checks.find((ch) => ch.kind === "url");
	    }
	    get isEmoji() {
	        return !!this._def.checks.find((ch) => ch.kind === "emoji");
	    }
	    get isUUID() {
	        return !!this._def.checks.find((ch) => ch.kind === "uuid");
	    }
	    get isNANOID() {
	        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
	    }
	    get isCUID() {
	        return !!this._def.checks.find((ch) => ch.kind === "cuid");
	    }
	    get isCUID2() {
	        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	    }
	    get isULID() {
	        return !!this._def.checks.find((ch) => ch.kind === "ulid");
	    }
	    get isIP() {
	        return !!this._def.checks.find((ch) => ch.kind === "ip");
	    }
	    get isCIDR() {
	        return !!this._def.checks.find((ch) => ch.kind === "cidr");
	    }
	    get isBase64() {
	        return !!this._def.checks.find((ch) => ch.kind === "base64");
	    }
	    get isBase64url() {
	        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
	        return !!this._def.checks.find((ch) => ch.kind === "base64url");
	    }
	    get minLength() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxLength() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	}
	types$1.ZodString = ZodString;
	ZodString.create = (params) => {
	    var _a;
	    return new ZodString({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodString,
	        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
	        ...processCreateParams(params),
	    });
	};
	// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
	function floatSafeRemainder(val, step) {
	    const valDecCount = (val.toString().split(".")[1] || "").length;
	    const stepDecCount = (step.toString().split(".")[1] || "").length;
	    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
	    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
	    return (valInt % stepInt) / Math.pow(10, decCount);
	}
	class ZodNumber extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.min = this.gte;
	        this.max = this.lte;
	        this.step = this.multipleOf;
	    }
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = Number(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.number) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.number,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        let ctx = undefined;
	        const status = new parseUtil_1.ParseStatus();
	        for (const check of this._def.checks) {
	            if (check.kind === "int") {
	                if (!util_1.util.isInteger(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.invalid_type,
	                        expected: "integer",
	                        received: "float",
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "min") {
	                const tooSmall = check.inclusive
	                    ? input.data < check.value
	                    : input.data <= check.value;
	                if (tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_small,
	                        minimum: check.value,
	                        type: "number",
	                        inclusive: check.inclusive,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                const tooBig = check.inclusive
	                    ? input.data > check.value
	                    : input.data >= check.value;
	                if (tooBig) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_big,
	                        maximum: check.value,
	                        type: "number",
	                        inclusive: check.inclusive,
	                        exact: false,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "multipleOf") {
	                if (floatSafeRemainder(input.data, check.value) !== 0) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.not_multiple_of,
	                        multipleOf: check.value,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "finite") {
	                if (!Number.isFinite(input.data)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.not_finite,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_1.util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    gte(value, message) {
	        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
	    }
	    gt(value, message) {
	        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
	    }
	    lte(value, message) {
	        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
	    }
	    lt(value, message) {
	        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
	    }
	    setLimit(kind, value, inclusive, message) {
	        return new ZodNumber({
	            ...this._def,
	            checks: [
	                ...this._def.checks,
	                {
	                    kind,
	                    value,
	                    inclusive,
	                    message: errorUtil_1.errorUtil.toString(message),
	                },
	            ],
	        });
	    }
	    _addCheck(check) {
	        return new ZodNumber({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    int(message) {
	        return this._addCheck({
	            kind: "int",
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    positive(message) {
	        return this._addCheck({
	            kind: "min",
	            value: 0,
	            inclusive: false,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    negative(message) {
	        return this._addCheck({
	            kind: "max",
	            value: 0,
	            inclusive: false,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    nonpositive(message) {
	        return this._addCheck({
	            kind: "max",
	            value: 0,
	            inclusive: true,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    nonnegative(message) {
	        return this._addCheck({
	            kind: "min",
	            value: 0,
	            inclusive: true,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    multipleOf(value, message) {
	        return this._addCheck({
	            kind: "multipleOf",
	            value: value,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    finite(message) {
	        return this._addCheck({
	            kind: "finite",
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    safe(message) {
	        return this._addCheck({
	            kind: "min",
	            inclusive: true,
	            value: Number.MIN_SAFE_INTEGER,
	            message: errorUtil_1.errorUtil.toString(message),
	        })._addCheck({
	            kind: "max",
	            inclusive: true,
	            value: Number.MAX_SAFE_INTEGER,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    get minValue() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxValue() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	    get isInt() {
	        return !!this._def.checks.find((ch) => ch.kind === "int" ||
	            (ch.kind === "multipleOf" && util_1.util.isInteger(ch.value)));
	    }
	    get isFinite() {
	        let max = null, min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "finite" ||
	                ch.kind === "int" ||
	                ch.kind === "multipleOf") {
	                return true;
	            }
	            else if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	            else if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return Number.isFinite(min) && Number.isFinite(max);
	    }
	}
	types$1.ZodNumber = ZodNumber;
	ZodNumber.create = (params) => {
	    return new ZodNumber({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodNumber,
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        ...processCreateParams(params),
	    });
	};
	class ZodBigInt extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.min = this.gte;
	        this.max = this.lte;
	    }
	    _parse(input) {
	        if (this._def.coerce) {
	            try {
	                input.data = BigInt(input.data);
	            }
	            catch (_a) {
	                return this._getInvalidInput(input);
	            }
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.bigint) {
	            return this._getInvalidInput(input);
	        }
	        let ctx = undefined;
	        const status = new parseUtil_1.ParseStatus();
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                const tooSmall = check.inclusive
	                    ? input.data < check.value
	                    : input.data <= check.value;
	                if (tooSmall) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_small,
	                        type: "bigint",
	                        minimum: check.value,
	                        inclusive: check.inclusive,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                const tooBig = check.inclusive
	                    ? input.data > check.value
	                    : input.data >= check.value;
	                if (tooBig) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_big,
	                        type: "bigint",
	                        maximum: check.value,
	                        inclusive: check.inclusive,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "multipleOf") {
	                if (input.data % check.value !== BigInt(0)) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.not_multiple_of,
	                        multipleOf: check.value,
	                        message: check.message,
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_1.util.assertNever(check);
	            }
	        }
	        return { status: status.value, value: input.data };
	    }
	    _getInvalidInput(input) {
	        const ctx = this._getOrReturnCtx(input);
	        (0, parseUtil_1.addIssueToContext)(ctx, {
	            code: ZodError_1.ZodIssueCode.invalid_type,
	            expected: util_1.ZodParsedType.bigint,
	            received: ctx.parsedType,
	        });
	        return parseUtil_1.INVALID;
	    }
	    gte(value, message) {
	        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
	    }
	    gt(value, message) {
	        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
	    }
	    lte(value, message) {
	        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
	    }
	    lt(value, message) {
	        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
	    }
	    setLimit(kind, value, inclusive, message) {
	        return new ZodBigInt({
	            ...this._def,
	            checks: [
	                ...this._def.checks,
	                {
	                    kind,
	                    value,
	                    inclusive,
	                    message: errorUtil_1.errorUtil.toString(message),
	                },
	            ],
	        });
	    }
	    _addCheck(check) {
	        return new ZodBigInt({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    positive(message) {
	        return this._addCheck({
	            kind: "min",
	            value: BigInt(0),
	            inclusive: false,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    negative(message) {
	        return this._addCheck({
	            kind: "max",
	            value: BigInt(0),
	            inclusive: false,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    nonpositive(message) {
	        return this._addCheck({
	            kind: "max",
	            value: BigInt(0),
	            inclusive: true,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    nonnegative(message) {
	        return this._addCheck({
	            kind: "min",
	            value: BigInt(0),
	            inclusive: true,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    multipleOf(value, message) {
	        return this._addCheck({
	            kind: "multipleOf",
	            value,
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    get minValue() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min;
	    }
	    get maxValue() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max;
	    }
	}
	types$1.ZodBigInt = ZodBigInt;
	ZodBigInt.create = (params) => {
	    var _a;
	    return new ZodBigInt({
	        checks: [],
	        typeName: ZodFirstPartyTypeKind.ZodBigInt,
	        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
	        ...processCreateParams(params),
	    });
	};
	class ZodBoolean extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = Boolean(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.boolean) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.boolean,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	types$1.ZodBoolean = ZodBoolean;
	ZodBoolean.create = (params) => {
	    return new ZodBoolean({
	        typeName: ZodFirstPartyTypeKind.ZodBoolean,
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        ...processCreateParams(params),
	    });
	};
	class ZodDate extends ZodType {
	    _parse(input) {
	        if (this._def.coerce) {
	            input.data = new Date(input.data);
	        }
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.date) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.date,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (isNaN(input.data.getTime())) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_date,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const status = new parseUtil_1.ParseStatus();
	        let ctx = undefined;
	        for (const check of this._def.checks) {
	            if (check.kind === "min") {
	                if (input.data.getTime() < check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_small,
	                        message: check.message,
	                        inclusive: true,
	                        exact: false,
	                        minimum: check.value,
	                        type: "date",
	                    });
	                    status.dirty();
	                }
	            }
	            else if (check.kind === "max") {
	                if (input.data.getTime() > check.value) {
	                    ctx = this._getOrReturnCtx(input, ctx);
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.too_big,
	                        message: check.message,
	                        inclusive: true,
	                        exact: false,
	                        maximum: check.value,
	                        type: "date",
	                    });
	                    status.dirty();
	                }
	            }
	            else {
	                util_1.util.assertNever(check);
	            }
	        }
	        return {
	            status: status.value,
	            value: new Date(input.data.getTime()),
	        };
	    }
	    _addCheck(check) {
	        return new ZodDate({
	            ...this._def,
	            checks: [...this._def.checks, check],
	        });
	    }
	    min(minDate, message) {
	        return this._addCheck({
	            kind: "min",
	            value: minDate.getTime(),
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    max(maxDate, message) {
	        return this._addCheck({
	            kind: "max",
	            value: maxDate.getTime(),
	            message: errorUtil_1.errorUtil.toString(message),
	        });
	    }
	    get minDate() {
	        let min = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "min") {
	                if (min === null || ch.value > min)
	                    min = ch.value;
	            }
	        }
	        return min != null ? new Date(min) : null;
	    }
	    get maxDate() {
	        let max = null;
	        for (const ch of this._def.checks) {
	            if (ch.kind === "max") {
	                if (max === null || ch.value < max)
	                    max = ch.value;
	            }
	        }
	        return max != null ? new Date(max) : null;
	    }
	}
	types$1.ZodDate = ZodDate;
	ZodDate.create = (params) => {
	    return new ZodDate({
	        checks: [],
	        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
	        typeName: ZodFirstPartyTypeKind.ZodDate,
	        ...processCreateParams(params),
	    });
	};
	class ZodSymbol extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.symbol) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.symbol,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	types$1.ZodSymbol = ZodSymbol;
	ZodSymbol.create = (params) => {
	    return new ZodSymbol({
	        typeName: ZodFirstPartyTypeKind.ZodSymbol,
	        ...processCreateParams(params),
	    });
	};
	class ZodUndefined extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.undefined) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.undefined,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	types$1.ZodUndefined = ZodUndefined;
	ZodUndefined.create = (params) => {
	    return new ZodUndefined({
	        typeName: ZodFirstPartyTypeKind.ZodUndefined,
	        ...processCreateParams(params),
	    });
	};
	class ZodNull extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.null) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.null,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	types$1.ZodNull = ZodNull;
	ZodNull.create = (params) => {
	    return new ZodNull({
	        typeName: ZodFirstPartyTypeKind.ZodNull,
	        ...processCreateParams(params),
	    });
	};
	class ZodAny extends ZodType {
	    constructor() {
	        super(...arguments);
	        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
	        this._any = true;
	    }
	    _parse(input) {
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	types$1.ZodAny = ZodAny;
	ZodAny.create = (params) => {
	    return new ZodAny({
	        typeName: ZodFirstPartyTypeKind.ZodAny,
	        ...processCreateParams(params),
	    });
	};
	class ZodUnknown extends ZodType {
	    constructor() {
	        super(...arguments);
	        // required
	        this._unknown = true;
	    }
	    _parse(input) {
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	types$1.ZodUnknown = ZodUnknown;
	ZodUnknown.create = (params) => {
	    return new ZodUnknown({
	        typeName: ZodFirstPartyTypeKind.ZodUnknown,
	        ...processCreateParams(params),
	    });
	};
	class ZodNever extends ZodType {
	    _parse(input) {
	        const ctx = this._getOrReturnCtx(input);
	        (0, parseUtil_1.addIssueToContext)(ctx, {
	            code: ZodError_1.ZodIssueCode.invalid_type,
	            expected: util_1.ZodParsedType.never,
	            received: ctx.parsedType,
	        });
	        return parseUtil_1.INVALID;
	    }
	}
	types$1.ZodNever = ZodNever;
	ZodNever.create = (params) => {
	    return new ZodNever({
	        typeName: ZodFirstPartyTypeKind.ZodNever,
	        ...processCreateParams(params),
	    });
	};
	class ZodVoid extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.undefined) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.void,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	}
	types$1.ZodVoid = ZodVoid;
	ZodVoid.create = (params) => {
	    return new ZodVoid({
	        typeName: ZodFirstPartyTypeKind.ZodVoid,
	        ...processCreateParams(params),
	    });
	};
	class ZodArray extends ZodType {
	    _parse(input) {
	        const { ctx, status } = this._processInputParams(input);
	        const def = this._def;
	        if (ctx.parsedType !== util_1.ZodParsedType.array) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.array,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (def.exactLength !== null) {
	            const tooBig = ctx.data.length > def.exactLength.value;
	            const tooSmall = ctx.data.length < def.exactLength.value;
	            if (tooBig || tooSmall) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
	                    minimum: (tooSmall ? def.exactLength.value : undefined),
	                    maximum: (tooBig ? def.exactLength.value : undefined),
	                    type: "array",
	                    inclusive: true,
	                    exact: true,
	                    message: def.exactLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.minLength !== null) {
	            if (ctx.data.length < def.minLength.value) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: ZodError_1.ZodIssueCode.too_small,
	                    minimum: def.minLength.value,
	                    type: "array",
	                    inclusive: true,
	                    exact: false,
	                    message: def.minLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.maxLength !== null) {
	            if (ctx.data.length > def.maxLength.value) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: ZodError_1.ZodIssueCode.too_big,
	                    maximum: def.maxLength.value,
	                    type: "array",
	                    inclusive: true,
	                    exact: false,
	                    message: def.maxLength.message,
	                });
	                status.dirty();
	            }
	        }
	        if (ctx.common.async) {
	            return Promise.all([...ctx.data].map((item, i) => {
	                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
	            })).then((result) => {
	                return parseUtil_1.ParseStatus.mergeArray(status, result);
	            });
	        }
	        const result = [...ctx.data].map((item, i) => {
	            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
	        });
	        return parseUtil_1.ParseStatus.mergeArray(status, result);
	    }
	    get element() {
	        return this._def.type;
	    }
	    min(minLength, message) {
	        return new ZodArray({
	            ...this._def,
	            minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) },
	        });
	    }
	    max(maxLength, message) {
	        return new ZodArray({
	            ...this._def,
	            maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) },
	        });
	    }
	    length(len, message) {
	        return new ZodArray({
	            ...this._def,
	            exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) },
	        });
	    }
	    nonempty(message) {
	        return this.min(1, message);
	    }
	}
	types$1.ZodArray = ZodArray;
	ZodArray.create = (schema, params) => {
	    return new ZodArray({
	        type: schema,
	        minLength: null,
	        maxLength: null,
	        exactLength: null,
	        typeName: ZodFirstPartyTypeKind.ZodArray,
	        ...processCreateParams(params),
	    });
	};
	function deepPartialify(schema) {
	    if (schema instanceof ZodObject) {
	        const newShape = {};
	        for (const key in schema.shape) {
	            const fieldSchema = schema.shape[key];
	            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
	        }
	        return new ZodObject({
	            ...schema._def,
	            shape: () => newShape,
	        });
	    }
	    else if (schema instanceof ZodArray) {
	        return new ZodArray({
	            ...schema._def,
	            type: deepPartialify(schema.element),
	        });
	    }
	    else if (schema instanceof ZodOptional) {
	        return ZodOptional.create(deepPartialify(schema.unwrap()));
	    }
	    else if (schema instanceof ZodNullable) {
	        return ZodNullable.create(deepPartialify(schema.unwrap()));
	    }
	    else if (schema instanceof ZodTuple) {
	        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	    }
	    else {
	        return schema;
	    }
	}
	class ZodObject extends ZodType {
	    constructor() {
	        super(...arguments);
	        this._cached = null;
	        /**
	         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
	         * If you want to pass through unknown properties, use `.passthrough()` instead.
	         */
	        this.nonstrict = this.passthrough;
	        // extend<
	        //   Augmentation extends ZodRawShape,
	        //   NewOutput extends util.flatten<{
	        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
	        //       ? Augmentation[k]["_output"]
	        //       : k extends keyof Output
	        //       ? Output[k]
	        //       : never;
	        //   }>,
	        //   NewInput extends util.flatten<{
	        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
	        //       ? Augmentation[k]["_input"]
	        //       : k extends keyof Input
	        //       ? Input[k]
	        //       : never;
	        //   }>
	        // >(
	        //   augmentation: Augmentation
	        // ): ZodObject<
	        //   extendShape<T, Augmentation>,
	        //   UnknownKeys,
	        //   Catchall,
	        //   NewOutput,
	        //   NewInput
	        // > {
	        //   return new ZodObject({
	        //     ...this._def,
	        //     shape: () => ({
	        //       ...this._def.shape(),
	        //       ...augmentation,
	        //     }),
	        //   }) as any;
	        // }
	        /**
	         * @deprecated Use `.extend` instead
	         *  */
	        this.augment = this.extend;
	    }
	    _getCached() {
	        if (this._cached !== null)
	            return this._cached;
	        const shape = this._def.shape();
	        const keys = util_1.util.objectKeys(shape);
	        return (this._cached = { shape, keys });
	    }
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.object) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const { status, ctx } = this._processInputParams(input);
	        const { shape, keys: shapeKeys } = this._getCached();
	        const extraKeys = [];
	        if (!(this._def.catchall instanceof ZodNever &&
	            this._def.unknownKeys === "strip")) {
	            for (const key in ctx.data) {
	                if (!shapeKeys.includes(key)) {
	                    extraKeys.push(key);
	                }
	            }
	        }
	        const pairs = [];
	        for (const key of shapeKeys) {
	            const keyValidator = shape[key];
	            const value = ctx.data[key];
	            pairs.push({
	                key: { status: "valid", value: key },
	                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
	                alwaysSet: key in ctx.data,
	            });
	        }
	        if (this._def.catchall instanceof ZodNever) {
	            const unknownKeys = this._def.unknownKeys;
	            if (unknownKeys === "passthrough") {
	                for (const key of extraKeys) {
	                    pairs.push({
	                        key: { status: "valid", value: key },
	                        value: { status: "valid", value: ctx.data[key] },
	                    });
	                }
	            }
	            else if (unknownKeys === "strict") {
	                if (extraKeys.length > 0) {
	                    (0, parseUtil_1.addIssueToContext)(ctx, {
	                        code: ZodError_1.ZodIssueCode.unrecognized_keys,
	                        keys: extraKeys,
	                    });
	                    status.dirty();
	                }
	            }
	            else if (unknownKeys === "strip") ;
	            else {
	                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
	            }
	        }
	        else {
	            // run catchall validation
	            const catchall = this._def.catchall;
	            for (const key of extraKeys) {
	                const value = ctx.data[key];
	                pairs.push({
	                    key: { status: "valid", value: key },
	                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
	                    ),
	                    alwaysSet: key in ctx.data,
	                });
	            }
	        }
	        if (ctx.common.async) {
	            return Promise.resolve()
	                .then(async () => {
	                const syncPairs = [];
	                for (const pair of pairs) {
	                    const key = await pair.key;
	                    const value = await pair.value;
	                    syncPairs.push({
	                        key,
	                        value,
	                        alwaysSet: pair.alwaysSet,
	                    });
	                }
	                return syncPairs;
	            })
	                .then((syncPairs) => {
	                return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
	            });
	        }
	        else {
	            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
	        }
	    }
	    get shape() {
	        return this._def.shape();
	    }
	    strict(message) {
	        errorUtil_1.errorUtil.errToObj;
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "strict",
	            ...(message !== undefined
	                ? {
	                    errorMap: (issue, ctx) => {
	                        var _a, _b, _c, _d;
	                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
	                        if (issue.code === "unrecognized_keys")
	                            return {
	                                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
	                            };
	                        return {
	                            message: defaultError,
	                        };
	                    },
	                }
	                : {}),
	        });
	    }
	    strip() {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "strip",
	        });
	    }
	    passthrough() {
	        return new ZodObject({
	            ...this._def,
	            unknownKeys: "passthrough",
	        });
	    }
	    // const AugmentFactory =
	    //   <Def extends ZodObjectDef>(def: Def) =>
	    //   <Augmentation extends ZodRawShape>(
	    //     augmentation: Augmentation
	    //   ): ZodObject<
	    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
	    //     Def["unknownKeys"],
	    //     Def["catchall"]
	    //   > => {
	    //     return new ZodObject({
	    //       ...def,
	    //       shape: () => ({
	    //         ...def.shape(),
	    //         ...augmentation,
	    //       }),
	    //     }) as any;
	    //   };
	    extend(augmentation) {
	        return new ZodObject({
	            ...this._def,
	            shape: () => ({
	                ...this._def.shape(),
	                ...augmentation,
	            }),
	        });
	    }
	    /**
	     * Prior to zod@1.0.12 there was a bug in the
	     * inferred type of merged objects. Please
	     * upgrade if you are experiencing issues.
	     */
	    merge(merging) {
	        const merged = new ZodObject({
	            unknownKeys: merging._def.unknownKeys,
	            catchall: merging._def.catchall,
	            shape: () => ({
	                ...this._def.shape(),
	                ...merging._def.shape(),
	            }),
	            typeName: ZodFirstPartyTypeKind.ZodObject,
	        });
	        return merged;
	    }
	    // merge<
	    //   Incoming extends AnyZodObject,
	    //   Augmentation extends Incoming["shape"],
	    //   NewOutput extends {
	    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
	    //       ? Augmentation[k]["_output"]
	    //       : k extends keyof Output
	    //       ? Output[k]
	    //       : never;
	    //   },
	    //   NewInput extends {
	    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
	    //       ? Augmentation[k]["_input"]
	    //       : k extends keyof Input
	    //       ? Input[k]
	    //       : never;
	    //   }
	    // >(
	    //   merging: Incoming
	    // ): ZodObject<
	    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
	    //   Incoming["_def"]["unknownKeys"],
	    //   Incoming["_def"]["catchall"],
	    //   NewOutput,
	    //   NewInput
	    // > {
	    //   const merged: any = new ZodObject({
	    //     unknownKeys: merging._def.unknownKeys,
	    //     catchall: merging._def.catchall,
	    //     shape: () =>
	    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
	    //     typeName: ZodFirstPartyTypeKind.ZodObject,
	    //   }) as any;
	    //   return merged;
	    // }
	    setKey(key, schema) {
	        return this.augment({ [key]: schema });
	    }
	    // merge<Incoming extends AnyZodObject>(
	    //   merging: Incoming
	    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
	    // ZodObject<
	    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
	    //   Incoming["_def"]["unknownKeys"],
	    //   Incoming["_def"]["catchall"]
	    // > {
	    //   // const mergedShape = objectUtil.mergeShapes(
	    //   //   this._def.shape(),
	    //   //   merging._def.shape()
	    //   // );
	    //   const merged: any = new ZodObject({
	    //     unknownKeys: merging._def.unknownKeys,
	    //     catchall: merging._def.catchall,
	    //     shape: () =>
	    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
	    //     typeName: ZodFirstPartyTypeKind.ZodObject,
	    //   }) as any;
	    //   return merged;
	    // }
	    catchall(index) {
	        return new ZodObject({
	            ...this._def,
	            catchall: index,
	        });
	    }
	    pick(mask) {
	        const shape = {};
	        util_1.util.objectKeys(mask).forEach((key) => {
	            if (mask[key] && this.shape[key]) {
	                shape[key] = this.shape[key];
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => shape,
	        });
	    }
	    omit(mask) {
	        const shape = {};
	        util_1.util.objectKeys(this.shape).forEach((key) => {
	            if (!mask[key]) {
	                shape[key] = this.shape[key];
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => shape,
	        });
	    }
	    /**
	     * @deprecated
	     */
	    deepPartial() {
	        return deepPartialify(this);
	    }
	    partial(mask) {
	        const newShape = {};
	        util_1.util.objectKeys(this.shape).forEach((key) => {
	            const fieldSchema = this.shape[key];
	            if (mask && !mask[key]) {
	                newShape[key] = fieldSchema;
	            }
	            else {
	                newShape[key] = fieldSchema.optional();
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => newShape,
	        });
	    }
	    required(mask) {
	        const newShape = {};
	        util_1.util.objectKeys(this.shape).forEach((key) => {
	            if (mask && !mask[key]) {
	                newShape[key] = this.shape[key];
	            }
	            else {
	                const fieldSchema = this.shape[key];
	                let newField = fieldSchema;
	                while (newField instanceof ZodOptional) {
	                    newField = newField._def.innerType;
	                }
	                newShape[key] = newField;
	            }
	        });
	        return new ZodObject({
	            ...this._def,
	            shape: () => newShape,
	        });
	    }
	    keyof() {
	        return createZodEnum(util_1.util.objectKeys(this.shape));
	    }
	}
	types$1.ZodObject = ZodObject;
	ZodObject.create = (shape, params) => {
	    return new ZodObject({
	        shape: () => shape,
	        unknownKeys: "strip",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	ZodObject.strictCreate = (shape, params) => {
	    return new ZodObject({
	        shape: () => shape,
	        unknownKeys: "strict",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	ZodObject.lazycreate = (shape, params) => {
	    return new ZodObject({
	        shape,
	        unknownKeys: "strip",
	        catchall: ZodNever.create(),
	        typeName: ZodFirstPartyTypeKind.ZodObject,
	        ...processCreateParams(params),
	    });
	};
	class ZodUnion extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const options = this._def.options;
	        function handleResults(results) {
	            // return first issue-free validation if it exists
	            for (const result of results) {
	                if (result.result.status === "valid") {
	                    return result.result;
	                }
	            }
	            for (const result of results) {
	                if (result.result.status === "dirty") {
	                    // add issues from dirty option
	                    ctx.common.issues.push(...result.ctx.common.issues);
	                    return result.result;
	                }
	            }
	            // return invalid
	            const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_union,
	                unionErrors,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (ctx.common.async) {
	            return Promise.all(options.map(async (option) => {
	                const childCtx = {
	                    ...ctx,
	                    common: {
	                        ...ctx.common,
	                        issues: [],
	                    },
	                    parent: null,
	                };
	                return {
	                    result: await option._parseAsync({
	                        data: ctx.data,
	                        path: ctx.path,
	                        parent: childCtx,
	                    }),
	                    ctx: childCtx,
	                };
	            })).then(handleResults);
	        }
	        else {
	            let dirty = undefined;
	            const issues = [];
	            for (const option of options) {
	                const childCtx = {
	                    ...ctx,
	                    common: {
	                        ...ctx.common,
	                        issues: [],
	                    },
	                    parent: null,
	                };
	                const result = option._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: childCtx,
	                });
	                if (result.status === "valid") {
	                    return result;
	                }
	                else if (result.status === "dirty" && !dirty) {
	                    dirty = { result, ctx: childCtx };
	                }
	                if (childCtx.common.issues.length) {
	                    issues.push(childCtx.common.issues);
	                }
	            }
	            if (dirty) {
	                ctx.common.issues.push(...dirty.ctx.common.issues);
	                return dirty.result;
	            }
	            const unionErrors = issues.map((issues) => new ZodError_1.ZodError(issues));
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_union,
	                unionErrors,
	            });
	            return parseUtil_1.INVALID;
	        }
	    }
	    get options() {
	        return this._def.options;
	    }
	}
	types$1.ZodUnion = ZodUnion;
	ZodUnion.create = (types, params) => {
	    return new ZodUnion({
	        options: types,
	        typeName: ZodFirstPartyTypeKind.ZodUnion,
	        ...processCreateParams(params),
	    });
	};
	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////
	//////////                                 //////////
	//////////      ZodDiscriminatedUnion      //////////
	//////////                                 //////////
	/////////////////////////////////////////////////////
	/////////////////////////////////////////////////////
	const getDiscriminator = (type) => {
	    if (type instanceof ZodLazy) {
	        return getDiscriminator(type.schema);
	    }
	    else if (type instanceof ZodEffects) {
	        return getDiscriminator(type.innerType());
	    }
	    else if (type instanceof ZodLiteral) {
	        return [type.value];
	    }
	    else if (type instanceof ZodEnum) {
	        return type.options;
	    }
	    else if (type instanceof ZodNativeEnum) {
	        // eslint-disable-next-line ban/ban
	        return util_1.util.objectValues(type.enum);
	    }
	    else if (type instanceof ZodDefault) {
	        return getDiscriminator(type._def.innerType);
	    }
	    else if (type instanceof ZodUndefined) {
	        return [undefined];
	    }
	    else if (type instanceof ZodNull) {
	        return [null];
	    }
	    else if (type instanceof ZodOptional) {
	        return [undefined, ...getDiscriminator(type.unwrap())];
	    }
	    else if (type instanceof ZodNullable) {
	        return [null, ...getDiscriminator(type.unwrap())];
	    }
	    else if (type instanceof ZodBranded) {
	        return getDiscriminator(type.unwrap());
	    }
	    else if (type instanceof ZodReadonly) {
	        return getDiscriminator(type.unwrap());
	    }
	    else if (type instanceof ZodCatch) {
	        return getDiscriminator(type._def.innerType);
	    }
	    else {
	        return [];
	    }
	};
	class ZodDiscriminatedUnion extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.object) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const discriminator = this.discriminator;
	        const discriminatorValue = ctx.data[discriminator];
	        const option = this.optionsMap.get(discriminatorValue);
	        if (!option) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
	                options: Array.from(this.optionsMap.keys()),
	                path: [discriminator],
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (ctx.common.async) {
	            return option._parseAsync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	        }
	        else {
	            return option._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	        }
	    }
	    get discriminator() {
	        return this._def.discriminator;
	    }
	    get options() {
	        return this._def.options;
	    }
	    get optionsMap() {
	        return this._def.optionsMap;
	    }
	    /**
	     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
	     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
	     * have a different value for each object in the union.
	     * @param discriminator the name of the discriminator property
	     * @param types an array of object schemas
	     * @param params
	     */
	    static create(discriminator, options, params) {
	        // Get all the valid discriminator values
	        const optionsMap = new Map();
	        // try {
	        for (const type of options) {
	            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
	            if (!discriminatorValues.length) {
	                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
	            }
	            for (const value of discriminatorValues) {
	                if (optionsMap.has(value)) {
	                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
	                }
	                optionsMap.set(value, type);
	            }
	        }
	        return new ZodDiscriminatedUnion({
	            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
	            discriminator,
	            options,
	            optionsMap,
	            ...processCreateParams(params),
	        });
	    }
	}
	types$1.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
	function mergeValues(a, b) {
	    const aType = (0, util_1.getParsedType)(a);
	    const bType = (0, util_1.getParsedType)(b);
	    if (a === b) {
	        return { valid: true, data: a };
	    }
	    else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
	        const bKeys = util_1.util.objectKeys(b);
	        const sharedKeys = util_1.util
	            .objectKeys(a)
	            .filter((key) => bKeys.indexOf(key) !== -1);
	        const newObj = { ...a, ...b };
	        for (const key of sharedKeys) {
	            const sharedValue = mergeValues(a[key], b[key]);
	            if (!sharedValue.valid) {
	                return { valid: false };
	            }
	            newObj[key] = sharedValue.data;
	        }
	        return { valid: true, data: newObj };
	    }
	    else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
	        if (a.length !== b.length) {
	            return { valid: false };
	        }
	        const newArray = [];
	        for (let index = 0; index < a.length; index++) {
	            const itemA = a[index];
	            const itemB = b[index];
	            const sharedValue = mergeValues(itemA, itemB);
	            if (!sharedValue.valid) {
	                return { valid: false };
	            }
	            newArray.push(sharedValue.data);
	        }
	        return { valid: true, data: newArray };
	    }
	    else if (aType === util_1.ZodParsedType.date &&
	        bType === util_1.ZodParsedType.date &&
	        +a === +b) {
	        return { valid: true, data: a };
	    }
	    else {
	        return { valid: false };
	    }
	}
	class ZodIntersection extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        const handleParsed = (parsedLeft, parsedRight) => {
	            if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
	                return parseUtil_1.INVALID;
	            }
	            const merged = mergeValues(parsedLeft.value, parsedRight.value);
	            if (!merged.valid) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: ZodError_1.ZodIssueCode.invalid_intersection_types,
	                });
	                return parseUtil_1.INVALID;
	            }
	            if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
	                status.dirty();
	            }
	            return { status: status.value, value: merged.data };
	        };
	        if (ctx.common.async) {
	            return Promise.all([
	                this._def.left._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                }),
	                this._def.right._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                }),
	            ]).then(([left, right]) => handleParsed(left, right));
	        }
	        else {
	            return handleParsed(this._def.left._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            }), this._def.right._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            }));
	        }
	    }
	}
	types$1.ZodIntersection = ZodIntersection;
	ZodIntersection.create = (left, right, params) => {
	    return new ZodIntersection({
	        left: left,
	        right: right,
	        typeName: ZodFirstPartyTypeKind.ZodIntersection,
	        ...processCreateParams(params),
	    });
	};
	class ZodTuple extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.array) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.array,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (ctx.data.length < this._def.items.length) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.too_small,
	                minimum: this._def.items.length,
	                inclusive: true,
	                exact: false,
	                type: "array",
	            });
	            return parseUtil_1.INVALID;
	        }
	        const rest = this._def.rest;
	        if (!rest && ctx.data.length > this._def.items.length) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.too_big,
	                maximum: this._def.items.length,
	                inclusive: true,
	                exact: false,
	                type: "array",
	            });
	            status.dirty();
	        }
	        const items = [...ctx.data]
	            .map((item, itemIndex) => {
	            const schema = this._def.items[itemIndex] || this._def.rest;
	            if (!schema)
	                return null;
	            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
	        })
	            .filter((x) => !!x); // filter nulls
	        if (ctx.common.async) {
	            return Promise.all(items).then((results) => {
	                return parseUtil_1.ParseStatus.mergeArray(status, results);
	            });
	        }
	        else {
	            return parseUtil_1.ParseStatus.mergeArray(status, items);
	        }
	    }
	    get items() {
	        return this._def.items;
	    }
	    rest(rest) {
	        return new ZodTuple({
	            ...this._def,
	            rest,
	        });
	    }
	}
	types$1.ZodTuple = ZodTuple;
	ZodTuple.create = (schemas, params) => {
	    if (!Array.isArray(schemas)) {
	        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	    }
	    return new ZodTuple({
	        items: schemas,
	        typeName: ZodFirstPartyTypeKind.ZodTuple,
	        rest: null,
	        ...processCreateParams(params),
	    });
	};
	class ZodRecord extends ZodType {
	    get keySchema() {
	        return this._def.keyType;
	    }
	    get valueSchema() {
	        return this._def.valueType;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.object) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.object,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const pairs = [];
	        const keyType = this._def.keyType;
	        const valueType = this._def.valueType;
	        for (const key in ctx.data) {
	            pairs.push({
	                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
	                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
	                alwaysSet: key in ctx.data,
	            });
	        }
	        if (ctx.common.async) {
	            return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
	        }
	        else {
	            return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
	        }
	    }
	    get element() {
	        return this._def.valueType;
	    }
	    static create(first, second, third) {
	        if (second instanceof ZodType) {
	            return new ZodRecord({
	                keyType: first,
	                valueType: second,
	                typeName: ZodFirstPartyTypeKind.ZodRecord,
	                ...processCreateParams(third),
	            });
	        }
	        return new ZodRecord({
	            keyType: ZodString.create(),
	            valueType: first,
	            typeName: ZodFirstPartyTypeKind.ZodRecord,
	            ...processCreateParams(second),
	        });
	    }
	}
	types$1.ZodRecord = ZodRecord;
	class ZodMap extends ZodType {
	    get keySchema() {
	        return this._def.keyType;
	    }
	    get valueSchema() {
	        return this._def.valueType;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.map) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.map,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const keyType = this._def.keyType;
	        const valueType = this._def.valueType;
	        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
	            return {
	                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
	                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
	            };
	        });
	        if (ctx.common.async) {
	            const finalMap = new Map();
	            return Promise.resolve().then(async () => {
	                for (const pair of pairs) {
	                    const key = await pair.key;
	                    const value = await pair.value;
	                    if (key.status === "aborted" || value.status === "aborted") {
	                        return parseUtil_1.INVALID;
	                    }
	                    if (key.status === "dirty" || value.status === "dirty") {
	                        status.dirty();
	                    }
	                    finalMap.set(key.value, value.value);
	                }
	                return { status: status.value, value: finalMap };
	            });
	        }
	        else {
	            const finalMap = new Map();
	            for (const pair of pairs) {
	                const key = pair.key;
	                const value = pair.value;
	                if (key.status === "aborted" || value.status === "aborted") {
	                    return parseUtil_1.INVALID;
	                }
	                if (key.status === "dirty" || value.status === "dirty") {
	                    status.dirty();
	                }
	                finalMap.set(key.value, value.value);
	            }
	            return { status: status.value, value: finalMap };
	        }
	    }
	}
	types$1.ZodMap = ZodMap;
	ZodMap.create = (keyType, valueType, params) => {
	    return new ZodMap({
	        valueType,
	        keyType,
	        typeName: ZodFirstPartyTypeKind.ZodMap,
	        ...processCreateParams(params),
	    });
	};
	class ZodSet extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.set) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.set,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const def = this._def;
	        if (def.minSize !== null) {
	            if (ctx.data.size < def.minSize.value) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: ZodError_1.ZodIssueCode.too_small,
	                    minimum: def.minSize.value,
	                    type: "set",
	                    inclusive: true,
	                    exact: false,
	                    message: def.minSize.message,
	                });
	                status.dirty();
	            }
	        }
	        if (def.maxSize !== null) {
	            if (ctx.data.size > def.maxSize.value) {
	                (0, parseUtil_1.addIssueToContext)(ctx, {
	                    code: ZodError_1.ZodIssueCode.too_big,
	                    maximum: def.maxSize.value,
	                    type: "set",
	                    inclusive: true,
	                    exact: false,
	                    message: def.maxSize.message,
	                });
	                status.dirty();
	            }
	        }
	        const valueType = this._def.valueType;
	        function finalizeSet(elements) {
	            const parsedSet = new Set();
	            for (const element of elements) {
	                if (element.status === "aborted")
	                    return parseUtil_1.INVALID;
	                if (element.status === "dirty")
	                    status.dirty();
	                parsedSet.add(element.value);
	            }
	            return { status: status.value, value: parsedSet };
	        }
	        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
	        if (ctx.common.async) {
	            return Promise.all(elements).then((elements) => finalizeSet(elements));
	        }
	        else {
	            return finalizeSet(elements);
	        }
	    }
	    min(minSize, message) {
	        return new ZodSet({
	            ...this._def,
	            minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) },
	        });
	    }
	    max(maxSize, message) {
	        return new ZodSet({
	            ...this._def,
	            maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) },
	        });
	    }
	    size(size, message) {
	        return this.min(size, message).max(size, message);
	    }
	    nonempty(message) {
	        return this.min(1, message);
	    }
	}
	types$1.ZodSet = ZodSet;
	ZodSet.create = (valueType, params) => {
	    return new ZodSet({
	        valueType,
	        minSize: null,
	        maxSize: null,
	        typeName: ZodFirstPartyTypeKind.ZodSet,
	        ...processCreateParams(params),
	    });
	};
	class ZodFunction extends ZodType {
	    constructor() {
	        super(...arguments);
	        this.validate = this.implement;
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.function) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.function,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        function makeArgsIssue(args, error) {
	            return (0, parseUtil_1.makeIssue)({
	                data: args,
	                path: ctx.path,
	                errorMaps: [
	                    ctx.common.contextualErrorMap,
	                    ctx.schemaErrorMap,
	                    (0, errors_1.getErrorMap)(),
	                    errors_1.defaultErrorMap,
	                ].filter((x) => !!x),
	                issueData: {
	                    code: ZodError_1.ZodIssueCode.invalid_arguments,
	                    argumentsError: error,
	                },
	            });
	        }
	        function makeReturnsIssue(returns, error) {
	            return (0, parseUtil_1.makeIssue)({
	                data: returns,
	                path: ctx.path,
	                errorMaps: [
	                    ctx.common.contextualErrorMap,
	                    ctx.schemaErrorMap,
	                    (0, errors_1.getErrorMap)(),
	                    errors_1.defaultErrorMap,
	                ].filter((x) => !!x),
	                issueData: {
	                    code: ZodError_1.ZodIssueCode.invalid_return_type,
	                    returnTypeError: error,
	                },
	            });
	        }
	        const params = { errorMap: ctx.common.contextualErrorMap };
	        const fn = ctx.data;
	        if (this._def.returns instanceof ZodPromise) {
	            // Would love a way to avoid disabling this rule, but we need
	            // an alias (using an arrow function was what caused 2651).
	            // eslint-disable-next-line @typescript-eslint/no-this-alias
	            const me = this;
	            return (0, parseUtil_1.OK)(async function (...args) {
	                const error = new ZodError_1.ZodError([]);
	                const parsedArgs = await me._def.args
	                    .parseAsync(args, params)
	                    .catch((e) => {
	                    error.addIssue(makeArgsIssue(args, e));
	                    throw error;
	                });
	                const result = await Reflect.apply(fn, this, parsedArgs);
	                const parsedReturns = await me._def.returns._def.type
	                    .parseAsync(result, params)
	                    .catch((e) => {
	                    error.addIssue(makeReturnsIssue(result, e));
	                    throw error;
	                });
	                return parsedReturns;
	            });
	        }
	        else {
	            // Would love a way to avoid disabling this rule, but we need
	            // an alias (using an arrow function was what caused 2651).
	            // eslint-disable-next-line @typescript-eslint/no-this-alias
	            const me = this;
	            return (0, parseUtil_1.OK)(function (...args) {
	                const parsedArgs = me._def.args.safeParse(args, params);
	                if (!parsedArgs.success) {
	                    throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
	                }
	                const result = Reflect.apply(fn, this, parsedArgs.data);
	                const parsedReturns = me._def.returns.safeParse(result, params);
	                if (!parsedReturns.success) {
	                    throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
	                }
	                return parsedReturns.data;
	            });
	        }
	    }
	    parameters() {
	        return this._def.args;
	    }
	    returnType() {
	        return this._def.returns;
	    }
	    args(...items) {
	        return new ZodFunction({
	            ...this._def,
	            args: ZodTuple.create(items).rest(ZodUnknown.create()),
	        });
	    }
	    returns(returnType) {
	        return new ZodFunction({
	            ...this._def,
	            returns: returnType,
	        });
	    }
	    implement(func) {
	        const validatedFunc = this.parse(func);
	        return validatedFunc;
	    }
	    strictImplement(func) {
	        const validatedFunc = this.parse(func);
	        return validatedFunc;
	    }
	    static create(args, returns, params) {
	        return new ZodFunction({
	            args: (args
	                ? args
	                : ZodTuple.create([]).rest(ZodUnknown.create())),
	            returns: returns || ZodUnknown.create(),
	            typeName: ZodFirstPartyTypeKind.ZodFunction,
	            ...processCreateParams(params),
	        });
	    }
	}
	types$1.ZodFunction = ZodFunction;
	class ZodLazy extends ZodType {
	    get schema() {
	        return this._def.getter();
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const lazySchema = this._def.getter();
	        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
	    }
	}
	types$1.ZodLazy = ZodLazy;
	ZodLazy.create = (getter, params) => {
	    return new ZodLazy({
	        getter: getter,
	        typeName: ZodFirstPartyTypeKind.ZodLazy,
	        ...processCreateParams(params),
	    });
	};
	class ZodLiteral extends ZodType {
	    _parse(input) {
	        if (input.data !== this._def.value) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                received: ctx.data,
	                code: ZodError_1.ZodIssueCode.invalid_literal,
	                expected: this._def.value,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return { status: "valid", value: input.data };
	    }
	    get value() {
	        return this._def.value;
	    }
	}
	types$1.ZodLiteral = ZodLiteral;
	ZodLiteral.create = (value, params) => {
	    return new ZodLiteral({
	        value: value,
	        typeName: ZodFirstPartyTypeKind.ZodLiteral,
	        ...processCreateParams(params),
	    });
	};
	function createZodEnum(values, params) {
	    return new ZodEnum({
	        values,
	        typeName: ZodFirstPartyTypeKind.ZodEnum,
	        ...processCreateParams(params),
	    });
	}
	class ZodEnum extends ZodType {
	    constructor() {
	        super(...arguments);
	        _ZodEnum_cache.set(this, void 0);
	    }
	    _parse(input) {
	        if (typeof input.data !== "string") {
	            const ctx = this._getOrReturnCtx(input);
	            const expectedValues = this._def.values;
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                expected: util_1.util.joinValues(expectedValues),
	                received: ctx.parsedType,
	                code: ZodError_1.ZodIssueCode.invalid_type,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
	            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
	        }
	        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
	            const ctx = this._getOrReturnCtx(input);
	            const expectedValues = this._def.values;
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                received: ctx.data,
	                code: ZodError_1.ZodIssueCode.invalid_enum_value,
	                options: expectedValues,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	    get options() {
	        return this._def.values;
	    }
	    get enum() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    get Values() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    get Enum() {
	        const enumValues = {};
	        for (const val of this._def.values) {
	            enumValues[val] = val;
	        }
	        return enumValues;
	    }
	    extract(values, newDef = this._def) {
	        return ZodEnum.create(values, {
	            ...this._def,
	            ...newDef,
	        });
	    }
	    exclude(values, newDef = this._def) {
	        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
	            ...this._def,
	            ...newDef,
	        });
	    }
	}
	types$1.ZodEnum = ZodEnum;
	_ZodEnum_cache = new WeakMap();
	ZodEnum.create = createZodEnum;
	class ZodNativeEnum extends ZodType {
	    constructor() {
	        super(...arguments);
	        _ZodNativeEnum_cache.set(this, void 0);
	    }
	    _parse(input) {
	        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
	        const ctx = this._getOrReturnCtx(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.string &&
	            ctx.parsedType !== util_1.ZodParsedType.number) {
	            const expectedValues = util_1.util.objectValues(nativeEnumValues);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                expected: util_1.util.joinValues(expectedValues),
	                received: ctx.parsedType,
	                code: ZodError_1.ZodIssueCode.invalid_type,
	            });
	            return parseUtil_1.INVALID;
	        }
	        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
	            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util_1.util.getValidEnumValues(this._def.values)), "f");
	        }
	        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
	            const expectedValues = util_1.util.objectValues(nativeEnumValues);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                received: ctx.data,
	                code: ZodError_1.ZodIssueCode.invalid_enum_value,
	                options: expectedValues,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return (0, parseUtil_1.OK)(input.data);
	    }
	    get enum() {
	        return this._def.values;
	    }
	}
	types$1.ZodNativeEnum = ZodNativeEnum;
	_ZodNativeEnum_cache = new WeakMap();
	ZodNativeEnum.create = (values, params) => {
	    return new ZodNativeEnum({
	        values: values,
	        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
	        ...processCreateParams(params),
	    });
	};
	class ZodPromise extends ZodType {
	    unwrap() {
	        return this._def.type;
	    }
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        if (ctx.parsedType !== util_1.ZodParsedType.promise &&
	            ctx.common.async === false) {
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.promise,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        const promisified = ctx.parsedType === util_1.ZodParsedType.promise
	            ? ctx.data
	            : Promise.resolve(ctx.data);
	        return (0, parseUtil_1.OK)(promisified.then((data) => {
	            return this._def.type.parseAsync(data, {
	                path: ctx.path,
	                errorMap: ctx.common.contextualErrorMap,
	            });
	        }));
	    }
	}
	types$1.ZodPromise = ZodPromise;
	ZodPromise.create = (schema, params) => {
	    return new ZodPromise({
	        type: schema,
	        typeName: ZodFirstPartyTypeKind.ZodPromise,
	        ...processCreateParams(params),
	    });
	};
	class ZodEffects extends ZodType {
	    innerType() {
	        return this._def.schema;
	    }
	    sourceType() {
	        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
	            ? this._def.schema.sourceType()
	            : this._def.schema;
	    }
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        const effect = this._def.effect || null;
	        const checkCtx = {
	            addIssue: (arg) => {
	                (0, parseUtil_1.addIssueToContext)(ctx, arg);
	                if (arg.fatal) {
	                    status.abort();
	                }
	                else {
	                    status.dirty();
	                }
	            },
	            get path() {
	                return ctx.path;
	            },
	        };
	        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
	        if (effect.type === "preprocess") {
	            const processed = effect.transform(ctx.data, checkCtx);
	            if (ctx.common.async) {
	                return Promise.resolve(processed).then(async (processed) => {
	                    if (status.value === "aborted")
	                        return parseUtil_1.INVALID;
	                    const result = await this._def.schema._parseAsync({
	                        data: processed,
	                        path: ctx.path,
	                        parent: ctx,
	                    });
	                    if (result.status === "aborted")
	                        return parseUtil_1.INVALID;
	                    if (result.status === "dirty")
	                        return (0, parseUtil_1.DIRTY)(result.value);
	                    if (status.value === "dirty")
	                        return (0, parseUtil_1.DIRTY)(result.value);
	                    return result;
	                });
	            }
	            else {
	                if (status.value === "aborted")
	                    return parseUtil_1.INVALID;
	                const result = this._def.schema._parseSync({
	                    data: processed,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (result.status === "aborted")
	                    return parseUtil_1.INVALID;
	                if (result.status === "dirty")
	                    return (0, parseUtil_1.DIRTY)(result.value);
	                if (status.value === "dirty")
	                    return (0, parseUtil_1.DIRTY)(result.value);
	                return result;
	            }
	        }
	        if (effect.type === "refinement") {
	            const executeRefinement = (acc) => {
	                const result = effect.refinement(acc, checkCtx);
	                if (ctx.common.async) {
	                    return Promise.resolve(result);
	                }
	                if (result instanceof Promise) {
	                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
	                }
	                return acc;
	            };
	            if (ctx.common.async === false) {
	                const inner = this._def.schema._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (inner.status === "aborted")
	                    return parseUtil_1.INVALID;
	                if (inner.status === "dirty")
	                    status.dirty();
	                // return value is ignored
	                executeRefinement(inner.value);
	                return { status: status.value, value: inner.value };
	            }
	            else {
	                return this._def.schema
	                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
	                    .then((inner) => {
	                    if (inner.status === "aborted")
	                        return parseUtil_1.INVALID;
	                    if (inner.status === "dirty")
	                        status.dirty();
	                    return executeRefinement(inner.value).then(() => {
	                        return { status: status.value, value: inner.value };
	                    });
	                });
	            }
	        }
	        if (effect.type === "transform") {
	            if (ctx.common.async === false) {
	                const base = this._def.schema._parseSync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (!(0, parseUtil_1.isValid)(base))
	                    return base;
	                const result = effect.transform(base.value, checkCtx);
	                if (result instanceof Promise) {
	                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
	                }
	                return { status: status.value, value: result };
	            }
	            else {
	                return this._def.schema
	                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
	                    .then((base) => {
	                    if (!(0, parseUtil_1.isValid)(base))
	                        return base;
	                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
	                });
	            }
	        }
	        util_1.util.assertNever(effect);
	    }
	}
	types$1.ZodEffects = ZodEffects;
	types$1.ZodTransformer = ZodEffects;
	ZodEffects.create = (schema, effect, params) => {
	    return new ZodEffects({
	        schema,
	        typeName: ZodFirstPartyTypeKind.ZodEffects,
	        effect,
	        ...processCreateParams(params),
	    });
	};
	ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	    return new ZodEffects({
	        schema,
	        effect: { type: "preprocess", transform: preprocess },
	        typeName: ZodFirstPartyTypeKind.ZodEffects,
	        ...processCreateParams(params),
	    });
	};
	class ZodOptional extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType === util_1.ZodParsedType.undefined) {
	            return (0, parseUtil_1.OK)(undefined);
	        }
	        return this._def.innerType._parse(input);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	types$1.ZodOptional = ZodOptional;
	ZodOptional.create = (type, params) => {
	    return new ZodOptional({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodOptional,
	        ...processCreateParams(params),
	    });
	};
	class ZodNullable extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType === util_1.ZodParsedType.null) {
	            return (0, parseUtil_1.OK)(null);
	        }
	        return this._def.innerType._parse(input);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	types$1.ZodNullable = ZodNullable;
	ZodNullable.create = (type, params) => {
	    return new ZodNullable({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodNullable,
	        ...processCreateParams(params),
	    });
	};
	class ZodDefault extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        let data = ctx.data;
	        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
	            data = this._def.defaultValue();
	        }
	        return this._def.innerType._parse({
	            data,
	            path: ctx.path,
	            parent: ctx,
	        });
	    }
	    removeDefault() {
	        return this._def.innerType;
	    }
	}
	types$1.ZodDefault = ZodDefault;
	ZodDefault.create = (type, params) => {
	    return new ZodDefault({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodDefault,
	        defaultValue: typeof params.default === "function"
	            ? params.default
	            : () => params.default,
	        ...processCreateParams(params),
	    });
	};
	class ZodCatch extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        // newCtx is used to not collect issues from inner types in ctx
	        const newCtx = {
	            ...ctx,
	            common: {
	                ...ctx.common,
	                issues: [],
	            },
	        };
	        const result = this._def.innerType._parse({
	            data: newCtx.data,
	            path: newCtx.path,
	            parent: {
	                ...newCtx,
	            },
	        });
	        if ((0, parseUtil_1.isAsync)(result)) {
	            return result.then((result) => {
	                return {
	                    status: "valid",
	                    value: result.status === "valid"
	                        ? result.value
	                        : this._def.catchValue({
	                            get error() {
	                                return new ZodError_1.ZodError(newCtx.common.issues);
	                            },
	                            input: newCtx.data,
	                        }),
	                };
	            });
	        }
	        else {
	            return {
	                status: "valid",
	                value: result.status === "valid"
	                    ? result.value
	                    : this._def.catchValue({
	                        get error() {
	                            return new ZodError_1.ZodError(newCtx.common.issues);
	                        },
	                        input: newCtx.data,
	                    }),
	            };
	        }
	    }
	    removeCatch() {
	        return this._def.innerType;
	    }
	}
	types$1.ZodCatch = ZodCatch;
	ZodCatch.create = (type, params) => {
	    return new ZodCatch({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodCatch,
	        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
	        ...processCreateParams(params),
	    });
	};
	class ZodNaN extends ZodType {
	    _parse(input) {
	        const parsedType = this._getType(input);
	        if (parsedType !== util_1.ZodParsedType.nan) {
	            const ctx = this._getOrReturnCtx(input);
	            (0, parseUtil_1.addIssueToContext)(ctx, {
	                code: ZodError_1.ZodIssueCode.invalid_type,
	                expected: util_1.ZodParsedType.nan,
	                received: ctx.parsedType,
	            });
	            return parseUtil_1.INVALID;
	        }
	        return { status: "valid", value: input.data };
	    }
	}
	types$1.ZodNaN = ZodNaN;
	ZodNaN.create = (params) => {
	    return new ZodNaN({
	        typeName: ZodFirstPartyTypeKind.ZodNaN,
	        ...processCreateParams(params),
	    });
	};
	types$1.BRAND = Symbol("zod_brand");
	class ZodBranded extends ZodType {
	    _parse(input) {
	        const { ctx } = this._processInputParams(input);
	        const data = ctx.data;
	        return this._def.type._parse({
	            data,
	            path: ctx.path,
	            parent: ctx,
	        });
	    }
	    unwrap() {
	        return this._def.type;
	    }
	}
	types$1.ZodBranded = ZodBranded;
	class ZodPipeline extends ZodType {
	    _parse(input) {
	        const { status, ctx } = this._processInputParams(input);
	        if (ctx.common.async) {
	            const handleAsync = async () => {
	                const inResult = await this._def.in._parseAsync({
	                    data: ctx.data,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	                if (inResult.status === "aborted")
	                    return parseUtil_1.INVALID;
	                if (inResult.status === "dirty") {
	                    status.dirty();
	                    return (0, parseUtil_1.DIRTY)(inResult.value);
	                }
	                else {
	                    return this._def.out._parseAsync({
	                        data: inResult.value,
	                        path: ctx.path,
	                        parent: ctx,
	                    });
	                }
	            };
	            return handleAsync();
	        }
	        else {
	            const inResult = this._def.in._parseSync({
	                data: ctx.data,
	                path: ctx.path,
	                parent: ctx,
	            });
	            if (inResult.status === "aborted")
	                return parseUtil_1.INVALID;
	            if (inResult.status === "dirty") {
	                status.dirty();
	                return {
	                    status: "dirty",
	                    value: inResult.value,
	                };
	            }
	            else {
	                return this._def.out._parseSync({
	                    data: inResult.value,
	                    path: ctx.path,
	                    parent: ctx,
	                });
	            }
	        }
	    }
	    static create(a, b) {
	        return new ZodPipeline({
	            in: a,
	            out: b,
	            typeName: ZodFirstPartyTypeKind.ZodPipeline,
	        });
	    }
	}
	types$1.ZodPipeline = ZodPipeline;
	class ZodReadonly extends ZodType {
	    _parse(input) {
	        const result = this._def.innerType._parse(input);
	        const freeze = (data) => {
	            if ((0, parseUtil_1.isValid)(data)) {
	                data.value = Object.freeze(data.value);
	            }
	            return data;
	        };
	        return (0, parseUtil_1.isAsync)(result)
	            ? result.then((data) => freeze(data))
	            : freeze(result);
	    }
	    unwrap() {
	        return this._def.innerType;
	    }
	}
	types$1.ZodReadonly = ZodReadonly;
	ZodReadonly.create = (type, params) => {
	    return new ZodReadonly({
	        innerType: type,
	        typeName: ZodFirstPartyTypeKind.ZodReadonly,
	        ...processCreateParams(params),
	    });
	};
	function custom(check, params = {}, 
	/**
	 * @deprecated
	 *
	 * Pass `fatal` into the params object instead:
	 *
	 * ```ts
	 * z.string().custom((val) => val.length > 5, { fatal: false })
	 * ```
	 *
	 */
	fatal) {
	    if (check)
	        return ZodAny.create().superRefine((data, ctx) => {
	            var _a, _b;
	            if (!check(data)) {
	                const p = typeof params === "function"
	                    ? params(data)
	                    : typeof params === "string"
	                        ? { message: params }
	                        : params;
	                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
	                const p2 = typeof p === "string" ? { message: p } : p;
	                ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
	            }
	        });
	    return ZodAny.create();
	}
	types$1.custom = custom;
	types$1.late = {
	    object: ZodObject.lazycreate,
	};
	var ZodFirstPartyTypeKind;
	(function (ZodFirstPartyTypeKind) {
	    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
	    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
	    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
	    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
	    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
	    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
	    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
	    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
	    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
	    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
	    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
	    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
	    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
	    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
	    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
	    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
	    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
	    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
	    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
	    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
	    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
	    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
	    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
	    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
	    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
	    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
	    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
	    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
	    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
	    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
	    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
	    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
	    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
	    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
	    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
	})(ZodFirstPartyTypeKind || (types$1.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));
	const instanceOfType = (
	// const instanceOfType = <T extends new (...args: any[]) => any>(
	cls, params = {
	    message: `Input not instance of ${cls.name}`,
	}) => custom((data) => data instanceof cls, params);
	types$1.instanceof = instanceOfType;
	const stringType = ZodString.create;
	types$1.string = stringType;
	const numberType = ZodNumber.create;
	types$1.number = numberType;
	const nanType = ZodNaN.create;
	types$1.nan = nanType;
	const bigIntType = ZodBigInt.create;
	types$1.bigint = bigIntType;
	const booleanType = ZodBoolean.create;
	types$1.boolean = booleanType;
	const dateType = ZodDate.create;
	types$1.date = dateType;
	const symbolType = ZodSymbol.create;
	types$1.symbol = symbolType;
	const undefinedType = ZodUndefined.create;
	types$1.undefined = undefinedType;
	const nullType = ZodNull.create;
	types$1.null = nullType;
	const anyType = ZodAny.create;
	types$1.any = anyType;
	const unknownType = ZodUnknown.create;
	types$1.unknown = unknownType;
	const neverType = ZodNever.create;
	types$1.never = neverType;
	const voidType = ZodVoid.create;
	types$1.void = voidType;
	const arrayType = ZodArray.create;
	types$1.array = arrayType;
	const objectType = ZodObject.create;
	types$1.object = objectType;
	const strictObjectType = ZodObject.strictCreate;
	types$1.strictObject = strictObjectType;
	const unionType = ZodUnion.create;
	types$1.union = unionType;
	const discriminatedUnionType = ZodDiscriminatedUnion.create;
	types$1.discriminatedUnion = discriminatedUnionType;
	const intersectionType = ZodIntersection.create;
	types$1.intersection = intersectionType;
	const tupleType = ZodTuple.create;
	types$1.tuple = tupleType;
	const recordType = ZodRecord.create;
	types$1.record = recordType;
	const mapType = ZodMap.create;
	types$1.map = mapType;
	const setType = ZodSet.create;
	types$1.set = setType;
	const functionType = ZodFunction.create;
	types$1.function = functionType;
	const lazyType = ZodLazy.create;
	types$1.lazy = lazyType;
	const literalType = ZodLiteral.create;
	types$1.literal = literalType;
	const enumType = ZodEnum.create;
	types$1.enum = enumType;
	const nativeEnumType = ZodNativeEnum.create;
	types$1.nativeEnum = nativeEnumType;
	const promiseType = ZodPromise.create;
	types$1.promise = promiseType;
	const effectsType = ZodEffects.create;
	types$1.effect = effectsType;
	types$1.transformer = effectsType;
	const optionalType = ZodOptional.create;
	types$1.optional = optionalType;
	const nullableType = ZodNullable.create;
	types$1.nullable = nullableType;
	const preprocessType = ZodEffects.createWithPreprocess;
	types$1.preprocess = preprocessType;
	const pipelineType = ZodPipeline.create;
	types$1.pipeline = pipelineType;
	const ostring = () => stringType().optional();
	types$1.ostring = ostring;
	const onumber = () => numberType().optional();
	types$1.onumber = onumber;
	const oboolean = () => booleanType().optional();
	types$1.oboolean = oboolean;
	types$1.coerce = {
	    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
	    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
	    boolean: ((arg) => ZodBoolean.create({
	        ...arg,
	        coerce: true,
	    })),
	    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
	    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
	};
	types$1.NEVER = parseUtil_1.INVALID;
	return types$1;
}

var hasRequiredExternal;

function requireExternal () {
	if (hasRequiredExternal) return external;
	hasRequiredExternal = 1;
	(function (exports) {
		var __createBinding = (external && external.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (external && external.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(/*@__PURE__*/ requireErrors$1(), exports);
		__exportStar(/*@__PURE__*/ requireParseUtil(), exports);
		__exportStar(/*@__PURE__*/ requireTypeAliases(), exports);
		__exportStar(/*@__PURE__*/ requireUtil(), exports);
		__exportStar(/*@__PURE__*/ requireTypes$1(), exports);
		__exportStar(/*@__PURE__*/ requireZodError(), exports); 
	} (external));
	return external;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;
	(function (exports) {
		var __createBinding = (lib$1 && lib$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (lib$1 && lib$1.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (lib$1 && lib$1.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __exportStar = (lib$1 && lib$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.z = void 0;
		const z = __importStar(/*@__PURE__*/ requireExternal());
		exports.z = z;
		__exportStar(/*@__PURE__*/ requireExternal(), exports);
		exports.default = z; 
	} (lib$1));
	return lib$1;
}

var AllowableEnvVars = {};

var hasRequiredAllowableEnvVars;

function requireAllowableEnvVars () {
	if (hasRequiredAllowableEnvVars) return AllowableEnvVars;
	hasRequiredAllowableEnvVars = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.allowableEnvVarsSchema = exports.allowableEnvVarKeysSchema = exports.allowableEnvVarKeys = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.allowableEnvVarKeys = ["HSA_OVERRIDE_GFX_VERSION"];
		exports.allowableEnvVarKeysSchema = zod_1.z.enum(exports.allowableEnvVarKeys);
		exports.allowableEnvVarsSchema = zod_1.z.record(exports.allowableEnvVarKeysSchema, zod_1.z.string());
		
	} (AllowableEnvVars));
	return AllowableEnvVars;
}

var ArtifactManifest = {};

var ModelManifest = {};

var ArtifactManifestBase = {};

var kebab = {};

var hasRequiredKebab;

function requireKebab () {
	if (hasRequiredKebab) return kebab;
	hasRequiredKebab = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.kebabCaseWithDotsSchema = exports.kebabCaseWithDotsRegex = exports.kebabCaseSchema = exports.kebabCaseRegex = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.kebabCaseRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
		exports.kebabCaseSchema = zod_1.z.string().regex(exports.kebabCaseRegex);
		exports.kebabCaseWithDotsRegex = /^[a-z0-9]+(?:[-.][a-z0-9]+)*$/;
		exports.kebabCaseWithDotsSchema = zod_1.z.string().regex(exports.kebabCaseWithDotsRegex);
		
	} (kebab));
	return kebab;
}

var ModelDownloadSource = {};

var path = {};

var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path;
	hasRequiredPath = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.relativePathNoLeadingDotSlashSchema = exports.relativePathNoLeadingDotSlashRegex = exports.fileNameSchema = exports.fileNameRegex = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		/**
		 * Matches valid file names
		 */
		exports.fileNameRegex = /^[\p{L}\p{N}!@#$%^&()\-_+=,.;'[\]{}~`][\p{L}\p{N}!@#$%^&()\-_+=,.;'[\]{}~` ]*(?<![. ])$/u;
		exports.fileNameSchema = zod_1.z.string().regex(exports.fileNameRegex, { message: "Invalid file name" });
		/**
		 * Matches paths like:
		 *
		 * a/b/c
		 */
		exports.relativePathNoLeadingDotSlashRegex = /^[\p{L}\p{N}!@#$%^&()\-_+=,.;'[\]{}~`][\p{L}\p{N}!@#$%^&()\-_+=,.;'[\]{}~` ]*(?<![. ])(?:\/[\p{L}\p{N}!@#$%^&()\-_+=,.;'[\]{}~`][\p{L}\p{N}!@#$%^&()\-_+=,.;'[\]{}~` ]*(?<![. ]))*$/u;
		exports.relativePathNoLeadingDotSlashSchema = zod_1.z
		    .string()
		    .regex(exports.relativePathNoLeadingDotSlashRegex, {
		    message: "Invalid relative path",
		});
		
	} (path));
	return path;
}

var hasRequiredModelDownloadSource;

function requireModelDownloadSource () {
	if (hasRequiredModelDownloadSource) return ModelDownloadSource;
	hasRequiredModelDownloadSource = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.modelDownloadSourceSchema = exports.huggingFaceModelDownloadSourceSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const path_js_1 = /*@__PURE__*/ requirePath();
		exports.huggingFaceModelDownloadSourceSchema = zod_1.z.object({
		    type: zod_1.z.literal("huggingface"),
		    user: path_js_1.fileNameSchema,
		    repo: path_js_1.fileNameSchema,
		});
		exports.modelDownloadSourceSchema = zod_1.z.discriminatedUnion("type", [exports.huggingFaceModelDownloadSourceSchema]);
		
	} (ModelDownloadSource));
	return ModelDownloadSource;
}

var hasRequiredArtifactManifestBase;

function requireArtifactManifestBase () {
	if (hasRequiredArtifactManifestBase) return ArtifactManifestBase;
	hasRequiredArtifactManifestBase = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.artifactManifestBaseSchema = exports.artifactDependencySchema = exports.artifactArtifactDependencySchema = exports.artifactModelDependencySchema = exports.artifactDependencyBaseSchema = exports.artifactDependencyPurposeSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const kebab_js_1 = /*@__PURE__*/ requireKebab();
		const ModelDownloadSource_js_1 = /*@__PURE__*/ requireModelDownloadSource();
		exports.artifactDependencyPurposeSchema = zod_1.z.enum([
		    "baseModel",
		    "draftModel",
		    "custom",
		]);
		exports.artifactDependencyBaseSchema = zod_1.z.object({
		    purpose: exports.artifactDependencyPurposeSchema,
		});
		exports.artifactModelDependencySchema = zod_1.z.object({
		    type: zod_1.z.literal("model"),
		    ...exports.artifactDependencyBaseSchema.shape,
		    modelKeys: zod_1.z.array(zod_1.z.string().min(1)),
		    sources: zod_1.z.array(ModelDownloadSource_js_1.modelDownloadSourceSchema),
		});
		exports.artifactArtifactDependencySchema = zod_1.z.object({
		    type: zod_1.z.literal("artifact"),
		    ...exports.artifactDependencyBaseSchema.shape,
		    owner: kebab_js_1.kebabCaseSchema,
		    name: kebab_js_1.kebabCaseWithDotsSchema,
		});
		exports.artifactDependencySchema = zod_1.z.discriminatedUnion("type", [
		    exports.artifactModelDependencySchema,
		    exports.artifactArtifactDependencySchema,
		]);
		exports.artifactManifestBaseSchema = zod_1.z.object({
		    owner: kebab_js_1.kebabCaseSchema,
		    name: kebab_js_1.kebabCaseWithDotsSchema.min(1, "Name is required").max(100, "Name too long"),
		    description: zod_1.z.string().max(1000, "Description too long"),
		    revision: zod_1.z.number().int().optional(),
		    dependencies: zod_1.z.array(exports.artifactDependencySchema).optional(),
		    tags: zod_1.z.array(zod_1.z.string()).optional(),
		});
		
	} (ArtifactManifestBase));
	return ArtifactManifestBase;
}

var hasRequiredModelManifest;

function requireModelManifest () {
	if (hasRequiredModelManifest) return ModelManifest;
	hasRequiredModelManifest = 1;
	Object.defineProperty(ModelManifest, "__esModule", { value: true });
	ModelManifest.modelManifestSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	const ArtifactManifestBase_js_1 = /*@__PURE__*/ requireArtifactManifestBase();
	ModelManifest.modelManifestSchema = zod_1.z.object({
	    type: zod_1.z.literal("model"),
	    ...ArtifactManifestBase_js_1.artifactManifestBaseSchema.shape,
	});
	
	return ModelManifest;
}

var PluginManifest = {};

var hasRequiredPluginManifest;

function requirePluginManifest () {
	if (hasRequiredPluginManifest) return PluginManifest;
	hasRequiredPluginManifest = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.pluginManifestSchema = exports.pluginRunnerTypeSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const ArtifactManifestBase_js_1 = /*@__PURE__*/ requireArtifactManifestBase();
		exports.pluginRunnerTypeSchema = zod_1.z.enum(["ecmascript"]);
		exports.pluginManifestSchema = zod_1.z.object({
		    type: zod_1.z.literal("plugin"),
		    runner: exports.pluginRunnerTypeSchema,
		    ...ArtifactManifestBase_js_1.artifactManifestBaseSchema.shape,
		});
		
	} (PluginManifest));
	return PluginManifest;
}

var PresetManifest = {};

var hasRequiredPresetManifest;

function requirePresetManifest () {
	if (hasRequiredPresetManifest) return PresetManifest;
	hasRequiredPresetManifest = 1;
	Object.defineProperty(PresetManifest, "__esModule", { value: true });
	PresetManifest.presetManifestSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	const ArtifactManifestBase_js_1 = /*@__PURE__*/ requireArtifactManifestBase();
	PresetManifest.presetManifestSchema = zod_1.z.object({
	    type: zod_1.z.literal("preset"),
	    ...ArtifactManifestBase_js_1.artifactManifestBaseSchema.shape,
	});
	
	return PresetManifest;
}

var hasRequiredArtifactManifest;

function requireArtifactManifest () {
	if (hasRequiredArtifactManifest) return ArtifactManifest;
	hasRequiredArtifactManifest = 1;
	Object.defineProperty(ArtifactManifest, "__esModule", { value: true });
	ArtifactManifest.artifactTypeSchema = ArtifactManifest.artifactManifestSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	const ModelManifest_js_1 = /*@__PURE__*/ requireModelManifest();
	const PluginManifest_js_1 = /*@__PURE__*/ requirePluginManifest();
	const PresetManifest_js_1 = /*@__PURE__*/ requirePresetManifest();
	ArtifactManifest.artifactManifestSchema = zod_1.z.discriminatedUnion("type", [
	    PluginManifest_js_1.pluginManifestSchema,
	    PresetManifest_js_1.presetManifestSchema,
	    ModelManifest_js_1.modelManifestSchema,
	]);
	ArtifactManifest.artifactTypeSchema = zod_1.z.enum(["plugin", "preset", "model"]);
	
	return ArtifactManifest;
}

var BackendNotification = {};

var hasRequiredBackendNotification;

function requireBackendNotification () {
	if (hasRequiredBackendNotification) return BackendNotification;
	hasRequiredBackendNotification = 1;
	Object.defineProperty(BackendNotification, "__esModule", { value: true });
	BackendNotification.backendNotificationSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	BackendNotification.backendNotificationSchema = zod_1.z.object({
	    title: zod_1.z.string(),
	    description: zod_1.z.string().optional(),
	    noAutoDismiss: zod_1.z.boolean().optional(),
	});
	
	return BackendNotification;
}

var ChatHistoryData = {};

var FileType = {};

var hasRequiredFileType;

function requireFileType () {
	if (hasRequiredFileType) return FileType;
	hasRequiredFileType = 1;
	Object.defineProperty(FileType, "__esModule", { value: true });
	FileType.fileTypeSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	FileType.fileTypeSchema = zod_1.z.enum([
	    "image",
	    "text/plain",
	    "application/pdf",
	    "application/word",
	    "text/other",
	    "unknown",
	]);
	
	return FileType;
}

var JSONSerializable = {};

var hasRequiredJSONSerializable;

function requireJSONSerializable () {
	if (hasRequiredJSONSerializable) return JSONSerializable;
	hasRequiredJSONSerializable = 1;
	Object.defineProperty(JSONSerializable, "__esModule", { value: true });
	JSONSerializable.jsonSerializableSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	JSONSerializable.jsonSerializableSchema = zod_1.z.any().transform((val, ctx) => {
	    try {
	        // Needs a more performant way to do this.
	        return JSON.parse(JSON.stringify(val));
	    }
	    catch (e) {
	        ctx.addIssue({
	            code: zod_1.z.ZodIssueCode.custom,
	            message: "Not JSON serializable: " + e.message,
	        });
	        return val;
	    }
	});
	
	return JSONSerializable;
}

var hasRequiredChatHistoryData;

function requireChatHistoryData () {
	if (hasRequiredChatHistoryData) return ChatHistoryData;
	hasRequiredChatHistoryData = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.chatHistoryDataSchema = exports.chatMessageDataSchema = exports.chatMessageRoleDataSchema = exports.chatMessagePartDataSchema = exports.chatMessagePartToolCallResultDataSchema = exports.chatMessagePartToolCallRequestDataSchema = exports.toolCallRequestSchema = exports.functionToolCallRequestSchema = exports.chatMessagePartFileDataSchema = exports.chatMessagePartTextDataSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const FileType_js_1 = /*@__PURE__*/ requireFileType();
		const JSONSerializable_js_1 = /*@__PURE__*/ requireJSONSerializable();
		exports.chatMessagePartTextDataSchema = zod_1.z.object({
		    type: zod_1.z.literal("text"),
		    text: zod_1.z.string(),
		});
		exports.chatMessagePartFileDataSchema = zod_1.z.object({
		    type: zod_1.z.literal("file"),
		    name: zod_1.z.string(),
		    identifier: zod_1.z.string(),
		    sizeBytes: zod_1.z.number().int(),
		    fileType: FileType_js_1.fileTypeSchema,
		});
		exports.functionToolCallRequestSchema = zod_1.z.object({
		    id: zod_1.z.string().optional(),
		    type: zod_1.z.literal("function"),
		    arguments: zod_1.z.record(JSONSerializable_js_1.jsonSerializableSchema).optional(),
		    name: zod_1.z.string(),
		});
		exports.toolCallRequestSchema = zod_1.z.discriminatedUnion("type", [
		    exports.functionToolCallRequestSchema,
		]);
		exports.chatMessagePartToolCallRequestDataSchema = zod_1.z.object({
		    type: zod_1.z.literal("toolCallRequest"),
		    toolCallRequest: exports.toolCallRequestSchema,
		});
		exports.chatMessagePartToolCallResultDataSchema = zod_1.z.object({
		    type: zod_1.z.literal("toolCallResult"),
		    content: zod_1.z.string(),
		    toolCallId: zod_1.z.string().optional(),
		});
		exports.chatMessagePartDataSchema = zod_1.z.discriminatedUnion("type", [
		    exports.chatMessagePartTextDataSchema,
		    exports.chatMessagePartFileDataSchema,
		    exports.chatMessagePartToolCallRequestDataSchema,
		    exports.chatMessagePartToolCallResultDataSchema,
		]);
		exports.chatMessageRoleDataSchema = zod_1.z.enum(["assistant", "user", "system", "tool"]);
		exports.chatMessageDataSchema = zod_1.z.discriminatedUnion("role", [
		    zod_1.z.object({
		        role: zod_1.z.literal("assistant"),
		        content: zod_1.z.array(zod_1.z.discriminatedUnion("type", [
		            exports.chatMessagePartTextDataSchema,
		            exports.chatMessagePartFileDataSchema,
		            exports.chatMessagePartToolCallRequestDataSchema,
		        ])),
		    }),
		    zod_1.z.object({
		        role: zod_1.z.literal("user"),
		        content: zod_1.z.array(zod_1.z.discriminatedUnion("type", [exports.chatMessagePartTextDataSchema, exports.chatMessagePartFileDataSchema])),
		    }),
		    zod_1.z.object({
		        role: zod_1.z.literal("system"),
		        content: zod_1.z.array(zod_1.z.discriminatedUnion("type", [exports.chatMessagePartTextDataSchema, exports.chatMessagePartFileDataSchema])),
		    }),
		    zod_1.z.object({
		        role: zod_1.z.literal("tool"),
		        content: zod_1.z.array(exports.chatMessagePartToolCallResultDataSchema),
		    }),
		]);
		exports.chatHistoryDataSchema = zod_1.z.object({
		    messages: zod_1.z.array(exports.chatMessageDataSchema),
		});
		
	} (ChatHistoryData));
	return ChatHistoryData;
}

var CitationSource = {};

var hasRequiredCitationSource;

function requireCitationSource () {
	if (hasRequiredCitationSource) return CitationSource;
	hasRequiredCitationSource = 1;
	Object.defineProperty(CitationSource, "__esModule", { value: true });
	CitationSource.citationSourceSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	CitationSource.citationSourceSchema = zod_1.z.object({
	    fileName: zod_1.z.string(),
	    absoluteFilePath: zod_1.z.string().optional(),
	    pageNumber: zod_1.z.union([zod_1.z.number().int(), zod_1.z.tuple([zod_1.z.number().int(), zod_1.z.number().int()])]).optional(),
	    lineNumber: zod_1.z.union([zod_1.z.number().int(), zod_1.z.tuple([zod_1.z.number().int(), zod_1.z.number().int()])]).optional(),
	});
	
	return CitationSource;
}

var ColorPalette = {};

var hasRequiredColorPalette;

function requireColorPalette () {
	if (hasRequiredColorPalette) return ColorPalette;
	hasRequiredColorPalette = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.colorPaletteSchema = exports.colorPalette = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		/**
		 * @deprecated Use colorPaletteSchema instead.
		 */
		exports.colorPalette = zod_1.z.enum([
		    "red",
		    "green",
		    "blue",
		    "yellow",
		    "orange",
		    "purple",
		    "default",
		]);
		exports.colorPaletteSchema = exports.colorPalette;
		
	} (ColorPalette));
	return ColorPalette;
}

var DiagnosticsLogEvent = {};

var hasRequiredDiagnosticsLogEvent;

function requireDiagnosticsLogEvent () {
	if (hasRequiredDiagnosticsLogEvent) return DiagnosticsLogEvent;
	hasRequiredDiagnosticsLogEvent = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.diagnosticsLogEventSchema = exports.diagnosticsLogEventDataSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.diagnosticsLogEventDataSchema = zod_1.z.discriminatedUnion("type", [
		    zod_1.z.object({
		        type: zod_1.z.literal("llm.prediction.input"),
		        modelPath: zod_1.z.string(),
		        modelIdentifier: zod_1.z.string(),
		        input: zod_1.z.string(),
		    }),
		]);
		exports.diagnosticsLogEventSchema = zod_1.z.object({
		    timestamp: zod_1.z.number(),
		    data: exports.diagnosticsLogEventDataSchema,
		});
		
	} (DiagnosticsLogEvent));
	return DiagnosticsLogEvent;
}

var EmbeddingLoadModelConfig = {};

var LLMLoadModelConfig = {};

var hasRequiredLLMLoadModelConfig;

function requireLLMLoadModelConfig () {
	if (hasRequiredLLMLoadModelConfig) return LLMLoadModelConfig;
	hasRequiredLLMLoadModelConfig = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.llmLoadModelConfigSchema = exports.llmMlxKvCacheQuantizationSchema = exports.llmMlxKvCacheGroupSizeTypesSchema = exports.llmMlxKvCacheGroupSizeTypes = exports.llmMlxKvCacheBitsTypeSchema = exports.llmMlxKvCacheBitsTypes = exports.llmLlamaCacheQuantizationTypeSchema = exports.llmLlamaCacheQuantizationTypes = exports.gpuSettingSchema = exports.llmSplitStrategySchema = exports.llmLlamaAccelerationOffloadRatioSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.llmLlamaAccelerationOffloadRatioSchema = zod_1.z.union([
		    zod_1.z.number().min(0).max(1),
		    zod_1.z.literal("max"),
		    zod_1.z.literal("off"),
		]);
		exports.llmSplitStrategySchema = zod_1.z.enum(["evenly", "favorMainGpu"]);
		exports.gpuSettingSchema = zod_1.z.object({
		    ratio: exports.llmLlamaAccelerationOffloadRatioSchema.optional(),
		    mainGpu: zod_1.z.number().int().optional(),
		    splitStrategy: exports.llmSplitStrategySchema.optional(),
		    disabledGpus: zod_1.z.array(zod_1.z.number().int()).optional(),
		});
		exports.llmLlamaCacheQuantizationTypes = [
		    "f32",
		    "f16",
		    "q8_0",
		    "q4_0",
		    "q4_1",
		    "iq4_nl",
		    "q5_0",
		    "q5_1",
		];
		exports.llmLlamaCacheQuantizationTypeSchema = zod_1.z.enum(exports.llmLlamaCacheQuantizationTypes);
		// MLX KV cache quantization
		exports.llmMlxKvCacheBitsTypes = [8, 6, 4, 3, 2];
		exports.llmMlxKvCacheBitsTypeSchema = zod_1.z.union([
		    zod_1.z.literal(8),
		    zod_1.z.literal(6),
		    zod_1.z.literal(4),
		    zod_1.z.literal(3),
		    zod_1.z.literal(2),
		]);
		exports.llmMlxKvCacheGroupSizeTypes = [32, 64, 128];
		exports.llmMlxKvCacheGroupSizeTypesSchema = zod_1.z.union([
		    zod_1.z.literal(32),
		    zod_1.z.literal(64),
		    zod_1.z.literal(128),
		]);
		exports.llmMlxKvCacheQuantizationSchema = zod_1.z.object({
		    enabled: zod_1.z.boolean(),
		    bits: exports.llmMlxKvCacheBitsTypeSchema,
		    groupSize: exports.llmMlxKvCacheGroupSizeTypesSchema,
		    quantizedStart: zod_1.z.number().int().nonnegative(),
		});
		exports.llmLoadModelConfigSchema = zod_1.z.object({
		    gpu: exports.gpuSettingSchema.optional(),
		    gpuStrictVramCap: zod_1.z.boolean().optional(),
		    contextLength: zod_1.z.number().int().min(1).optional(),
		    ropeFrequencyBase: zod_1.z.number().optional(),
		    ropeFrequencyScale: zod_1.z.number().optional(),
		    evalBatchSize: zod_1.z.number().int().min(1).optional(),
		    flashAttention: zod_1.z.boolean().optional(),
		    keepModelInMemory: zod_1.z.boolean().optional(),
		    seed: zod_1.z.number().int().optional(),
		    useFp16ForKVCache: zod_1.z.boolean().optional(),
		    tryMmap: zod_1.z.boolean().optional(),
		    numExperts: zod_1.z.number().int().optional(),
		    llamaKCacheQuantizationType: zod_1.z
		        .enum(exports.llmLlamaCacheQuantizationTypes)
		        .or(zod_1.z.literal(false))
		        .optional(),
		    llamaVCacheQuantizationType: zod_1.z
		        .enum(exports.llmLlamaCacheQuantizationTypes)
		        .or(zod_1.z.literal(false))
		        .optional(),
		});
		
	} (LLMLoadModelConfig));
	return LLMLoadModelConfig;
}

var hasRequiredEmbeddingLoadModelConfig;

function requireEmbeddingLoadModelConfig () {
	if (hasRequiredEmbeddingLoadModelConfig) return EmbeddingLoadModelConfig;
	hasRequiredEmbeddingLoadModelConfig = 1;
	Object.defineProperty(EmbeddingLoadModelConfig, "__esModule", { value: true });
	EmbeddingLoadModelConfig.embeddingLoadModelConfigSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	const LLMLoadModelConfig_js_1 = /*@__PURE__*/ requireLLMLoadModelConfig();
	EmbeddingLoadModelConfig.embeddingLoadModelConfigSchema = zod_1.z.object({
	    gpu: LLMLoadModelConfig_js_1.gpuSettingSchema.optional(),
	    contextLength: zod_1.z.number().int().min(1).optional(),
	    ropeFrequencyBase: zod_1.z.number().optional(),
	    ropeFrequencyScale: zod_1.z.number().optional(),
	    keepModelInMemory: zod_1.z.boolean().optional(),
	    tryMmap: zod_1.z.boolean().optional(),
	});
	
	return EmbeddingLoadModelConfig;
}

var EmbeddingModelInfo = {};

var ModelInfoBase = {};

var ModelCompatibilityType = {};

var hasRequiredModelCompatibilityType;

function requireModelCompatibilityType () {
	if (hasRequiredModelCompatibilityType) return ModelCompatibilityType;
	hasRequiredModelCompatibilityType = 1;
	Object.defineProperty(ModelCompatibilityType, "__esModule", { value: true });
	ModelCompatibilityType.modelCompatibilityTypeSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	ModelCompatibilityType.modelCompatibilityTypeSchema = zod_1.z.enum([
	    "gguf",
	    "safetensors",
	    "onnx",
	    "ggml",
	    "mlx_placeholder",
	    "torch_safetensors",
	]);
	
	return ModelCompatibilityType;
}

var hasRequiredModelInfoBase;

function requireModelInfoBase () {
	if (hasRequiredModelInfoBase) return ModelInfoBase;
	hasRequiredModelInfoBase = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.modelInstanceInfoBaseSchema = exports.modelInfoBaseSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const ModelCompatibilityType_1 = /*@__PURE__*/ requireModelCompatibilityType();
		exports.modelInfoBaseSchema = zod_1.z.object({
		    modelKey: zod_1.z.string(),
		    format: ModelCompatibilityType_1.modelCompatibilityTypeSchema,
		    displayName: zod_1.z.string(),
		    path: zod_1.z.string(),
		    sizeBytes: zod_1.z.number().int(),
		    paramsString: zod_1.z.string().optional(),
		    architecture: zod_1.z.string().optional(),
		});
		exports.modelInstanceInfoBaseSchema = exports.modelInfoBaseSchema.extend({
		    identifier: zod_1.z.string(),
		    instanceReference: zod_1.z.string(),
		});
		
	} (ModelInfoBase));
	return ModelInfoBase;
}

var hasRequiredEmbeddingModelInfo;

function requireEmbeddingModelInfo () {
	if (hasRequiredEmbeddingModelInfo) return EmbeddingModelInfo;
	hasRequiredEmbeddingModelInfo = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.embeddingModelInstanceInfoSchema = exports.embeddingModelInfoSchema = exports.embeddingModelInstanceAdditionalInfoSchema = exports.embeddingModelAdditionalInfoSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const ModelInfoBase_js_1 = /*@__PURE__*/ requireModelInfoBase();
		exports.embeddingModelAdditionalInfoSchema = zod_1.z.object({
		    maxContextLength: zod_1.z.number().int(),
		});
		exports.embeddingModelInstanceAdditionalInfoSchema = zod_1.z.object({
		    contextLength: zod_1.z.number().int(),
		});
		exports.embeddingModelInfoSchema = zod_1.z
		    .object({
		    type: zod_1.z.literal("embedding"),
		})
		    .extend(ModelInfoBase_js_1.modelInfoBaseSchema.shape)
		    .extend(exports.embeddingModelAdditionalInfoSchema.shape);
		exports.embeddingModelInstanceInfoSchema = zod_1.z
		    .object({ type: zod_1.z.literal("embedding") })
		    .extend(ModelInfoBase_js_1.modelInstanceInfoBaseSchema.shape)
		    .extend(exports.embeddingModelAdditionalInfoSchema.shape)
		    .extend(exports.embeddingModelInstanceAdditionalInfoSchema.shape);
		
	} (EmbeddingModelInfo));
	return EmbeddingModelInfo;
}

var _Error = {};

var GenericErrorDisplayData = {};

var ModelDomainType = {};

var hasRequiredModelDomainType;

function requireModelDomainType () {
	if (hasRequiredModelDomainType) return ModelDomainType;
	hasRequiredModelDomainType = 1;
	Object.defineProperty(ModelDomainType, "__esModule", { value: true });
	ModelDomainType.modelDomainTypeSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	ModelDomainType.modelDomainTypeSchema = zod_1.z.enum([
	    "llm",
	    "embedding",
	    "imageGen",
	    "transcription",
	    "tts",
	]);
	
	return ModelDomainType;
}

var ModelSpecifier = {};

var reasonable = {};

var hasRequiredReasonable;

function requireReasonable () {
	if (hasRequiredReasonable) return reasonable;
	hasRequiredReasonable = 1;
	Object.defineProperty(reasonable, "__esModule", { value: true });
	reasonable.reasonableKeyStringSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	/**
	 * A string that is reasonable to use as a key. For example, as preset name, model path, or model
	 * identifier.
	 */
	reasonable.reasonableKeyStringSchema = zod_1.z
	    .string()
	    .min(1)
	    .max(1024)
	    .refine(value => value !== "__proto__", {
	    message: 'For security reasons, "__proto__" is not allowed',
	})
	    .refine(value => /\p{C}/u.test(value) === false, {
	    message: "Control characters are not allowed",
	});
	
	return reasonable;
}

var hasRequiredModelSpecifier;

function requireModelSpecifier () {
	if (hasRequiredModelSpecifier) return ModelSpecifier;
	hasRequiredModelSpecifier = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.modelSpecifierSchema = exports.modelQuerySchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const ModelDomainType_js_1 = /*@__PURE__*/ requireModelDomainType();
		const reasonable_js_1 = /*@__PURE__*/ requireReasonable();
		exports.modelQuerySchema = zod_1.z.object({
		    domain: ModelDomainType_js_1.modelDomainTypeSchema.optional(),
		    identifier: reasonable_js_1.reasonableKeyStringSchema.optional(),
		    path: reasonable_js_1.reasonableKeyStringSchema.optional(),
		    vision: zod_1.z.boolean().optional(),
		});
		exports.modelSpecifierSchema = zod_1.z.discriminatedUnion("type", [
		    zod_1.z.object({
		        type: zod_1.z.literal("query"),
		        query: exports.modelQuerySchema,
		    }),
		    zod_1.z.object({
		        type: zod_1.z.literal("instanceReference"),
		        instanceReference: zod_1.z.string(),
		    }),
		]);
		
	} (ModelSpecifier));
	return ModelSpecifier;
}

var hasRequiredGenericErrorDisplayData;

function requireGenericErrorDisplayData () {
	if (hasRequiredGenericErrorDisplayData) return GenericErrorDisplayData;
	hasRequiredGenericErrorDisplayData = 1;
	Object.defineProperty(GenericErrorDisplayData, "__esModule", { value: true });
	GenericErrorDisplayData.genericErrorDisplayDataSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	const ModelDomainType_js_1 = /*@__PURE__*/ requireModelDomainType();
	const ModelSpecifier_js_1 = /*@__PURE__*/ requireModelSpecifier();
	GenericErrorDisplayData.genericErrorDisplayDataSchema = [
	    zod_1.z.object({
	        code: zod_1.z.literal("generic.specificModelUnloaded"),
	    }),
	    zod_1.z.object({
	        code: zod_1.z.literal("generic.noModelMatchingQuery"),
	        query: ModelSpecifier_js_1.modelQuerySchema,
	        loadedModelsSample: zod_1.z.array(zod_1.z.string()),
	        totalLoadedModels: zod_1.z.number().int(),
	    }),
	    zod_1.z.object({
	        code: zod_1.z.literal("generic.pathNotFound"),
	        path: zod_1.z.string(),
	        availablePathsSample: zod_1.z.array(zod_1.z.string()),
	        totalModels: zod_1.z.number().int(),
	    }),
	    zod_1.z.object({
	        code: zod_1.z.literal("generic.identifierNotFound"),
	        identifier: zod_1.z.string(),
	        loadedModelsSample: zod_1.z.array(zod_1.z.string()),
	        totalLoadedModels: zod_1.z.number().int(),
	    }),
	    zod_1.z.object({
	        code: zod_1.z.literal("generic.domainMismatch"),
	        path: zod_1.z.string(),
	        actualDomain: ModelDomainType_js_1.modelDomainTypeSchema,
	        expectedDomain: ModelDomainType_js_1.modelDomainTypeSchema,
	    }),
	    zod_1.z.object({
	        code: zod_1.z.literal("generic.engineDoesNotSupportFeature"),
	        feature: zod_1.z.string(),
	        engineName: zod_1.z.string(),
	        engineType: zod_1.z.string(),
	        installedVersion: zod_1.z.string(),
	        supportedVersion: zod_1.z.string().nullable(),
	    }),
	    zod_1.z.object({
	        code: zod_1.z.literal("generic.presetNotFound"),
	        specifiedFuzzyPresetIdentifier: zod_1.z.string(),
	        availablePresetsSample: zod_1.z.array(zod_1.z.object({
	            identifier: zod_1.z.string(),
	            name: zod_1.z.string(),
	        })),
	        totalAvailablePresets: zod_1.z.number().int(),
	    }),
	];
	
	return GenericErrorDisplayData;
}

var LLMErrorDisplayData = {};

var hasRequiredLLMErrorDisplayData;

function requireLLMErrorDisplayData () {
	if (hasRequiredLLMErrorDisplayData) return LLMErrorDisplayData;
	hasRequiredLLMErrorDisplayData = 1;
	Object.defineProperty(LLMErrorDisplayData, "__esModule", { value: true });
	LLMErrorDisplayData.llmErrorDisplayDataSchema = void 0;
	LLMErrorDisplayData.llmErrorDisplayDataSchema = [];
	
	return LLMErrorDisplayData;
}

var hasRequired_Error;

function require_Error () {
	if (hasRequired_Error) return _Error;
	hasRequired_Error = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.serializedLMSExtendedErrorSchema = exports.errorDisplayDataSchema = void 0;
		exports.serializeError = serializeError;
		exports.attachSerializedErrorData = attachSerializedErrorData;
		exports.fromSerializedError = fromSerializedError;
		exports.recreateSerializedError = recreateSerializedError;
		exports.extractDisplayData = extractDisplayData;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const GenericErrorDisplayData_js_1 = /*@__PURE__*/ requireGenericErrorDisplayData();
		const LLMErrorDisplayData_js_1 = /*@__PURE__*/ requireLLMErrorDisplayData();
		exports.errorDisplayDataSchema = zod_1.z.discriminatedUnion("code", [
		    ...LLMErrorDisplayData_js_1.llmErrorDisplayDataSchema,
		    ...GenericErrorDisplayData_js_1.genericErrorDisplayDataSchema,
		]);
		/**
		 * Makes a Zod schema that turns a failed parse into an `undefined`.
		 */
		function failOk(schema) {
		    return zod_1.z.any().transform(val => (schema.safeParse(val).success ? val : undefined));
		}
		exports.serializedLMSExtendedErrorSchema = zod_1.z.object({
		    title: failOk(zod_1.z.string()).default("Unknown error"),
		    cause: failOk(zod_1.z.string()).optional(),
		    suggestion: failOk(zod_1.z.string()).optional(),
		    errorData: failOk(zod_1.z.record(zod_1.z.string(), zod_1.z.unknown())).optional(),
		    displayData: failOk(exports.errorDisplayDataSchema).optional(),
		    stack: failOk(zod_1.z.string()).optional(),
		    rootTitle: failOk(zod_1.z.string()).optional(),
		});
		function serializeError(error) {
		    if (typeof error === "object") {
		        const title = error.title ?? error.lmstudioRawError ?? error.message ?? "Unknown error";
		        return exports.serializedLMSExtendedErrorSchema.parse({
		            title,
		            cause: error.cause,
		            suggestion: error.suggestion,
		            errorData: error.errorData,
		            displayData: error.displayData,
		            stack: error.stack,
		            rootTitle: title,
		        });
		    }
		    else {
		        const title = String(error);
		        return {
		            title,
		            rootTitle: title,
		        };
		    }
		}
		/**
		 * Attaches the additional error data from a serialized error to an error object.
		 */
		function attachSerializedErrorData(error, serialized) {
		    const untypedError = error;
		    untypedError.title = serialized.title;
		    if (serialized.cause !== undefined) {
		        untypedError.cause = serialized.cause;
		    }
		    if (serialized.suggestion !== undefined) {
		        untypedError.suggestion = serialized.suggestion;
		    }
		    if (serialized.errorData !== undefined) {
		        untypedError.errorData = serialized.errorData;
		    }
		}
		function fromSerializedError(error, message = "Rehydrated error", replacementStack) {
		    const result = new Error(error.rootTitle);
		    attachSerializedErrorData(result, error);
		    if (error.displayData !== undefined) {
		        result.displayData = error.displayData;
		    }
		    if (replacementStack !== undefined) {
		        if (error.stack !== undefined) {
		            result.stack = `Error: ${message}\n${replacementStack}\n- Caused By: ${error.stack}`;
		        }
		        else {
		            result.stack = `Error: ${message}\n${replacementStack}`;
		        }
		    }
		    else {
		        if (error.stack !== undefined) {
		            result.stack =
		                `Error: ${message}\n${result.stack.substring(error.stack.indexOf("\n") + 1)}\n- Caused By: ` +
		                    error.stack;
		        }
		        else {
		            result.message += ` - caused by error without stack (${error.title})`;
		        }
		    }
		    return result;
		}
		/**
		 * Recreate an error as-is.
		 */
		function recreateSerializedError(error) {
		    const result = new Error(error.title);
		    result.name = "LMSExtendedError";
		    attachSerializedErrorData(result, error);
		    return result;
		}
		function extractDisplayData(error) {
		    return error.displayData;
		}
		
	} (_Error));
	return _Error;
}

var FileIdentifier = {};

var hasRequiredFileIdentifier;

function requireFileIdentifier () {
	if (hasRequiredFileIdentifier) return FileIdentifier;
	hasRequiredFileIdentifier = 1;
	Object.defineProperty(FileIdentifier, "__esModule", { value: true });
	FileIdentifier.parsedFileIdentifierSchema = FileIdentifier.fileNamespaceSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	FileIdentifier.fileNamespaceSchema = zod_1.z.enum(["local", "base64"]);
	FileIdentifier.parsedFileIdentifierSchema = zod_1.z.discriminatedUnion("type", [
	    zod_1.z.object({
	        type: zod_1.z.literal("local"),
	        fileName: zod_1.z.string(),
	    }),
	    zod_1.z.object({
	        type: zod_1.z.literal("base64"),
	        base64Data: zod_1.z.string(),
	    }),
	]);
	
	return FileIdentifier;
}

var GPUSplitStrategy = {};

var hasRequiredGPUSplitStrategy;

function requireGPUSplitStrategy () {
	if (hasRequiredGPUSplitStrategy) return GPUSplitStrategy;
	hasRequiredGPUSplitStrategy = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.gpuSplitConfigSchema = exports.defaultGPUSplitConfig = exports.gpuSplitStrategySchema = exports.gpuSplitStrategies = void 0;
		exports.convertGPUSettingToGPUSplitConfig = convertGPUSettingToGPUSplitConfig;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.gpuSplitStrategies = ["evenly", "priorityOrder", "custom"];
		exports.gpuSplitStrategySchema = zod_1.z.enum(exports.gpuSplitStrategies);
		exports.defaultGPUSplitConfig = {
		    strategy: "evenly",
		    disabledGpus: [],
		    priority: [],
		    customRatio: [],
		};
		exports.gpuSplitConfigSchema = zod_1.z.object({
		    strategy: exports.gpuSplitStrategySchema,
		    disabledGpus: zod_1.z.array(zod_1.z.number().int().min(0)),
		    priority: zod_1.z.array(zod_1.z.number().int().min(0)),
		    customRatio: zod_1.z.array(zod_1.z.number().min(0)),
		});
		function convertGPUSettingToGPUSplitConfig(gpuSetting) {
		    return {
		        strategy: gpuSetting?.splitStrategy == "favorMainGpu"
		            ? "priorityOrder"
		            : gpuSetting?.splitStrategy ?? "evenly",
		        disabledGpus: gpuSetting?.disabledGpus ?? [],
		        priority: gpuSetting?.mainGpu ? [gpuSetting.mainGpu] : [],
		        customRatio: [],
		    };
		}
		
	} (GPUSplitStrategy));
	return GPUSplitStrategy;
}

var KVConfig = {};

var hasRequiredKVConfig;

function requireKVConfig () {
	if (hasRequiredKVConfig) return KVConfig;
	hasRequiredKVConfig = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.kvConfigFieldDependencySchema = exports.kvConfigStackSchema = exports.kvConfigStackLayerSchema = exports.kvConfigLayerNameSchema = exports.kvConfigSchema = exports.kvConfigFieldSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.kvConfigFieldSchema = zod_1.z.object({
		    key: zod_1.z.string(),
		    value: zod_1.z.any(),
		});
		exports.kvConfigSchema = zod_1.z.object({
		    fields: zod_1.z.array(exports.kvConfigFieldSchema),
		});
		exports.kvConfigLayerNameSchema = zod_1.z.enum([
		    "currentlyEditing",
		    "currentlyLoaded",
		    "apiOverride",
		    "conversationSpecific",
		    "conversationGlobal",
		    "preset",
		    "serverSession",
		    "httpServerRequestOverride",
		    "completeModeFormatting",
		    "instance",
		    "userModelDefault",
		    "virtualModel",
		    "modelDefault",
		    "hardware",
		]);
		exports.kvConfigStackLayerSchema = zod_1.z.object({
		    layerName: exports.kvConfigLayerNameSchema,
		    config: exports.kvConfigSchema,
		});
		exports.kvConfigStackSchema = zod_1.z.object({
		    layers: zod_1.z.array(exports.kvConfigStackLayerSchema),
		});
		exports.kvConfigFieldDependencySchema = zod_1.z.object({
		    key: zod_1.z.string(),
		    condition: zod_1.z.discriminatedUnion("type", [
		        zod_1.z.object({ type: zod_1.z.literal("equals"), value: zod_1.z.any() }),
		        zod_1.z.object({ type: zod_1.z.literal("notEquals"), value: zod_1.z.any() }),
		    ]),
		});
		
	} (KVConfig));
	return KVConfig;
}

var ContentBlockStyle = {};

var hasRequiredContentBlockStyle;

function requireContentBlockStyle () {
	if (hasRequiredContentBlockStyle) return ContentBlockStyle;
	hasRequiredContentBlockStyle = 1;
	Object.defineProperty(ContentBlockStyle, "__esModule", { value: true });
	ContentBlockStyle.contentBlockStyleSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	const ColorPalette_1 = /*@__PURE__*/ requireColorPalette();
	ContentBlockStyle.contentBlockStyleSchema = zod_1.z.discriminatedUnion("type", [
	    zod_1.z.object({
	        type: zod_1.z.literal("default"),
	    }),
	    zod_1.z.object({
	        type: zod_1.z.literal("customLabel"),
	        label: zod_1.z.string(),
	        color: zod_1.z.optional(ColorPalette_1.colorPaletteSchema),
	    }),
	    zod_1.z.object({
	        type: zod_1.z.literal("thinking"),
	        ended: zod_1.z.boolean().optional(),
	        title: zod_1.z.string().optional(),
	    }),
	]);
	
	return ContentBlockStyle;
}

var LLMApplyPromptTemplateOpts = {};

var hasRequiredLLMApplyPromptTemplateOpts;

function requireLLMApplyPromptTemplateOpts () {
	if (hasRequiredLLMApplyPromptTemplateOpts) return LLMApplyPromptTemplateOpts;
	hasRequiredLLMApplyPromptTemplateOpts = 1;
	Object.defineProperty(LLMApplyPromptTemplateOpts, "__esModule", { value: true });
	LLMApplyPromptTemplateOpts.llmApplyPromptTemplateOptsSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	LLMApplyPromptTemplateOpts.llmApplyPromptTemplateOptsSchema = zod_1.z.object({
	    omitBosToken: zod_1.z.boolean().optional(),
	    omitEosToken: zod_1.z.boolean().optional(),
	});
	
	return LLMApplyPromptTemplateOpts;
}

var LLMContextReference = {};

var hasRequiredLLMContextReference;

function requireLLMContextReference () {
	if (hasRequiredLLMContextReference) return LLMContextReference;
	hasRequiredLLMContextReference = 1;
	Object.defineProperty(LLMContextReference, "__esModule", { value: true });
	LLMContextReference.llmContextReferenceYamlFileSchema = LLMContextReference.llmContextReferenceJsonFileSchema = LLMContextReference.llmContextReferenceSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	LLMContextReference.llmContextReferenceSchema = zod_1.z.discriminatedUnion("type", [
	    zod_1.z.object({
	        type: zod_1.z.literal("jsonFile"),
	        absPath: zod_1.z.string(),
	    }),
	    zod_1.z.object({
	        type: zod_1.z.literal("yamlFile"),
	        absPath: zod_1.z.string(),
	    }),
	]);
	LLMContextReference.llmContextReferenceJsonFileSchema = zod_1.z.array(zod_1.z.object({
	    role: zod_1.z.enum(["user", "assistant", "system"]),
	    content: zod_1.z.string(),
	}));
	LLMContextReference.llmContextReferenceYamlFileSchema = zod_1.z.array(zod_1.z.union([
	    zod_1.z.object({
	        system: zod_1.z.string(),
	    }),
	    zod_1.z.object({
	        user: zod_1.z.string(),
	    }),
	    zod_1.z.object({
	        assistant: zod_1.z.string(),
	    }),
	]));
	
	return LLMContextReference;
}

var LLMModelInfo = {};

var hasRequiredLLMModelInfo;

function requireLLMModelInfo () {
	if (hasRequiredLLMModelInfo) return LLMModelInfo;
	hasRequiredLLMModelInfo = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.llmInstanceInfoSchema = exports.llmInfoSchema = exports.llmInstanceAdditionalInfoSchema = exports.llmAdditionalInfoSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const ModelInfoBase_js_1 = /*@__PURE__*/ requireModelInfoBase();
		exports.llmAdditionalInfoSchema = zod_1.z.object({
		    vision: zod_1.z.boolean(),
		    trainedForToolUse: zod_1.z.boolean(),
		    maxContextLength: zod_1.z.number().int(),
		});
		exports.llmInstanceAdditionalInfoSchema = zod_1.z.object({
		    contextLength: zod_1.z.number().int(),
		});
		exports.llmInfoSchema = zod_1.z
		    .object({
		    type: zod_1.z.literal("llm"),
		})
		    .extend(ModelInfoBase_js_1.modelInfoBaseSchema.shape)
		    .extend(exports.llmAdditionalInfoSchema.shape);
		exports.llmInstanceInfoSchema = zod_1.z
		    .object({
		    type: zod_1.z.literal("llm"),
		})
		    .extend(ModelInfoBase_js_1.modelInstanceInfoBaseSchema.shape)
		    .extend(exports.llmAdditionalInfoSchema.shape)
		    .extend(exports.llmInstanceAdditionalInfoSchema.shape);
		
	} (LLMModelInfo));
	return LLMModelInfo;
}

var LLMPredictionConfig = {};

var Zod = {};

var hasRequiredZod;

function requireZod () {
	if (hasRequiredZod) return Zod;
	hasRequiredZod = 1;
	Object.defineProperty(Zod, "__esModule", { value: true });
	Zod.zodSchemaSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	/**
	 * Check if has a parse method. If not, output error message asking for it to be a zod schema.
	 */
	Zod.zodSchemaSchema = zod_1.z.custom(value => {
	    if (typeof value?.parse !== "function") {
	        return false;
	    }
	    return true;
	}, "Expected a zod schema");
	
	return Zod;
}

var LLMPromptTemplate = {};

var hasRequiredLLMPromptTemplate;

function requireLLMPromptTemplate () {
	if (hasRequiredLLMPromptTemplate) return LLMPromptTemplate;
	hasRequiredLLMPromptTemplate = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.llmPromptTemplateSchema = exports.llmPromptTemplateTypeSchema = exports.llmJinjaPromptTemplateSchema = exports.llmJinjaInputConfigSchema = exports.llmJinjaInputMessagesConfigSchema = exports.llmJinjaInputMessagesContentConfigSchema = exports.llmJinjaInputMessagesContentConfigTextFieldNameSchema = exports.llmJinjaInputMessagesContentImagesConfigSchema = exports.llmManualPromptTemplateSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.llmManualPromptTemplateSchema = zod_1.z.object({
		    beforeSystem: zod_1.z.string(),
		    afterSystem: zod_1.z.string(),
		    beforeUser: zod_1.z.string(),
		    afterUser: zod_1.z.string(),
		    beforeAssistant: zod_1.z.string(),
		    afterAssistant: zod_1.z.string(),
		});
		exports.llmJinjaInputMessagesContentImagesConfigSchema = zod_1.z.discriminatedUnion("type", [
		    zod_1.z.object({
		        type: zod_1.z.literal("simple"),
		        value: zod_1.z.string(),
		    }),
		    zod_1.z.object({
		        type: zod_1.z.literal("numbered"),
		        prefix: zod_1.z.string(),
		        suffix: zod_1.z.string(),
		    }),
		    zod_1.z.object({
		        type: zod_1.z.literal("object"),
		    }),
		]);
		exports.llmJinjaInputMessagesContentConfigTextFieldNameSchema = zod_1.z.enum(["content", "text"]);
		exports.llmJinjaInputMessagesContentConfigSchema = zod_1.z.discriminatedUnion("type", [
		    zod_1.z.object({
		        type: zod_1.z.literal("string"),
		        imagesConfig: exports.llmJinjaInputMessagesContentImagesConfigSchema.optional(),
		    }),
		    zod_1.z.object({
		        type: zod_1.z.literal("array"),
		        textFieldName: exports.llmJinjaInputMessagesContentConfigTextFieldNameSchema,
		        imagesConfig: exports.llmJinjaInputMessagesContentImagesConfigSchema.optional(),
		    }),
		]);
		exports.llmJinjaInputMessagesConfigSchema = zod_1.z.object({
		    contentConfig: exports.llmJinjaInputMessagesContentConfigSchema,
		});
		exports.llmJinjaInputConfigSchema = zod_1.z.object({
		    messagesConfig: exports.llmJinjaInputMessagesConfigSchema,
		    useTools: zod_1.z.boolean(),
		});
		exports.llmJinjaPromptTemplateSchema = zod_1.z.object({
		    template: zod_1.z.string(),
		    bosToken: zod_1.z.string(),
		    eosToken: zod_1.z.string(),
		    inputConfig: exports.llmJinjaInputConfigSchema,
		});
		exports.llmPromptTemplateTypeSchema = zod_1.z.enum(["manual", "jinja"]);
		exports.llmPromptTemplateSchema = zod_1.z.object({
		    type: exports.llmPromptTemplateTypeSchema,
		    manualPromptTemplate: exports.llmManualPromptTemplateSchema.optional(),
		    jinjaPromptTemplate: exports.llmJinjaPromptTemplateSchema.optional(),
		    stopStrings: zod_1.z.array(zod_1.z.string()),
		});
		
	} (LLMPromptTemplate));
	return LLMPromptTemplate;
}

var LLMStructuredPredictionSetting = {};

var hasRequiredLLMStructuredPredictionSetting;

function requireLLMStructuredPredictionSetting () {
	if (hasRequiredLLMStructuredPredictionSetting) return LLMStructuredPredictionSetting;
	hasRequiredLLMStructuredPredictionSetting = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.llmStructuredPredictionSettingSchema = exports.llmStructuredPredictionTypeSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const JSONSerializable_js_1 = /*@__PURE__*/ requireJSONSerializable();
		exports.llmStructuredPredictionTypeSchema = zod_1.z.enum(["none", "json", "gbnf"]);
		exports.llmStructuredPredictionSettingSchema = zod_1.z.object({
		    type: exports.llmStructuredPredictionTypeSchema,
		    jsonSchema: JSONSerializable_js_1.jsonSerializableSchema.optional(),
		    gbnfGrammar: zod_1.z.string().optional(),
		});
		
	} (LLMStructuredPredictionSetting));
	return LLMStructuredPredictionSetting;
}

var LLMToolUseSetting = {};

var hasRequiredLLMToolUseSetting;

function requireLLMToolUseSetting () {
	if (hasRequiredLLMToolUseSetting) return LLMToolUseSetting;
	hasRequiredLLMToolUseSetting = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.llmToolUseSettingSchema = exports.llmToolArraySchema = exports.llmToolSchema = exports.llmToolParametersSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const JSONSerializable_js_1 = /*@__PURE__*/ requireJSONSerializable();
		exports.llmToolParametersSchema = zod_1.z.discriminatedUnion("type", [
		    zod_1.z.object({
		        type: zod_1.z.literal("object"),
		        properties: zod_1.z.record(JSONSerializable_js_1.jsonSerializableSchema),
		        required: zod_1.z.array(zod_1.z.string()).optional(),
		        additionalProperties: zod_1.z.boolean().optional(),
		    }),
		    // add more parameter types here
		    // ...
		]);
		exports.llmToolSchema = zod_1.z.discriminatedUnion("type", [
		    zod_1.z.object({
		        type: zod_1.z.literal("function"),
		        function: zod_1.z.object({
		            name: zod_1.z.string(),
		            description: zod_1.z.string().optional(),
		            parameters: exports.llmToolParametersSchema.optional(),
		        }),
		    }),
		    // add more tool types here
		    // ...
		]);
		/**
		 * For convenience
		 */
		exports.llmToolArraySchema = zod_1.z.array(exports.llmToolSchema);
		exports.llmToolUseSettingSchema = zod_1.z.discriminatedUnion("type", [
		    zod_1.z.object({
		        type: zod_1.z.literal("none"),
		    }),
		    zod_1.z.object({
		        type: zod_1.z.literal("toolArray"),
		        tools: zod_1.z.array(exports.llmToolSchema).optional(),
		    }),
		]);
		
	} (LLMToolUseSetting));
	return LLMToolUseSetting;
}

var hasRequiredLLMPredictionConfig;

function requireLLMPredictionConfig () {
	if (hasRequiredLLMPredictionConfig) return LLMPredictionConfig;
	hasRequiredLLMPredictionConfig = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.llmLlamaLogitBiasConfigSchema = exports.llmLlamaSingleLogitBiasModificationSchema = exports.llmLlamaMirostatSamplingConfigSchema = exports.llmPredictionConfigSchema = exports.llmPredictionConfigInputSchema = exports.llmReasoningParsingSchema = exports.llmContextOverflowPolicySchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const Zod_js_1 = /*@__PURE__*/ requireZod();
		const LLMPromptTemplate_js_1 = /*@__PURE__*/ requireLLMPromptTemplate();
		const LLMStructuredPredictionSetting_js_1 = /*@__PURE__*/ requireLLMStructuredPredictionSetting();
		const LLMToolUseSetting_js_1 = /*@__PURE__*/ requireLLMToolUseSetting();
		exports.llmContextOverflowPolicySchema = zod_1.z.enum([
		    "stopAtLimit",
		    "truncateMiddle",
		    "rollingWindow",
		]);
		exports.llmReasoningParsingSchema = zod_1.z.object({
		    enabled: zod_1.z.boolean(),
		    startString: zod_1.z.string(),
		    endString: zod_1.z.string(),
		});
		exports.llmPredictionConfigInputSchema = zod_1.z.object({
		    maxTokens: zod_1.z.number().int().min(-1).optional().or(zod_1.z.literal(false)),
		    temperature: zod_1.z.number().min(0).optional(),
		    stopStrings: zod_1.z.array(zod_1.z.string()).optional(),
		    toolCallStopStrings: zod_1.z.array(zod_1.z.string()).optional(),
		    contextOverflowPolicy: exports.llmContextOverflowPolicySchema.optional(),
		    structured: zod_1.z.union([Zod_js_1.zodSchemaSchema, LLMStructuredPredictionSetting_js_1.llmStructuredPredictionSettingSchema]).optional(),
		    rawTools: LLMToolUseSetting_js_1.llmToolUseSettingSchema.optional(),
		    topKSampling: zod_1.z.number().optional(),
		    repeatPenalty: zod_1.z.number().optional().or(zod_1.z.literal(false)),
		    minPSampling: zod_1.z.number().optional().or(zod_1.z.literal(false)),
		    topPSampling: zod_1.z.number().optional().or(zod_1.z.literal(false)),
		    cpuThreads: zod_1.z.number().int().optional(),
		    promptTemplate: LLMPromptTemplate_js_1.llmPromptTemplateSchema.optional(),
		    draftModel: zod_1.z.string().optional(),
		    speculativeDecodingNumDraftTokensExact: zod_1.z.number().int().min(1).optional(),
		    speculativeDecodingMinDraftLengthToConsider: zod_1.z.number().int().min(0).optional(),
		    speculativeDecodingMinContinueDraftingProbability: zod_1.z.number().optional(),
		    reasoningParsing: exports.llmReasoningParsingSchema.optional(),
		});
		exports.llmPredictionConfigSchema = zod_1.z.object({
		    ...exports.llmPredictionConfigInputSchema.shape,
		    structured: LLMStructuredPredictionSetting_js_1.llmStructuredPredictionSettingSchema.optional(),
		});
		exports.llmLlamaMirostatSamplingConfigSchema = zod_1.z.object({
		    version: zod_1.z.union([zod_1.z.literal(0), zod_1.z.literal(1), zod_1.z.literal(2)]),
		    learningRate: zod_1.z.number(),
		    targetEntropy: zod_1.z.number(),
		});
		exports.llmLlamaSingleLogitBiasModificationSchema = zod_1.z.union([zod_1.z.number(), zod_1.z.literal("-inf")]);
		exports.llmLlamaLogitBiasConfigSchema = zod_1.z.array(zod_1.z.tuple([zod_1.z.number(), exports.llmLlamaSingleLogitBiasModificationSchema]));
		
	} (LLMPredictionConfig));
	return LLMPredictionConfig;
}

var LLMPredictionFragment = {};

var hasRequiredLLMPredictionFragment;

function requireLLMPredictionFragment () {
	if (hasRequiredLLMPredictionFragment) return LLMPredictionFragment;
	hasRequiredLLMPredictionFragment = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.llmPredictionFragmentSchema = exports.llmPredictionFragmentReasoningTypeSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.llmPredictionFragmentReasoningTypeSchema = zod_1.z.enum([
		    "none",
		    "reasoning",
		    "reasoningStartTag",
		    "reasoningEndTag",
		]);
		exports.llmPredictionFragmentSchema = zod_1.z.object({
		    content: zod_1.z.string(),
		    tokensCount: zod_1.z.number().int(),
		    containsDrafted: zod_1.z.boolean(),
		    reasoningType: exports.llmPredictionFragmentReasoningTypeSchema,
		});
		
	} (LLMPredictionFragment));
	return LLMPredictionFragment;
}

var LLMPredictionStats = {};

var hasRequiredLLMPredictionStats;

function requireLLMPredictionStats () {
	if (hasRequiredLLMPredictionStats) return LLMPredictionStats;
	hasRequiredLLMPredictionStats = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.llmGenInfoSchema = exports.llmPredictionStatsSchema = exports.llmPredictionStopReasonSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const KVConfig_js_1 = /*@__PURE__*/ requireKVConfig();
		exports.llmPredictionStopReasonSchema = zod_1.z.enum([
		    "userStopped",
		    "modelUnloaded",
		    "failed",
		    "eosFound",
		    "stopStringFound",
		    "toolCalls",
		    "maxPredictedTokensReached",
		    "contextLengthReached",
		]);
		exports.llmPredictionStatsSchema = zod_1.z.object({
		    stopReason: exports.llmPredictionStopReasonSchema,
		    tokensPerSecond: zod_1.z.number().optional(),
		    numGpuLayers: zod_1.z.number().optional(),
		    timeToFirstTokenSec: zod_1.z.number().optional(),
		    promptTokensCount: zod_1.z.number().int().optional(),
		    predictedTokensCount: zod_1.z.number().int().optional(),
		    totalTokensCount: zod_1.z.number().int().optional(),
		    usedDraftModelKey: zod_1.z.string().optional(),
		    totalDraftTokensCount: zod_1.z.number().int().optional(),
		    acceptedDraftTokensCount: zod_1.z.number().int().optional(),
		    rejectedDraftTokensCount: zod_1.z.number().int().optional(),
		    ignoredDraftTokensCount: zod_1.z.number().int().optional(),
		});
		exports.llmGenInfoSchema = zod_1.z.object({
		    indexedModelIdentifier: zod_1.z.string(),
		    identifier: zod_1.z.string(),
		    loadModelConfig: KVConfig_js_1.kvConfigSchema,
		    predictionConfig: KVConfig_js_1.kvConfigSchema,
		    stats: exports.llmPredictionStatsSchema,
		});
		
	} (LLMPredictionStats));
	return LLMPredictionStats;
}

var GeneratorUpdate = {};

var ProcessingUpdate = {};

var hasRequiredProcessingUpdate;

function requireProcessingUpdate () {
	if (hasRequiredProcessingUpdate) return ProcessingUpdate;
	hasRequiredProcessingUpdate = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.processingUpdateSchema = exports.processingUpdateSetSenderNameSchema = exports.processingUpdateContentBlockSetStyleSchema = exports.processingUpdateContentBlockAttachGenInfoSchema = exports.processingUpdateContentBlockSetSuffixSchema = exports.processingUpdateContentBlockSetPrefixSchema = exports.processingUpdateContentBlockReplaceTextSchema = exports.processingUpdateContentBlockReplaceToolRequestSchema = exports.processingUpdateContentBlockAppendToolRequestSchema = exports.processingUpdateContentBlockAppendToolResultSchema = exports.processingUpdateContentBlockAppendTextSchema = exports.processingUpdateContentBlockCreateSchema = exports.processingUpdateDebugInfoBlockCreateSchema = exports.processingUpdateCitationBlockCreateSchema = exports.processingUpdateStatusRemoveSchema = exports.processingUpdateStatusUpdateSchema = exports.processingUpdateStatusCreateSchema = exports.statusStepStateSchema = exports.statusStepStatusSchema = exports.blockLocationSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const ContentBlockStyle_js_1 = /*@__PURE__*/ requireContentBlockStyle();
		const LLMPredictionStats_js_1 = /*@__PURE__*/ requireLLMPredictionStats();
		exports.blockLocationSchema = zod_1.z.discriminatedUnion("type", [
		    zod_1.z.object({
		        type: zod_1.z.literal("beforeId"),
		        id: zod_1.z.string(),
		    }),
		    zod_1.z.object({
		        type: zod_1.z.literal("afterId"),
		        id: zod_1.z.string(),
		    }),
		]);
		exports.statusStepStatusSchema = zod_1.z.enum([
		    "waiting",
		    "loading",
		    "done",
		    "error",
		    "canceled",
		]);
		exports.statusStepStateSchema = zod_1.z.object({
		    status: exports.statusStepStatusSchema,
		    text: zod_1.z.string(),
		});
		exports.processingUpdateStatusCreateSchema = zod_1.z.object({
		    type: zod_1.z.literal("status.create"),
		    id: zod_1.z.string(),
		    state: exports.statusStepStateSchema,
		    location: exports.blockLocationSchema.optional(),
		    indentation: zod_1.z.number().int().optional(),
		});
		exports.processingUpdateStatusUpdateSchema = zod_1.z.object({
		    type: zod_1.z.literal("status.update"),
		    id: zod_1.z.string(),
		    state: exports.statusStepStateSchema,
		});
		exports.processingUpdateStatusRemoveSchema = zod_1.z.object({
		    type: zod_1.z.literal("status.remove"),
		    id: zod_1.z.string(),
		});
		exports.processingUpdateCitationBlockCreateSchema = zod_1.z.object({
		    type: zod_1.z.literal("citationBlock.create"),
		    id: zod_1.z.string(),
		    citedText: zod_1.z.string(),
		    fileName: zod_1.z.string(),
		    fileIdentifier: zod_1.z.string(),
		    pageNumber: zod_1.z.union([zod_1.z.number().int(), zod_1.z.tuple([zod_1.z.number().int(), zod_1.z.number().int()])]).optional(),
		    lineNumber: zod_1.z.union([zod_1.z.number().int(), zod_1.z.tuple([zod_1.z.number().int(), zod_1.z.number().int()])]).optional(),
		});
		exports.processingUpdateDebugInfoBlockCreateSchema = zod_1.z.object({
		    type: zod_1.z.literal("debugInfoBlock.create"),
		    id: zod_1.z.string(),
		    debugInfo: zod_1.z.string(),
		});
		exports.processingUpdateContentBlockCreateSchema = zod_1.z.object({
		    type: zod_1.z.literal("contentBlock.create"),
		    id: zod_1.z.string(),
		    includeInContext: zod_1.z.boolean(),
		    roleOverride: zod_1.z.enum(["user", "assistant", "system", "tool"]).optional(),
		    style: ContentBlockStyle_js_1.contentBlockStyleSchema.optional(),
		    prefix: zod_1.z.string().optional(),
		    suffix: zod_1.z.string().optional(),
		});
		exports.processingUpdateContentBlockAppendTextSchema = zod_1.z.object({
		    type: zod_1.z.literal("contentBlock.appendText"),
		    id: zod_1.z.string(),
		    text: zod_1.z.string(),
		    tokensCount: zod_1.z.number().int().optional(),
		    fromDraftModel: zod_1.z.boolean().optional(),
		});
		exports.processingUpdateContentBlockAppendToolResultSchema = zod_1.z.object({
		    type: zod_1.z.literal("contentBlock.appendToolResult"),
		    id: zod_1.z.string(),
		    requestId: zod_1.z.string(),
		    content: zod_1.z.string(),
		});
		exports.processingUpdateContentBlockAppendToolRequestSchema = zod_1.z.object({
		    type: zod_1.z.literal("contentBlock.appendToolRequest"),
		    id: zod_1.z.string(),
		    requestId: zod_1.z.string(),
		    name: zod_1.z.string(),
		    arguments: zod_1.z.record(zod_1.z.unknown()),
		});
		exports.processingUpdateContentBlockReplaceToolRequestSchema = zod_1.z.object({
		    type: zod_1.z.literal("contentBlock.replaceToolRequest"),
		    id: zod_1.z.string(),
		    requestId: zod_1.z.string(),
		    name: zod_1.z.string(),
		    arguments: zod_1.z.record(zod_1.z.unknown()),
		});
		exports.processingUpdateContentBlockReplaceTextSchema = zod_1.z.object({
		    type: zod_1.z.literal("contentBlock.replaceText"),
		    id: zod_1.z.string(),
		    text: zod_1.z.string(),
		});
		exports.processingUpdateContentBlockSetPrefixSchema = zod_1.z.object({
		    type: zod_1.z.literal("contentBlock.setPrefix"),
		    id: zod_1.z.string(),
		    prefix: zod_1.z.string(),
		});
		exports.processingUpdateContentBlockSetSuffixSchema = zod_1.z.object({
		    type: zod_1.z.literal("contentBlock.setSuffix"),
		    id: zod_1.z.string(),
		    suffix: zod_1.z.string(),
		});
		exports.processingUpdateContentBlockAttachGenInfoSchema = zod_1.z.object({
		    type: zod_1.z.literal("contentBlock.attachGenInfo"),
		    id: zod_1.z.string(),
		    genInfo: LLMPredictionStats_js_1.llmGenInfoSchema,
		});
		exports.processingUpdateContentBlockSetStyleSchema = zod_1.z.object({
		    type: zod_1.z.literal("contentBlock.setStyle"),
		    id: zod_1.z.string(),
		    style: ContentBlockStyle_js_1.contentBlockStyleSchema,
		});
		exports.processingUpdateSetSenderNameSchema = zod_1.z.object({
		    type: zod_1.z.literal("setSenderName"),
		    name: zod_1.z.string(),
		});
		exports.processingUpdateSchema = zod_1.z.discriminatedUnion("type", [
		    exports.processingUpdateStatusCreateSchema,
		    exports.processingUpdateStatusUpdateSchema,
		    exports.processingUpdateStatusRemoveSchema,
		    exports.processingUpdateCitationBlockCreateSchema,
		    exports.processingUpdateDebugInfoBlockCreateSchema,
		    exports.processingUpdateContentBlockCreateSchema,
		    exports.processingUpdateContentBlockAppendTextSchema,
		    exports.processingUpdateContentBlockAppendToolRequestSchema,
		    exports.processingUpdateContentBlockReplaceToolRequestSchema,
		    exports.processingUpdateContentBlockAppendToolResultSchema,
		    exports.processingUpdateContentBlockReplaceTextSchema,
		    exports.processingUpdateContentBlockSetPrefixSchema,
		    exports.processingUpdateContentBlockSetSuffixSchema,
		    exports.processingUpdateContentBlockAttachGenInfoSchema,
		    exports.processingUpdateContentBlockSetStyleSchema,
		    exports.processingUpdateSetSenderNameSchema,
		]);
		
	} (ProcessingUpdate));
	return ProcessingUpdate;
}

var hasRequiredGeneratorUpdate;

function requireGeneratorUpdate () {
	if (hasRequiredGeneratorUpdate) return GeneratorUpdate;
	hasRequiredGeneratorUpdate = 1;
	Object.defineProperty(GeneratorUpdate, "__esModule", { value: true });
	GeneratorUpdate.generatorUpdateSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	const ProcessingUpdate_js_1 = /*@__PURE__*/ requireProcessingUpdate();
	GeneratorUpdate.generatorUpdateSchema = zod_1.z.discriminatedUnion("type", [
	    ProcessingUpdate_js_1.processingUpdateStatusCreateSchema,
	    ProcessingUpdate_js_1.processingUpdateStatusUpdateSchema,
	    ProcessingUpdate_js_1.processingUpdateStatusRemoveSchema,
	    ProcessingUpdate_js_1.processingUpdateCitationBlockCreateSchema,
	    ProcessingUpdate_js_1.processingUpdateDebugInfoBlockCreateSchema,
	    ProcessingUpdate_js_1.processingUpdateContentBlockCreateSchema,
	    ProcessingUpdate_js_1.processingUpdateContentBlockAppendTextSchema,
	    ProcessingUpdate_js_1.processingUpdateContentBlockReplaceTextSchema,
	    ProcessingUpdate_js_1.processingUpdateContentBlockAppendToolRequestSchema,
	    ProcessingUpdate_js_1.processingUpdateContentBlockReplaceToolRequestSchema,
	    ProcessingUpdate_js_1.processingUpdateContentBlockAppendToolResultSchema,
	    ProcessingUpdate_js_1.processingUpdateContentBlockAttachGenInfoSchema,
	    ProcessingUpdate_js_1.processingUpdateContentBlockSetStyleSchema,
	    ProcessingUpdate_js_1.processingUpdateSetSenderNameSchema,
	]);
	
	return GeneratorUpdate;
}

var PreprocessorUpdate = {};

var hasRequiredPreprocessorUpdate;

function requirePreprocessorUpdate () {
	if (hasRequiredPreprocessorUpdate) return PreprocessorUpdate;
	hasRequiredPreprocessorUpdate = 1;
	Object.defineProperty(PreprocessorUpdate, "__esModule", { value: true });
	PreprocessorUpdate.preprocessorUpdateSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	const ProcessingUpdate_js_1 = /*@__PURE__*/ requireProcessingUpdate();
	PreprocessorUpdate.preprocessorUpdateSchema = zod_1.z.discriminatedUnion("type", [
	    ProcessingUpdate_js_1.processingUpdateStatusCreateSchema,
	    ProcessingUpdate_js_1.processingUpdateStatusUpdateSchema,
	    ProcessingUpdate_js_1.processingUpdateStatusRemoveSchema,
	    ProcessingUpdate_js_1.processingUpdateCitationBlockCreateSchema,
	    ProcessingUpdate_js_1.processingUpdateDebugInfoBlockCreateSchema,
	]);
	
	return PreprocessorUpdate;
}

var ProcessingRequest = {};

var hasRequiredProcessingRequest;

function requireProcessingRequest () {
	if (hasRequiredProcessingRequest) return ProcessingRequest;
	hasRequiredProcessingRequest = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.processingRequestResponseSchema = exports.processingRequestResponseTextInputSchema = exports.processingRequestResponseConfirmToolCallSchema = exports.processingRequestSchema = exports.processingRequestTextInputSchema = exports.processingRequestConfirmToolCallSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.processingRequestConfirmToolCallSchema = zod_1.z.object({
		    type: zod_1.z.literal("confirmToolCall"),
		    pluginIdentifier: zod_1.z.string().optional(),
		    toolName: zod_1.z.string(),
		    toolArgs: zod_1.z.record(zod_1.z.any()),
		});
		exports.processingRequestTextInputSchema = zod_1.z.object({
		    type: zod_1.z.literal("textInput"),
		    prompt: zod_1.z.string(),
		});
		exports.processingRequestSchema = zod_1.z.discriminatedUnion("type", [
		    exports.processingRequestConfirmToolCallSchema,
		    exports.processingRequestTextInputSchema,
		]);
		exports.processingRequestResponseConfirmToolCallSchema = zod_1.z.object({
		    type: zod_1.z.literal("confirmToolCall"),
		    result: zod_1.z.discriminatedUnion("type", [
		        zod_1.z.object({
		            type: zod_1.z.literal("allow"),
		            toolArgsOverride: zod_1.z.record(zod_1.z.any()).optional(),
		        }),
		        zod_1.z.object({
		            type: zod_1.z.literal("deny"),
		            denyReason: zod_1.z.string().optional(),
		        }),
		    ]),
		});
		exports.processingRequestResponseTextInputSchema = zod_1.z.object({
		    type: zod_1.z.literal("textInput"),
		    result: zod_1.z.string(),
		});
		exports.processingRequestResponseSchema = zod_1.z.discriminatedUnion("type", [
		    exports.processingRequestResponseConfirmToolCallSchema,
		    exports.processingRequestResponseTextInputSchema,
		]);
		
	} (ProcessingRequest));
	return ProcessingRequest;
}

var Processor = {};

var hasRequiredProcessor;

function requireProcessor () {
	if (hasRequiredProcessor) return Processor;
	hasRequiredProcessor = 1;
	Object.defineProperty(Processor, "__esModule", { value: true });
	Processor.getModelOptsSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	Processor.getModelOptsSchema = zod_1.z.object({
	    modelTag: zod_1.z.string().optional(),
	    ignoreUserConfig: zod_1.z.boolean().optional(),
	});
	
	return Processor;
}

var ModelInfo = {};

var hasRequiredModelInfo;

function requireModelInfo () {
	if (hasRequiredModelInfo) return ModelInfo;
	hasRequiredModelInfo = 1;
	Object.defineProperty(ModelInfo, "__esModule", { value: true });
	ModelInfo.modelInstanceInfoSchema = ModelInfo.modelInfoSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	const EmbeddingModelInfo_js_1 = /*@__PURE__*/ requireEmbeddingModelInfo();
	const LLMModelInfo_js_1 = /*@__PURE__*/ requireLLMModelInfo();
	ModelInfo.modelInfoSchema = zod_1.z.discriminatedUnion("type", [
	    LLMModelInfo_js_1.llmInfoSchema,
	    EmbeddingModelInfo_js_1.embeddingModelInfoSchema,
	]);
	ModelInfo.modelInstanceInfoSchema = zod_1.z.discriminatedUnion("type", [
	    LLMModelInfo_js_1.llmInstanceInfoSchema,
	    EmbeddingModelInfo_js_1.embeddingModelInstanceInfoSchema,
	]);
	
	return ModelInfo;
}

var ArtifactDownloadPlan = {};

var hasRequiredArtifactDownloadPlan;

function requireArtifactDownloadPlan () {
	if (hasRequiredArtifactDownloadPlan) return ArtifactDownloadPlan;
	hasRequiredArtifactDownloadPlan = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.artifactDownloadPlanSchema = exports.artifactDownloadPlanNodeSchema = exports.artifactDownloadPlanNodeStateSchema = exports.artifactDownloadPlanModelInfoSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const ArtifactManifest_js_1 = /*@__PURE__*/ requireArtifactManifest();
		const kebab_js_1 = /*@__PURE__*/ requireKebab();
		const ModelCompatibilityType_js_1 = /*@__PURE__*/ requireModelCompatibilityType();
		exports.artifactDownloadPlanModelInfoSchema = zod_1.z.object({
		    displayName: zod_1.z.string(),
		    sizeBytes: zod_1.z.number(),
		    quantName: zod_1.z.string().optional(),
		    compatibilityType: ModelCompatibilityType_js_1.modelCompatibilityTypeSchema,
		});
		exports.artifactDownloadPlanNodeStateSchema = zod_1.z.enum(["pending", "fetching", "satisfied", "completed"]);
		exports.artifactDownloadPlanNodeSchema = zod_1.z.discriminatedUnion("type", [
		    zod_1.z.object({
		        type: zod_1.z.literal("artifact"),
		        owner: kebab_js_1.kebabCaseSchema,
		        name: kebab_js_1.kebabCaseWithDotsSchema,
		        state: exports.artifactDownloadPlanNodeStateSchema,
		        artifactType: ArtifactManifest_js_1.artifactTypeSchema.optional(),
		        sizeBytes: zod_1.z.number().int().optional(),
		        dependencyNodes: zod_1.z.array(zod_1.z.number().int()),
		    }),
		    zod_1.z.object({
		        type: zod_1.z.literal("model"),
		        state: exports.artifactDownloadPlanNodeStateSchema,
		        resolvedSources: zod_1.z.number().int().optional(),
		        totalSources: zod_1.z.number().int().optional(),
		        alreadyOwned: exports.artifactDownloadPlanModelInfoSchema.optional(),
		        selected: exports.artifactDownloadPlanModelInfoSchema.optional(),
		    }),
		]);
		exports.artifactDownloadPlanSchema = zod_1.z.object({
		    nodes: zod_1.z.array(exports.artifactDownloadPlanNodeSchema),
		    downloadSizeBytes: zod_1.z.number().int(),
		});
		
	} (ArtifactDownloadPlan));
	return ArtifactDownloadPlan;
}

var ArtifactUpload = {};

var hasRequiredArtifactUpload;

function requireArtifactUpload () {
	if (hasRequiredArtifactUpload) return ArtifactUpload;
	hasRequiredArtifactUpload = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.localArtifactFileListSchema = exports.localArtifactFileEntrySchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.localArtifactFileEntrySchema = zod_1.z.object({
		    relativePath: zod_1.z.string(),
		    sizeBytes: zod_1.z.number().int(),
		});
		exports.localArtifactFileListSchema = zod_1.z.object({
		    files: zod_1.z.array(exports.localArtifactFileEntrySchema),
		    usedIgnoreFile: zod_1.z.string().nullable(),
		});
		
	} (ArtifactUpload));
	return ArtifactUpload;
}

var DownloadProgressUpdate = {};

var hasRequiredDownloadProgressUpdate;

function requireDownloadProgressUpdate () {
	if (hasRequiredDownloadProgressUpdate) return DownloadProgressUpdate;
	hasRequiredDownloadProgressUpdate = 1;
	Object.defineProperty(DownloadProgressUpdate, "__esModule", { value: true });
	DownloadProgressUpdate.downloadProgressUpdateSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	DownloadProgressUpdate.downloadProgressUpdateSchema = zod_1.z.object({
	    downloadedBytes: zod_1.z.number().int(),
	    totalBytes: zod_1.z.number().int(),
	    speedBytesPerSecond: zod_1.z.number(),
	});
	
	return DownloadProgressUpdate;
}

var ModelSearch = {};

var hasRequiredModelSearch;

function requireModelSearch () {
	if (hasRequiredModelSearch) return ModelSearch;
	hasRequiredModelSearch = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.modelSearchOptsSchema = exports.modelSearchResultEntryDataSchema = exports.modelSearchResultIdentifierSchema = exports.modelSearchResultDownloadOptionDataSchema = exports.modelSearchResultDownloadOptionFitEstimationSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const ModelCompatibilityType_js_1 = /*@__PURE__*/ requireModelCompatibilityType();
		exports.modelSearchResultDownloadOptionFitEstimationSchema = zod_1.z.enum([
		    "fullGPUOffload",
		    "partialGPUOffload",
		    "fitWithoutGPU",
		    "willNotFit",
		]);
		exports.modelSearchResultDownloadOptionDataSchema = zod_1.z.object({
		    quantization: zod_1.z.string().optional(),
		    name: zod_1.z.string(),
		    sizeBytes: zod_1.z.number().int(),
		    fitEstimation: exports.modelSearchResultDownloadOptionFitEstimationSchema,
		    recommended: zod_1.z.boolean().optional(),
		    downloadIdentifier: zod_1.z.string(),
		    indexedModelIdentifier: zod_1.z.string(),
		});
		exports.modelSearchResultIdentifierSchema = zod_1.z.discriminatedUnion("type", [
		    zod_1.z.object({
		        type: zod_1.z.literal("catalog"),
		        identifier: zod_1.z.string(),
		    }),
		    zod_1.z.object({
		        type: zod_1.z.literal("hf"),
		        identifier: zod_1.z.string(),
		    }),
		]);
		exports.modelSearchResultEntryDataSchema = zod_1.z.object({
		    name: zod_1.z.string(),
		    identifier: exports.modelSearchResultIdentifierSchema,
		    exact: zod_1.z.boolean().optional(),
		    staffPick: zod_1.z.boolean().optional(),
		});
		exports.modelSearchOptsSchema = zod_1.z.object({
		    searchTerm: zod_1.z.string().optional(),
		    limit: zod_1.z.number().int().positive().max(25).optional(),
		    compatibilityTypes: zod_1.z.array(ModelCompatibilityType_js_1.modelCompatibilityTypeSchema).optional(),
		});
		
	} (ModelSearch));
	return ModelSearch;
}

var InternalRetrievalResult = {};

var hasRequiredInternalRetrievalResult;

function requireInternalRetrievalResult () {
	if (hasRequiredInternalRetrievalResult) return InternalRetrievalResult;
	hasRequiredInternalRetrievalResult = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.internalRetrievalResultSchema = exports.internalRetrievalResultEntrySchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.internalRetrievalResultEntrySchema = zod_1.z.object({
		    content: zod_1.z.string(),
		    score: zod_1.z.number(),
		    sourceIndex: zod_1.z.number().int(),
		    pageNumber: zod_1.z.union([zod_1.z.number().int(), zod_1.z.tuple([zod_1.z.number().int(), zod_1.z.number().int()])]).optional(),
		    lineNumber: zod_1.z.union([zod_1.z.number().int(), zod_1.z.tuple([zod_1.z.number().int(), zod_1.z.number().int()])]).optional(),
		});
		exports.internalRetrievalResultSchema = zod_1.z.object({
		    entries: zod_1.z.array(exports.internalRetrievalResultEntrySchema),
		});
		
	} (InternalRetrievalResult));
	return InternalRetrievalResult;
}

var RetrievalChunk = {};

var hasRequiredRetrievalChunk;

function requireRetrievalChunk () {
	if (hasRequiredRetrievalChunk) return RetrievalChunk;
	hasRequiredRetrievalChunk = 1;
	Object.defineProperty(RetrievalChunk, "__esModule", { value: true });
	RetrievalChunk.retrievalChunkSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	const CitationSource_js_1 = /*@__PURE__*/ requireCitationSource();
	RetrievalChunk.retrievalChunkSchema = zod_1.z.object({
	    content: zod_1.z.string(),
	    score: zod_1.z.number(),
	    citation: CitationSource_js_1.citationSourceSchema,
	});
	
	return RetrievalChunk;
}

var RetrievalChunkingMethod = {};

var hasRequiredRetrievalChunkingMethod;

function requireRetrievalChunkingMethod () {
	if (hasRequiredRetrievalChunkingMethod) return RetrievalChunkingMethod;
	hasRequiredRetrievalChunkingMethod = 1;
	Object.defineProperty(RetrievalChunkingMethod, "__esModule", { value: true });
	RetrievalChunkingMethod.retrievalChunkingMethodSchema = void 0;
	RetrievalChunkingMethod.serializeRetrievalChunkingMethod = serializeRetrievalChunkingMethod;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	RetrievalChunkingMethod.retrievalChunkingMethodSchema = zod_1.z.discriminatedUnion("type", [
	    zod_1.z.object({
	        type: zod_1.z.literal("recursive-v1"),
	        chunkSize: zod_1.z.number().int(),
	        chunkOverlap: zod_1.z.number().int(),
	    }),
	]);
	function serializeRetrievalChunkingMethod(chunkingMethod) {
	    switch (chunkingMethod.type) {
	        case "recursive-v1":
	            return `recursive-v1(${chunkingMethod.chunkSize},${chunkingMethod.chunkOverlap})`;
	        default: {
	            const exhaustiveCheck = chunkingMethod.type;
	            throw new Error(`Unknown chunking method type: ${exhaustiveCheck}.`);
	        }
	    }
	}
	
	return RetrievalChunkingMethod;
}

var RetrievalFileProcessingStep = {};

var hasRequiredRetrievalFileProcessingStep;

function requireRetrievalFileProcessingStep () {
	if (hasRequiredRetrievalFileProcessingStep) return RetrievalFileProcessingStep;
	hasRequiredRetrievalFileProcessingStep = 1;
	Object.defineProperty(RetrievalFileProcessingStep, "__esModule", { value: true });
	RetrievalFileProcessingStep.retrievalFileProcessingStepSchema = void 0;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	RetrievalFileProcessingStep.retrievalFileProcessingStepSchema = zod_1.z.enum(["loading", "chunking", "embedding"]);
	
	return RetrievalFileProcessingStep;
}

var Runtime = {};

var hasRequiredRuntime;

function requireRuntime () {
	if (hasRequiredRuntime) return Runtime;
	hasRequiredRuntime = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.runtimeSchema = exports.acceleratorSchema = exports.acceleratorTypeSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.acceleratorTypeSchema = zod_1.z.enum(["unknown", "integratedGpu", "dedicatedGpu"]);
		exports.acceleratorSchema = zod_1.z.object({
		    name: zod_1.z.string(),
		    deviceId: zod_1.z.number().int(),
		    totalMemoryBytes: zod_1.z.number().int(),
		    type: exports.acceleratorTypeSchema,
		});
		exports.runtimeSchema = zod_1.z.object({
		    key: zod_1.z.string(),
		    name: zod_1.z.string(),
		    accelerators: zod_1.z.array(exports.acceleratorSchema),
		});
		
	} (Runtime));
	return Runtime;
}

var SerializedKVConfigSchematics = {};

var hasRequiredSerializedKVConfigSchematics;

function requireSerializedKVConfigSchematics () {
	if (hasRequiredSerializedKVConfigSchematics) return SerializedKVConfigSchematics;
	hasRequiredSerializedKVConfigSchematics = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.kvConfigSchematicsDeserializationErrorSchema = exports.serializedKVConfigSchematicsSchema = exports.serializedKVConfigSchematicsFieldSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const JSONSerializable_js_1 = /*@__PURE__*/ requireJSONSerializable();
		exports.serializedKVConfigSchematicsFieldSchema = zod_1.z.object({
		    shortKey: zod_1.z.string(),
		    fullKey: zod_1.z.string(),
		    typeKey: zod_1.z.string(),
		    typeParams: JSONSerializable_js_1.jsonSerializableSchema,
		    defaultValue: JSONSerializable_js_1.jsonSerializableSchema,
		});
		exports.serializedKVConfigSchematicsSchema = zod_1.z.object({
		    fields: zod_1.z.array(exports.serializedKVConfigSchematicsFieldSchema),
		});
		exports.kvConfigSchematicsDeserializationErrorSchema = zod_1.z.object({
		    fullKey: zod_1.z.string(),
		    error: JSONSerializable_js_1.jsonSerializableSchema,
		});
		
	} (SerializedKVConfigSchematics));
	return SerializedKVConfigSchematics;
}

var VirtualModelDefinition = {};

var hasRequiredVirtualModelDefinition;

function requireVirtualModelDefinition () {
	if (hasRequiredVirtualModelDefinition) return VirtualModelDefinition;
	hasRequiredVirtualModelDefinition = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.virtualModelDefinitionSchema = exports.virtualModelDefinitionConcreteModelBaseSchema = exports.virtualModelDefinitionMetadataOverridesSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		const KVConfig_js_1 = /*@__PURE__*/ requireKVConfig();
		const ModelCompatibilityType_js_1 = /*@__PURE__*/ requireModelCompatibilityType();
		const ModelDomainType_js_1 = /*@__PURE__*/ requireModelDomainType();
		const ModelDownloadSource_js_1 = /*@__PURE__*/ requireModelDownloadSource();
		const virtualModelTrainedForToolUseSchema = zod_1.z.union([
		    zod_1.z.boolean(),
		    zod_1.z.literal("mixed"),
		]);
		const virtualModelVisionSupportSchema = zod_1.z.union([
		    zod_1.z.boolean(),
		    zod_1.z.literal("mixed"),
		]);
		exports.virtualModelDefinitionMetadataOverridesSchema = zod_1.z.object({
		    domain: ModelDomainType_js_1.modelDomainTypeSchema.optional(),
		    architectures: zod_1.z.array(zod_1.z.string()).optional(),
		    compatibilityTypes: zod_1.z.array(ModelCompatibilityType_js_1.modelCompatibilityTypeSchema).optional(),
		    paramsStrings: zod_1.z.array(zod_1.z.string()).optional(),
		    minMemoryUsageBytes: zod_1.z.number().optional(),
		    contextLengths: zod_1.z.array(zod_1.z.number()).optional(),
		    trainedForToolUse: virtualModelTrainedForToolUseSchema.optional(),
		    vision: virtualModelVisionSupportSchema.optional(),
		});
		exports.virtualModelDefinitionConcreteModelBaseSchema = zod_1.z.object({
		    key: zod_1.z.string(),
		    sources: zod_1.z.array(ModelDownloadSource_js_1.modelDownloadSourceSchema),
		});
		exports.virtualModelDefinitionSchema = zod_1.z.object({
		    model: zod_1.z.string().regex(/^[^/]+\/[^/]+$/),
		    base: zod_1.z.union([zod_1.z.string(), zod_1.z.array(exports.virtualModelDefinitionConcreteModelBaseSchema)]),
		    description: zod_1.z.string().max(1000).optional(),
		    tags: zod_1.z.array(zod_1.z.string().max(100)).optional(),
		    config: zod_1.z
		        .object({
		        load: KVConfig_js_1.kvConfigSchema.optional(),
		        operation: KVConfig_js_1.kvConfigSchema.optional(),
		    })
		        .optional(),
		    metadataOverrides: exports.virtualModelDefinitionMetadataOverridesSchema.optional(),
		});
		
	} (VirtualModelDefinition));
	return VirtualModelDefinition;
}

var hasRequiredCjs$4;

function requireCjs$4 () {
	if (hasRequiredCjs$4) return cjs$2;
	hasRequiredCjs$4 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.kebabCaseRegex = exports.jsonSerializableSchema = exports.gpuSplitStrategySchema = exports.gpuSplitStrategies = exports.gpuSplitConfigSchema = exports.defaultGPUSplitConfig = exports.convertGPUSettingToGPUSplitConfig = exports.fileTypeSchema = exports.parsedFileIdentifierSchema = exports.fileNamespaceSchema = exports.serializeError = exports.serializedLMSExtendedErrorSchema = exports.recreateSerializedError = exports.fromSerializedError = exports.extractDisplayData = exports.errorDisplayDataSchema = exports.attachSerializedErrorData = exports.embeddingModelInstanceInfoSchema = exports.embeddingModelInstanceAdditionalInfoSchema = exports.embeddingModelInfoSchema = exports.embeddingModelAdditionalInfoSchema = exports.embeddingLoadModelConfigSchema = exports.diagnosticsLogEventSchema = exports.diagnosticsLogEventDataSchema = exports.colorPaletteSchema = exports.colorPalette = exports.citationSourceSchema = exports.toolCallRequestSchema = exports.functionToolCallRequestSchema = exports.chatMessageRoleDataSchema = exports.chatMessagePartToolCallResultDataSchema = exports.chatMessagePartToolCallRequestDataSchema = exports.chatMessagePartTextDataSchema = exports.chatMessagePartFileDataSchema = exports.chatMessagePartDataSchema = exports.chatMessageDataSchema = exports.chatHistoryDataSchema = exports.backendNotificationSchema = exports.artifactModelDependencySchema = exports.artifactManifestBaseSchema = exports.artifactDependencySchema = exports.artifactDependencyPurposeSchema = exports.artifactDependencyBaseSchema = exports.artifactArtifactDependencySchema = exports.artifactTypeSchema = exports.artifactManifestSchema = exports.allowableEnvVarsSchema = exports.allowableEnvVarKeysSchema = exports.allowableEnvVarKeys = exports.logLevelSchema = void 0;
		exports.llmPromptTemplateTypeSchema = exports.llmPromptTemplateSchema = exports.llmManualPromptTemplateSchema = exports.llmJinjaPromptTemplateSchema = exports.llmJinjaInputMessagesContentImagesConfigSchema = exports.llmJinjaInputMessagesContentConfigTextFieldNameSchema = exports.llmJinjaInputMessagesContentConfigSchema = exports.llmJinjaInputMessagesConfigSchema = exports.llmJinjaInputConfigSchema = exports.llmPredictionStopReasonSchema = exports.llmPredictionStatsSchema = exports.llmGenInfoSchema = exports.llmPredictionFragmentSchema = exports.llmPredictionFragmentReasoningTypeSchema = exports.llmReasoningParsingSchema = exports.llmPredictionConfigSchema = exports.llmPredictionConfigInputSchema = exports.llmLlamaSingleLogitBiasModificationSchema = exports.llmLlamaMirostatSamplingConfigSchema = exports.llmLlamaLogitBiasConfigSchema = exports.llmContextOverflowPolicySchema = exports.llmInstanceInfoSchema = exports.llmInstanceAdditionalInfoSchema = exports.llmInfoSchema = exports.llmAdditionalInfoSchema = exports.llmSplitStrategySchema = exports.llmMlxKvCacheQuantizationSchema = exports.llmMlxKvCacheGroupSizeTypesSchema = exports.llmMlxKvCacheGroupSizeTypes = exports.llmMlxKvCacheBitsTypeSchema = exports.llmMlxKvCacheBitsTypes = exports.llmLoadModelConfigSchema = exports.llmLlamaCacheQuantizationTypeSchema = exports.llmLlamaCacheQuantizationTypes = exports.llmLlamaAccelerationOffloadRatioSchema = exports.gpuSettingSchema = exports.llmContextReferenceYamlFileSchema = exports.llmContextReferenceSchema = exports.llmContextReferenceJsonFileSchema = exports.llmApplyPromptTemplateOptsSchema = exports.contentBlockStyleSchema = exports.kvConfigStackSchema = exports.kvConfigStackLayerSchema = exports.kvConfigSchema = exports.kvConfigLayerNameSchema = exports.kvConfigFieldSchema = exports.kvConfigFieldDependencySchema = exports.kebabCaseWithDotsSchema = exports.kebabCaseWithDotsRegex = exports.kebabCaseSchema = void 0;
		exports.presetManifestSchema = exports.pluginRunnerTypeSchema = exports.pluginManifestSchema = exports.relativePathNoLeadingDotSlashSchema = exports.relativePathNoLeadingDotSlashRegex = exports.fileNameSchema = exports.fileNameRegex = exports.modelSpecifierSchema = exports.modelQuerySchema = exports.modelManifestSchema = exports.modelInstanceInfoBaseSchema = exports.modelInfoBaseSchema = exports.modelInstanceInfoSchema = exports.modelInfoSchema = exports.modelDownloadSourceSchema = exports.huggingFaceModelDownloadSourceSchema = exports.modelDomainTypeSchema = exports.modelCompatibilityTypeSchema = exports.getModelOptsSchema = exports.statusStepStatusSchema = exports.statusStepStateSchema = exports.processingUpdateStatusUpdateSchema = exports.processingUpdateStatusRemoveSchema = exports.processingUpdateStatusCreateSchema = exports.processingUpdateSetSenderNameSchema = exports.processingUpdateSchema = exports.processingUpdateDebugInfoBlockCreateSchema = exports.processingUpdateContentBlockSetSuffixSchema = exports.processingUpdateContentBlockSetStyleSchema = exports.processingUpdateContentBlockSetPrefixSchema = exports.processingUpdateContentBlockReplaceTextSchema = exports.processingUpdateContentBlockCreateSchema = exports.processingUpdateContentBlockAttachGenInfoSchema = exports.processingUpdateContentBlockAppendTextSchema = exports.processingUpdateCitationBlockCreateSchema = exports.blockLocationSchema = exports.processingRequestTextInputSchema = exports.processingRequestSchema = exports.processingRequestResponseTextInputSchema = exports.processingRequestResponseSchema = exports.processingRequestResponseConfirmToolCallSchema = exports.processingRequestConfirmToolCallSchema = exports.preprocessorUpdateSchema = exports.generatorUpdateSchema = exports.llmToolUseSettingSchema = exports.llmToolSchema = exports.llmToolParametersSchema = exports.llmToolArraySchema = exports.llmStructuredPredictionTypeSchema = exports.llmStructuredPredictionSettingSchema = void 0;
		exports.zodSchemaSchema = exports.virtualModelDefinitionSchema = exports.serializedKVConfigSchematicsSchema = exports.serializedKVConfigSchematicsFieldSchema = exports.kvConfigSchematicsDeserializationErrorSchema = exports.runtimeSchema = exports.acceleratorTypeSchema = exports.acceleratorSchema = exports.retrievalFileProcessingStepSchema = exports.serializeRetrievalChunkingMethod = exports.retrievalChunkingMethodSchema = exports.retrievalChunkSchema = exports.internalRetrievalResultSchema = exports.internalRetrievalResultEntrySchema = exports.modelSearchResultIdentifierSchema = exports.modelSearchResultEntryDataSchema = exports.modelSearchResultDownloadOptionDataSchema = exports.modelSearchOptsSchema = exports.downloadProgressUpdateSchema = exports.localArtifactFileListSchema = exports.localArtifactFileEntrySchema = exports.artifactDownloadPlanSchema = exports.artifactDownloadPlanNodeStateSchema = exports.artifactDownloadPlanNodeSchema = exports.artifactDownloadPlanModelInfoSchema = exports.reasonableKeyStringSchema = void 0;
		const zod_1 = /*@__PURE__*/ requireLib$1();
		exports.logLevelSchema = zod_1.z.enum(["debug", "info", "warn", "error"]);
		var AllowableEnvVars_js_1 = /*@__PURE__*/ requireAllowableEnvVars();
		Object.defineProperty(exports, "allowableEnvVarKeys", { enumerable: true, get: function () { return AllowableEnvVars_js_1.allowableEnvVarKeys; } });
		Object.defineProperty(exports, "allowableEnvVarKeysSchema", { enumerable: true, get: function () { return AllowableEnvVars_js_1.allowableEnvVarKeysSchema; } });
		Object.defineProperty(exports, "allowableEnvVarsSchema", { enumerable: true, get: function () { return AllowableEnvVars_js_1.allowableEnvVarsSchema; } });
		var ArtifactManifest_js_1 = /*@__PURE__*/ requireArtifactManifest();
		Object.defineProperty(exports, "artifactManifestSchema", { enumerable: true, get: function () { return ArtifactManifest_js_1.artifactManifestSchema; } });
		Object.defineProperty(exports, "artifactTypeSchema", { enumerable: true, get: function () { return ArtifactManifest_js_1.artifactTypeSchema; } });
		var ArtifactManifestBase_js_1 = /*@__PURE__*/ requireArtifactManifestBase();
		Object.defineProperty(exports, "artifactArtifactDependencySchema", { enumerable: true, get: function () { return ArtifactManifestBase_js_1.artifactArtifactDependencySchema; } });
		Object.defineProperty(exports, "artifactDependencyBaseSchema", { enumerable: true, get: function () { return ArtifactManifestBase_js_1.artifactDependencyBaseSchema; } });
		Object.defineProperty(exports, "artifactDependencyPurposeSchema", { enumerable: true, get: function () { return ArtifactManifestBase_js_1.artifactDependencyPurposeSchema; } });
		Object.defineProperty(exports, "artifactDependencySchema", { enumerable: true, get: function () { return ArtifactManifestBase_js_1.artifactDependencySchema; } });
		Object.defineProperty(exports, "artifactManifestBaseSchema", { enumerable: true, get: function () { return ArtifactManifestBase_js_1.artifactManifestBaseSchema; } });
		Object.defineProperty(exports, "artifactModelDependencySchema", { enumerable: true, get: function () { return ArtifactManifestBase_js_1.artifactModelDependencySchema; } });
		var BackendNotification_js_1 = /*@__PURE__*/ requireBackendNotification();
		Object.defineProperty(exports, "backendNotificationSchema", { enumerable: true, get: function () { return BackendNotification_js_1.backendNotificationSchema; } });
		var ChatHistoryData_js_1 = /*@__PURE__*/ requireChatHistoryData();
		Object.defineProperty(exports, "chatHistoryDataSchema", { enumerable: true, get: function () { return ChatHistoryData_js_1.chatHistoryDataSchema; } });
		Object.defineProperty(exports, "chatMessageDataSchema", { enumerable: true, get: function () { return ChatHistoryData_js_1.chatMessageDataSchema; } });
		Object.defineProperty(exports, "chatMessagePartDataSchema", { enumerable: true, get: function () { return ChatHistoryData_js_1.chatMessagePartDataSchema; } });
		Object.defineProperty(exports, "chatMessagePartFileDataSchema", { enumerable: true, get: function () { return ChatHistoryData_js_1.chatMessagePartFileDataSchema; } });
		Object.defineProperty(exports, "chatMessagePartTextDataSchema", { enumerable: true, get: function () { return ChatHistoryData_js_1.chatMessagePartTextDataSchema; } });
		Object.defineProperty(exports, "chatMessagePartToolCallRequestDataSchema", { enumerable: true, get: function () { return ChatHistoryData_js_1.chatMessagePartToolCallRequestDataSchema; } });
		Object.defineProperty(exports, "chatMessagePartToolCallResultDataSchema", { enumerable: true, get: function () { return ChatHistoryData_js_1.chatMessagePartToolCallResultDataSchema; } });
		Object.defineProperty(exports, "chatMessageRoleDataSchema", { enumerable: true, get: function () { return ChatHistoryData_js_1.chatMessageRoleDataSchema; } });
		Object.defineProperty(exports, "functionToolCallRequestSchema", { enumerable: true, get: function () { return ChatHistoryData_js_1.functionToolCallRequestSchema; } });
		Object.defineProperty(exports, "toolCallRequestSchema", { enumerable: true, get: function () { return ChatHistoryData_js_1.toolCallRequestSchema; } });
		var CitationSource_js_1 = /*@__PURE__*/ requireCitationSource();
		Object.defineProperty(exports, "citationSourceSchema", { enumerable: true, get: function () { return CitationSource_js_1.citationSourceSchema; } });
		var ColorPalette_js_1 = /*@__PURE__*/ requireColorPalette();
		Object.defineProperty(exports, "colorPalette", { enumerable: true, get: function () { return ColorPalette_js_1.colorPalette; } });
		Object.defineProperty(exports, "colorPaletteSchema", { enumerable: true, get: function () { return ColorPalette_js_1.colorPaletteSchema; } });
		var DiagnosticsLogEvent_js_1 = /*@__PURE__*/ requireDiagnosticsLogEvent();
		Object.defineProperty(exports, "diagnosticsLogEventDataSchema", { enumerable: true, get: function () { return DiagnosticsLogEvent_js_1.diagnosticsLogEventDataSchema; } });
		Object.defineProperty(exports, "diagnosticsLogEventSchema", { enumerable: true, get: function () { return DiagnosticsLogEvent_js_1.diagnosticsLogEventSchema; } });
		var EmbeddingLoadModelConfig_js_1 = /*@__PURE__*/ requireEmbeddingLoadModelConfig();
		Object.defineProperty(exports, "embeddingLoadModelConfigSchema", { enumerable: true, get: function () { return EmbeddingLoadModelConfig_js_1.embeddingLoadModelConfigSchema; } });
		var EmbeddingModelInfo_js_1 = /*@__PURE__*/ requireEmbeddingModelInfo();
		Object.defineProperty(exports, "embeddingModelAdditionalInfoSchema", { enumerable: true, get: function () { return EmbeddingModelInfo_js_1.embeddingModelAdditionalInfoSchema; } });
		Object.defineProperty(exports, "embeddingModelInfoSchema", { enumerable: true, get: function () { return EmbeddingModelInfo_js_1.embeddingModelInfoSchema; } });
		Object.defineProperty(exports, "embeddingModelInstanceAdditionalInfoSchema", { enumerable: true, get: function () { return EmbeddingModelInfo_js_1.embeddingModelInstanceAdditionalInfoSchema; } });
		Object.defineProperty(exports, "embeddingModelInstanceInfoSchema", { enumerable: true, get: function () { return EmbeddingModelInfo_js_1.embeddingModelInstanceInfoSchema; } });
		var Error_js_1 = /*@__PURE__*/ require_Error();
		Object.defineProperty(exports, "attachSerializedErrorData", { enumerable: true, get: function () { return Error_js_1.attachSerializedErrorData; } });
		Object.defineProperty(exports, "errorDisplayDataSchema", { enumerable: true, get: function () { return Error_js_1.errorDisplayDataSchema; } });
		Object.defineProperty(exports, "extractDisplayData", { enumerable: true, get: function () { return Error_js_1.extractDisplayData; } });
		Object.defineProperty(exports, "fromSerializedError", { enumerable: true, get: function () { return Error_js_1.fromSerializedError; } });
		Object.defineProperty(exports, "recreateSerializedError", { enumerable: true, get: function () { return Error_js_1.recreateSerializedError; } });
		Object.defineProperty(exports, "serializedLMSExtendedErrorSchema", { enumerable: true, get: function () { return Error_js_1.serializedLMSExtendedErrorSchema; } });
		Object.defineProperty(exports, "serializeError", { enumerable: true, get: function () { return Error_js_1.serializeError; } });
		var FileIdentifier_js_1 = /*@__PURE__*/ requireFileIdentifier();
		Object.defineProperty(exports, "fileNamespaceSchema", { enumerable: true, get: function () { return FileIdentifier_js_1.fileNamespaceSchema; } });
		Object.defineProperty(exports, "parsedFileIdentifierSchema", { enumerable: true, get: function () { return FileIdentifier_js_1.parsedFileIdentifierSchema; } });
		var FileType_js_1 = /*@__PURE__*/ requireFileType();
		Object.defineProperty(exports, "fileTypeSchema", { enumerable: true, get: function () { return FileType_js_1.fileTypeSchema; } });
		var GPUSplitStrategy_js_1 = /*@__PURE__*/ requireGPUSplitStrategy();
		Object.defineProperty(exports, "convertGPUSettingToGPUSplitConfig", { enumerable: true, get: function () { return GPUSplitStrategy_js_1.convertGPUSettingToGPUSplitConfig; } });
		Object.defineProperty(exports, "defaultGPUSplitConfig", { enumerable: true, get: function () { return GPUSplitStrategy_js_1.defaultGPUSplitConfig; } });
		Object.defineProperty(exports, "gpuSplitConfigSchema", { enumerable: true, get: function () { return GPUSplitStrategy_js_1.gpuSplitConfigSchema; } });
		Object.defineProperty(exports, "gpuSplitStrategies", { enumerable: true, get: function () { return GPUSplitStrategy_js_1.gpuSplitStrategies; } });
		Object.defineProperty(exports, "gpuSplitStrategySchema", { enumerable: true, get: function () { return GPUSplitStrategy_js_1.gpuSplitStrategySchema; } });
		var JSONSerializable_js_1 = /*@__PURE__*/ requireJSONSerializable();
		Object.defineProperty(exports, "jsonSerializableSchema", { enumerable: true, get: function () { return JSONSerializable_js_1.jsonSerializableSchema; } });
		var kebab_js_1 = /*@__PURE__*/ requireKebab();
		Object.defineProperty(exports, "kebabCaseRegex", { enumerable: true, get: function () { return kebab_js_1.kebabCaseRegex; } });
		Object.defineProperty(exports, "kebabCaseSchema", { enumerable: true, get: function () { return kebab_js_1.kebabCaseSchema; } });
		Object.defineProperty(exports, "kebabCaseWithDotsRegex", { enumerable: true, get: function () { return kebab_js_1.kebabCaseWithDotsRegex; } });
		Object.defineProperty(exports, "kebabCaseWithDotsSchema", { enumerable: true, get: function () { return kebab_js_1.kebabCaseWithDotsSchema; } });
		var KVConfig_js_1 = /*@__PURE__*/ requireKVConfig();
		Object.defineProperty(exports, "kvConfigFieldDependencySchema", { enumerable: true, get: function () { return KVConfig_js_1.kvConfigFieldDependencySchema; } });
		Object.defineProperty(exports, "kvConfigFieldSchema", { enumerable: true, get: function () { return KVConfig_js_1.kvConfigFieldSchema; } });
		Object.defineProperty(exports, "kvConfigLayerNameSchema", { enumerable: true, get: function () { return KVConfig_js_1.kvConfigLayerNameSchema; } });
		Object.defineProperty(exports, "kvConfigSchema", { enumerable: true, get: function () { return KVConfig_js_1.kvConfigSchema; } });
		Object.defineProperty(exports, "kvConfigStackLayerSchema", { enumerable: true, get: function () { return KVConfig_js_1.kvConfigStackLayerSchema; } });
		Object.defineProperty(exports, "kvConfigStackSchema", { enumerable: true, get: function () { return KVConfig_js_1.kvConfigStackSchema; } });
		var ContentBlockStyle_js_1 = /*@__PURE__*/ requireContentBlockStyle();
		Object.defineProperty(exports, "contentBlockStyleSchema", { enumerable: true, get: function () { return ContentBlockStyle_js_1.contentBlockStyleSchema; } });
		var LLMApplyPromptTemplateOpts_js_1 = /*@__PURE__*/ requireLLMApplyPromptTemplateOpts();
		Object.defineProperty(exports, "llmApplyPromptTemplateOptsSchema", { enumerable: true, get: function () { return LLMApplyPromptTemplateOpts_js_1.llmApplyPromptTemplateOptsSchema; } });
		var LLMContextReference_js_1 = /*@__PURE__*/ requireLLMContextReference();
		Object.defineProperty(exports, "llmContextReferenceJsonFileSchema", { enumerable: true, get: function () { return LLMContextReference_js_1.llmContextReferenceJsonFileSchema; } });
		Object.defineProperty(exports, "llmContextReferenceSchema", { enumerable: true, get: function () { return LLMContextReference_js_1.llmContextReferenceSchema; } });
		Object.defineProperty(exports, "llmContextReferenceYamlFileSchema", { enumerable: true, get: function () { return LLMContextReference_js_1.llmContextReferenceYamlFileSchema; } });
		var LLMLoadModelConfig_js_1 = /*@__PURE__*/ requireLLMLoadModelConfig();
		Object.defineProperty(exports, "gpuSettingSchema", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.gpuSettingSchema; } });
		Object.defineProperty(exports, "llmLlamaAccelerationOffloadRatioSchema", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.llmLlamaAccelerationOffloadRatioSchema; } });
		Object.defineProperty(exports, "llmLlamaCacheQuantizationTypes", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.llmLlamaCacheQuantizationTypes; } });
		Object.defineProperty(exports, "llmLlamaCacheQuantizationTypeSchema", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.llmLlamaCacheQuantizationTypeSchema; } });
		Object.defineProperty(exports, "llmLoadModelConfigSchema", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.llmLoadModelConfigSchema; } });
		Object.defineProperty(exports, "llmMlxKvCacheBitsTypes", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.llmMlxKvCacheBitsTypes; } });
		Object.defineProperty(exports, "llmMlxKvCacheBitsTypeSchema", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.llmMlxKvCacheBitsTypeSchema; } });
		Object.defineProperty(exports, "llmMlxKvCacheGroupSizeTypes", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.llmMlxKvCacheGroupSizeTypes; } });
		Object.defineProperty(exports, "llmMlxKvCacheGroupSizeTypesSchema", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.llmMlxKvCacheGroupSizeTypesSchema; } });
		Object.defineProperty(exports, "llmMlxKvCacheQuantizationSchema", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.llmMlxKvCacheQuantizationSchema; } });
		Object.defineProperty(exports, "llmSplitStrategySchema", { enumerable: true, get: function () { return LLMLoadModelConfig_js_1.llmSplitStrategySchema; } });
		var LLMModelInfo_js_1 = /*@__PURE__*/ requireLLMModelInfo();
		Object.defineProperty(exports, "llmAdditionalInfoSchema", { enumerable: true, get: function () { return LLMModelInfo_js_1.llmAdditionalInfoSchema; } });
		Object.defineProperty(exports, "llmInfoSchema", { enumerable: true, get: function () { return LLMModelInfo_js_1.llmInfoSchema; } });
		Object.defineProperty(exports, "llmInstanceAdditionalInfoSchema", { enumerable: true, get: function () { return LLMModelInfo_js_1.llmInstanceAdditionalInfoSchema; } });
		Object.defineProperty(exports, "llmInstanceInfoSchema", { enumerable: true, get: function () { return LLMModelInfo_js_1.llmInstanceInfoSchema; } });
		var LLMPredictionConfig_js_1 = /*@__PURE__*/ requireLLMPredictionConfig();
		Object.defineProperty(exports, "llmContextOverflowPolicySchema", { enumerable: true, get: function () { return LLMPredictionConfig_js_1.llmContextOverflowPolicySchema; } });
		Object.defineProperty(exports, "llmLlamaLogitBiasConfigSchema", { enumerable: true, get: function () { return LLMPredictionConfig_js_1.llmLlamaLogitBiasConfigSchema; } });
		Object.defineProperty(exports, "llmLlamaMirostatSamplingConfigSchema", { enumerable: true, get: function () { return LLMPredictionConfig_js_1.llmLlamaMirostatSamplingConfigSchema; } });
		Object.defineProperty(exports, "llmLlamaSingleLogitBiasModificationSchema", { enumerable: true, get: function () { return LLMPredictionConfig_js_1.llmLlamaSingleLogitBiasModificationSchema; } });
		Object.defineProperty(exports, "llmPredictionConfigInputSchema", { enumerable: true, get: function () { return LLMPredictionConfig_js_1.llmPredictionConfigInputSchema; } });
		Object.defineProperty(exports, "llmPredictionConfigSchema", { enumerable: true, get: function () { return LLMPredictionConfig_js_1.llmPredictionConfigSchema; } });
		Object.defineProperty(exports, "llmReasoningParsingSchema", { enumerable: true, get: function () { return LLMPredictionConfig_js_1.llmReasoningParsingSchema; } });
		var LLMPredictionFragment_js_1 = /*@__PURE__*/ requireLLMPredictionFragment();
		Object.defineProperty(exports, "llmPredictionFragmentReasoningTypeSchema", { enumerable: true, get: function () { return LLMPredictionFragment_js_1.llmPredictionFragmentReasoningTypeSchema; } });
		Object.defineProperty(exports, "llmPredictionFragmentSchema", { enumerable: true, get: function () { return LLMPredictionFragment_js_1.llmPredictionFragmentSchema; } });
		var LLMPredictionStats_js_1 = /*@__PURE__*/ requireLLMPredictionStats();
		Object.defineProperty(exports, "llmGenInfoSchema", { enumerable: true, get: function () { return LLMPredictionStats_js_1.llmGenInfoSchema; } });
		Object.defineProperty(exports, "llmPredictionStatsSchema", { enumerable: true, get: function () { return LLMPredictionStats_js_1.llmPredictionStatsSchema; } });
		Object.defineProperty(exports, "llmPredictionStopReasonSchema", { enumerable: true, get: function () { return LLMPredictionStats_js_1.llmPredictionStopReasonSchema; } });
		var LLMPromptTemplate_js_1 = /*@__PURE__*/ requireLLMPromptTemplate();
		Object.defineProperty(exports, "llmJinjaInputConfigSchema", { enumerable: true, get: function () { return LLMPromptTemplate_js_1.llmJinjaInputConfigSchema; } });
		Object.defineProperty(exports, "llmJinjaInputMessagesConfigSchema", { enumerable: true, get: function () { return LLMPromptTemplate_js_1.llmJinjaInputMessagesConfigSchema; } });
		Object.defineProperty(exports, "llmJinjaInputMessagesContentConfigSchema", { enumerable: true, get: function () { return LLMPromptTemplate_js_1.llmJinjaInputMessagesContentConfigSchema; } });
		Object.defineProperty(exports, "llmJinjaInputMessagesContentConfigTextFieldNameSchema", { enumerable: true, get: function () { return LLMPromptTemplate_js_1.llmJinjaInputMessagesContentConfigTextFieldNameSchema; } });
		Object.defineProperty(exports, "llmJinjaInputMessagesContentImagesConfigSchema", { enumerable: true, get: function () { return LLMPromptTemplate_js_1.llmJinjaInputMessagesContentImagesConfigSchema; } });
		Object.defineProperty(exports, "llmJinjaPromptTemplateSchema", { enumerable: true, get: function () { return LLMPromptTemplate_js_1.llmJinjaPromptTemplateSchema; } });
		Object.defineProperty(exports, "llmManualPromptTemplateSchema", { enumerable: true, get: function () { return LLMPromptTemplate_js_1.llmManualPromptTemplateSchema; } });
		Object.defineProperty(exports, "llmPromptTemplateSchema", { enumerable: true, get: function () { return LLMPromptTemplate_js_1.llmPromptTemplateSchema; } });
		Object.defineProperty(exports, "llmPromptTemplateTypeSchema", { enumerable: true, get: function () { return LLMPromptTemplate_js_1.llmPromptTemplateTypeSchema; } });
		var LLMStructuredPredictionSetting_js_1 = /*@__PURE__*/ requireLLMStructuredPredictionSetting();
		Object.defineProperty(exports, "llmStructuredPredictionSettingSchema", { enumerable: true, get: function () { return LLMStructuredPredictionSetting_js_1.llmStructuredPredictionSettingSchema; } });
		Object.defineProperty(exports, "llmStructuredPredictionTypeSchema", { enumerable: true, get: function () { return LLMStructuredPredictionSetting_js_1.llmStructuredPredictionTypeSchema; } });
		var LLMToolUseSetting_js_1 = /*@__PURE__*/ requireLLMToolUseSetting();
		Object.defineProperty(exports, "llmToolArraySchema", { enumerable: true, get: function () { return LLMToolUseSetting_js_1.llmToolArraySchema; } });
		Object.defineProperty(exports, "llmToolParametersSchema", { enumerable: true, get: function () { return LLMToolUseSetting_js_1.llmToolParametersSchema; } });
		Object.defineProperty(exports, "llmToolSchema", { enumerable: true, get: function () { return LLMToolUseSetting_js_1.llmToolSchema; } });
		Object.defineProperty(exports, "llmToolUseSettingSchema", { enumerable: true, get: function () { return LLMToolUseSetting_js_1.llmToolUseSettingSchema; } });
		var GeneratorUpdate_js_1 = /*@__PURE__*/ requireGeneratorUpdate();
		Object.defineProperty(exports, "generatorUpdateSchema", { enumerable: true, get: function () { return GeneratorUpdate_js_1.generatorUpdateSchema; } });
		var PreprocessorUpdate_js_1 = /*@__PURE__*/ requirePreprocessorUpdate();
		Object.defineProperty(exports, "preprocessorUpdateSchema", { enumerable: true, get: function () { return PreprocessorUpdate_js_1.preprocessorUpdateSchema; } });
		var ProcessingRequest_js_1 = /*@__PURE__*/ requireProcessingRequest();
		Object.defineProperty(exports, "processingRequestConfirmToolCallSchema", { enumerable: true, get: function () { return ProcessingRequest_js_1.processingRequestConfirmToolCallSchema; } });
		Object.defineProperty(exports, "processingRequestResponseConfirmToolCallSchema", { enumerable: true, get: function () { return ProcessingRequest_js_1.processingRequestResponseConfirmToolCallSchema; } });
		Object.defineProperty(exports, "processingRequestResponseSchema", { enumerable: true, get: function () { return ProcessingRequest_js_1.processingRequestResponseSchema; } });
		Object.defineProperty(exports, "processingRequestResponseTextInputSchema", { enumerable: true, get: function () { return ProcessingRequest_js_1.processingRequestResponseTextInputSchema; } });
		Object.defineProperty(exports, "processingRequestSchema", { enumerable: true, get: function () { return ProcessingRequest_js_1.processingRequestSchema; } });
		Object.defineProperty(exports, "processingRequestTextInputSchema", { enumerable: true, get: function () { return ProcessingRequest_js_1.processingRequestTextInputSchema; } });
		var ProcessingUpdate_js_1 = /*@__PURE__*/ requireProcessingUpdate();
		Object.defineProperty(exports, "blockLocationSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.blockLocationSchema; } });
		Object.defineProperty(exports, "processingUpdateCitationBlockCreateSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateCitationBlockCreateSchema; } });
		Object.defineProperty(exports, "processingUpdateContentBlockAppendTextSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateContentBlockAppendTextSchema; } });
		Object.defineProperty(exports, "processingUpdateContentBlockAttachGenInfoSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateContentBlockAttachGenInfoSchema; } });
		Object.defineProperty(exports, "processingUpdateContentBlockCreateSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateContentBlockCreateSchema; } });
		Object.defineProperty(exports, "processingUpdateContentBlockReplaceTextSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateContentBlockReplaceTextSchema; } });
		Object.defineProperty(exports, "processingUpdateContentBlockSetPrefixSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateContentBlockSetPrefixSchema; } });
		Object.defineProperty(exports, "processingUpdateContentBlockSetStyleSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateContentBlockSetStyleSchema; } });
		Object.defineProperty(exports, "processingUpdateContentBlockSetSuffixSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateContentBlockSetSuffixSchema; } });
		Object.defineProperty(exports, "processingUpdateDebugInfoBlockCreateSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateDebugInfoBlockCreateSchema; } });
		Object.defineProperty(exports, "processingUpdateSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateSchema; } });
		Object.defineProperty(exports, "processingUpdateSetSenderNameSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateSetSenderNameSchema; } });
		Object.defineProperty(exports, "processingUpdateStatusCreateSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateStatusCreateSchema; } });
		Object.defineProperty(exports, "processingUpdateStatusRemoveSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateStatusRemoveSchema; } });
		Object.defineProperty(exports, "processingUpdateStatusUpdateSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.processingUpdateStatusUpdateSchema; } });
		Object.defineProperty(exports, "statusStepStateSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.statusStepStateSchema; } });
		Object.defineProperty(exports, "statusStepStatusSchema", { enumerable: true, get: function () { return ProcessingUpdate_js_1.statusStepStatusSchema; } });
		var Processor_js_1 = /*@__PURE__*/ requireProcessor();
		Object.defineProperty(exports, "getModelOptsSchema", { enumerable: true, get: function () { return Processor_js_1.getModelOptsSchema; } });
		var ModelCompatibilityType_js_1 = /*@__PURE__*/ requireModelCompatibilityType();
		Object.defineProperty(exports, "modelCompatibilityTypeSchema", { enumerable: true, get: function () { return ModelCompatibilityType_js_1.modelCompatibilityTypeSchema; } });
		var ModelDomainType_js_1 = /*@__PURE__*/ requireModelDomainType();
		Object.defineProperty(exports, "modelDomainTypeSchema", { enumerable: true, get: function () { return ModelDomainType_js_1.modelDomainTypeSchema; } });
		var ModelDownloadSource_js_1 = /*@__PURE__*/ requireModelDownloadSource();
		Object.defineProperty(exports, "huggingFaceModelDownloadSourceSchema", { enumerable: true, get: function () { return ModelDownloadSource_js_1.huggingFaceModelDownloadSourceSchema; } });
		Object.defineProperty(exports, "modelDownloadSourceSchema", { enumerable: true, get: function () { return ModelDownloadSource_js_1.modelDownloadSourceSchema; } });
		var ModelInfo_js_1 = /*@__PURE__*/ requireModelInfo();
		Object.defineProperty(exports, "modelInfoSchema", { enumerable: true, get: function () { return ModelInfo_js_1.modelInfoSchema; } });
		Object.defineProperty(exports, "modelInstanceInfoSchema", { enumerable: true, get: function () { return ModelInfo_js_1.modelInstanceInfoSchema; } });
		var ModelInfoBase_js_1 = /*@__PURE__*/ requireModelInfoBase();
		Object.defineProperty(exports, "modelInfoBaseSchema", { enumerable: true, get: function () { return ModelInfoBase_js_1.modelInfoBaseSchema; } });
		Object.defineProperty(exports, "modelInstanceInfoBaseSchema", { enumerable: true, get: function () { return ModelInfoBase_js_1.modelInstanceInfoBaseSchema; } });
		var ModelManifest_js_1 = /*@__PURE__*/ requireModelManifest();
		Object.defineProperty(exports, "modelManifestSchema", { enumerable: true, get: function () { return ModelManifest_js_1.modelManifestSchema; } });
		var ModelSpecifier_js_1 = /*@__PURE__*/ requireModelSpecifier();
		Object.defineProperty(exports, "modelQuerySchema", { enumerable: true, get: function () { return ModelSpecifier_js_1.modelQuerySchema; } });
		Object.defineProperty(exports, "modelSpecifierSchema", { enumerable: true, get: function () { return ModelSpecifier_js_1.modelSpecifierSchema; } });
		var path_js_1 = /*@__PURE__*/ requirePath();
		Object.defineProperty(exports, "fileNameRegex", { enumerable: true, get: function () { return path_js_1.fileNameRegex; } });
		Object.defineProperty(exports, "fileNameSchema", { enumerable: true, get: function () { return path_js_1.fileNameSchema; } });
		Object.defineProperty(exports, "relativePathNoLeadingDotSlashRegex", { enumerable: true, get: function () { return path_js_1.relativePathNoLeadingDotSlashRegex; } });
		Object.defineProperty(exports, "relativePathNoLeadingDotSlashSchema", { enumerable: true, get: function () { return path_js_1.relativePathNoLeadingDotSlashSchema; } });
		var PluginManifest_js_1 = /*@__PURE__*/ requirePluginManifest();
		Object.defineProperty(exports, "pluginManifestSchema", { enumerable: true, get: function () { return PluginManifest_js_1.pluginManifestSchema; } });
		Object.defineProperty(exports, "pluginRunnerTypeSchema", { enumerable: true, get: function () { return PluginManifest_js_1.pluginRunnerTypeSchema; } });
		var PresetManifest_js_1 = /*@__PURE__*/ requirePresetManifest();
		Object.defineProperty(exports, "presetManifestSchema", { enumerable: true, get: function () { return PresetManifest_js_1.presetManifestSchema; } });
		var reasonable_js_1 = /*@__PURE__*/ requireReasonable();
		Object.defineProperty(exports, "reasonableKeyStringSchema", { enumerable: true, get: function () { return reasonable_js_1.reasonableKeyStringSchema; } });
		var ArtifactDownloadPlan_js_1 = /*@__PURE__*/ requireArtifactDownloadPlan();
		Object.defineProperty(exports, "artifactDownloadPlanModelInfoSchema", { enumerable: true, get: function () { return ArtifactDownloadPlan_js_1.artifactDownloadPlanModelInfoSchema; } });
		Object.defineProperty(exports, "artifactDownloadPlanNodeSchema", { enumerable: true, get: function () { return ArtifactDownloadPlan_js_1.artifactDownloadPlanNodeSchema; } });
		Object.defineProperty(exports, "artifactDownloadPlanNodeStateSchema", { enumerable: true, get: function () { return ArtifactDownloadPlan_js_1.artifactDownloadPlanNodeStateSchema; } });
		Object.defineProperty(exports, "artifactDownloadPlanSchema", { enumerable: true, get: function () { return ArtifactDownloadPlan_js_1.artifactDownloadPlanSchema; } });
		var ArtifactUpload_js_1 = /*@__PURE__*/ requireArtifactUpload();
		Object.defineProperty(exports, "localArtifactFileEntrySchema", { enumerable: true, get: function () { return ArtifactUpload_js_1.localArtifactFileEntrySchema; } });
		Object.defineProperty(exports, "localArtifactFileListSchema", { enumerable: true, get: function () { return ArtifactUpload_js_1.localArtifactFileListSchema; } });
		var DownloadProgressUpdate_js_1 = /*@__PURE__*/ requireDownloadProgressUpdate();
		Object.defineProperty(exports, "downloadProgressUpdateSchema", { enumerable: true, get: function () { return DownloadProgressUpdate_js_1.downloadProgressUpdateSchema; } });
		var ModelSearch_js_1 = /*@__PURE__*/ requireModelSearch();
		Object.defineProperty(exports, "modelSearchOptsSchema", { enumerable: true, get: function () { return ModelSearch_js_1.modelSearchOptsSchema; } });
		Object.defineProperty(exports, "modelSearchResultDownloadOptionDataSchema", { enumerable: true, get: function () { return ModelSearch_js_1.modelSearchResultDownloadOptionDataSchema; } });
		Object.defineProperty(exports, "modelSearchResultEntryDataSchema", { enumerable: true, get: function () { return ModelSearch_js_1.modelSearchResultEntryDataSchema; } });
		Object.defineProperty(exports, "modelSearchResultIdentifierSchema", { enumerable: true, get: function () { return ModelSearch_js_1.modelSearchResultIdentifierSchema; } });
		var InternalRetrievalResult_js_1 = /*@__PURE__*/ requireInternalRetrievalResult();
		Object.defineProperty(exports, "internalRetrievalResultEntrySchema", { enumerable: true, get: function () { return InternalRetrievalResult_js_1.internalRetrievalResultEntrySchema; } });
		Object.defineProperty(exports, "internalRetrievalResultSchema", { enumerable: true, get: function () { return InternalRetrievalResult_js_1.internalRetrievalResultSchema; } });
		var RetrievalChunk_js_1 = /*@__PURE__*/ requireRetrievalChunk();
		Object.defineProperty(exports, "retrievalChunkSchema", { enumerable: true, get: function () { return RetrievalChunk_js_1.retrievalChunkSchema; } });
		var RetrievalChunkingMethod_js_1 = /*@__PURE__*/ requireRetrievalChunkingMethod();
		Object.defineProperty(exports, "retrievalChunkingMethodSchema", { enumerable: true, get: function () { return RetrievalChunkingMethod_js_1.retrievalChunkingMethodSchema; } });
		Object.defineProperty(exports, "serializeRetrievalChunkingMethod", { enumerable: true, get: function () { return RetrievalChunkingMethod_js_1.serializeRetrievalChunkingMethod; } });
		var RetrievalFileProcessingStep_js_1 = /*@__PURE__*/ requireRetrievalFileProcessingStep();
		Object.defineProperty(exports, "retrievalFileProcessingStepSchema", { enumerable: true, get: function () { return RetrievalFileProcessingStep_js_1.retrievalFileProcessingStepSchema; } });
		var Runtime_js_1 = /*@__PURE__*/ requireRuntime();
		Object.defineProperty(exports, "acceleratorSchema", { enumerable: true, get: function () { return Runtime_js_1.acceleratorSchema; } });
		Object.defineProperty(exports, "acceleratorTypeSchema", { enumerable: true, get: function () { return Runtime_js_1.acceleratorTypeSchema; } });
		Object.defineProperty(exports, "runtimeSchema", { enumerable: true, get: function () { return Runtime_js_1.runtimeSchema; } });
		var SerializedKVConfigSchematics_js_1 = /*@__PURE__*/ requireSerializedKVConfigSchematics();
		Object.defineProperty(exports, "kvConfigSchematicsDeserializationErrorSchema", { enumerable: true, get: function () { return SerializedKVConfigSchematics_js_1.kvConfigSchematicsDeserializationErrorSchema; } });
		Object.defineProperty(exports, "serializedKVConfigSchematicsFieldSchema", { enumerable: true, get: function () { return SerializedKVConfigSchematics_js_1.serializedKVConfigSchematicsFieldSchema; } });
		Object.defineProperty(exports, "serializedKVConfigSchematicsSchema", { enumerable: true, get: function () { return SerializedKVConfigSchematics_js_1.serializedKVConfigSchematicsSchema; } });
		var VirtualModelDefinition_js_1 = /*@__PURE__*/ requireVirtualModelDefinition();
		Object.defineProperty(exports, "virtualModelDefinitionSchema", { enumerable: true, get: function () { return VirtualModelDefinition_js_1.virtualModelDefinitionSchema; } });
		var Zod_js_1 = /*@__PURE__*/ requireZod();
		Object.defineProperty(exports, "zodSchemaSchema", { enumerable: true, get: function () { return Zod_js_1.zodSchemaSchema; } });
		
	} (cjs$2));
	return cjs$2;
}

var hasRequiredResultTypes;

function requireResultTypes () {
	if (hasRequiredResultTypes) return resultTypes;
	hasRequiredResultTypes = 1;
	Object.defineProperty(resultTypes, "__esModule", { value: true });
	resultTypes.maybeErroredSchema = void 0;
	resultTypes.promiseToMaybeErrored = promiseToMaybeErrored;
	resultTypes.unwrapPromiseOfMaybeErrored = unwrapPromiseOfMaybeErrored;
	resultTypes.createResultSchema = createResultSchema;
	resultTypes.promiseToResult = promiseToResult;
	resultTypes.unwrapPromiseOfResult = unwrapPromiseOfResult;
	resultTypes.unwrapResult = unwrapResult;
	resultTypes.routeResultToCallbacks = routeResultToCallbacks;
	const lms_shared_types_1 = /*@__PURE__*/ requireCjs$4();
	const zod_1 = /*@__PURE__*/ requireLib$1();
	resultTypes.maybeErroredSchema = zod_1.z.discriminatedUnion("success", [
	    zod_1.z.object({
	        success: zod_1.z.literal(true),
	    }),
	    zod_1.z.object({
	        success: zod_1.z.literal(false),
	        error: lms_shared_types_1.serializedLMSExtendedErrorSchema,
	    }),
	]);
	function promiseToMaybeErrored(promise) {
	    return promise.then(() => ({ success: true }), error => ({ success: false, error: (0, lms_shared_types_1.serializeError)(error) }));
	}
	async function unwrapPromiseOfMaybeErrored(promise) {
	    const result = await promise;
	    if (result.success) {
	        return Promise.resolve();
	    }
	    else {
	        return Promise.reject((0, lms_shared_types_1.fromSerializedError)(result.error));
	    }
	}
	function createResultSchema(schema) {
	    return zod_1.z.discriminatedUnion("success", [
	        zod_1.z.object({
	            success: zod_1.z.literal(true),
	            result: schema,
	        }),
	        zod_1.z.object({
	            success: zod_1.z.literal(false),
	            error: lms_shared_types_1.serializedLMSExtendedErrorSchema,
	        }),
	    ]);
	}
	function promiseToResult(promise) {
	    return promise.then(result => ({ success: true, result }), error => ({ success: false, error: (0, lms_shared_types_1.serializeError)(error) }));
	}
	async function unwrapPromiseOfResult(promise) {
	    const result = await promise;
	    if (result.success) {
	        return result.result;
	    }
	    else {
	        return Promise.reject((0, lms_shared_types_1.fromSerializedError)(result.error));
	    }
	}
	function unwrapResult(result) {
	    if (result.success) {
	        return result.result;
	    }
	    else {
	        throw (0, lms_shared_types_1.fromSerializedError)(result.error);
	    }
	}
	function routeResultToCallbacks(result, resolve, reject) {
	    if (result.success) {
	        resolve(result.result);
	    }
	    else {
	        reject((0, lms_shared_types_1.fromSerializedError)(result.error));
	    }
	}
	
	return resultTypes;
}

var runOnDispose = {};

var hasRequiredRunOnDispose;

function requireRunOnDispose () {
	if (hasRequiredRunOnDispose) return runOnDispose;
	hasRequiredRunOnDispose = 1;
	Object.defineProperty(runOnDispose, "__esModule", { value: true });
	runOnDispose.runOnDispose = runOnDispose$1;
	function runOnDispose$1(fn) {
	    return {
	        [Symbol.dispose]: fn,
	    };
	}
	
	return runOnDispose;
}

var safeCallCallback = {};

var hasRequiredSafeCallCallback;

function requireSafeCallCallback () {
	if (hasRequiredSafeCallCallback) return safeCallCallback;
	hasRequiredSafeCallCallback = 1;
	Object.defineProperty(safeCallCallback, "__esModule", { value: true });
	safeCallCallback.safeCallCallback = safeCallCallback$1;
	/**
	 * Call a user provided callback and log any errors that occur. This prevents the error from
	 * crashing the application.
	 */
	function safeCallCallback$1(logger, name, callback, args) {
	    if (callback === undefined) {
	        return;
	    }
	    try {
	        const maybePromise = callback(...args);
	        if (typeof maybePromise === "object" && typeof maybePromise.catch === "function") {
	            maybePromise.catch((error) => {
	                logger.error(`Error in the ${name} callback (triggered asynchronously):`, error);
	            });
	        }
	    }
	    catch (error) {
	        logger.error(`Error in the ${name} callback:`, error);
	    }
	}
	
	return safeCallCallback;
}

var SimpleLogger = {};

var hasRequiredSimpleLogger;

function requireSimpleLogger () {
	if (hasRequiredSimpleLogger) return SimpleLogger;
	hasRequiredSimpleLogger = 1;
	var __importDefault = (SimpleLogger && SimpleLogger.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(SimpleLogger, "__esModule", { value: true });
	SimpleLogger.SimpleLogger = void 0;
	const chalk_1 = __importDefault(requireSource());
	const text_js_1 = /*@__PURE__*/ requireText();
	function isSimpleLogger(logger) {
	    return logger?.isSimpleLogger === true;
	}
	const defaultInfoPrefix = chalk_1.default.greenBright("I");
	const defaultWarnPrefix = chalk_1.default.yellowBright("W");
	const defaultErrorPrefix = chalk_1.default.redBright("E");
	const defaultDebugPrefix = chalk_1.default.blueBright("D");
	let SimpleLogger$1 = class SimpleLogger {
	    constructor(prefixText = "", parentLogger = console, { useLogLevelPrefixes, infoPrefix, warnPrefix, errorPrefix, debugPrefix, } = {}) {
	        this.isSimpleLogger = true;
	        this.infoPrefix = [];
	        this.warnPrefix = [];
	        this.errorPrefix = [];
	        this.debugPrefix = [];
	        if (isSimpleLogger(parentLogger)) {
	            useLogLevelPrefixes = useLogLevelPrefixes ?? parentLogger.opts.useLogLevelPrefixes;
	            infoPrefix = infoPrefix === undefined ? parentLogger.opts.infoPrefix : infoPrefix;
	            warnPrefix = warnPrefix === undefined ? parentLogger.opts.warnPrefix : warnPrefix;
	            errorPrefix = errorPrefix === undefined ? parentLogger.opts.errorPrefix : errorPrefix;
	            debugPrefix = debugPrefix === undefined ? parentLogger.opts.debugPrefix : debugPrefix;
	            if (prefixText === "") {
	                this.innerPrefix = parentLogger.innerPrefix;
	                this.fullPrefix = parentLogger.fullPrefix;
	            }
	            else {
	                if (parentLogger.fullPrefix === "") {
	                    this.innerPrefix = prefixText;
	                }
	                else {
	                    this.innerPrefix = `${parentLogger.innerPrefix}][${prefixText}`;
	                }
	                this.fullPrefix = chalk_1.default.whiteBright(`[${this.innerPrefix}]`);
	            }
	            this.parentLogger = parentLogger.parentLogger;
	        }
	        else {
	            useLogLevelPrefixes = useLogLevelPrefixes ?? false;
	            infoPrefix = infoPrefix === undefined ? defaultInfoPrefix : infoPrefix;
	            warnPrefix = warnPrefix === undefined ? defaultWarnPrefix : warnPrefix;
	            errorPrefix = errorPrefix === undefined ? defaultErrorPrefix : errorPrefix;
	            debugPrefix = debugPrefix === undefined ? defaultDebugPrefix : debugPrefix;
	            if (prefixText === "") {
	                this.innerPrefix = "";
	                this.fullPrefix = "";
	            }
	            else {
	                this.innerPrefix = prefixText;
	                this.fullPrefix = chalk_1.default.whiteBright(`[${this.innerPrefix}]`);
	            }
	            this.parentLogger = parentLogger;
	        }
	        if (useLogLevelPrefixes) {
	            if (infoPrefix !== null) {
	                this.infoPrefix.push(infoPrefix);
	            }
	            if (warnPrefix !== null) {
	                this.warnPrefix.push(warnPrefix);
	            }
	            if (errorPrefix !== null) {
	                this.errorPrefix.push(errorPrefix);
	            }
	            if (debugPrefix !== null) {
	                this.debugPrefix.push(debugPrefix);
	            }
	        }
	        if (this.fullPrefix !== "") {
	            this.infoPrefix.push(this.fullPrefix);
	            this.warnPrefix.push(this.fullPrefix);
	            this.errorPrefix.push(this.fullPrefix);
	            this.debugPrefix.push(this.fullPrefix);
	        }
	        this.opts = {
	            useLogLevelPrefixes,
	            infoPrefix,
	            warnPrefix,
	            errorPrefix,
	            debugPrefix,
	        };
	    }
	    subclass(prefixText) {
	        return new SimpleLogger(`${this.innerPrefix}:${prefixText}`, this.parentLogger);
	    }
	    info(...messages) {
	        this.parentLogger.info(...this.infoPrefix, ...messages);
	    }
	    infoText(strings, ...values) {
	        this.info((0, text_js_1.text)(strings, ...values));
	    }
	    infoWithoutPrefix(...messages) {
	        this.parentLogger.info(...messages);
	    }
	    error(...messages) {
	        this.parentLogger.error(...this.errorPrefix, ...messages);
	    }
	    errorText(strings, ...values) {
	        this.error((0, text_js_1.text)(strings, ...values));
	    }
	    errorWithoutPrefix(...messages) {
	        this.parentLogger.error(...messages);
	    }
	    warn(...messages) {
	        this.parentLogger.warn(...this.warnPrefix, ...messages);
	    }
	    warnText(strings, ...values) {
	        this.warn((0, text_js_1.text)(strings, ...values));
	    }
	    warnWithoutPrefix(...messages) {
	        this.parentLogger.warn(...messages);
	    }
	    debug(...messages) {
	        this.parentLogger.debug(...this.debugPrefix, ...messages);
	    }
	    debugText(strings, ...values) {
	        this.debug((0, text_js_1.text)(strings, ...values));
	    }
	    debugWithoutPrefix(...messages) {
	        this.parentLogger.debug(...messages);
	    }
	    throw(message) {
	        throw new Error(`${this.fullPrefix} ${message}`);
	    }
	    logAtLevel(level, ...messages) {
	        switch (level) {
	            case "debug":
	                this.debug(...messages);
	                break;
	            case "info":
	                this.info(...messages);
	                break;
	            case "warn":
	                this.warn(...messages);
	                break;
	            case "error":
	                this.error(...messages);
	                break;
	        }
	    }
	    static fromMultiple(loggers, opts) {
	        return new SimpleLogger("", {
	            debug: (...messages) => {
	                for (const logger of loggers) {
	                    logger.debug(...messages);
	                }
	            },
	            info: (...messages) => {
	                for (const logger of loggers) {
	                    logger.info(...messages);
	                }
	            },
	            warn: (...messages) => {
	                for (const logger of loggers) {
	                    logger.warn(...messages);
	                }
	            },
	            error: (...messages) => {
	                for (const logger of loggers) {
	                    logger.error(...messages);
	                }
	            },
	        }, {
	            ...opts,
	            useLogLevelPrefixes: false,
	        });
	    }
	};
	SimpleLogger.SimpleLogger = SimpleLogger$1;
	
	return SimpleLogger;
}

var SlicedSignal = {};

var hasRequiredSlicedSignal;

function requireSlicedSignal () {
	if (hasRequiredSlicedSignal) return SlicedSignal;
	hasRequiredSlicedSignal = 1;
	Object.defineProperty(SlicedSignal, "__esModule", { value: true });
	SlicedSignal.makeSlicedSignalFrom = makeSlicedSignalFrom;
	SlicedSignal.pathRelationship = pathRelationship;
	const immer_with_plugins_1 = /*@__PURE__*/ requireCjs$6();
	const LazySignal_js_1 = /*@__PURE__*/ requireLazySignal();
	const makeSetter_js_1 = /*@__PURE__*/ requireMakeSetter();
	/**
	 * A sliced signal is a writable signal that represents a portion of another writable signal.
	 */
	function makeSlicedSignalFrom(writableSignal) {
	    return new SlicedSignalBuilderImpl(writableSignal[0], writableSignal[1]);
	}
	/**
	 * Given a value and a path, return the value at the path.
	 *
	 * At any point, if a default value is used, the defaultUsed callback is called with the index of
	 * the path segment where the default value was used.
	 */
	function drill(value, path, defaultUsed) {
	    let current = value;
	    let index = 0;
	    for (const key of path) {
	        if (key.key === "__proto__") {
	            throw new Error("Cannot access __proto__");
	        }
	        switch (key.type) {
	            case "key":
	                current = current[key.key];
	                break;
	            case "keyWithDefault": {
	                if (current[key.key] === undefined) {
	                    current = key.default;
	                    defaultUsed?.(index);
	                }
	                else {
	                    current = current[key.key];
	                }
	                break;
	            }
	            case "mapKey":
	                current = current.get(key.key);
	                break;
	            case "mapKeyWithDefault":
	                if (!current.has(key.key)) {
	                    current = key.default;
	                    defaultUsed?.(index);
	                }
	                else {
	                    current = current.get(key.key);
	                }
	                break;
	            default: {
	                const _exhaustiveCheck = key;
	                return _exhaustiveCheck;
	            }
	        }
	        index++;
	    }
	    return current;
	}
	/**
	 * Determine the relationship of a to b.
	 *
	 * - Returns "ancestor" if a is an ancestor of b.
	 * - Returns "children" if
	 *   - a is a child of b, or
	 *   - a is the same as b.
	 * - Returns "neither" if a and b are not direct ancestors or children of each other.
	 */
	function pathRelationship(a, b) {
	    if (a.length < b.length) {
	        if (pathStartsWith(b, a)) {
	            return "ancestor";
	        }
	        else {
	            return "neither";
	        }
	    }
	    else {
	        if (pathStartsWith(a, b)) {
	            return "children";
	        }
	        else {
	            return "neither";
	        }
	    }
	}
	function pathStartsWith(path, prefix) {
	    if (path.length < prefix.length) {
	        return false;
	    }
	    for (let i = 0; i < prefix.length; i++) {
	        if (path[i] !== prefix[i]) {
	            return false;
	        }
	    }
	    return true;
	}
	class SlicedSignalBuilderImpl {
	    constructor(sourceSignal, sourceSetter) {
	        this.sourceSignal = sourceSignal;
	        this.sourceSetter = sourceSetter;
	        this.accessPath = [];
	        this.path = [];
	        this.tagKey = String(Math.random());
	    }
	    access(key) {
	        this.accessPath.push({ type: "key", key });
	        this.path.push(key);
	        return this;
	    }
	    accessWithDefault(key, defaultValue) {
	        this.accessPath.push({ type: "keyWithDefault", key, default: defaultValue });
	        this.path.push(key);
	        return this;
	    }
	    mapAccess(key) {
	        this.accessPath.push({ type: "mapKey", key });
	        this.path.push(key);
	        return this;
	    }
	    mapAccessWithDefault(key, defaultValue) {
	        this.accessPath.push({ type: "mapKeyWithDefault", key, default: defaultValue });
	        this.path.push(key);
	        return this;
	    }
	    done() {
	        const sourceInitialValue = this.sourceSignal.get();
	        const initialValue = (0, LazySignal_js_1.isAvailable)(sourceInitialValue)
	            ? drill(sourceInitialValue, this.accessPath)
	            : LazySignal_js_1.LazySignal.NOT_AVAILABLE;
	        const signal = LazySignal_js_1.LazySignal.create(initialValue, setDownstream => {
	            const unsubscribe = this.sourceSignal.subscribeFull((value, patches, tags) => {
	                const newPatches = [];
	                // Transform patches
	                for (const patch of patches) {
	                    const relationship = pathRelationship(patch.path, this.path);
	                    // If one of the ancestors have been replaced, we need to replace the whole value
	                    if (relationship === "ancestor") {
	                        if (patch.op !== "replace") {
	                            throw new Error("Only replace patches are supported for ancestor relationships");
	                        }
	                        newPatches.length = 0;
	                        newPatches.push({
	                            op: "replace",
	                            path: [],
	                            value: drill(patch.value, 
	                            // Get the part that is relevant to this slice
	                            this.accessPath.slice(patch.path.length)),
	                        });
	                    }
	                    else if (relationship === "children") {
	                        // If one of the children have been replaced, we need to replace the subset that
	                        // corresponds to the change
	                        newPatches.push({
	                            ...patch,
	                            path: patch.path.slice(this.accessPath.length),
	                        });
	                    }
	                    // Otherwise, we don't need to do anything
	                }
	                const newValue = drill(value, this.accessPath);
	                const newTags = tags
	                    .filter(tag => tag.startsWith(this.tagKey))
	                    .map(tag => tag.slice(this.tagKey.length));
	                if (newPatches.length > 0 || newTags.length > 0) {
	                    setDownstream.withValueAndPatches(newValue, newPatches, newTags);
	                }
	            });
	            const value = this.sourceSignal.pull();
	            if (value instanceof Promise) {
	                value.then(value => {
	                    setDownstream(drill(value, this.accessPath));
	                });
	            }
	            else {
	                setDownstream(drill(value, this.accessPath));
	            }
	            return unsubscribe;
	        });
	        const setter = (0, makeSetter_js_1.makeSetterWithPatches)((updater, tags) => {
	            const newTags = tags?.map(tag => this.tagKey + tag);
	            this.sourceSetter.withPatchUpdater(oldValue => {
	                const newPatches = [];
	                const slicedOldValue = drill(oldValue, this.accessPath, index => {
	                    // A default value has been used. We need to inject a patch that adds the default value
	                    // to the parent object.
	                    const defaultPathSegment = this.accessPath[index];
	                    if (defaultPathSegment.type !== "keyWithDefault" &&
	                        defaultPathSegment.type !== "mapKeyWithDefault") {
	                        throw new Error("Expected keyWithDefault or mapKeyWithDefault");
	                    }
	                    const defaultValue = defaultPathSegment.default;
	                    newPatches.push({
	                        op: "replace",
	                        path: this.path.slice(0, index + 1),
	                        value: defaultValue,
	                    });
	                });
	                const [_newSlicedValue, patches] = updater(slicedOldValue);
	                newPatches.push(...patches.map(patch => ({
	                    ...patch,
	                    path: [...this.path, ...patch.path],
	                })));
	                const newValue = (0, immer_with_plugins_1.applyPatches)(oldValue, newPatches);
	                return [newValue, newPatches];
	            }, newTags);
	        });
	        return [signal, setter];
	    }
	}
	
	return SlicedSignal;
}

var StreamablePromise = {};

var hasRequiredStreamablePromise;

function requireStreamablePromise () {
	if (hasRequiredStreamablePromise) return StreamablePromise;
	hasRequiredStreamablePromise = 1;
	var _a;
	Object.defineProperty(StreamablePromise, "__esModule", { value: true });
	StreamablePromise.StreamablePromise = void 0;
	const makePromise_js_1 = /*@__PURE__*/ requireMakePromise();
	const finished = Symbol("finished");
	/**
	 * A StreamablePromise is a promise-like that is also async iterable. This means you can use it as a
	 * promise (awaiting it, using `.then`, `.catch`, etc.), and you can also use it as an async
	 * iterable (using `for await`).
	 *
	 * Notably, as much as it implements the async iterable interface, it is not a traditional iterable,
	 * as it internally maintains a buffer and new values are pushed into the buffer by the producer, as
	 * oppose to being pulled by the consumer.
	 *
	 * The async iterable interface is used instead of the Node.js object stream because streams are too
	 * clunky to use, and the `for await` syntax is much more ergonomic for most people.
	 *
	 * If any iterator is created for this instance, an empty rejection handler will be attached to the
	 * promise to prevent unhandled rejection warnings.
	 *
	 * This class is provided as an abstract class and is meant to be extended. Crucially, the `collect`
	 * method must be implemented, which will be called to convert an array of values into the final
	 * resolved value of the promise.
	 *
	 * In addition, the constructor of the subclass should be marked as private, and a static method
	 * that exposes the constructor, the `finished` method, and the `push` method should be provided.
	 *
	 * @typeParam TFragment - The type of the individual fragments that are pushed into the buffer.
	 * @typeParam TFinal - The type of the final resolved value of the promise.
	 * @public
	 */
	let StreamablePromise$1 = class StreamablePromise {
	    /**
	     * Called by the producer when it has finished producing values. If an error is provided, the
	     * promise will be rejected with that error. If no error is provided, the promise will be resolved
	     * with the final value.
	     *
	     * This method should be exposed in the static constructor of the subclass.
	     *
	     * @param error - The error to reject the promise with, if any.
	     */
	    finished(error) {
	        if (this.status !== "pending") {
	            throw new Error("`finished` called while not pending");
	        }
	        if (error === undefined) {
	            this.status = "resolved";
	            this.nextFragmentPromiseBundle?.resolve(finished);
	            this.resolveFinal(this.collect(this.buffer));
	        }
	        else {
	            this.status = "rejected";
	            this.nextFragmentPromiseBundle?.reject(error);
	            this.rejectFinal(error);
	        }
	    }
	    /**
	     * Called by the producer to push a new fragment into the buffer. This method should be exposed in
	     * the static constructor of the subclass.
	     *
	     * This method should be exposed in the static constructor of the subclass.
	     *
	     * @param fragment - The fragment to push into the buffer.
	     */
	    push(fragment) {
	        if (this.status !== "pending") {
	            throw new Error("`push` called while not pending");
	        }
	        this.buffer.push(fragment);
	        this.nextFragmentPromiseBundle?.resolve(fragment);
	        this.nextFragmentPromiseBundle = null;
	    }
	    constructor() {
	        this.status = "pending";
	        this.buffer = [];
	        this.nextFragmentPromiseBundle = null;
	        /**
	         * If there has ever been any iterators created for this instance. Once any iterator is created,
	         * a reject handler will be attached to the promise to prevent unhandled rejection warnings, as
	         * the errors will be handled by the iterator.
	         *
	         * The purpose of this variable is to prevent registering the reject handler more than once.
	         */
	        this.hasIterator = false;
	        this[_a] = "StreamablePromise";
	        const { promise, resolve, reject } = (0, makePromise_js_1.makePromise)();
	        this.promiseFinal = promise;
	        this.resolveFinal = resolve;
	        this.rejectFinal = reject;
	    }
	    then(onfulfilled, onrejected) {
	        return this.promiseFinal.then(onfulfilled, onrejected);
	    }
	    catch(onrejected) {
	        return this.promiseFinal.catch(onrejected);
	    }
	    finally(onfinally) {
	        return this.promiseFinal.finally(onfinally);
	    }
	    /**
	     * If nextFragmentPromiseBundle exists, it is returned. Otherwise, a new one is created and
	     * returned.
	     */
	    obtainNextFragmentPromiseBundle() {
	        if (this.nextFragmentPromiseBundle === null) {
	            this.nextFragmentPromiseBundle = (0, makePromise_js_1.makePromise)();
	        }
	        return this.nextFragmentPromiseBundle;
	    }
	    async *[(_a = Symbol.toStringTag, Symbol.asyncIterator)]() {
	        if (!this.hasIterator) {
	            this.promiseFinal.catch(() => { }); // Prevent unhandled rejection warning
	            this.hasIterator = true;
	        }
	        let i = 0;
	        while (i < this.buffer.length || this.status === "pending") {
	            if (i < this.buffer.length) {
	                yield this.buffer[i];
	                i++;
	            }
	            else {
	                const nextFragmentPromiseBundle = this.obtainNextFragmentPromiseBundle();
	                const nextFragment = await nextFragmentPromiseBundle.promise;
	                if (nextFragment === finished) {
	                    // Make sure the promise is resolved before breaking the loop.
	                    break;
	                }
	                yield nextFragment;
	                i++;
	            }
	        }
	        await this.promiseFinal;
	        // Wait for one more microtask to ensure that the promise is resolved before terminating the
	        // loop. This ensures that the by the time async loop is terminated, the onMessage handler is
	        // already triggered.
	        await Promise.resolve();
	    }
	};
	StreamablePromise.StreamablePromise = StreamablePromise$1;
	
	return StreamablePromise;
}

var TimeoutTracker = {};

var hasRequiredTimeoutTracker;

function requireTimeoutTracker () {
	if (hasRequiredTimeoutTracker) return TimeoutTracker;
	hasRequiredTimeoutTracker = 1;
	Object.defineProperty(TimeoutTracker, "__esModule", { value: true });
	TimeoutTracker.TimeoutTracker = void 0;
	const BufferedEvent_js_1 = /*@__PURE__*/ requireBufferedEvent();
	let TimeoutTracker$1 = class TimeoutTracker {
	    constructor(timeoutMs) {
	        this.timeoutMs = timeoutMs;
	        this.started = false;
	        this.timeout = null;
	        [this.triggeredEvent, this.emitTriggeredEvent] = BufferedEvent_js_1.BufferedEvent.create();
	    }
	    reset() {
	        if (!this.started) {
	            return;
	        }
	        if (this.timeout !== null) {
	            clearTimeout(this.timeout);
	        }
	        this.timeout = setTimeout(() => {
	            this.emitTriggeredEvent();
	            if (this.timeout !== null) {
	                clearTimeout(this.timeout);
	            }
	        }, this.timeoutMs);
	    }
	    start() {
	        this.started = true;
	        this.reset();
	    }
	    stop() {
	        if (this.timeout !== null) {
	            clearTimeout(this.timeout);
	            this.timeout = null;
	        }
	        this.started = false;
	    }
	};
	TimeoutTracker.TimeoutTracker = TimeoutTracker$1;
	
	return TimeoutTracker;
}

var toJSONSafeNumber = {};

var hasRequiredToJSONSafeNumber;

function requireToJSONSafeNumber () {
	if (hasRequiredToJSONSafeNumber) return toJSONSafeNumber;
	hasRequiredToJSONSafeNumber = 1;
	Object.defineProperty(toJSONSafeNumber, "__esModule", { value: true });
	toJSONSafeNumber.toJSONSafeNumber = toJSONSafeNumber$1;
	function toJSONSafeNumber$1(value) {
	    if (value === undefined) {
	        return undefined;
	    }
	    else if (!Number.isFinite(value)) {
	        return undefined;
	    }
	    else if (Number.isNaN(value)) {
	        return undefined;
	    }
	    else {
	        return value;
	    }
	}
	
	return toJSONSafeNumber;
}

var Validator = {};

var hasRequiredValidator;

function requireValidator () {
	if (hasRequiredValidator) return Validator;
	hasRequiredValidator = 1;
	var __importDefault = (Validator && Validator.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(Validator, "__esModule", { value: true });
	Validator.sharedValidator = Validator.Validator = void 0;
	const chalk_1 = __importDefault(requireSource());
	const makePrettyError_js_1 = /*@__PURE__*/ requireMakePrettyError();
	const text_js_1 = /*@__PURE__*/ requireText();
	let Validator$1 = class Validator {
	    constructor({ attachStack } = {}) {
	        this.attachStack = attachStack ?? true;
	    }
	    /**
	     * Pretty-prints a Zod error.
	     *
	     * @param rootObjectName - The name of the object being validated (used for error messages)
	     * @param error - The Zod error to pretty-print
	     *
	     * @returns The pretty-printed error in a string
	     */
	    static prettyPrintZod(rootObjectName, error) {
	        return error.errors
	            .map(e => {
	            if (e.path.length === 0) {
	                return `- ${chalk_1.default.redBright(rootObjectName)}: ${e.message}`;
	            }
	            const path = chalk_1.default.red(`.${e.path.join(".")}`);
	            return `- ${chalk_1.default.redBright(rootObjectName)}${path}: ${e.message}`;
	        })
	            .join("\n");
	    }
	    /**
	     * Validates a value against a schema and throws an error if it's invalid.
	     *
	     * @param lead - The start of the error message (used for error messages)
	     * @param rootObjectName - The name of the object being validated (used for error messages)
	     * @param schema - The schema to validate against
	     * @param value - The value to validate
	     *
	     * @returns The validated value
	     * @throws An error if the value is invalid
	     */
	    validateOrThrow(lead, rootObjectName, schema, value, stack) {
	        const result = schema.safeParse(value);
	        if (result.success) {
	            return result.data;
	        }
	        else {
	            throw (0, makePrettyError_js_1.makePrettyError)(`${lead}\n\n${Validator.prettyPrintZod(rootObjectName, result.error)}`, this.attachStack ? stack : undefined);
	        }
	    }
	    /**
	     * Validates multiple values against multiple schemas and throws an error if any of them are
	     * invalid. All values are validated before any errors are thrown. This is useful when you want to
	     * validate multiple values at once and want to see all the errors at once.
	     *
	     * @param leadProducer - The function to produce the start of the error message (used for error).
	     * It is called with a set of indices of the invalid values.
	     * @param rootObjectNames - The names of the objects being validated (used for error messages)
	     * @param schemas - The schemas to validate against
	     * @param values - The values to validate
	     *
	     * @returns The validated values
	     * @throws An error if any of the values are invalid
	     */
	    validateMultipleOrThrow(leadProducer, rootObjectNames, schemas, values, stack) {
	        const results = schemas.map((schema, index) => schema.safeParse(values[index]));
	        const errors = results
	            .map((result, index) => ({ result, index, rootObjectName: rootObjectNames[index] }))
	            .filter(({ result }) => !result.success)
	            .map(({ result, rootObjectName, index }) => ({
	            error: result.error,
	            rootObjectName,
	            index,
	        }));
	        if (errors.length === 0) {
	            return results.map(result => result.data);
	        }
	        else {
	            const erroredValues = new Set(errors.map(({ index }) => index));
	            const lead = leadProducer(erroredValues);
	            throw (0, makePrettyError_js_1.makePrettyError)(`${lead}\n\n${errors
	                .map(({ error, rootObjectName }) => Validator.prettyPrintZod(rootObjectName, error))
	                .join("\n")}`, this.attachStack ? stack : undefined);
	        }
	    }
	    /**
	     * Validates a value against a schema and throws an error if it's invalid. This is a convenience
	     * function for validating one single method parameter.
	     *
	     * @param className - The name of the class containing the method (used for error messages)
	     * @param methodName - The name of the method (used for error messages)
	     * @param paramName - The name of the parameter being validated (used for error messages)
	     * @param schema - The schema to validate against
	     * @param value - The value to validate
	     *
	     * @returns The validated value
	     * @throws An error if the value is invalid
	     */
	    validateMethodParamOrThrow(className, methodName, paramName, schema, value, stack) {
	        const functionCall = chalk_1.default.yellowBright((0, text_js_1.text) `
    ${className}.${methodName}(${chalk_1.default.redBright(paramName)})
  `);
	        return this.validateOrThrow(`Invalid parameter(s) for ${functionCall}:`, paramName, schema, value, stack);
	    }
	    /**
	     * Validates multiple values against multiple schemas and throws an error if any of them are
	     * invalid. This is a convenience function for validating multiple method parameters.
	     *
	     * @param className - The name of the class containing the method (used for error messages)
	     * @param methodName - The name of the method (used for error messages)
	     * @param paramNames - The names of the parameters being validated (used for error messages)
	     * @param schemas - The schemas to validate against
	     * @param values - The values to validate
	     *
	     * @returns The validated values
	     * @throws An error if any of the values are invalid
	     */
	    validateMethodParamsOrThrow(className, methodName, paramNames, schemas, values, stack) {
	        return this.validateMultipleOrThrow(erroredValues => {
	            const coloredParamNames = paramNames.map((name, index) => erroredValues.has(index) ? chalk_1.default.redBright(name) : name);
	            const functionCall = chalk_1.default.yellowBright((0, text_js_1.text) `
        ${className}.${methodName}(${coloredParamNames.join(", ")})
      `);
	            return `Invalid parameter(s) for ${functionCall}:`;
	        }, paramNames, schemas, values, stack);
	    }
	    /**
	     * Validates a value against a schema and throws an error if it's invalid. This is a convenience
	     * function for validating one single constructor parameter.
	     *
	     * @param className - The name of the class (used for error messages)
	     * @param paramName - The name of the parameter being validated (used for error messages)
	     * @param schema - The schema to validate against
	     * @param value - The value to validate
	     *
	     * @returns The validated value
	     * @throws An error if the value is invalid
	     */
	    validateConstructorParamOrThrow(className, paramName, schema, value, stack) {
	        const functionCall = chalk_1.default.yellowBright((0, text_js_1.text) `
    ${className}(${chalk_1.default.redBright(paramName)})
  `);
	        return this.validateOrThrow(`Invalid parameter(s) when constructing ${functionCall}`, paramName, schema, value, stack);
	    }
	    /**
	     * Validates multiple values against multiple schemas and throws an error if any of them are
	     * invalid. This is a convenience function for validating multiple constructor parameters.
	     *
	     * @param className - The name of the class (used for error messages)
	     * @param paramNames - The names of the parameters being validated (used for error messages)
	     *
	     * @param schemas - The schemas to validate against
	     * @param values - The values to validate
	     */
	    validateConstructorParamsOrThrow(className, paramNames, schemas, values, stack) {
	        return this.validateMultipleOrThrow(erroredValues => {
	            const coloredParamNames = paramNames.map((name, index) => erroredValues.has(index) ? chalk_1.default.redBright(name) : name);
	            const functionCall = chalk_1.default.yellowBright((0, text_js_1.text) `
        ${className}(${coloredParamNames.join(", ")})
      `);
	            return `Invalid parameter(s) when constructing ${functionCall}:`;
	        }, paramNames, schemas, values, stack);
	    }
	};
	Validator.Validator = Validator$1;
	Validator.sharedValidator = new Validator$1();
	
	return Validator;
}

var WaitQueue = {};

var hasRequiredWaitQueue;

function requireWaitQueue () {
	if (hasRequiredWaitQueue) return WaitQueue;
	hasRequiredWaitQueue = 1;
	Object.defineProperty(WaitQueue, "__esModule", { value: true });
	WaitQueue.Holder = WaitQueue.Pager = WaitQueue.WaitQueue = WaitQueue.QueueClearedError = WaitQueue.PagerExitedError = void 0;
	const Signal_js_1 = /*@__PURE__*/ requireSignal();
	const SimpleLogger_js_1 = /*@__PURE__*/ requireSimpleLogger();
	const makePromise_js_1 = /*@__PURE__*/ requireMakePromise();
	const resolvePager = Symbol("resolvePager");
	const rejectPager = Symbol("rejectPager");
	const dropHolder = Symbol("dropHolder");
	const getLogger = Symbol("logger");
	const removePager = Symbol("removePager");
	class PagerExitedError extends Error {
	    constructor() {
	        super("Pager has been exited");
	    }
	}
	WaitQueue.PagerExitedError = PagerExitedError;
	class QueueClearedError extends Error {
	    constructor() {
	        super("Queue has been cleared");
	    }
	}
	WaitQueue.QueueClearedError = QueueClearedError;
	/**
	 * WaitQueue is a queue that can be used to wait for a resource to become available.
	 *
	 * It is similar to going to a busy restaurant in that you get a pager (the plastic thing that has a
	 * red LED on it), which will beep when your table is ready.
	 *
	 * The {@link WaitQueue#enterQueue} method is used to get a pager, and the Pager object that is
	 * returned can be waited on using the {@link Pager#wait} method, which returns a promise that
	 * resolves to a {@link Holder} object. When you are done, {@link Holder#drop} should be called to
	 * release the resource. Alternatively, the `using` keyword can be used to automatically release the
	 * resource when the block is exited.
	 *
	 * Queue can be exited with the {@link Pager#exit} method.
	 */
	let WaitQueue$1 = class WaitQueue {
	    constructor(parentLogger) {
	        this.pagers = [];
	        this.finalizationRegistry = new FinalizationRegistry(() => {
	            this.logger.warnText `
      A holder has been finalized without being dropped! FinalizationRegistry is the last resort
      and should not be relied upon. Please make sure to always drop the holder when you are done
      with it.
    `;
	            this.currentlyServing = null;
	            this.tryAdvancingQueue();
	        });
	        this.currentlyServing = null;
	        this.logger = new SimpleLogger_js_1.SimpleLogger("WaitQueue", parentLogger);
	        [this.queueLengthSignal, this.setQueueLength] = Signal_js_1.Signal.create(0);
	    }
	    updateQueueLength() {
	        this.setQueueLength(this.pagers.length + (this.currentlyServing === null ? 0 : 1));
	    }
	    /**
	     * Enters the queue and returns a pager that can be waited on.
	     *
	     * @param priority - The priority of the pager. Lower numbers are served first. Defaults to 0.
	     */
	    enterQueue(priority = 0) {
	        const pager = new Pager(this, priority);
	        this.pagers.push(pager);
	        this.pagers.sort((a, b) => (a.priority < b.priority ? -1 : a.priority > b.priority ? 1 : 0));
	        this.tryAdvancingQueue();
	        return pager;
	    }
	    tryAdvancingQueue() {
	        if (this.currentlyServing === null) {
	            const pager = this.pagers.shift();
	            if (pager !== undefined) {
	                this.currentlyServing = pager;
	                const holder = new Holder(this);
	                this.finalizationRegistry.register(holder, undefined, holder);
	                pager[resolvePager](holder);
	            }
	        }
	        this.updateQueueLength();
	    }
	    clearQueue(error = new QueueClearedError()) {
	        for (const pager of this.pagers) {
	            pager[rejectPager](error);
	        }
	        this.pagers.length = 0;
	        this.updateQueueLength();
	    }
	    /** @internal */
	    [dropHolder](holder) {
	        this.finalizationRegistry.unregister(holder);
	        this.currentlyServing = null;
	        this.tryAdvancingQueue();
	    }
	    /** @internal */
	    [getLogger]() {
	        return this.logger;
	    }
	    /** @internal */
	    [removePager](pager) {
	        const index = this.pagers.indexOf(pager);
	        if (index !== -1) {
	            this.pagers.splice(index, 1);
	        }
	        else {
	            this.logger.warnText `
        A pager was removed from the queue, but it was not in the queue. This is a bug in the code
        that uses the WaitQueue.
      `;
	        }
	        this.updateQueueLength();
	    }
	};
	WaitQueue.WaitQueue = WaitQueue$1;
	class Pager {
	    /** @internal */
	    constructor(queue, priority) {
	        this.queue = queue;
	        this.priority = priority;
	        const { promise, resolve, reject } = (0, makePromise_js_1.makePromise)();
	        this.waitingPromise = promise;
	        this.resolveWaitingPromise = resolve;
	        this.rejectWaitingPromise = reject;
	    }
	    /** @internal */
	    [resolvePager](holder) {
	        this.resolveWaitingPromise(holder);
	    }
	    /** @internal */
	    [rejectPager](error) {
	        this.rejectWaitingPromise(error);
	    }
	    wait() {
	        return this.waitingPromise;
	    }
	    exit(error = new PagerExitedError()) {
	        this.queue[removePager](this);
	        this[rejectPager](error);
	    }
	}
	WaitQueue.Pager = Pager;
	class Holder {
	    /** @internal */
	    constructor(queue) {
	        this.queue = queue;
	        this.dropped = false;
	    }
	    drop() {
	        if (this.dropped) {
	            this.queue[getLogger]().throw("Holder has already been dropped. This is a bug in the code that uses the WaitQueue.");
	        }
	        this.dropped = true;
	        this.queue[dropHolder](this);
	    }
	    [Symbol.dispose]() {
	        this.drop();
	    }
	}
	WaitQueue.Holder = Holder;
	
	return WaitQueue;
}

var zodHelpers = {};

var hasRequiredZodHelpers;

function requireZodHelpers () {
	if (hasRequiredZodHelpers) return zodHelpers;
	hasRequiredZodHelpers = 1;
	Object.defineProperty(zodHelpers, "__esModule", { value: true });
	zodHelpers.filteredArray = filteredArray;
	zodHelpers.failOk = failOk;
	const zod_1 = /*@__PURE__*/ requireLib$1();
	/**
	 * Makes a Zod schema that filters out elements that do not match the provided schema.
	 */
	function filteredArray(schema) {
	    return zod_1.z.array(zod_1.z.any()).transform(val => val
	        .map(v => schema.safeParse(v))
	        .filter(parsed => parsed.success)
	        .map(parsed => parsed.data));
	}
	/**
	 * Makes a Zod schema that turns a failed parse into an `undefined`.
	 */
	function failOk(schema) {
	    return zod_1.z.any().transform(val => {
	        const parsed = schema.safeParse(val);
	        if (parsed.success) {
	            return parsed.data;
	        }
	        return undefined;
	    });
	}
	
	return zodHelpers;
}

var hasRequiredCjs$3;

function requireCjs$3 () {
	if (hasRequiredCjs$3) return cjs$5;
	hasRequiredCjs$3 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.filteredArray = exports.failOk = exports.WaitQueue = exports.QueueClearedError = exports.PagerExitedError = exports.Validator = exports.sharedValidator = exports.toJSONSafeNumber = exports.TimeoutTracker = exports.text = exports.Subscribable = exports.StreamablePromise = exports.makeSlicedSignalFrom = exports.SimpleLogger = exports.Signal = exports.safeCallCallback = exports.runOnDispose = exports.unwrapPromiseOfResult = exports.unwrapPromiseOfMaybeErrored = exports.promiseToResult = exports.promiseToMaybeErrored = exports.maybeErroredSchema = exports.createResultSchema = exports.removeUndefinedValues = exports.raceWithAbortSignal = exports.promisifyAbortSignal = exports.parseFileIdentifier = exports.OWLSignal = exports.MaybeMutable = exports.accessMaybeMutableInternals = exports.makeSetterWithPatches = exports.makeSetter = exports.makePromise = exports.makeTitledPrettyError = exports.makePrettyError = exports.HandledEvent = exports.flattenSignalOfWritableSignal = exports.flattenSignalOfSignal = exports.modelExtensions = exports.doesFileNameIndicateModel = exports.Event = exports.getCurrentStack = exports.changeErrorStackInPlace = exports.deepFreeze = exports.Cleaner = exports.CancelEvent = exports.BufferedEvent = exports.apiServerPorts = exports.LazySignal = exports.isAvailable = void 0;
		// Export lazy signal first to avoid circular dependency issues
		var LazySignal_js_1 = /*@__PURE__*/ requireLazySignal();
		Object.defineProperty(exports, "isAvailable", { enumerable: true, get: function () { return LazySignal_js_1.isAvailable; } });
		Object.defineProperty(exports, "LazySignal", { enumerable: true, get: function () { return LazySignal_js_1.LazySignal; } });
		var apiServerPorts_js_1 = /*@__PURE__*/ requireApiServerPorts();
		Object.defineProperty(exports, "apiServerPorts", { enumerable: true, get: function () { return apiServerPorts_js_1.apiServerPorts; } });
		var BufferedEvent_js_1 = /*@__PURE__*/ requireBufferedEvent();
		Object.defineProperty(exports, "BufferedEvent", { enumerable: true, get: function () { return BufferedEvent_js_1.BufferedEvent; } });
		var CancelEvent_js_1 = /*@__PURE__*/ requireCancelEvent();
		Object.defineProperty(exports, "CancelEvent", { enumerable: true, get: function () { return CancelEvent_js_1.CancelEvent; } });
		var Cleaner_js_1 = /*@__PURE__*/ requireCleaner();
		Object.defineProperty(exports, "Cleaner", { enumerable: true, get: function () { return Cleaner_js_1.Cleaner; } });
		var deepFreeze_js_1 = /*@__PURE__*/ requireDeepFreeze();
		Object.defineProperty(exports, "deepFreeze", { enumerable: true, get: function () { return deepFreeze_js_1.deepFreeze; } });
		var errorStack_js_1 = /*@__PURE__*/ requireErrorStack();
		Object.defineProperty(exports, "changeErrorStackInPlace", { enumerable: true, get: function () { return errorStack_js_1.changeErrorStackInPlace; } });
		Object.defineProperty(exports, "getCurrentStack", { enumerable: true, get: function () { return errorStack_js_1.getCurrentStack; } });
		var Event_js_1 = /*@__PURE__*/ requireEvent();
		Object.defineProperty(exports, "Event", { enumerable: true, get: function () { return Event_js_1.Event; } });
		var fileName_js_1 = /*@__PURE__*/ requireFileName();
		Object.defineProperty(exports, "doesFileNameIndicateModel", { enumerable: true, get: function () { return fileName_js_1.doesFileNameIndicateModel; } });
		Object.defineProperty(exports, "modelExtensions", { enumerable: true, get: function () { return fileName_js_1.modelExtensions; } });
		var flattenSignal_js_1 = /*@__PURE__*/ requireFlattenSignal();
		Object.defineProperty(exports, "flattenSignalOfSignal", { enumerable: true, get: function () { return flattenSignal_js_1.flattenSignalOfSignal; } });
		Object.defineProperty(exports, "flattenSignalOfWritableSignal", { enumerable: true, get: function () { return flattenSignal_js_1.flattenSignalOfWritableSignal; } });
		var HandledEvent_js_1 = /*@__PURE__*/ requireHandledEvent();
		Object.defineProperty(exports, "HandledEvent", { enumerable: true, get: function () { return HandledEvent_js_1.HandledEvent; } });
		var makePrettyError_js_1 = /*@__PURE__*/ requireMakePrettyError();
		Object.defineProperty(exports, "makePrettyError", { enumerable: true, get: function () { return makePrettyError_js_1.makePrettyError; } });
		Object.defineProperty(exports, "makeTitledPrettyError", { enumerable: true, get: function () { return makePrettyError_js_1.makeTitledPrettyError; } });
		var makePromise_js_1 = /*@__PURE__*/ requireMakePromise();
		Object.defineProperty(exports, "makePromise", { enumerable: true, get: function () { return makePromise_js_1.makePromise; } });
		var makeSetter_js_1 = /*@__PURE__*/ requireMakeSetter();
		Object.defineProperty(exports, "makeSetter", { enumerable: true, get: function () { return makeSetter_js_1.makeSetter; } });
		Object.defineProperty(exports, "makeSetterWithPatches", { enumerable: true, get: function () { return makeSetter_js_1.makeSetterWithPatches; } });
		var MaybeMutable_js_1 = /*@__PURE__*/ requireMaybeMutable();
		Object.defineProperty(exports, "accessMaybeMutableInternals", { enumerable: true, get: function () { return MaybeMutable_js_1.accessMaybeMutableInternals; } });
		Object.defineProperty(exports, "MaybeMutable", { enumerable: true, get: function () { return MaybeMutable_js_1.MaybeMutable; } });
		var OWLSignal_js_1 = /*@__PURE__*/ requireOWLSignal();
		Object.defineProperty(exports, "OWLSignal", { enumerable: true, get: function () { return OWLSignal_js_1.OWLSignal; } });
		var parseFileIdentifier_js_1 = /*@__PURE__*/ requireParseFileIdentifier();
		Object.defineProperty(exports, "parseFileIdentifier", { enumerable: true, get: function () { return parseFileIdentifier_js_1.parseFileIdentifier; } });
		var promisifyAbortSignal_js_1 = /*@__PURE__*/ requirePromisifyAbortSignal();
		Object.defineProperty(exports, "promisifyAbortSignal", { enumerable: true, get: function () { return promisifyAbortSignal_js_1.promisifyAbortSignal; } });
		Object.defineProperty(exports, "raceWithAbortSignal", { enumerable: true, get: function () { return promisifyAbortSignal_js_1.raceWithAbortSignal; } });
		var removeUndefinedValues_js_1 = /*@__PURE__*/ requireRemoveUndefinedValues();
		Object.defineProperty(exports, "removeUndefinedValues", { enumerable: true, get: function () { return removeUndefinedValues_js_1.removeUndefinedValues; } });
		var resultTypes_js_1 = /*@__PURE__*/ requireResultTypes();
		Object.defineProperty(exports, "createResultSchema", { enumerable: true, get: function () { return resultTypes_js_1.createResultSchema; } });
		Object.defineProperty(exports, "maybeErroredSchema", { enumerable: true, get: function () { return resultTypes_js_1.maybeErroredSchema; } });
		Object.defineProperty(exports, "promiseToMaybeErrored", { enumerable: true, get: function () { return resultTypes_js_1.promiseToMaybeErrored; } });
		Object.defineProperty(exports, "promiseToResult", { enumerable: true, get: function () { return resultTypes_js_1.promiseToResult; } });
		Object.defineProperty(exports, "unwrapPromiseOfMaybeErrored", { enumerable: true, get: function () { return resultTypes_js_1.unwrapPromiseOfMaybeErrored; } });
		Object.defineProperty(exports, "unwrapPromiseOfResult", { enumerable: true, get: function () { return resultTypes_js_1.unwrapPromiseOfResult; } });
		var runOnDispose_js_1 = /*@__PURE__*/ requireRunOnDispose();
		Object.defineProperty(exports, "runOnDispose", { enumerable: true, get: function () { return runOnDispose_js_1.runOnDispose; } });
		var safeCallCallback_js_1 = /*@__PURE__*/ requireSafeCallCallback();
		Object.defineProperty(exports, "safeCallCallback", { enumerable: true, get: function () { return safeCallCallback_js_1.safeCallCallback; } });
		var Signal_js_1 = /*@__PURE__*/ requireSignal();
		Object.defineProperty(exports, "Signal", { enumerable: true, get: function () { return Signal_js_1.Signal; } });
		var SimpleLogger_js_1 = /*@__PURE__*/ requireSimpleLogger();
		Object.defineProperty(exports, "SimpleLogger", { enumerable: true, get: function () { return SimpleLogger_js_1.SimpleLogger; } });
		var SlicedSignal_js_1 = /*@__PURE__*/ requireSlicedSignal();
		Object.defineProperty(exports, "makeSlicedSignalFrom", { enumerable: true, get: function () { return SlicedSignal_js_1.makeSlicedSignalFrom; } });
		var StreamablePromise_js_1 = /*@__PURE__*/ requireStreamablePromise();
		Object.defineProperty(exports, "StreamablePromise", { enumerable: true, get: function () { return StreamablePromise_js_1.StreamablePromise; } });
		var Subscribable_js_1 = /*@__PURE__*/ requireSubscribable();
		Object.defineProperty(exports, "Subscribable", { enumerable: true, get: function () { return Subscribable_js_1.Subscribable; } });
		var text_js_1 = /*@__PURE__*/ requireText();
		Object.defineProperty(exports, "text", { enumerable: true, get: function () { return text_js_1.text; } });
		var TimeoutTracker_js_1 = /*@__PURE__*/ requireTimeoutTracker();
		Object.defineProperty(exports, "TimeoutTracker", { enumerable: true, get: function () { return TimeoutTracker_js_1.TimeoutTracker; } });
		var toJSONSafeNumber_js_1 = /*@__PURE__*/ requireToJSONSafeNumber();
		Object.defineProperty(exports, "toJSONSafeNumber", { enumerable: true, get: function () { return toJSONSafeNumber_js_1.toJSONSafeNumber; } });
		var Validator_js_1 = /*@__PURE__*/ requireValidator();
		Object.defineProperty(exports, "sharedValidator", { enumerable: true, get: function () { return Validator_js_1.sharedValidator; } });
		Object.defineProperty(exports, "Validator", { enumerable: true, get: function () { return Validator_js_1.Validator; } });
		var WaitQueue_js_1 = /*@__PURE__*/ requireWaitQueue();
		Object.defineProperty(exports, "PagerExitedError", { enumerable: true, get: function () { return WaitQueue_js_1.PagerExitedError; } });
		Object.defineProperty(exports, "QueueClearedError", { enumerable: true, get: function () { return WaitQueue_js_1.QueueClearedError; } });
		Object.defineProperty(exports, "WaitQueue", { enumerable: true, get: function () { return WaitQueue_js_1.WaitQueue; } });
		var zodHelpers_js_1 = /*@__PURE__*/ requireZodHelpers();
		Object.defineProperty(exports, "failOk", { enumerable: true, get: function () { return zodHelpers_js_1.failOk; } });
		Object.defineProperty(exports, "filteredArray", { enumerable: true, get: function () { return zodHelpers_js_1.filteredArray; } });
		
	} (cjs$5));
	return cjs$5;
}

var installCli = {};

var cjs$1 = {};

var FileData = {};

var hasRequiredFileData;

function requireFileData () {
	if (hasRequiredFileData) return FileData;
	hasRequiredFileData = 1;
	var __importDefault = (FileData && FileData.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(FileData, "__esModule", { value: true });
	FileData.FileData = void 0;
	const lms_common_1 = /*@__PURE__*/ requireCjs$3();
	const fs_1 = require$$0$6;
	const promises_1 = require$$0$5;
	const path_1 = __importDefault(require$$1$1);
	let FileData$1 = class FileData {
	    get dataSignal() {
	        if (this.initializationState.type !== "initialized") {
	            throw new Error("FileData is not initialized yet, cannot access dataSignal. (Must call init() first)");
	        }
	        return this.outerSignal;
	    }
	    constructor(filePath, defaultData, serializer, deserializer, { logger, watch, doNotCreateOnInit, makeBackupOnFail, onDelete } = {}) {
	        this.filePath = filePath;
	        this.defaultData = defaultData;
	        this.serializer = serializer;
	        this.deserializer = deserializer;
	        this.lastWroteBuffer = null;
	        this.initializationState = { type: "notStarted" };
	        this.set = (0, lms_common_1.makeSetterWithPatches)((updater, tags) => {
	            this.setData.withPatchUpdater(updater, tags);
	            this.writeData(this.innerSignal.get());
	        });
	        this.logger = logger ?? new lms_common_1.SimpleLogger("FileData");
	        this.shouldWatch = watch ?? false;
	        this.doNotCreateOnInit = doNotCreateOnInit ?? false;
	        this.makeBackupOnFail = makeBackupOnFail ?? false;
	        if (!this.shouldWatch && onDelete) {
	            throw new Error("onDelete is only supported when watching is enabled");
	        }
	    }
	    async init() {
	        if (this.initializationState.type === "initializing") {
	            await this.initializationState.promise;
	            return;
	        }
	        if (this.initializationState.type === "initialized") {
	            return;
	        }
	        const initPromise = this.initInternal();
	        this.initializationState = { type: "initializing", promise: initPromise };
	        await initPromise;
	        this.initializationState = { type: "initialized" };
	    }
	    async getDefaultData() {
	        return typeof this.defaultData === "function"
	            ? await this.defaultData()
	            : this.defaultData;
	    }
	    async initInternal() {
	        this.logger?.debug("Initializing FileData");
	        const dir = path_1.default.dirname(this.filePath);
	        await (0, promises_1.mkdir)(dir, { recursive: true });
	        let data = null;
	        if (!(0, fs_1.existsSync)(this.filePath)) {
	            data = await this.getDefaultData();
	            if (!this.doNotCreateOnInit) {
	                this.logger?.debug("File does not exist, writing default data");
	                this.writeData(data);
	            }
	        }
	        else {
	            data = await this.readData();
	        }
	        if (data === null) {
	            data = await this.getDefaultData();
	            this.writeData(data);
	        }
	        [this.innerSignal, this.setData] = lms_common_1.Signal.create(data);
	        this.outerSignal = lms_common_1.LazySignal.create(data, setDownstream => {
	            const ac = new AbortController();
	            setDownstream(this.innerSignal.get());
	            if (this.shouldWatch) {
	                this.startWatcher(ac).catch(e => {
	                    if (e.name === "AbortError") {
	                        return;
	                    }
	                    this.logger?.error(`Watcher failed: ${e}`);
	                });
	            }
	            const unsubscribe = this.innerSignal.subscribeFull((_data, patches, tags) => {
	                setDownstream.withPatches(patches, tags);
	            });
	            return () => {
	                ac.abort();
	                unsubscribe();
	            };
	        });
	    }
	    async startWatcher(ac) {
	        const watcher = (0, promises_1.watch)(this.filePath, {
	            persistent: false,
	            signal: ac.signal,
	        });
	        try {
	            for await (const event of watcher) {
	                if (event.eventType === "change") {
	                    this.logger?.debug("File changed, reading data");
	                    const data = await this.readData();
	                    if (data !== null) {
	                        this.setData(data);
	                    }
	                }
	                else if (event.eventType === "rename") {
	                    this.logger?.debug("File renamed, reinitializing");
	                    this.onDelete?.();
	                    this.setData(await this.getDefaultData());
	                }
	            }
	        }
	        catch (error) {
	            if (error.name === "AbortError") ;
	            throw error;
	        }
	    }
	    makeBackup() {
	        this.logger?.error("Making backup of file");
	        try {
	            let id = 1;
	            while ((0, fs_1.existsSync)(`${this.filePath}.bak.${id}`)) {
	                id++;
	            }
	            (0, fs_1.writeFileSync)(`${this.filePath}.bak.${id}`, (0, fs_1.readFileSync)(this.filePath));
	        }
	        catch (e) {
	            this.logger?.error(`Error making backup: ${e}`);
	        }
	    }
	    async readData() {
	        try {
	            const content = await (0, promises_1.readFile)(this.filePath);
	            if (this.lastWroteBuffer !== null && content.equals(this.lastWroteBuffer)) {
	                this.logger?.debug("File content is the same as last written, skipping read");
	                return null;
	            }
	            const data = this.deserializer(content);
	            if ((0, lms_common_1.isAvailable)(data)) {
	                return data;
	            }
	            else {
	                this.logger?.error("Data is not available after deserialization");
	                return null;
	            }
	        }
	        catch (e) {
	            this.logger?.error(`Error reading data from file: ${e}`);
	            if (this.makeBackupOnFail) {
	                this.makeBackup();
	            }
	            return null;
	        }
	    }
	    writeData(data) {
	        // TODO: We should have a queue to batch up writes
	        const serialized = this.serializer(data);
	        this.lastWroteBuffer = serialized;
	        try {
	            (0, fs_1.writeFileSync)(this.filePath, serialized);
	        }
	        catch (e) {
	            this.logger?.error(`Error writing data to file: ${e}`);
	        }
	    }
	    get() {
	        return this.dataSignal.get();
	    }
	};
	FileData.FileData = FileData$1;
	
	return FileData;
}

var findLMStudioHome = {};

var hasRequiredFindLMStudioHome;

function requireFindLMStudioHome () {
	if (hasRequiredFindLMStudioHome) return findLMStudioHome;
	hasRequiredFindLMStudioHome = 1;
	Object.defineProperty(findLMStudioHome, "__esModule", { value: true });
	findLMStudioHome.findLMStudioHome = findLMStudioHome$1;
	const fs_1 = require$$0$6;
	const os_1 = require$$2$1;
	const path_1 = require$$1$1;
	let lmstudioHome = null;
	function findLMStudioHome$1() {
	    if (lmstudioHome !== null) {
	        return lmstudioHome;
	    }
	    // if applicable, convert relative path to absolute and follow the symlink
	    const resolvedHomeDir = (0, fs_1.realpathSync)((0, os_1.homedir)());
	    const pointerFilePath = (0, path_1.join)(resolvedHomeDir, ".lmstudio-home-pointer");
	    if ((0, fs_1.existsSync)(pointerFilePath)) {
	        lmstudioHome = (0, fs_1.readFileSync)(pointerFilePath, "utf-8").trim();
	        return lmstudioHome;
	    }
	    // See if ~/.cache/lm-studio exists. If it does, use it.
	    const cacheHome = (0, path_1.join)(resolvedHomeDir, ".cache", "lm-studio");
	    if ((0, fs_1.existsSync)(cacheHome)) {
	        lmstudioHome = cacheHome;
	        (0, fs_1.writeFileSync)(pointerFilePath, lmstudioHome, "utf-8");
	        return lmstudioHome;
	    }
	    // Otherwise, fallback to ~/.lmstudio
	    const home = (0, path_1.join)(resolvedHomeDir, ".lmstudio");
	    lmstudioHome = home;
	    (0, fs_1.writeFileSync)(pointerFilePath, lmstudioHome, "utf-8");
	    return lmstudioHome;
	}
	
	return findLMStudioHome;
}

var PlainTextFileData = {};

var hasRequiredPlainTextFileData;

function requirePlainTextFileData () {
	if (hasRequiredPlainTextFileData) return PlainTextFileData;
	hasRequiredPlainTextFileData = 1;
	Object.defineProperty(PlainTextFileData, "__esModule", { value: true });
	PlainTextFileData.PlainTextFileData = void 0;
	const FileData_js_1 = /*@__PURE__*/ requireFileData();
	/**
	 * Capable of storing plain text
	 */
	let PlainTextFileData$1 = class PlainTextFileData extends FileData_js_1.FileData {
	    constructor(filePath, defaultData = "", opts) {
	        super(filePath, defaultData, data => Buffer.from(data, "utf-8"), buffer => buffer.toString("utf-8"), opts);
	    }
	};
	PlainTextFileData.PlainTextFileData = PlainTextFileData$1;
	
	return PlainTextFileData;
}

var SimpleFileData = {};

var hasRequiredSimpleFileData;

function requireSimpleFileData () {
	if (hasRequiredSimpleFileData) return SimpleFileData;
	hasRequiredSimpleFileData = 1;
	Object.defineProperty(SimpleFileData, "__esModule", { value: true });
	SimpleFileData.SimpleFileData = void 0;
	const lms_common_1 = /*@__PURE__*/ requireCjs$3();
	const FileData_js_1 = /*@__PURE__*/ requireFileData();
	/**
	 * Capable of storing JSON serializable values.
	 */
	let SimpleFileData$1 = class SimpleFileData extends FileData_js_1.FileData {
	    constructor(filePath, defaultData, schema, opts) {
	        super(filePath, defaultData, data => {
	            if ((0, lms_common_1.isAvailable)(data)) {
	                if (!schema.safeParse(data).success) {
	                    throw new Error("Data does not match schema");
	                }
	                return Buffer.from(JSON.stringify(data), "utf-8");
	            }
	            throw new Error("Data is not available");
	        }, buffer => schema.parse(JSON.parse(buffer.toString("utf-8"))), opts);
	    }
	};
	SimpleFileData.SimpleFileData = SimpleFileData$1;
	
	return SimpleFileData;
}

var hasRequiredCjs$2;

function requireCjs$2 () {
	if (hasRequiredCjs$2) return cjs$1;
	hasRequiredCjs$2 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SimpleFileData = exports.PlainTextFileData = exports.findLMStudioHome = exports.FileData = void 0;
		var FileData_js_1 = /*@__PURE__*/ requireFileData();
		Object.defineProperty(exports, "FileData", { enumerable: true, get: function () { return FileData_js_1.FileData; } });
		var findLMStudioHome_js_1 = /*@__PURE__*/ requireFindLMStudioHome();
		Object.defineProperty(exports, "findLMStudioHome", { enumerable: true, get: function () { return findLMStudioHome_js_1.findLMStudioHome; } });
		var PlainTextFileData_js_1 = /*@__PURE__*/ requirePlainTextFileData();
		Object.defineProperty(exports, "PlainTextFileData", { enumerable: true, get: function () { return PlainTextFileData_js_1.PlainTextFileData; } });
		var SimpleFileData_js_1 = /*@__PURE__*/ requireSimpleFileData();
		Object.defineProperty(exports, "SimpleFileData", { enumerable: true, get: function () { return SimpleFileData_js_1.SimpleFileData; } });
		
	} (cjs$1));
	return cjs$1;
}

var darwinOrLinux = {};

var inquirer = {exports: {}};

var figures = {exports: {}};

var escapeStringRegexp;
var hasRequiredEscapeStringRegexp;

function requireEscapeStringRegexp () {
	if (hasRequiredEscapeStringRegexp) return escapeStringRegexp;
	hasRequiredEscapeStringRegexp = 1;

	var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

	escapeStringRegexp = function (str) {
		if (typeof str !== 'string') {
			throw new TypeError('Expected a string');
		}

		return str.replace(matchOperatorsRe, '\\$&');
	};
	return escapeStringRegexp;
}

var hasRequiredFigures;

function requireFigures () {
	if (hasRequiredFigures) return figures.exports;
	hasRequiredFigures = 1;
	const escapeStringRegexp = requireEscapeStringRegexp();

	const {platform} = process;

	const main = {
		tick: '',
		cross: '',
		star: '',
		square: '',
		squareSmall: '',
		squareSmallFilled: '',
		play: '',
		circle: '',
		circleFilled: '',
		circleDotted: '',
		circleDouble: '',
		circleCircle: '',
		circleCross: '',
		circlePipe: '',
		circleQuestionMark: '?',
		bullet: '',
		dot: '',
		line: '',
		ellipsis: '',
		pointer: '',
		pointerSmall: '',
		info: '',
		warning: '',
		hamburger: '',
		smiley: '',
		mustache: '',
		heart: '',
		nodejs: '',
		arrowUp: '',
		arrowDown: '',
		arrowLeft: '',
		arrowRight: '',
		radioOn: '',
		radioOff: '',
		checkboxOn: '',
		checkboxOff: '',
		checkboxCircleOn: '',
		checkboxCircleOff: '',
		questionMarkPrefix: '?',
		oneHalf: '',
		oneThird: '',
		oneQuarter: '',
		oneFifth: '',
		oneSixth: '',
		oneSeventh: '',
		oneEighth: '',
		oneNinth: '',
		oneTenth: '',
		twoThirds: '',
		twoFifths: '',
		threeQuarters: '',
		threeFifths: '',
		threeEighths: '',
		fourFifths: '',
		fiveSixths: '',
		fiveEighths: '',
		sevenEighths: ''
	};

	const windows = {
		tick: '',
		cross: '',
		star: '*',
		square: '',
		squareSmall: '[ ]',
		squareSmallFilled: '[]',
		play: '',
		circle: '( )',
		circleFilled: '(*)',
		circleDotted: '( )',
		circleDouble: '( )',
		circleCircle: '()',
		circleCross: '()',
		circlePipe: '()',
		circleQuestionMark: '(?)',
		bullet: '*',
		dot: '.',
		line: '',
		ellipsis: '...',
		pointer: '>',
		pointerSmall: '',
		info: 'i',
		warning: '',
		hamburger: '',
		smiley: '',
		mustache: '',
		heart: main.heart,
		nodejs: '',
		arrowUp: main.arrowUp,
		arrowDown: main.arrowDown,
		arrowLeft: main.arrowLeft,
		arrowRight: main.arrowRight,
		radioOn: '(*)',
		radioOff: '( )',
		checkboxOn: '[]',
		checkboxOff: '[ ]',
		checkboxCircleOn: '()',
		checkboxCircleOff: '( )',
		questionMarkPrefix: '',
		oneHalf: '1/2',
		oneThird: '1/3',
		oneQuarter: '1/4',
		oneFifth: '1/5',
		oneSixth: '1/6',
		oneSeventh: '1/7',
		oneEighth: '1/8',
		oneNinth: '1/9',
		oneTenth: '1/10',
		twoThirds: '2/3',
		twoFifths: '2/5',
		threeQuarters: '3/4',
		threeFifths: '3/5',
		threeEighths: '3/8',
		fourFifths: '4/5',
		fiveSixths: '5/6',
		fiveEighths: '5/8',
		sevenEighths: '7/8'
	};

	if (platform === 'linux') {
		// The main one doesn't look that good on Ubuntu.
		main.questionMarkPrefix = '?';
	}

	const figures$1 = platform === 'win32' ? windows : main;

	const fn = string => {
		if (figures$1 === main) {
			return string;
		}

		for (const [key, value] of Object.entries(main)) {
			if (value === figures$1[key]) {
				continue;
			}

			string = string.replace(new RegExp(escapeStringRegexp(value), 'g'), figures$1[key]);
		}

		return string;
	};

	figures.exports = Object.assign(fn, figures$1);
	figures.exports.main = main;
	figures.exports.windows = windows;
	return figures.exports;
}

var separator;
var hasRequiredSeparator;

function requireSeparator () {
	if (hasRequiredSeparator) return separator;
	hasRequiredSeparator = 1;
	const chalk = requireSource();
	const figures = requireFigures();

	/**
	 * Separator object
	 * Used to space/separate choices group
	 * @constructor
	 * @param {String} line   Separation line content (facultative)
	 */

	class Separator {
	  constructor(line) {
	    this.type = 'separator';
	    this.line = chalk.dim(line || new Array(15).join(figures.line));
	  }

	  /**
	   * Stringify separator
	   * @return {String} the separator display string
	   */
	  toString() {
	    return this.line;
	  }
	}

	/**
	 * Helper function returning false if object is a separator
	 * @param  {Object} obj object to test against
	 * @return {Boolean}    `false` if object is a separator
	 */

	Separator.exclude = function (obj) {
	  return obj.type !== 'separator';
	};

	separator = Separator;
	return separator;
}

var through = {exports: {}};

var hasRequiredThrough;

function requireThrough () {
	if (hasRequiredThrough) return through.exports;
	hasRequiredThrough = 1;
	(function (module, exports) {
		var Stream = require$$0$a;

		// through
		//
		// a stream that does nothing but re-emit the input.
		// useful for aggregating a series of changing but not ending streams into one stream)

		module.exports = through;
		through.through = through;

		//create a readable writable stream.

		function through (write, end, opts) {
		  write = write || function (data) { this.queue(data); };
		  end = end || function () { this.queue(null); };

		  var ended = false, destroyed = false, buffer = [], _ended = false;
		  var stream = new Stream();
		  stream.readable = stream.writable = true;
		  stream.paused = false;

		//  stream.autoPause   = !(opts && opts.autoPause   === false)
		  stream.autoDestroy = !(opts && opts.autoDestroy === false);

		  stream.write = function (data) {
		    write.call(this, data);
		    return !stream.paused
		  };

		  function drain() {
		    while(buffer.length && !stream.paused) {
		      var data = buffer.shift();
		      if(null === data)
		        return stream.emit('end')
		      else
		        stream.emit('data', data);
		    }
		  }

		  stream.queue = stream.push = function (data) {
		//    console.error(ended)
		    if(_ended) return stream
		    if(data === null) _ended = true;
		    buffer.push(data);
		    drain();
		    return stream
		  };

		  //this will be registered as the first 'end' listener
		  //must call destroy next tick, to make sure we're after any
		  //stream piped from here.
		  //this is only a problem if end is not emitted synchronously.
		  //a nicer way to do this is to make sure this is the last listener for 'end'

		  stream.on('end', function () {
		    stream.readable = false;
		    if(!stream.writable && stream.autoDestroy)
		      process.nextTick(function () {
		        stream.destroy();
		      });
		  });

		  function _end () {
		    stream.writable = false;
		    end.call(stream);
		    if(!stream.readable && stream.autoDestroy)
		      stream.destroy();
		  }

		  stream.end = function (data) {
		    if(ended) return
		    ended = true;
		    if(arguments.length) stream.write(data);
		    _end(); // will emit or queue
		    return stream
		  };

		  stream.destroy = function () {
		    if(destroyed) return
		    destroyed = true;
		    ended = true;
		    buffer.length = 0;
		    stream.writable = stream.readable = false;
		    stream.emit('close');
		    return stream
		  };

		  stream.pause = function () {
		    if(stream.paused) return
		    stream.paused = true;
		    return stream
		  };

		  stream.resume = function () {
		    if(stream.paused) {
		      stream.paused = false;
		      stream.emit('resume');
		    }
		    drain();
		    //may have become paused again,
		    //as drain emits 'data'.
		    if(!stream.paused)
		      stream.emit('drain');
		    return stream
		  };
		  return stream
		} 
	} (through));
	return through.exports;
}

var mute;
var hasRequiredMute;

function requireMute () {
	if (hasRequiredMute) return mute;
	hasRequiredMute = 1;
	var Stream = require$$0$a;

	mute = MuteStream;

	// var out = new MuteStream(process.stdout)
	// argument auto-pipes
	function MuteStream (opts) {
	  Stream.apply(this);
	  opts = opts || {};
	  this.writable = this.readable = true;
	  this.muted = false;
	  this.on('pipe', this._onpipe);
	  this.replace = opts.replace;

	  // For readline-type situations
	  // This much at the start of a line being redrawn after a ctrl char
	  // is seen (such as backspace) won't be redrawn as the replacement
	  this._prompt = opts.prompt || null;
	  this._hadControl = false;
	}

	MuteStream.prototype = Object.create(Stream.prototype);

	Object.defineProperty(MuteStream.prototype, 'constructor', {
	  value: MuteStream,
	  enumerable: false
	});

	MuteStream.prototype.mute = function () {
	  this.muted = true;
	};

	MuteStream.prototype.unmute = function () {
	  this.muted = false;
	};

	Object.defineProperty(MuteStream.prototype, '_onpipe', {
	  value: onPipe,
	  enumerable: false,
	  writable: true,
	  configurable: true
	});

	function onPipe (src) {
	  this._src = src;
	}

	Object.defineProperty(MuteStream.prototype, 'isTTY', {
	  get: getIsTTY,
	  set: setIsTTY,
	  enumerable: true,
	  configurable: true
	});

	function getIsTTY () {
	  return( (this._dest) ? this._dest.isTTY
	        : (this._src) ? this._src.isTTY
	        : false
	        )
	}

	// basically just get replace the getter/setter with a regular value
	function setIsTTY (isTTY) {
	  Object.defineProperty(this, 'isTTY', {
	    value: isTTY,
	    enumerable: true,
	    writable: true,
	    configurable: true
	  });
	}

	Object.defineProperty(MuteStream.prototype, 'rows', {
	  get: function () {
	    return( this._dest ? this._dest.rows
	          : this._src ? this._src.rows
	          : undefined )
	  }, enumerable: true, configurable: true });

	Object.defineProperty(MuteStream.prototype, 'columns', {
	  get: function () {
	    return( this._dest ? this._dest.columns
	          : this._src ? this._src.columns
	          : undefined )
	  }, enumerable: true, configurable: true });


	MuteStream.prototype.pipe = function (dest, options) {
	  this._dest = dest;
	  return Stream.prototype.pipe.call(this, dest, options)
	};

	MuteStream.prototype.pause = function () {
	  if (this._src) return this._src.pause()
	};

	MuteStream.prototype.resume = function () {
	  if (this._src) return this._src.resume()
	};

	MuteStream.prototype.write = function (c) {
	  if (this.muted) {
	    if (!this.replace) return true
	    if (c.match(/^\u001b/)) {
	      if(c.indexOf(this._prompt) === 0) {
	        c = c.substr(this._prompt.length);
	        c = c.replace(/./g, this.replace);
	        c = this._prompt + c;
	      }
	      this._hadControl = true;
	      return this.emit('data', c)
	    } else {
	      if (this._prompt && this._hadControl &&
	          c.indexOf(this._prompt) === 0) {
	        this._hadControl = false;
	        this.emit('data', this._prompt);
	        c = c.substr(this._prompt.length);
	      }
	      c = c.toString().replace(/./g, this.replace);
	    }
	  }
	  this.emit('data', c);
	};

	MuteStream.prototype.end = function (c) {
	  if (this.muted) {
	    if (c && this.replace) {
	      c = c.toString().replace(/./g, this.replace);
	    } else {
	      c = null;
	    }
	  }
	  if (c) this.emit('data', c);
	  this.emit('end');
	};

	function proxy (fn) { return function () {
	  var d = this._dest;
	  var s = this._src;
	  if (d && d[fn]) d[fn].apply(d, arguments);
	  if (s && s[fn]) s[fn].apply(s, arguments);
	}}

	MuteStream.prototype.destroy = proxy('destroy');
	MuteStream.prototype.destroySoon = proxy('destroySoon');
	MuteStream.prototype.close = proxy('close');
	return mute;
}

var baseUI;
var hasRequiredBaseUI;

function requireBaseUI () {
	if (hasRequiredBaseUI) return baseUI;
	hasRequiredBaseUI = 1;
	const MuteStream = requireMute();
	const readline = require$$1$3;

	/**
	 * Base interface class other can inherits from
	 */

	class UI {
	  constructor(opt) {
	    // Instantiate the Readline interface
	    // @Note: Don't reassign if already present (allow test to override the Stream)
	    if (!this.rl) {
	      this.rl = readline.createInterface(setupReadlineOptions(opt));
	    }

	    this.rl.resume();

	    this.onForceClose = this.onForceClose.bind(this);

	    // Make sure new prompt start on a newline when closing
	    process.on('exit', this.onForceClose);

	    // Terminate process on SIGINT (which will call process.on('exit') in return)
	    this.rl.on('SIGINT', this.onForceClose);
	  }

	  /**
	   * Handle the ^C exit
	   * @return {null}
	   */

	  onForceClose() {
	    this.close();
	    process.kill(process.pid, 'SIGINT');
	    console.log('');
	  }

	  /**
	   * Close the interface and cleanup listeners
	   */

	  close() {
	    // Remove events listeners
	    this.rl.removeListener('SIGINT', this.onForceClose);
	    process.removeListener('exit', this.onForceClose);

	    this.rl.output.unmute();

	    if (this.activePrompt && typeof this.activePrompt.close === 'function') {
	      this.activePrompt.close();
	    }

	    // Close the readline
	    this.rl.output.end();
	    this.rl.pause();
	    this.rl.close();
	  }
	}

	function setupReadlineOptions(opt = {}) {
	  // Inquirer 8.x:
	  // opt.skipTTYChecks = opt.skipTTYChecks === undefined ? opt.input !== undefined : opt.skipTTYChecks;
	  opt.skipTTYChecks = opt.skipTTYChecks === undefined ? true : opt.skipTTYChecks;

	  // Default `input` to stdin
	  const input = opt.input || process.stdin;

	  // Check if prompt is being called in TTY environment
	  // If it isn't return a failed promise
	  if (!opt.skipTTYChecks && !input.isTTY) {
	    const nonTtyError = new Error(
	      'Prompts can not be meaningfully rendered in non-TTY environments'
	    );
	    nonTtyError.isTtyError = true;
	    throw nonTtyError;
	  }

	  // Add mute capabilities to the output
	  const ms = new MuteStream();
	  ms.pipe(opt.output || process.stdout);
	  const output = ms;

	  return {
	    terminal: true,
	    ...opt,
	    input,
	    output,
	  };
	}

	baseUI = UI;
	return baseUI;
}

var readline = {};

var ansiEscapes = {exports: {}};

var hasRequiredAnsiEscapes;

function requireAnsiEscapes () {
	if (hasRequiredAnsiEscapes) return ansiEscapes.exports;
	hasRequiredAnsiEscapes = 1;
	(function (module) {
		const ansiEscapes = module.exports;
		// TODO: remove this in the next major version
		module.exports.default = ansiEscapes;

		const ESC = '\u001B[';
		const OSC = '\u001B]';
		const BEL = '\u0007';
		const SEP = ';';
		const isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';

		ansiEscapes.cursorTo = (x, y) => {
			if (typeof x !== 'number') {
				throw new TypeError('The `x` argument is required');
			}

			if (typeof y !== 'number') {
				return ESC + (x + 1) + 'G';
			}

			return ESC + (y + 1) + ';' + (x + 1) + 'H';
		};

		ansiEscapes.cursorMove = (x, y) => {
			if (typeof x !== 'number') {
				throw new TypeError('The `x` argument is required');
			}

			let ret = '';

			if (x < 0) {
				ret += ESC + (-x) + 'D';
			} else if (x > 0) {
				ret += ESC + x + 'C';
			}

			if (y < 0) {
				ret += ESC + (-y) + 'A';
			} else if (y > 0) {
				ret += ESC + y + 'B';
			}

			return ret;
		};

		ansiEscapes.cursorUp = (count = 1) => ESC + count + 'A';
		ansiEscapes.cursorDown = (count = 1) => ESC + count + 'B';
		ansiEscapes.cursorForward = (count = 1) => ESC + count + 'C';
		ansiEscapes.cursorBackward = (count = 1) => ESC + count + 'D';

		ansiEscapes.cursorLeft = ESC + 'G';
		ansiEscapes.cursorSavePosition = isTerminalApp ? '\u001B7' : ESC + 's';
		ansiEscapes.cursorRestorePosition = isTerminalApp ? '\u001B8' : ESC + 'u';
		ansiEscapes.cursorGetPosition = ESC + '6n';
		ansiEscapes.cursorNextLine = ESC + 'E';
		ansiEscapes.cursorPrevLine = ESC + 'F';
		ansiEscapes.cursorHide = ESC + '?25l';
		ansiEscapes.cursorShow = ESC + '?25h';

		ansiEscapes.eraseLines = count => {
			let clear = '';

			for (let i = 0; i < count; i++) {
				clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : '');
			}

			if (count) {
				clear += ansiEscapes.cursorLeft;
			}

			return clear;
		};

		ansiEscapes.eraseEndLine = ESC + 'K';
		ansiEscapes.eraseStartLine = ESC + '1K';
		ansiEscapes.eraseLine = ESC + '2K';
		ansiEscapes.eraseDown = ESC + 'J';
		ansiEscapes.eraseUp = ESC + '1J';
		ansiEscapes.eraseScreen = ESC + '2J';
		ansiEscapes.scrollUp = ESC + 'S';
		ansiEscapes.scrollDown = ESC + 'T';

		ansiEscapes.clearScreen = '\u001Bc';

		ansiEscapes.clearTerminal = process.platform === 'win32' ?
			`${ansiEscapes.eraseScreen}${ESC}0f` :
			// 1. Erases the screen (Only done in case `2` is not supported)
			// 2. Erases the whole screen including scrollback buffer
			// 3. Moves cursor to the top-left position
			// More info: https://www.real-world-systems.com/docs/ANSIcode.html
			`${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;

		ansiEscapes.beep = BEL;

		ansiEscapes.link = (text, url) => {
			return [
				OSC,
				'8',
				SEP,
				SEP,
				url,
				BEL,
				text,
				OSC,
				'8',
				SEP,
				SEP,
				BEL
			].join('');
		};

		ansiEscapes.image = (buffer, options = {}) => {
			let ret = `${OSC}1337;File=inline=1`;

			if (options.width) {
				ret += `;width=${options.width}`;
			}

			if (options.height) {
				ret += `;height=${options.height}`;
			}

			if (options.preserveAspectRatio === false) {
				ret += ';preserveAspectRatio=0';
			}

			return ret + ':' + buffer.toString('base64') + BEL;
		};

		ansiEscapes.iTerm = {
			setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,

			annotation: (message, options = {}) => {
				let ret = `${OSC}1337;`;

				const hasX = typeof options.x !== 'undefined';
				const hasY = typeof options.y !== 'undefined';
				if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== 'undefined')) {
					throw new Error('`x`, `y` and `length` must be defined when `x` or `y` is defined');
				}

				message = message.replace(/\|/g, '');

				ret += options.isHidden ? 'AddHiddenAnnotation=' : 'AddAnnotation=';

				if (options.length > 0) {
					ret +=
							(hasX ?
								[message, options.length, options.x, options.y] :
								[options.length, message]).join('|');
				} else {
					ret += message;
				}

				return ret + BEL;
			}
		}; 
	} (ansiEscapes));
	return ansiEscapes.exports;
}

var hasRequiredReadline;

function requireReadline () {
	if (hasRequiredReadline) return readline;
	hasRequiredReadline = 1;
	const ansiEscapes = requireAnsiEscapes();

	/**
	 * Move cursor left by `x`
	 * @param  {Readline} rl - Readline instance
	 * @param  {Number}   x  - How far to go left (default to 1)
	 */

	readline.left = function (rl, x) {
	  rl.output.write(ansiEscapes.cursorBackward(x));
	};

	/**
	 * Move cursor right by `x`
	 * @param  {Readline} rl - Readline instance
	 * @param  {Number}   x  - How far to go left (default to 1)
	 */

	readline.right = function (rl, x) {
	  rl.output.write(ansiEscapes.cursorForward(x));
	};

	/**
	 * Move cursor up by `x`
	 * @param  {Readline} rl - Readline instance
	 * @param  {Number}   x  - How far to go up (default to 1)
	 */

	readline.up = function (rl, x) {
	  rl.output.write(ansiEscapes.cursorUp(x));
	};

	/**
	 * Move cursor down by `x`
	 * @param  {Readline} rl - Readline instance
	 * @param  {Number}   x  - How far to go down (default to 1)
	 */

	readline.down = function (rl, x) {
	  rl.output.write(ansiEscapes.cursorDown(x));
	};

	/**
	 * Clear current line
	 * @param  {Readline} rl  - Readline instance
	 * @param  {Number}   len - number of line to delete
	 */
	readline.clearLine = function (rl, len) {
	  rl.output.write(ansiEscapes.eraseLines(len));
	};
	return readline;
}

var bottomBar;
var hasRequiredBottomBar;

function requireBottomBar () {
	if (hasRequiredBottomBar) return bottomBar;
	hasRequiredBottomBar = 1;
	/**
	 * Sticky bottom bar user interface
	 */

	const through = requireThrough();
	const Base = requireBaseUI();
	const rlUtils = requireReadline();

	class BottomBar extends Base {
	  constructor(opt = {}) {
	    super(opt);

	    this.log = through(this.writeLog.bind(this));
	    this.bottomBar = opt.bottomBar || '';
	    this.render();
	  }

	  /**
	   * Render the prompt to screen
	   * @return {BottomBar} self
	   */

	  render() {
	    this.write(this.bottomBar);
	    return this;
	  }

	  clean() {
	    rlUtils.clearLine(this.rl, this.bottomBar.split('\n').length);
	    return this;
	  }

	  /**
	   * Update the bottom bar content and rerender
	   * @param  {String} bottomBar Bottom bar content
	   * @return {BottomBar}           self
	   */

	  updateBottomBar(bottomBar) {
	    rlUtils.clearLine(this.rl, 1);
	    this.rl.output.unmute();
	    this.clean();
	    this.bottomBar = bottomBar;
	    this.render();
	    this.rl.output.mute();
	    return this;
	  }

	  /**
	   * Write out log data
	   * @param {String} data - The log data to be output
	   * @return {BottomBar} self
	   */

	  writeLog(data) {
	    this.rl.output.unmute();
	    this.clean();
	    this.rl.output.write(this.enforceLF(data.toString()));
	    this.render();
	    this.rl.output.mute();
	    return this;
	  }

	  /**
	   * Make sure line end on a line feed
	   * @param  {String} str Input string
	   * @return {String}     The input string with a final line feed
	   */

	  enforceLF(str) {
	    return str.match(/[\r\n]$/) ? str : str + '\n';
	  }

	  /**
	   * Helper for writing message in Prompt
	   * @param {String} message - The message to be output
	   */
	  write(message) {
	    const msgLines = message.split(/\n/);
	    this.height = msgLines.length;

	    // Write message to screen and setPrompt to control backspace
	    this.rl.setPrompt(msgLines[msgLines.length - 1]);

	    if (this.rl.output.rows === 0 && this.rl.output.columns === 0) {
	      /* When it's a tty through serial port there's no terminal info and the render will malfunction,
	         so we need enforce the cursor to locate to the leftmost position for rendering. */
	      rlUtils.left(this.rl, message.length + this.rl.line.length);
	    }

	    this.rl.output.write(message);
	  }
	}

	bottomBar = BottomBar;
	return bottomBar;
}

/** Detect free variable `global` from Node.js. */

var _freeGlobal;
var hasRequired_freeGlobal;

function require_freeGlobal () {
	if (hasRequired_freeGlobal) return _freeGlobal;
	hasRequired_freeGlobal = 1;
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	_freeGlobal = freeGlobal;
	return _freeGlobal;
}

var _root;
var hasRequired_root;

function require_root () {
	if (hasRequired_root) return _root;
	hasRequired_root = 1;
	var freeGlobal = require_freeGlobal();

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	_root = root;
	return _root;
}

var _Symbol;
var hasRequired_Symbol;

function require_Symbol () {
	if (hasRequired_Symbol) return _Symbol;
	hasRequired_Symbol = 1;
	var root = require_root();

	/** Built-in value references. */
	var Symbol = root.Symbol;

	_Symbol = Symbol;
	return _Symbol;
}

var _getRawTag;
var hasRequired_getRawTag;

function require_getRawTag () {
	if (hasRequired_getRawTag) return _getRawTag;
	hasRequired_getRawTag = 1;
	var Symbol = require_Symbol();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	_getRawTag = getRawTag;
	return _getRawTag;
}

/** Used for built-in method references. */

var _objectToString;
var hasRequired_objectToString;

function require_objectToString () {
	if (hasRequired_objectToString) return _objectToString;
	hasRequired_objectToString = 1;
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	_objectToString = objectToString;
	return _objectToString;
}

var _baseGetTag;
var hasRequired_baseGetTag;

function require_baseGetTag () {
	if (hasRequired_baseGetTag) return _baseGetTag;
	hasRequired_baseGetTag = 1;
	var Symbol = require_Symbol(),
	    getRawTag = require_getRawTag(),
	    objectToString = require_objectToString();

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	_baseGetTag = baseGetTag;
	return _baseGetTag;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

var _overArg;
var hasRequired_overArg;

function require_overArg () {
	if (hasRequired_overArg) return _overArg;
	hasRequired_overArg = 1;
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	_overArg = overArg;
	return _overArg;
}

var _getPrototype;
var hasRequired_getPrototype;

function require_getPrototype () {
	if (hasRequired_getPrototype) return _getPrototype;
	hasRequired_getPrototype = 1;
	var overArg = require_overArg();

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	_getPrototype = getPrototype;
	return _getPrototype;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

var isObjectLike_1;
var hasRequiredIsObjectLike;

function requireIsObjectLike () {
	if (hasRequiredIsObjectLike) return isObjectLike_1;
	hasRequiredIsObjectLike = 1;
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	isObjectLike_1 = isObjectLike;
	return isObjectLike_1;
}

var isPlainObject_1;
var hasRequiredIsPlainObject;

function requireIsPlainObject () {
	if (hasRequiredIsPlainObject) return isPlainObject_1;
	hasRequiredIsPlainObject = 1;
	var baseGetTag = require_baseGetTag(),
	    getPrototype = require_getPrototype(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	isPlainObject_1 = isPlainObject;
	return isPlainObject_1;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */

var isArray_1;
var hasRequiredIsArray;

function requireIsArray () {
	if (hasRequiredIsArray) return isArray_1;
	hasRequiredIsArray = 1;
	var isArray = Array.isArray;

	isArray_1 = isArray;
	return isArray_1;
}

var isSymbol_1;
var hasRequiredIsSymbol;

function requireIsSymbol () {
	if (hasRequiredIsSymbol) return isSymbol_1;
	hasRequiredIsSymbol = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	isSymbol_1 = isSymbol;
	return isSymbol_1;
}

var _isKey;
var hasRequired_isKey;

function require_isKey () {
	if (hasRequired_isKey) return _isKey;
	hasRequired_isKey = 1;
	var isArray = requireIsArray(),
	    isSymbol = requireIsSymbol();

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	_isKey = isKey;
	return _isKey;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */

var isObject_1;
var hasRequiredIsObject;

function requireIsObject () {
	if (hasRequiredIsObject) return isObject_1;
	hasRequiredIsObject = 1;
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	isObject_1 = isObject;
	return isObject_1;
}

var isFunction_1;
var hasRequiredIsFunction$1;

function requireIsFunction$1 () {
	if (hasRequiredIsFunction$1) return isFunction_1;
	hasRequiredIsFunction$1 = 1;
	var baseGetTag = require_baseGetTag(),
	    isObject = requireIsObject();

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	isFunction_1 = isFunction;
	return isFunction_1;
}

var _coreJsData;
var hasRequired_coreJsData;

function require_coreJsData () {
	if (hasRequired_coreJsData) return _coreJsData;
	hasRequired_coreJsData = 1;
	var root = require_root();

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	_coreJsData = coreJsData;
	return _coreJsData;
}

var _isMasked;
var hasRequired_isMasked;

function require_isMasked () {
	if (hasRequired_isMasked) return _isMasked;
	hasRequired_isMasked = 1;
	var coreJsData = require_coreJsData();

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	_isMasked = isMasked;
	return _isMasked;
}

/** Used for built-in method references. */

var _toSource;
var hasRequired_toSource;

function require_toSource () {
	if (hasRequired_toSource) return _toSource;
	hasRequired_toSource = 1;
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	_toSource = toSource;
	return _toSource;
}

var _baseIsNative;
var hasRequired_baseIsNative;

function require_baseIsNative () {
	if (hasRequired_baseIsNative) return _baseIsNative;
	hasRequired_baseIsNative = 1;
	var isFunction = requireIsFunction$1(),
	    isMasked = require_isMasked(),
	    isObject = requireIsObject(),
	    toSource = require_toSource();

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	_baseIsNative = baseIsNative;
	return _baseIsNative;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

var _getValue;
var hasRequired_getValue;

function require_getValue () {
	if (hasRequired_getValue) return _getValue;
	hasRequired_getValue = 1;
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	_getValue = getValue;
	return _getValue;
}

var _getNative;
var hasRequired_getNative;

function require_getNative () {
	if (hasRequired_getNative) return _getNative;
	hasRequired_getNative = 1;
	var baseIsNative = require_baseIsNative(),
	    getValue = require_getValue();

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	_getNative = getNative;
	return _getNative;
}

var _nativeCreate;
var hasRequired_nativeCreate;

function require_nativeCreate () {
	if (hasRequired_nativeCreate) return _nativeCreate;
	hasRequired_nativeCreate = 1;
	var getNative = require_getNative();

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	_nativeCreate = nativeCreate;
	return _nativeCreate;
}

var _hashClear;
var hasRequired_hashClear;

function require_hashClear () {
	if (hasRequired_hashClear) return _hashClear;
	hasRequired_hashClear = 1;
	var nativeCreate = require_nativeCreate();

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	_hashClear = hashClear;
	return _hashClear;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _hashDelete;
var hasRequired_hashDelete;

function require_hashDelete () {
	if (hasRequired_hashDelete) return _hashDelete;
	hasRequired_hashDelete = 1;
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_hashDelete = hashDelete;
	return _hashDelete;
}

var _hashGet;
var hasRequired_hashGet;

function require_hashGet () {
	if (hasRequired_hashGet) return _hashGet;
	hasRequired_hashGet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	_hashGet = hashGet;
	return _hashGet;
}

var _hashHas;
var hasRequired_hashHas;

function require_hashHas () {
	if (hasRequired_hashHas) return _hashHas;
	hasRequired_hashHas = 1;
	var nativeCreate = require_nativeCreate();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	_hashHas = hashHas;
	return _hashHas;
}

var _hashSet;
var hasRequired_hashSet;

function require_hashSet () {
	if (hasRequired_hashSet) return _hashSet;
	hasRequired_hashSet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	_hashSet = hashSet;
	return _hashSet;
}

var _Hash;
var hasRequired_Hash;

function require_Hash () {
	if (hasRequired_Hash) return _Hash;
	hasRequired_Hash = 1;
	var hashClear = require_hashClear(),
	    hashDelete = require_hashDelete(),
	    hashGet = require_hashGet(),
	    hashHas = require_hashHas(),
	    hashSet = require_hashSet();

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	_Hash = Hash;
	return _Hash;
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

var _listCacheClear;
var hasRequired_listCacheClear;

function require_listCacheClear () {
	if (hasRequired_listCacheClear) return _listCacheClear;
	hasRequired_listCacheClear = 1;
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	_listCacheClear = listCacheClear;
	return _listCacheClear;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	eq_1 = eq;
	return eq_1;
}

var _assocIndexOf;
var hasRequired_assocIndexOf;

function require_assocIndexOf () {
	if (hasRequired_assocIndexOf) return _assocIndexOf;
	hasRequired_assocIndexOf = 1;
	var eq = requireEq();

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	_assocIndexOf = assocIndexOf;
	return _assocIndexOf;
}

var _listCacheDelete;
var hasRequired_listCacheDelete;

function require_listCacheDelete () {
	if (hasRequired_listCacheDelete) return _listCacheDelete;
	hasRequired_listCacheDelete = 1;
	var assocIndexOf = require_assocIndexOf();

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	_listCacheDelete = listCacheDelete;
	return _listCacheDelete;
}

var _listCacheGet;
var hasRequired_listCacheGet;

function require_listCacheGet () {
	if (hasRequired_listCacheGet) return _listCacheGet;
	hasRequired_listCacheGet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	_listCacheGet = listCacheGet;
	return _listCacheGet;
}

var _listCacheHas;
var hasRequired_listCacheHas;

function require_listCacheHas () {
	if (hasRequired_listCacheHas) return _listCacheHas;
	hasRequired_listCacheHas = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	_listCacheHas = listCacheHas;
	return _listCacheHas;
}

var _listCacheSet;
var hasRequired_listCacheSet;

function require_listCacheSet () {
	if (hasRequired_listCacheSet) return _listCacheSet;
	hasRequired_listCacheSet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	_listCacheSet = listCacheSet;
	return _listCacheSet;
}

var _ListCache;
var hasRequired_ListCache;

function require_ListCache () {
	if (hasRequired_ListCache) return _ListCache;
	hasRequired_ListCache = 1;
	var listCacheClear = require_listCacheClear(),
	    listCacheDelete = require_listCacheDelete(),
	    listCacheGet = require_listCacheGet(),
	    listCacheHas = require_listCacheHas(),
	    listCacheSet = require_listCacheSet();

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	_ListCache = ListCache;
	return _ListCache;
}

var _Map;
var hasRequired_Map;

function require_Map () {
	if (hasRequired_Map) return _Map;
	hasRequired_Map = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	_Map = Map;
	return _Map;
}

var _mapCacheClear;
var hasRequired_mapCacheClear;

function require_mapCacheClear () {
	if (hasRequired_mapCacheClear) return _mapCacheClear;
	hasRequired_mapCacheClear = 1;
	var Hash = require_Hash(),
	    ListCache = require_ListCache(),
	    Map = require_Map();

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	_mapCacheClear = mapCacheClear;
	return _mapCacheClear;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */

var _isKeyable;
var hasRequired_isKeyable;

function require_isKeyable () {
	if (hasRequired_isKeyable) return _isKeyable;
	hasRequired_isKeyable = 1;
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	_isKeyable = isKeyable;
	return _isKeyable;
}

var _getMapData;
var hasRequired_getMapData;

function require_getMapData () {
	if (hasRequired_getMapData) return _getMapData;
	hasRequired_getMapData = 1;
	var isKeyable = require_isKeyable();

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	_getMapData = getMapData;
	return _getMapData;
}

var _mapCacheDelete;
var hasRequired_mapCacheDelete;

function require_mapCacheDelete () {
	if (hasRequired_mapCacheDelete) return _mapCacheDelete;
	hasRequired_mapCacheDelete = 1;
	var getMapData = require_getMapData();

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_mapCacheDelete = mapCacheDelete;
	return _mapCacheDelete;
}

var _mapCacheGet;
var hasRequired_mapCacheGet;

function require_mapCacheGet () {
	if (hasRequired_mapCacheGet) return _mapCacheGet;
	hasRequired_mapCacheGet = 1;
	var getMapData = require_getMapData();

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	_mapCacheGet = mapCacheGet;
	return _mapCacheGet;
}

var _mapCacheHas;
var hasRequired_mapCacheHas;

function require_mapCacheHas () {
	if (hasRequired_mapCacheHas) return _mapCacheHas;
	hasRequired_mapCacheHas = 1;
	var getMapData = require_getMapData();

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	_mapCacheHas = mapCacheHas;
	return _mapCacheHas;
}

var _mapCacheSet;
var hasRequired_mapCacheSet;

function require_mapCacheSet () {
	if (hasRequired_mapCacheSet) return _mapCacheSet;
	hasRequired_mapCacheSet = 1;
	var getMapData = require_getMapData();

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	_mapCacheSet = mapCacheSet;
	return _mapCacheSet;
}

var _MapCache;
var hasRequired_MapCache;

function require_MapCache () {
	if (hasRequired_MapCache) return _MapCache;
	hasRequired_MapCache = 1;
	var mapCacheClear = require_mapCacheClear(),
	    mapCacheDelete = require_mapCacheDelete(),
	    mapCacheGet = require_mapCacheGet(),
	    mapCacheHas = require_mapCacheHas(),
	    mapCacheSet = require_mapCacheSet();

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	_MapCache = MapCache;
	return _MapCache;
}

var memoize_1;
var hasRequiredMemoize;

function requireMemoize () {
	if (hasRequiredMemoize) return memoize_1;
	hasRequiredMemoize = 1;
	var MapCache = require_MapCache();

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	memoize_1 = memoize;
	return memoize_1;
}

var _memoizeCapped;
var hasRequired_memoizeCapped;

function require_memoizeCapped () {
	if (hasRequired_memoizeCapped) return _memoizeCapped;
	hasRequired_memoizeCapped = 1;
	var memoize = requireMemoize();

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	_memoizeCapped = memoizeCapped;
	return _memoizeCapped;
}

var _stringToPath;
var hasRequired_stringToPath;

function require_stringToPath () {
	if (hasRequired_stringToPath) return _stringToPath;
	hasRequired_stringToPath = 1;
	var memoizeCapped = require_memoizeCapped();

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	_stringToPath = stringToPath;
	return _stringToPath;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

var _arrayMap;
var hasRequired_arrayMap;

function require_arrayMap () {
	if (hasRequired_arrayMap) return _arrayMap;
	hasRequired_arrayMap = 1;
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	_arrayMap = arrayMap;
	return _arrayMap;
}

var _baseToString;
var hasRequired_baseToString;

function require_baseToString () {
	if (hasRequired_baseToString) return _baseToString;
	hasRequired_baseToString = 1;
	var Symbol = require_Symbol(),
	    arrayMap = require_arrayMap(),
	    isArray = requireIsArray(),
	    isSymbol = requireIsSymbol();

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	_baseToString = baseToString;
	return _baseToString;
}

var toString_1;
var hasRequiredToString;

function requireToString () {
	if (hasRequiredToString) return toString_1;
	hasRequiredToString = 1;
	var baseToString = require_baseToString();

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	toString_1 = toString;
	return toString_1;
}

var _castPath;
var hasRequired_castPath;

function require_castPath () {
	if (hasRequired_castPath) return _castPath;
	hasRequired_castPath = 1;
	var isArray = requireIsArray(),
	    isKey = require_isKey(),
	    stringToPath = require_stringToPath(),
	    toString = requireToString();

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	_castPath = castPath;
	return _castPath;
}

var _toKey;
var hasRequired_toKey;

function require_toKey () {
	if (hasRequired_toKey) return _toKey;
	hasRequired_toKey = 1;
	var isSymbol = requireIsSymbol();

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	_toKey = toKey;
	return _toKey;
}

var _baseGet;
var hasRequired_baseGet;

function require_baseGet () {
	if (hasRequired_baseGet) return _baseGet;
	hasRequired_baseGet = 1;
	var castPath = require_castPath(),
	    toKey = require_toKey();

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	_baseGet = baseGet;
	return _baseGet;
}

var get_1;
var hasRequiredGet;

function requireGet () {
	if (hasRequiredGet) return get_1;
	hasRequiredGet = 1;
	var baseGet = require_baseGet();

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	get_1 = get;
	return get_1;
}

var _defineProperty;
var hasRequired_defineProperty;

function require_defineProperty () {
	if (hasRequired_defineProperty) return _defineProperty;
	hasRequired_defineProperty = 1;
	var getNative = require_getNative();

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	_defineProperty = defineProperty;
	return _defineProperty;
}

var _baseAssignValue;
var hasRequired_baseAssignValue;

function require_baseAssignValue () {
	if (hasRequired_baseAssignValue) return _baseAssignValue;
	hasRequired_baseAssignValue = 1;
	var defineProperty = require_defineProperty();

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	_baseAssignValue = baseAssignValue;
	return _baseAssignValue;
}

var _assignValue;
var hasRequired_assignValue;

function require_assignValue () {
	if (hasRequired_assignValue) return _assignValue;
	hasRequired_assignValue = 1;
	var baseAssignValue = require_baseAssignValue(),
	    eq = requireEq();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	_assignValue = assignValue;
	return _assignValue;
}

/** Used as references for various `Number` constants. */

var _isIndex;
var hasRequired_isIndex;

function require_isIndex () {
	if (hasRequired_isIndex) return _isIndex;
	hasRequired_isIndex = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	_isIndex = isIndex;
	return _isIndex;
}

var _baseSet;
var hasRequired_baseSet;

function require_baseSet () {
	if (hasRequired_baseSet) return _baseSet;
	hasRequired_baseSet = 1;
	var assignValue = require_assignValue(),
	    castPath = require_castPath(),
	    isIndex = require_isIndex(),
	    isObject = requireIsObject(),
	    toKey = require_toKey();

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!isObject(object)) {
	    return object;
	  }
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;

	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]),
	        newValue = value;

	    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
	      return object;
	    }

	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject(objValue)
	          ? objValue
	          : (isIndex(path[index + 1]) ? [] : {});
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}

	_baseSet = baseSet;
	return _baseSet;
}

var set_1;
var hasRequiredSet;

function requireSet () {
	if (hasRequiredSet) return set_1;
	hasRequiredSet = 1;
	var baseSet = require_baseSet();

	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `_.setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, ['x', '0', 'y', 'z'], 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : baseSet(object, path, value);
	}

	set_1 = set;
	return set_1;
}

var cjs = {};

var Observable = {};

var Subscriber = {};

var isFunction = {};

var hasRequiredIsFunction;

function requireIsFunction () {
	if (hasRequiredIsFunction) return isFunction;
	hasRequiredIsFunction = 1;
	Object.defineProperty(isFunction, "__esModule", { value: true });
	isFunction.isFunction = void 0;
	function isFunction$1(value) {
	    return typeof value === 'function';
	}
	isFunction.isFunction = isFunction$1;
	
	return isFunction;
}

var Subscription = {};

var UnsubscriptionError = {};

var createErrorClass = {};

var hasRequiredCreateErrorClass;

function requireCreateErrorClass () {
	if (hasRequiredCreateErrorClass) return createErrorClass;
	hasRequiredCreateErrorClass = 1;
	Object.defineProperty(createErrorClass, "__esModule", { value: true });
	createErrorClass.createErrorClass = void 0;
	function createErrorClass$1(createImpl) {
	    var _super = function (instance) {
	        Error.call(instance);
	        instance.stack = new Error().stack;
	    };
	    var ctorFunc = createImpl(_super);
	    ctorFunc.prototype = Object.create(Error.prototype);
	    ctorFunc.prototype.constructor = ctorFunc;
	    return ctorFunc;
	}
	createErrorClass.createErrorClass = createErrorClass$1;
	
	return createErrorClass;
}

var hasRequiredUnsubscriptionError;

function requireUnsubscriptionError () {
	if (hasRequiredUnsubscriptionError) return UnsubscriptionError;
	hasRequiredUnsubscriptionError = 1;
	Object.defineProperty(UnsubscriptionError, "__esModule", { value: true });
	UnsubscriptionError.UnsubscriptionError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	UnsubscriptionError.UnsubscriptionError = createErrorClass_1.createErrorClass(function (_super) {
	    return function UnsubscriptionErrorImpl(errors) {
	        _super(this);
	        this.message = errors
	            ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
	            : '';
	        this.name = 'UnsubscriptionError';
	        this.errors = errors;
	    };
	});
	
	return UnsubscriptionError;
}

var arrRemove = {};

var hasRequiredArrRemove;

function requireArrRemove () {
	if (hasRequiredArrRemove) return arrRemove;
	hasRequiredArrRemove = 1;
	Object.defineProperty(arrRemove, "__esModule", { value: true });
	arrRemove.arrRemove = void 0;
	function arrRemove$1(arr, item) {
	    if (arr) {
	        var index = arr.indexOf(item);
	        0 <= index && arr.splice(index, 1);
	    }
	}
	arrRemove.arrRemove = arrRemove$1;
	
	return arrRemove;
}

var hasRequiredSubscription;

function requireSubscription () {
	if (hasRequiredSubscription) return Subscription;
	hasRequiredSubscription = 1;
	var __values = (Subscription && Subscription.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read = (Subscription && Subscription.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (Subscription && Subscription.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(Subscription, "__esModule", { value: true });
	Subscription.isSubscription = Subscription.EMPTY_SUBSCRIPTION = Subscription.Subscription = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var UnsubscriptionError_1 = /*@__PURE__*/ requireUnsubscriptionError();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	var Subscription$1 = (function () {
	    function Subscription(initialTeardown) {
	        this.initialTeardown = initialTeardown;
	        this.closed = false;
	        this._parentage = null;
	        this._finalizers = null;
	    }
	    Subscription.prototype.unsubscribe = function () {
	        var e_1, _a, e_2, _b;
	        var errors;
	        if (!this.closed) {
	            this.closed = true;
	            var _parentage = this._parentage;
	            if (_parentage) {
	                this._parentage = null;
	                if (Array.isArray(_parentage)) {
	                    try {
	                        for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
	                            var parent_1 = _parentage_1_1.value;
	                            parent_1.remove(this);
	                        }
	                    }
	                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                    finally {
	                        try {
	                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
	                        }
	                        finally { if (e_1) throw e_1.error; }
	                    }
	                }
	                else {
	                    _parentage.remove(this);
	                }
	            }
	            var initialFinalizer = this.initialTeardown;
	            if (isFunction_1.isFunction(initialFinalizer)) {
	                try {
	                    initialFinalizer();
	                }
	                catch (e) {
	                    errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
	                }
	            }
	            var _finalizers = this._finalizers;
	            if (_finalizers) {
	                this._finalizers = null;
	                try {
	                    for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
	                        var finalizer = _finalizers_1_1.value;
	                        try {
	                            execFinalizer(finalizer);
	                        }
	                        catch (err) {
	                            errors = errors !== null && errors !== void 0 ? errors : [];
	                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
	                            }
	                            else {
	                                errors.push(err);
	                            }
	                        }
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	            }
	            if (errors) {
	                throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	            }
	        }
	    };
	    Subscription.prototype.add = function (teardown) {
	        var _a;
	        if (teardown && teardown !== this) {
	            if (this.closed) {
	                execFinalizer(teardown);
	            }
	            else {
	                if (teardown instanceof Subscription) {
	                    if (teardown.closed || teardown._hasParent(this)) {
	                        return;
	                    }
	                    teardown._addParent(this);
	                }
	                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
	            }
	        }
	    };
	    Subscription.prototype._hasParent = function (parent) {
	        var _parentage = this._parentage;
	        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _parentage = this._parentage;
	        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
	    };
	    Subscription.prototype._removeParent = function (parent) {
	        var _parentage = this._parentage;
	        if (_parentage === parent) {
	            this._parentage = null;
	        }
	        else if (Array.isArray(_parentage)) {
	            arrRemove_1.arrRemove(_parentage, parent);
	        }
	    };
	    Subscription.prototype.remove = function (teardown) {
	        var _finalizers = this._finalizers;
	        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
	        if (teardown instanceof Subscription) {
	            teardown._removeParent(this);
	        }
	    };
	    Subscription.EMPTY = (function () {
	        var empty = new Subscription();
	        empty.closed = true;
	        return empty;
	    })();
	    return Subscription;
	}());
	Subscription.Subscription = Subscription$1;
	Subscription.EMPTY_SUBSCRIPTION = Subscription$1.EMPTY;
	function isSubscription(value) {
	    return (value instanceof Subscription$1 ||
	        (value && 'closed' in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe)));
	}
	Subscription.isSubscription = isSubscription;
	function execFinalizer(finalizer) {
	    if (isFunction_1.isFunction(finalizer)) {
	        finalizer();
	    }
	    else {
	        finalizer.unsubscribe();
	    }
	}
	
	return Subscription;
}

var config = {};

var hasRequiredConfig;

function requireConfig () {
	if (hasRequiredConfig) return config;
	hasRequiredConfig = 1;
	Object.defineProperty(config, "__esModule", { value: true });
	config.config = void 0;
	config.config = {
	    onUnhandledError: null,
	    onStoppedNotification: null,
	    Promise: undefined,
	    useDeprecatedSynchronousErrorHandling: false,
	    useDeprecatedNextContext: false,
	};
	
	return config;
}

var reportUnhandledError = {};

var timeoutProvider = {};

var hasRequiredTimeoutProvider;

function requireTimeoutProvider () {
	if (hasRequiredTimeoutProvider) return timeoutProvider;
	hasRequiredTimeoutProvider = 1;
	(function (exports) {
		var __read = (timeoutProvider && timeoutProvider.__read) || function (o, n) {
		    var m = typeof Symbol === "function" && o[Symbol.iterator];
		    if (!m) return o;
		    var i = m.call(o), r, ar = [], e;
		    try {
		        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		    }
		    catch (error) { e = { error: error }; }
		    finally {
		        try {
		            if (r && !r.done && (m = i["return"])) m.call(i);
		        }
		        finally { if (e) throw e.error; }
		    }
		    return ar;
		};
		var __spreadArray = (timeoutProvider && timeoutProvider.__spreadArray) || function (to, from) {
		    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
		        to[j] = from[i];
		    return to;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.timeoutProvider = void 0;
		exports.timeoutProvider = {
		    setTimeout: function (handler, timeout) {
		        var args = [];
		        for (var _i = 2; _i < arguments.length; _i++) {
		            args[_i - 2] = arguments[_i];
		        }
		        var delegate = exports.timeoutProvider.delegate;
		        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
		            return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
		        }
		        return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
		    },
		    clearTimeout: function (handle) {
		        var delegate = exports.timeoutProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
		    },
		    delegate: undefined,
		};
		
	} (timeoutProvider));
	return timeoutProvider;
}

var hasRequiredReportUnhandledError;

function requireReportUnhandledError () {
	if (hasRequiredReportUnhandledError) return reportUnhandledError;
	hasRequiredReportUnhandledError = 1;
	Object.defineProperty(reportUnhandledError, "__esModule", { value: true });
	reportUnhandledError.reportUnhandledError = void 0;
	var config_1 = /*@__PURE__*/ requireConfig();
	var timeoutProvider_1 = /*@__PURE__*/ requireTimeoutProvider();
	function reportUnhandledError$1(err) {
	    timeoutProvider_1.timeoutProvider.setTimeout(function () {
	        var onUnhandledError = config_1.config.onUnhandledError;
	        if (onUnhandledError) {
	            onUnhandledError(err);
	        }
	        else {
	            throw err;
	        }
	    });
	}
	reportUnhandledError.reportUnhandledError = reportUnhandledError$1;
	
	return reportUnhandledError;
}

var noop = {};

var hasRequiredNoop;

function requireNoop () {
	if (hasRequiredNoop) return noop;
	hasRequiredNoop = 1;
	Object.defineProperty(noop, "__esModule", { value: true });
	noop.noop = void 0;
	function noop$1() { }
	noop.noop = noop$1;
	
	return noop;
}

var NotificationFactories = {};

var hasRequiredNotificationFactories;

function requireNotificationFactories () {
	if (hasRequiredNotificationFactories) return NotificationFactories;
	hasRequiredNotificationFactories = 1;
	Object.defineProperty(NotificationFactories, "__esModule", { value: true });
	NotificationFactories.createNotification = NotificationFactories.nextNotification = NotificationFactories.errorNotification = NotificationFactories.COMPLETE_NOTIFICATION = void 0;
	NotificationFactories.COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
	function errorNotification(error) {
	    return createNotification('E', undefined, error);
	}
	NotificationFactories.errorNotification = errorNotification;
	function nextNotification(value) {
	    return createNotification('N', value, undefined);
	}
	NotificationFactories.nextNotification = nextNotification;
	function createNotification(kind, value, error) {
	    return {
	        kind: kind,
	        value: value,
	        error: error,
	    };
	}
	NotificationFactories.createNotification = createNotification;
	
	return NotificationFactories;
}

var errorContext = {};

var hasRequiredErrorContext;

function requireErrorContext () {
	if (hasRequiredErrorContext) return errorContext;
	hasRequiredErrorContext = 1;
	Object.defineProperty(errorContext, "__esModule", { value: true });
	errorContext.captureError = errorContext.errorContext = void 0;
	var config_1 = /*@__PURE__*/ requireConfig();
	var context = null;
	function errorContext$1(cb) {
	    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
	        var isRoot = !context;
	        if (isRoot) {
	            context = { errorThrown: false, error: null };
	        }
	        cb();
	        if (isRoot) {
	            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
	            context = null;
	            if (errorThrown) {
	                throw error;
	            }
	        }
	    }
	    else {
	        cb();
	    }
	}
	errorContext.errorContext = errorContext$1;
	function captureError(err) {
	    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
	        context.errorThrown = true;
	        context.error = err;
	    }
	}
	errorContext.captureError = captureError;
	
	return errorContext;
}

var hasRequiredSubscriber;

function requireSubscriber () {
	if (hasRequiredSubscriber) return Subscriber;
	hasRequiredSubscriber = 1;
	(function (exports) {
		var __extends = (Subscriber && Subscriber.__extends) || (function () {
		    var extendStatics = function (d, b) {
		        extendStatics = Object.setPrototypeOf ||
		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
		        return extendStatics(d, b);
		    };
		    return function (d, b) {
		        if (typeof b !== "function" && b !== null)
		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
		        extendStatics(d, b);
		        function __() { this.constructor = d; }
		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
		    };
		})();
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
		var isFunction_1 = /*@__PURE__*/ requireIsFunction();
		var Subscription_1 = /*@__PURE__*/ requireSubscription();
		var config_1 = /*@__PURE__*/ requireConfig();
		var reportUnhandledError_1 = /*@__PURE__*/ requireReportUnhandledError();
		var noop_1 = /*@__PURE__*/ requireNoop();
		var NotificationFactories_1 = /*@__PURE__*/ requireNotificationFactories();
		var timeoutProvider_1 = /*@__PURE__*/ requireTimeoutProvider();
		var errorContext_1 = /*@__PURE__*/ requireErrorContext();
		var Subscriber$1 = (function (_super) {
		    __extends(Subscriber, _super);
		    function Subscriber(destination) {
		        var _this = _super.call(this) || this;
		        _this.isStopped = false;
		        if (destination) {
		            _this.destination = destination;
		            if (Subscription_1.isSubscription(destination)) {
		                destination.add(_this);
		            }
		        }
		        else {
		            _this.destination = exports.EMPTY_OBSERVER;
		        }
		        return _this;
		    }
		    Subscriber.create = function (next, error, complete) {
		        return new SafeSubscriber(next, error, complete);
		    };
		    Subscriber.prototype.next = function (value) {
		        if (this.isStopped) {
		            handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
		        }
		        else {
		            this._next(value);
		        }
		    };
		    Subscriber.prototype.error = function (err) {
		        if (this.isStopped) {
		            handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
		        }
		        else {
		            this.isStopped = true;
		            this._error(err);
		        }
		    };
		    Subscriber.prototype.complete = function () {
		        if (this.isStopped) {
		            handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
		        }
		        else {
		            this.isStopped = true;
		            this._complete();
		        }
		    };
		    Subscriber.prototype.unsubscribe = function () {
		        if (!this.closed) {
		            this.isStopped = true;
		            _super.prototype.unsubscribe.call(this);
		            this.destination = null;
		        }
		    };
		    Subscriber.prototype._next = function (value) {
		        this.destination.next(value);
		    };
		    Subscriber.prototype._error = function (err) {
		        try {
		            this.destination.error(err);
		        }
		        finally {
		            this.unsubscribe();
		        }
		    };
		    Subscriber.prototype._complete = function () {
		        try {
		            this.destination.complete();
		        }
		        finally {
		            this.unsubscribe();
		        }
		    };
		    return Subscriber;
		}(Subscription_1.Subscription));
		exports.Subscriber = Subscriber$1;
		var _bind = Function.prototype.bind;
		function bind(fn, thisArg) {
		    return _bind.call(fn, thisArg);
		}
		var ConsumerObserver = (function () {
		    function ConsumerObserver(partialObserver) {
		        this.partialObserver = partialObserver;
		    }
		    ConsumerObserver.prototype.next = function (value) {
		        var partialObserver = this.partialObserver;
		        if (partialObserver.next) {
		            try {
		                partialObserver.next(value);
		            }
		            catch (error) {
		                handleUnhandledError(error);
		            }
		        }
		    };
		    ConsumerObserver.prototype.error = function (err) {
		        var partialObserver = this.partialObserver;
		        if (partialObserver.error) {
		            try {
		                partialObserver.error(err);
		            }
		            catch (error) {
		                handleUnhandledError(error);
		            }
		        }
		        else {
		            handleUnhandledError(err);
		        }
		    };
		    ConsumerObserver.prototype.complete = function () {
		        var partialObserver = this.partialObserver;
		        if (partialObserver.complete) {
		            try {
		                partialObserver.complete();
		            }
		            catch (error) {
		                handleUnhandledError(error);
		            }
		        }
		    };
		    return ConsumerObserver;
		}());
		var SafeSubscriber = (function (_super) {
		    __extends(SafeSubscriber, _super);
		    function SafeSubscriber(observerOrNext, error, complete) {
		        var _this = _super.call(this) || this;
		        var partialObserver;
		        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
		            partialObserver = {
		                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),
		                error: error !== null && error !== void 0 ? error : undefined,
		                complete: complete !== null && complete !== void 0 ? complete : undefined,
		            };
		        }
		        else {
		            var context_1;
		            if (_this && config_1.config.useDeprecatedNextContext) {
		                context_1 = Object.create(observerOrNext);
		                context_1.unsubscribe = function () { return _this.unsubscribe(); };
		                partialObserver = {
		                    next: observerOrNext.next && bind(observerOrNext.next, context_1),
		                    error: observerOrNext.error && bind(observerOrNext.error, context_1),
		                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),
		                };
		            }
		            else {
		                partialObserver = observerOrNext;
		            }
		        }
		        _this.destination = new ConsumerObserver(partialObserver);
		        return _this;
		    }
		    return SafeSubscriber;
		}(Subscriber$1));
		exports.SafeSubscriber = SafeSubscriber;
		function handleUnhandledError(error) {
		    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
		        errorContext_1.captureError(error);
		    }
		    else {
		        reportUnhandledError_1.reportUnhandledError(error);
		    }
		}
		function defaultErrorHandler(err) {
		    throw err;
		}
		function handleStoppedNotification(notification, subscriber) {
		    var onStoppedNotification = config_1.config.onStoppedNotification;
		    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
		}
		exports.EMPTY_OBSERVER = {
		    closed: true,
		    next: noop_1.noop,
		    error: defaultErrorHandler,
		    complete: noop_1.noop,
		};
		
	} (Subscriber));
	return Subscriber;
}

var observable = {};

var hasRequiredObservable$1;

function requireObservable$1 () {
	if (hasRequiredObservable$1) return observable;
	hasRequiredObservable$1 = 1;
	Object.defineProperty(observable, "__esModule", { value: true });
	observable.observable = void 0;
	observable.observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();
	
	return observable;
}

var pipe$1 = {};

var identity = {};

var hasRequiredIdentity$1;

function requireIdentity$1 () {
	if (hasRequiredIdentity$1) return identity;
	hasRequiredIdentity$1 = 1;
	Object.defineProperty(identity, "__esModule", { value: true });
	identity.identity = void 0;
	function identity$1(x) {
	    return x;
	}
	identity.identity = identity$1;
	
	return identity;
}

var hasRequiredPipe;

function requirePipe () {
	if (hasRequiredPipe) return pipe$1;
	hasRequiredPipe = 1;
	Object.defineProperty(pipe$1, "__esModule", { value: true });
	pipe$1.pipeFromArray = pipe$1.pipe = void 0;
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	function pipe() {
	    var fns = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        fns[_i] = arguments[_i];
	    }
	    return pipeFromArray(fns);
	}
	pipe$1.pipe = pipe;
	function pipeFromArray(fns) {
	    if (fns.length === 0) {
	        return identity_1.identity;
	    }
	    if (fns.length === 1) {
	        return fns[0];
	    }
	    return function piped(input) {
	        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
	    };
	}
	pipe$1.pipeFromArray = pipeFromArray;
	
	return pipe$1;
}

var hasRequiredObservable;

function requireObservable () {
	if (hasRequiredObservable) return Observable;
	hasRequiredObservable = 1;
	Object.defineProperty(Observable, "__esModule", { value: true });
	Observable.Observable = void 0;
	var Subscriber_1 = /*@__PURE__*/ requireSubscriber();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var observable_1 = /*@__PURE__*/ requireObservable$1();
	var pipe_1 = /*@__PURE__*/ requirePipe();
	var config_1 = /*@__PURE__*/ requireConfig();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var errorContext_1 = /*@__PURE__*/ requireErrorContext();
	var Observable$1 = (function () {
	    function Observable(subscribe) {
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var _this = this;
	        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
	        errorContext_1.errorContext(function () {
	            var _a = _this, operator = _a.operator, source = _a.source;
	            subscriber.add(operator
	                ?
	                    operator.call(subscriber, source)
	                : source
	                    ?
	                        _this._subscribe(subscriber)
	                    :
	                        _this._trySubscribe(subscriber));
	        });
	        return subscriber;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.error(err);
	        }
	    };
	    Observable.prototype.forEach = function (next, promiseCtor) {
	        var _this = this;
	        promiseCtor = getPromiseCtor(promiseCtor);
	        return new promiseCtor(function (resolve, reject) {
	            var subscriber = new Subscriber_1.SafeSubscriber({
	                next: function (value) {
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscriber.unsubscribe();
	                    }
	                },
	                error: reject,
	                complete: resolve,
	            });
	            _this.subscribe(subscriber);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        var _a;
	        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
	    };
	    Observable.prototype[observable_1.observable] = function () {
	        return this;
	    };
	    Observable.prototype.pipe = function () {
	        var operations = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            operations[_i] = arguments[_i];
	        }
	        return pipe_1.pipeFromArray(operations)(this);
	    };
	    Observable.prototype.toPromise = function (promiseCtor) {
	        var _this = this;
	        promiseCtor = getPromiseCtor(promiseCtor);
	        return new promiseCtor(function (resolve, reject) {
	            var value;
	            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
	        });
	    };
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	Observable.Observable = Observable$1;
	function getPromiseCtor(promiseCtor) {
	    var _a;
	    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
	}
	function isObserver(value) {
	    return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
	}
	function isSubscriber(value) {
	    return (value && value instanceof Subscriber_1.Subscriber) || (isObserver(value) && Subscription_1.isSubscription(value));
	}
	
	return Observable;
}

var ConnectableObservable = {};

var refCount = {};

var lift = {};

var hasRequiredLift;

function requireLift () {
	if (hasRequiredLift) return lift;
	hasRequiredLift = 1;
	Object.defineProperty(lift, "__esModule", { value: true });
	lift.operate = lift.hasLift = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function hasLift(source) {
	    return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
	}
	lift.hasLift = hasLift;
	function operate(init) {
	    return function (source) {
	        if (hasLift(source)) {
	            return source.lift(function (liftedSource) {
	                try {
	                    return init(liftedSource, this);
	                }
	                catch (err) {
	                    this.error(err);
	                }
	            });
	        }
	        throw new TypeError('Unable to lift unknown Observable type');
	    };
	}
	lift.operate = operate;
	
	return lift;
}

var OperatorSubscriber = {};

var hasRequiredOperatorSubscriber;

function requireOperatorSubscriber () {
	if (hasRequiredOperatorSubscriber) return OperatorSubscriber;
	hasRequiredOperatorSubscriber = 1;
	var __extends = (OperatorSubscriber && OperatorSubscriber.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(OperatorSubscriber, "__esModule", { value: true });
	OperatorSubscriber.OperatorSubscriber = OperatorSubscriber.createOperatorSubscriber = void 0;
	var Subscriber_1 = /*@__PURE__*/ requireSubscriber();
	function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
	    return new OperatorSubscriber$1(destination, onNext, onComplete, onError, onFinalize);
	}
	OperatorSubscriber.createOperatorSubscriber = createOperatorSubscriber;
	var OperatorSubscriber$1 = (function (_super) {
	    __extends(OperatorSubscriber, _super);
	    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
	        var _this = _super.call(this, destination) || this;
	        _this.onFinalize = onFinalize;
	        _this.shouldUnsubscribe = shouldUnsubscribe;
	        _this._next = onNext
	            ? function (value) {
	                try {
	                    onNext(value);
	                }
	                catch (err) {
	                    destination.error(err);
	                }
	            }
	            : _super.prototype._next;
	        _this._error = onError
	            ? function (err) {
	                try {
	                    onError(err);
	                }
	                catch (err) {
	                    destination.error(err);
	                }
	                finally {
	                    this.unsubscribe();
	                }
	            }
	            : _super.prototype._error;
	        _this._complete = onComplete
	            ? function () {
	                try {
	                    onComplete();
	                }
	                catch (err) {
	                    destination.error(err);
	                }
	                finally {
	                    this.unsubscribe();
	                }
	            }
	            : _super.prototype._complete;
	        return _this;
	    }
	    OperatorSubscriber.prototype.unsubscribe = function () {
	        var _a;
	        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
	            var closed_1 = this.closed;
	            _super.prototype.unsubscribe.call(this);
	            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
	        }
	    };
	    return OperatorSubscriber;
	}(Subscriber_1.Subscriber));
	OperatorSubscriber.OperatorSubscriber = OperatorSubscriber$1;
	
	return OperatorSubscriber;
}

var hasRequiredRefCount;

function requireRefCount () {
	if (hasRequiredRefCount) return refCount;
	hasRequiredRefCount = 1;
	Object.defineProperty(refCount, "__esModule", { value: true });
	refCount.refCount = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function refCount$1() {
	    return lift_1.operate(function (source, subscriber) {
	        var connection = null;
	        source._refCount++;
	        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, undefined, function () {
	            if (!source || source._refCount <= 0 || 0 < --source._refCount) {
	                connection = null;
	                return;
	            }
	            var sharedConnection = source._connection;
	            var conn = connection;
	            connection = null;
	            if (sharedConnection && (!conn || sharedConnection === conn)) {
	                sharedConnection.unsubscribe();
	            }
	            subscriber.unsubscribe();
	        });
	        source.subscribe(refCounter);
	        if (!refCounter.closed) {
	            connection = source.connect();
	        }
	    });
	}
	refCount.refCount = refCount$1;
	
	return refCount;
}

var hasRequiredConnectableObservable;

function requireConnectableObservable () {
	if (hasRequiredConnectableObservable) return ConnectableObservable;
	hasRequiredConnectableObservable = 1;
	var __extends = (ConnectableObservable && ConnectableObservable.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(ConnectableObservable, "__esModule", { value: true });
	ConnectableObservable.ConnectableObservable = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var refCount_1 = /*@__PURE__*/ requireRefCount();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var lift_1 = /*@__PURE__*/ requireLift();
	var ConnectableObservable$1 = (function (_super) {
	    __extends(ConnectableObservable, _super);
	    function ConnectableObservable(source, subjectFactory) {
	        var _this = _super.call(this) || this;
	        _this.source = source;
	        _this.subjectFactory = subjectFactory;
	        _this._subject = null;
	        _this._refCount = 0;
	        _this._connection = null;
	        if (lift_1.hasLift(source)) {
	            _this.lift = source.lift;
	        }
	        return _this;
	    }
	    ConnectableObservable.prototype._subscribe = function (subscriber) {
	        return this.getSubject().subscribe(subscriber);
	    };
	    ConnectableObservable.prototype.getSubject = function () {
	        var subject = this._subject;
	        if (!subject || subject.isStopped) {
	            this._subject = this.subjectFactory();
	        }
	        return this._subject;
	    };
	    ConnectableObservable.prototype._teardown = function () {
	        this._refCount = 0;
	        var _connection = this._connection;
	        this._subject = this._connection = null;
	        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
	    };
	    ConnectableObservable.prototype.connect = function () {
	        var _this = this;
	        var connection = this._connection;
	        if (!connection) {
	            connection = this._connection = new Subscription_1.Subscription();
	            var subject_1 = this.getSubject();
	            connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, undefined, function () {
	                _this._teardown();
	                subject_1.complete();
	            }, function (err) {
	                _this._teardown();
	                subject_1.error(err);
	            }, function () { return _this._teardown(); })));
	            if (connection.closed) {
	                this._connection = null;
	                connection = Subscription_1.Subscription.EMPTY;
	            }
	        }
	        return connection;
	    };
	    ConnectableObservable.prototype.refCount = function () {
	        return refCount_1.refCount()(this);
	    };
	    return ConnectableObservable;
	}(Observable_1.Observable));
	ConnectableObservable.ConnectableObservable = ConnectableObservable$1;
	
	return ConnectableObservable;
}

var animationFrames = {};

var performanceTimestampProvider = {};

var hasRequiredPerformanceTimestampProvider;

function requirePerformanceTimestampProvider () {
	if (hasRequiredPerformanceTimestampProvider) return performanceTimestampProvider;
	hasRequiredPerformanceTimestampProvider = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.performanceTimestampProvider = void 0;
		exports.performanceTimestampProvider = {
		    now: function () {
		        return (exports.performanceTimestampProvider.delegate || performance).now();
		    },
		    delegate: undefined,
		};
		
	} (performanceTimestampProvider));
	return performanceTimestampProvider;
}

var animationFrameProvider = {};

var hasRequiredAnimationFrameProvider;

function requireAnimationFrameProvider () {
	if (hasRequiredAnimationFrameProvider) return animationFrameProvider;
	hasRequiredAnimationFrameProvider = 1;
	(function (exports) {
		var __read = (animationFrameProvider && animationFrameProvider.__read) || function (o, n) {
		    var m = typeof Symbol === "function" && o[Symbol.iterator];
		    if (!m) return o;
		    var i = m.call(o), r, ar = [], e;
		    try {
		        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		    }
		    catch (error) { e = { error: error }; }
		    finally {
		        try {
		            if (r && !r.done && (m = i["return"])) m.call(i);
		        }
		        finally { if (e) throw e.error; }
		    }
		    return ar;
		};
		var __spreadArray = (animationFrameProvider && animationFrameProvider.__spreadArray) || function (to, from) {
		    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
		        to[j] = from[i];
		    return to;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.animationFrameProvider = void 0;
		var Subscription_1 = /*@__PURE__*/ requireSubscription();
		exports.animationFrameProvider = {
		    schedule: function (callback) {
		        var request = requestAnimationFrame;
		        var cancel = cancelAnimationFrame;
		        var delegate = exports.animationFrameProvider.delegate;
		        if (delegate) {
		            request = delegate.requestAnimationFrame;
		            cancel = delegate.cancelAnimationFrame;
		        }
		        var handle = request(function (timestamp) {
		            cancel = undefined;
		            callback(timestamp);
		        });
		        return new Subscription_1.Subscription(function () { return cancel === null || cancel === void 0 ? void 0 : cancel(handle); });
		    },
		    requestAnimationFrame: function () {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var delegate = exports.animationFrameProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
		    },
		    cancelAnimationFrame: function () {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var delegate = exports.animationFrameProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
		    },
		    delegate: undefined,
		};
		
	} (animationFrameProvider));
	return animationFrameProvider;
}

var hasRequiredAnimationFrames;

function requireAnimationFrames () {
	if (hasRequiredAnimationFrames) return animationFrames;
	hasRequiredAnimationFrames = 1;
	Object.defineProperty(animationFrames, "__esModule", { value: true });
	animationFrames.animationFrames = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var performanceTimestampProvider_1 = /*@__PURE__*/ requirePerformanceTimestampProvider();
	var animationFrameProvider_1 = /*@__PURE__*/ requireAnimationFrameProvider();
	function animationFrames$1(timestampProvider) {
	    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
	}
	animationFrames.animationFrames = animationFrames$1;
	function animationFramesFactory(timestampProvider) {
	    return new Observable_1.Observable(function (subscriber) {
	        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
	        var start = provider.now();
	        var id = 0;
	        var run = function () {
	            if (!subscriber.closed) {
	                id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function (timestamp) {
	                    id = 0;
	                    var now = provider.now();
	                    subscriber.next({
	                        timestamp: timestampProvider ? now : timestamp,
	                        elapsed: now - start,
	                    });
	                    run();
	                });
	            }
	        };
	        run();
	        return function () {
	            if (id) {
	                animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
	            }
	        };
	    });
	}
	var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
	
	return animationFrames;
}

var Subject = {};

var ObjectUnsubscribedError = {};

var hasRequiredObjectUnsubscribedError;

function requireObjectUnsubscribedError () {
	if (hasRequiredObjectUnsubscribedError) return ObjectUnsubscribedError;
	hasRequiredObjectUnsubscribedError = 1;
	Object.defineProperty(ObjectUnsubscribedError, "__esModule", { value: true });
	ObjectUnsubscribedError.ObjectUnsubscribedError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	ObjectUnsubscribedError.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function (_super) {
	    return function ObjectUnsubscribedErrorImpl() {
	        _super(this);
	        this.name = 'ObjectUnsubscribedError';
	        this.message = 'object unsubscribed';
	    };
	});
	
	return ObjectUnsubscribedError;
}

var hasRequiredSubject;

function requireSubject () {
	if (hasRequiredSubject) return Subject;
	hasRequiredSubject = 1;
	var __extends = (Subject && Subject.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values = (Subject && Subject.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(Subject, "__esModule", { value: true });
	Subject.AnonymousSubject = Subject.Subject = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var ObjectUnsubscribedError_1 = /*@__PURE__*/ requireObjectUnsubscribedError();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	var errorContext_1 = /*@__PURE__*/ requireErrorContext();
	var Subject$1 = (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        var _this = _super.call(this) || this;
	        _this.closed = false;
	        _this.currentObservers = null;
	        _this.observers = [];
	        _this.isStopped = false;
	        _this.hasError = false;
	        _this.thrownError = null;
	        return _this;
	    }
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype._throwIfClosed = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	    };
	    Subject.prototype.next = function (value) {
	        var _this = this;
	        errorContext_1.errorContext(function () {
	            var e_1, _a;
	            _this._throwIfClosed();
	            if (!_this.isStopped) {
	                if (!_this.currentObservers) {
	                    _this.currentObservers = Array.from(_this.observers);
	                }
	                try {
	                    for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
	                        var observer = _c.value;
	                        observer.next(value);
	                    }
	                }
	                catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                finally {
	                    try {
	                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                    }
	                    finally { if (e_1) throw e_1.error; }
	                }
	            }
	        });
	    };
	    Subject.prototype.error = function (err) {
	        var _this = this;
	        errorContext_1.errorContext(function () {
	            _this._throwIfClosed();
	            if (!_this.isStopped) {
	                _this.hasError = _this.isStopped = true;
	                _this.thrownError = err;
	                var observers = _this.observers;
	                while (observers.length) {
	                    observers.shift().error(err);
	                }
	            }
	        });
	    };
	    Subject.prototype.complete = function () {
	        var _this = this;
	        errorContext_1.errorContext(function () {
	            _this._throwIfClosed();
	            if (!_this.isStopped) {
	                _this.isStopped = true;
	                var observers = _this.observers;
	                while (observers.length) {
	                    observers.shift().complete();
	                }
	            }
	        });
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = this.closed = true;
	        this.observers = this.currentObservers = null;
	    };
	    Object.defineProperty(Subject.prototype, "observed", {
	        get: function () {
	            var _a;
	            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Subject.prototype._trySubscribe = function (subscriber) {
	        this._throwIfClosed();
	        return _super.prototype._trySubscribe.call(this, subscriber);
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        this._throwIfClosed();
	        this._checkFinalizedStatuses(subscriber);
	        return this._innerSubscribe(subscriber);
	    };
	    Subject.prototype._innerSubscribe = function (subscriber) {
	        var _this = this;
	        var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
	        if (hasError || isStopped) {
	            return Subscription_1.EMPTY_SUBSCRIPTION;
	        }
	        this.currentObservers = null;
	        observers.push(subscriber);
	        return new Subscription_1.Subscription(function () {
	            _this.currentObservers = null;
	            arrRemove_1.arrRemove(observers, subscriber);
	        });
	    };
	    Subject.prototype._checkFinalizedStatuses = function (subscriber) {
	        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
	        if (hasError) {
	            subscriber.error(thrownError);
	        }
	        else if (isStopped) {
	            subscriber.complete();
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	Subject.Subject = Subject$1;
	var AnonymousSubject = (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        var _this = _super.call(this) || this;
	        _this.destination = destination;
	        _this.source = source;
	        return _this;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var _a, _b;
	        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var _a, _b;
	        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var _a, _b;
	        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var _a, _b;
	        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
	    };
	    return AnonymousSubject;
	}(Subject$1));
	Subject.AnonymousSubject = AnonymousSubject;
	
	return Subject;
}

var BehaviorSubject = {};

var hasRequiredBehaviorSubject;

function requireBehaviorSubject () {
	if (hasRequiredBehaviorSubject) return BehaviorSubject;
	hasRequiredBehaviorSubject = 1;
	var __extends = (BehaviorSubject && BehaviorSubject.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(BehaviorSubject, "__esModule", { value: true });
	BehaviorSubject.BehaviorSubject = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var BehaviorSubject$1 = (function (_super) {
	    __extends(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        var _this = _super.call(this) || this;
	        _this._value = _value;
	        return _this;
	    }
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: false,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        !subscription.closed && subscriber.next(this._value);
	        return subscription;
	    };
	    BehaviorSubject.prototype.getValue = function () {
	        var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
	        if (hasError) {
	            throw thrownError;
	        }
	        this._throwIfClosed();
	        return _value;
	    };
	    BehaviorSubject.prototype.next = function (value) {
	        _super.prototype.next.call(this, (this._value = value));
	    };
	    return BehaviorSubject;
	}(Subject_1.Subject));
	BehaviorSubject.BehaviorSubject = BehaviorSubject$1;
	
	return BehaviorSubject;
}

var ReplaySubject = {};

var dateTimestampProvider = {};

var hasRequiredDateTimestampProvider;

function requireDateTimestampProvider () {
	if (hasRequiredDateTimestampProvider) return dateTimestampProvider;
	hasRequiredDateTimestampProvider = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.dateTimestampProvider = void 0;
		exports.dateTimestampProvider = {
		    now: function () {
		        return (exports.dateTimestampProvider.delegate || Date).now();
		    },
		    delegate: undefined,
		};
		
	} (dateTimestampProvider));
	return dateTimestampProvider;
}

var hasRequiredReplaySubject;

function requireReplaySubject () {
	if (hasRequiredReplaySubject) return ReplaySubject;
	hasRequiredReplaySubject = 1;
	var __extends = (ReplaySubject && ReplaySubject.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(ReplaySubject, "__esModule", { value: true });
	ReplaySubject.ReplaySubject = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var dateTimestampProvider_1 = /*@__PURE__*/ requireDateTimestampProvider();
	var ReplaySubject$1 = (function (_super) {
	    __extends(ReplaySubject, _super);
	    function ReplaySubject(_bufferSize, _windowTime, _timestampProvider) {
	        if (_bufferSize === void 0) { _bufferSize = Infinity; }
	        if (_windowTime === void 0) { _windowTime = Infinity; }
	        if (_timestampProvider === void 0) { _timestampProvider = dateTimestampProvider_1.dateTimestampProvider; }
	        var _this = _super.call(this) || this;
	        _this._bufferSize = _bufferSize;
	        _this._windowTime = _windowTime;
	        _this._timestampProvider = _timestampProvider;
	        _this._buffer = [];
	        _this._infiniteTimeWindow = true;
	        _this._infiniteTimeWindow = _windowTime === Infinity;
	        _this._bufferSize = Math.max(1, _bufferSize);
	        _this._windowTime = Math.max(1, _windowTime);
	        return _this;
	    }
	    ReplaySubject.prototype.next = function (value) {
	        var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
	        if (!isStopped) {
	            _buffer.push(value);
	            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
	        }
	        this._trimBuffer();
	        _super.prototype.next.call(this, value);
	    };
	    ReplaySubject.prototype._subscribe = function (subscriber) {
	        this._throwIfClosed();
	        this._trimBuffer();
	        var subscription = this._innerSubscribe(subscriber);
	        var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
	        var copy = _buffer.slice();
	        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
	            subscriber.next(copy[i]);
	        }
	        this._checkFinalizedStatuses(subscriber);
	        return subscription;
	    };
	    ReplaySubject.prototype._trimBuffer = function () {
	        var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
	        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
	        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
	        if (!_infiniteTimeWindow) {
	            var now = _timestampProvider.now();
	            var last = 0;
	            for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
	                last = i;
	            }
	            last && _buffer.splice(0, last + 1);
	        }
	    };
	    return ReplaySubject;
	}(Subject_1.Subject));
	ReplaySubject.ReplaySubject = ReplaySubject$1;
	
	return ReplaySubject;
}

var AsyncSubject = {};

var hasRequiredAsyncSubject;

function requireAsyncSubject () {
	if (hasRequiredAsyncSubject) return AsyncSubject;
	hasRequiredAsyncSubject = 1;
	var __extends = (AsyncSubject && AsyncSubject.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AsyncSubject, "__esModule", { value: true });
	AsyncSubject.AsyncSubject = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var AsyncSubject$1 = (function (_super) {
	    __extends(AsyncSubject, _super);
	    function AsyncSubject() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this._value = null;
	        _this._hasValue = false;
	        _this._isComplete = false;
	        return _this;
	    }
	    AsyncSubject.prototype._checkFinalizedStatuses = function (subscriber) {
	        var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
	        if (hasError) {
	            subscriber.error(thrownError);
	        }
	        else if (isStopped || _isComplete) {
	            _hasValue && subscriber.next(_value);
	            subscriber.complete();
	        }
	    };
	    AsyncSubject.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._value = value;
	            this._hasValue = true;
	        }
	    };
	    AsyncSubject.prototype.complete = function () {
	        var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
	        if (!_isComplete) {
	            this._isComplete = true;
	            _hasValue && _super.prototype.next.call(this, _value);
	            _super.prototype.complete.call(this);
	        }
	    };
	    return AsyncSubject;
	}(Subject_1.Subject));
	AsyncSubject.AsyncSubject = AsyncSubject$1;
	
	return AsyncSubject;
}

var asap = {};

var AsapAction = {};

var AsyncAction = {};

var Action = {};

var hasRequiredAction;

function requireAction () {
	if (hasRequiredAction) return Action;
	hasRequiredAction = 1;
	var __extends = (Action && Action.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(Action, "__esModule", { value: true });
	Action.Action = void 0;
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var Action$1 = (function (_super) {
	    __extends(Action, _super);
	    function Action(scheduler, work) {
	        return _super.call(this) || this;
	    }
	    Action.prototype.schedule = function (state, delay) {
	        return this;
	    };
	    return Action;
	}(Subscription_1.Subscription));
	Action.Action = Action$1;
	
	return Action;
}

var intervalProvider = {};

var hasRequiredIntervalProvider;

function requireIntervalProvider () {
	if (hasRequiredIntervalProvider) return intervalProvider;
	hasRequiredIntervalProvider = 1;
	(function (exports) {
		var __read = (intervalProvider && intervalProvider.__read) || function (o, n) {
		    var m = typeof Symbol === "function" && o[Symbol.iterator];
		    if (!m) return o;
		    var i = m.call(o), r, ar = [], e;
		    try {
		        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		    }
		    catch (error) { e = { error: error }; }
		    finally {
		        try {
		            if (r && !r.done && (m = i["return"])) m.call(i);
		        }
		        finally { if (e) throw e.error; }
		    }
		    return ar;
		};
		var __spreadArray = (intervalProvider && intervalProvider.__spreadArray) || function (to, from) {
		    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
		        to[j] = from[i];
		    return to;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.intervalProvider = void 0;
		exports.intervalProvider = {
		    setInterval: function (handler, timeout) {
		        var args = [];
		        for (var _i = 2; _i < arguments.length; _i++) {
		            args[_i - 2] = arguments[_i];
		        }
		        var delegate = exports.intervalProvider.delegate;
		        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
		            return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
		        }
		        return setInterval.apply(void 0, __spreadArray([handler, timeout], __read(args)));
		    },
		    clearInterval: function (handle) {
		        var delegate = exports.intervalProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
		    },
		    delegate: undefined,
		};
		
	} (intervalProvider));
	return intervalProvider;
}

var hasRequiredAsyncAction;

function requireAsyncAction () {
	if (hasRequiredAsyncAction) return AsyncAction;
	hasRequiredAsyncAction = 1;
	var __extends = (AsyncAction && AsyncAction.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AsyncAction, "__esModule", { value: true });
	AsyncAction.AsyncAction = void 0;
	var Action_1 = /*@__PURE__*/ requireAction();
	var intervalProvider_1 = /*@__PURE__*/ requireIntervalProvider();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	var AsyncAction$1 = (function (_super) {
	    __extends(AsyncAction, _super);
	    function AsyncAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        _this.pending = false;
	        return _this;
	    }
	    AsyncAction.prototype.schedule = function (state, delay) {
	        var _a;
	        if (delay === void 0) { delay = 0; }
	        if (this.closed) {
	            return this;
	        }
	        this.state = state;
	        var id = this.id;
	        var scheduler = this.scheduler;
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, delay);
	        }
	        this.pending = true;
	        this.delay = delay;
	        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
	        return this;
	    };
	    AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
	        if (delay === void 0) { delay = 0; }
	        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
	    };
	    AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay != null && this.delay === delay && this.pending === false) {
	            return id;
	        }
	        if (id != null) {
	            intervalProvider_1.intervalProvider.clearInterval(id);
	        }
	        return undefined;
	    };
	    AsyncAction.prototype.execute = function (state, delay) {
	        if (this.closed) {
	            return new Error('executing a cancelled action');
	        }
	        this.pending = false;
	        var error = this._execute(state, delay);
	        if (error) {
	            return error;
	        }
	        else if (this.pending === false && this.id != null) {
	            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
	        }
	    };
	    AsyncAction.prototype._execute = function (state, _delay) {
	        var errored = false;
	        var errorValue;
	        try {
	            this.work(state);
	        }
	        catch (e) {
	            errored = true;
	            errorValue = e ? e : new Error('Scheduled action threw falsy error');
	        }
	        if (errored) {
	            this.unsubscribe();
	            return errorValue;
	        }
	    };
	    AsyncAction.prototype.unsubscribe = function () {
	        if (!this.closed) {
	            var _a = this, id = _a.id, scheduler = _a.scheduler;
	            var actions = scheduler.actions;
	            this.work = this.state = this.scheduler = null;
	            this.pending = false;
	            arrRemove_1.arrRemove(actions, this);
	            if (id != null) {
	                this.id = this.recycleAsyncId(scheduler, id, null);
	            }
	            this.delay = null;
	            _super.prototype.unsubscribe.call(this);
	        }
	    };
	    return AsyncAction;
	}(Action_1.Action));
	AsyncAction.AsyncAction = AsyncAction$1;
	
	return AsyncAction;
}

var immediateProvider = {};

var Immediate = {};

var hasRequiredImmediate;

function requireImmediate () {
	if (hasRequiredImmediate) return Immediate;
	hasRequiredImmediate = 1;
	Object.defineProperty(Immediate, "__esModule", { value: true });
	Immediate.TestTools = Immediate.Immediate = void 0;
	var nextHandle = 1;
	var resolved;
	var activeHandles = {};
	function findAndClearHandle(handle) {
	    if (handle in activeHandles) {
	        delete activeHandles[handle];
	        return true;
	    }
	    return false;
	}
	Immediate.Immediate = {
	    setImmediate: function (cb) {
	        var handle = nextHandle++;
	        activeHandles[handle] = true;
	        if (!resolved) {
	            resolved = Promise.resolve();
	        }
	        resolved.then(function () { return findAndClearHandle(handle) && cb(); });
	        return handle;
	    },
	    clearImmediate: function (handle) {
	        findAndClearHandle(handle);
	    },
	};
	Immediate.TestTools = {
	    pending: function () {
	        return Object.keys(activeHandles).length;
	    }
	};
	
	return Immediate;
}

var hasRequiredImmediateProvider;

function requireImmediateProvider () {
	if (hasRequiredImmediateProvider) return immediateProvider;
	hasRequiredImmediateProvider = 1;
	(function (exports) {
		var __read = (immediateProvider && immediateProvider.__read) || function (o, n) {
		    var m = typeof Symbol === "function" && o[Symbol.iterator];
		    if (!m) return o;
		    var i = m.call(o), r, ar = [], e;
		    try {
		        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
		    }
		    catch (error) { e = { error: error }; }
		    finally {
		        try {
		            if (r && !r.done && (m = i["return"])) m.call(i);
		        }
		        finally { if (e) throw e.error; }
		    }
		    return ar;
		};
		var __spreadArray = (immediateProvider && immediateProvider.__spreadArray) || function (to, from) {
		    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
		        to[j] = from[i];
		    return to;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.immediateProvider = void 0;
		var Immediate_1 = /*@__PURE__*/ requireImmediate();
		var setImmediate = Immediate_1.Immediate.setImmediate, clearImmediate = Immediate_1.Immediate.clearImmediate;
		exports.immediateProvider = {
		    setImmediate: function () {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        var delegate = exports.immediateProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
		    },
		    clearImmediate: function (handle) {
		        var delegate = exports.immediateProvider.delegate;
		        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
		    },
		    delegate: undefined,
		};
		
	} (immediateProvider));
	return immediateProvider;
}

var hasRequiredAsapAction;

function requireAsapAction () {
	if (hasRequiredAsapAction) return AsapAction;
	hasRequiredAsapAction = 1;
	var __extends = (AsapAction && AsapAction.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AsapAction, "__esModule", { value: true });
	AsapAction.AsapAction = void 0;
	var AsyncAction_1 = /*@__PURE__*/ requireAsyncAction();
	var immediateProvider_1 = /*@__PURE__*/ requireImmediateProvider();
	var AsapAction$1 = (function (_super) {
	    __extends(AsapAction, _super);
	    function AsapAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        scheduler.actions.push(this);
	        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
	    };
	    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        var _a;
	        if (delay === void 0) { delay = 0; }
	        if (delay != null ? delay > 0 : this.delay > 0) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        var actions = scheduler.actions;
	        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
	            immediateProvider_1.immediateProvider.clearImmediate(id);
	            if (scheduler._scheduled === id) {
	                scheduler._scheduled = undefined;
	            }
	        }
	        return undefined;
	    };
	    return AsapAction;
	}(AsyncAction_1.AsyncAction));
	AsapAction.AsapAction = AsapAction$1;
	
	return AsapAction;
}

var AsapScheduler = {};

var AsyncScheduler = {};

var Scheduler = {};

var hasRequiredScheduler;

function requireScheduler () {
	if (hasRequiredScheduler) return Scheduler;
	hasRequiredScheduler = 1;
	Object.defineProperty(Scheduler, "__esModule", { value: true });
	Scheduler.Scheduler = void 0;
	var dateTimestampProvider_1 = /*@__PURE__*/ requireDateTimestampProvider();
	var Scheduler$1 = (function () {
	    function Scheduler(schedulerActionCtor, now) {
	        if (now === void 0) { now = Scheduler.now; }
	        this.schedulerActionCtor = schedulerActionCtor;
	        this.now = now;
	    }
	    Scheduler.prototype.schedule = function (work, delay, state) {
	        if (delay === void 0) { delay = 0; }
	        return new this.schedulerActionCtor(this, work).schedule(state, delay);
	    };
	    Scheduler.now = dateTimestampProvider_1.dateTimestampProvider.now;
	    return Scheduler;
	}());
	Scheduler.Scheduler = Scheduler$1;
	
	return Scheduler;
}

var hasRequiredAsyncScheduler;

function requireAsyncScheduler () {
	if (hasRequiredAsyncScheduler) return AsyncScheduler;
	hasRequiredAsyncScheduler = 1;
	var __extends = (AsyncScheduler && AsyncScheduler.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AsyncScheduler, "__esModule", { value: true });
	AsyncScheduler.AsyncScheduler = void 0;
	var Scheduler_1 = /*@__PURE__*/ requireScheduler();
	var AsyncScheduler$1 = (function (_super) {
	    __extends(AsyncScheduler, _super);
	    function AsyncScheduler(SchedulerAction, now) {
	        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
	        var _this = _super.call(this, SchedulerAction, now) || this;
	        _this.actions = [];
	        _this._active = false;
	        return _this;
	    }
	    AsyncScheduler.prototype.flush = function (action) {
	        var actions = this.actions;
	        if (this._active) {
	            actions.push(action);
	            return;
	        }
	        var error;
	        this._active = true;
	        do {
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        } while ((action = actions.shift()));
	        this._active = false;
	        if (error) {
	            while ((action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsyncScheduler;
	}(Scheduler_1.Scheduler));
	AsyncScheduler.AsyncScheduler = AsyncScheduler$1;
	
	return AsyncScheduler;
}

var hasRequiredAsapScheduler;

function requireAsapScheduler () {
	if (hasRequiredAsapScheduler) return AsapScheduler;
	hasRequiredAsapScheduler = 1;
	var __extends = (AsapScheduler && AsapScheduler.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AsapScheduler, "__esModule", { value: true });
	AsapScheduler.AsapScheduler = void 0;
	var AsyncScheduler_1 = /*@__PURE__*/ requireAsyncScheduler();
	var AsapScheduler$1 = (function (_super) {
	    __extends(AsapScheduler, _super);
	    function AsapScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    AsapScheduler.prototype.flush = function (action) {
	        this._active = true;
	        var flushId = this._scheduled;
	        this._scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        action = action || actions.shift();
	        do {
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        } while ((action = actions[0]) && action.id === flushId && actions.shift());
	        this._active = false;
	        if (error) {
	            while ((action = actions[0]) && action.id === flushId && actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsapScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	AsapScheduler.AsapScheduler = AsapScheduler$1;
	
	return AsapScheduler;
}

var hasRequiredAsap;

function requireAsap () {
	if (hasRequiredAsap) return asap;
	hasRequiredAsap = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.asap = exports.asapScheduler = void 0;
		var AsapAction_1 = /*@__PURE__*/ requireAsapAction();
		var AsapScheduler_1 = /*@__PURE__*/ requireAsapScheduler();
		exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
		exports.asap = exports.asapScheduler;
		
	} (asap));
	return asap;
}

var async = {};

var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async;
	hasRequiredAsync = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.async = exports.asyncScheduler = void 0;
		var AsyncAction_1 = /*@__PURE__*/ requireAsyncAction();
		var AsyncScheduler_1 = /*@__PURE__*/ requireAsyncScheduler();
		exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
		exports.async = exports.asyncScheduler;
		
	} (async));
	return async;
}

var queue = {};

var QueueAction = {};

var hasRequiredQueueAction;

function requireQueueAction () {
	if (hasRequiredQueueAction) return QueueAction;
	hasRequiredQueueAction = 1;
	var __extends = (QueueAction && QueueAction.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(QueueAction, "__esModule", { value: true });
	QueueAction.QueueAction = void 0;
	var AsyncAction_1 = /*@__PURE__*/ requireAsyncAction();
	var QueueAction$1 = (function (_super) {
	    __extends(QueueAction, _super);
	    function QueueAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    QueueAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay > 0) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        this.delay = delay;
	        this.state = state;
	        this.scheduler.flush(this);
	        return this;
	    };
	    QueueAction.prototype.execute = function (state, delay) {
	        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
	    };
	    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        scheduler.flush(this);
	        return 0;
	    };
	    return QueueAction;
	}(AsyncAction_1.AsyncAction));
	QueueAction.QueueAction = QueueAction$1;
	
	return QueueAction;
}

var QueueScheduler = {};

var hasRequiredQueueScheduler;

function requireQueueScheduler () {
	if (hasRequiredQueueScheduler) return QueueScheduler;
	hasRequiredQueueScheduler = 1;
	var __extends = (QueueScheduler && QueueScheduler.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(QueueScheduler, "__esModule", { value: true });
	QueueScheduler.QueueScheduler = void 0;
	var AsyncScheduler_1 = /*@__PURE__*/ requireAsyncScheduler();
	var QueueScheduler$1 = (function (_super) {
	    __extends(QueueScheduler, _super);
	    function QueueScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return QueueScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	QueueScheduler.QueueScheduler = QueueScheduler$1;
	
	return QueueScheduler;
}

var hasRequiredQueue;

function requireQueue () {
	if (hasRequiredQueue) return queue;
	hasRequiredQueue = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.queue = exports.queueScheduler = void 0;
		var QueueAction_1 = /*@__PURE__*/ requireQueueAction();
		var QueueScheduler_1 = /*@__PURE__*/ requireQueueScheduler();
		exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
		exports.queue = exports.queueScheduler;
		
	} (queue));
	return queue;
}

var animationFrame = {};

var AnimationFrameAction = {};

var hasRequiredAnimationFrameAction;

function requireAnimationFrameAction () {
	if (hasRequiredAnimationFrameAction) return AnimationFrameAction;
	hasRequiredAnimationFrameAction = 1;
	var __extends = (AnimationFrameAction && AnimationFrameAction.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AnimationFrameAction, "__esModule", { value: true });
	AnimationFrameAction.AnimationFrameAction = void 0;
	var AsyncAction_1 = /*@__PURE__*/ requireAsyncAction();
	var animationFrameProvider_1 = /*@__PURE__*/ requireAnimationFrameProvider();
	var AnimationFrameAction$1 = (function (_super) {
	    __extends(AnimationFrameAction, _super);
	    function AnimationFrameAction(scheduler, work) {
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        return _this;
	    }
	    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        scheduler.actions.push(this);
	        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function () { return scheduler.flush(undefined); }));
	    };
	    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        var _a;
	        if (delay === void 0) { delay = 0; }
	        if (delay != null ? delay > 0 : this.delay > 0) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        var actions = scheduler.actions;
	        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
	            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
	            scheduler._scheduled = undefined;
	        }
	        return undefined;
	    };
	    return AnimationFrameAction;
	}(AsyncAction_1.AsyncAction));
	AnimationFrameAction.AnimationFrameAction = AnimationFrameAction$1;
	
	return AnimationFrameAction;
}

var AnimationFrameScheduler = {};

var hasRequiredAnimationFrameScheduler;

function requireAnimationFrameScheduler () {
	if (hasRequiredAnimationFrameScheduler) return AnimationFrameScheduler;
	hasRequiredAnimationFrameScheduler = 1;
	var __extends = (AnimationFrameScheduler && AnimationFrameScheduler.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(AnimationFrameScheduler, "__esModule", { value: true });
	AnimationFrameScheduler.AnimationFrameScheduler = void 0;
	var AsyncScheduler_1 = /*@__PURE__*/ requireAsyncScheduler();
	var AnimationFrameScheduler$1 = (function (_super) {
	    __extends(AnimationFrameScheduler, _super);
	    function AnimationFrameScheduler() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    AnimationFrameScheduler.prototype.flush = function (action) {
	        this._active = true;
	        var flushId = this._scheduled;
	        this._scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        action = action || actions.shift();
	        do {
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        } while ((action = actions[0]) && action.id === flushId && actions.shift());
	        this._active = false;
	        if (error) {
	            while ((action = actions[0]) && action.id === flushId && actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AnimationFrameScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	AnimationFrameScheduler.AnimationFrameScheduler = AnimationFrameScheduler$1;
	
	return AnimationFrameScheduler;
}

var hasRequiredAnimationFrame;

function requireAnimationFrame () {
	if (hasRequiredAnimationFrame) return animationFrame;
	hasRequiredAnimationFrame = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.animationFrame = exports.animationFrameScheduler = void 0;
		var AnimationFrameAction_1 = /*@__PURE__*/ requireAnimationFrameAction();
		var AnimationFrameScheduler_1 = /*@__PURE__*/ requireAnimationFrameScheduler();
		exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
		exports.animationFrame = exports.animationFrameScheduler;
		
	} (animationFrame));
	return animationFrame;
}

var VirtualTimeScheduler = {};

var hasRequiredVirtualTimeScheduler;

function requireVirtualTimeScheduler () {
	if (hasRequiredVirtualTimeScheduler) return VirtualTimeScheduler;
	hasRequiredVirtualTimeScheduler = 1;
	var __extends = (VirtualTimeScheduler && VirtualTimeScheduler.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(VirtualTimeScheduler, "__esModule", { value: true });
	VirtualTimeScheduler.VirtualAction = VirtualTimeScheduler.VirtualTimeScheduler = void 0;
	var AsyncAction_1 = /*@__PURE__*/ requireAsyncAction();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var AsyncScheduler_1 = /*@__PURE__*/ requireAsyncScheduler();
	var VirtualTimeScheduler$1 = (function (_super) {
	    __extends(VirtualTimeScheduler, _super);
	    function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {
	        if (schedulerActionCtor === void 0) { schedulerActionCtor = VirtualAction; }
	        if (maxFrames === void 0) { maxFrames = Infinity; }
	        var _this = _super.call(this, schedulerActionCtor, function () { return _this.frame; }) || this;
	        _this.maxFrames = maxFrames;
	        _this.frame = 0;
	        _this.index = -1;
	        return _this;
	    }
	    VirtualTimeScheduler.prototype.flush = function () {
	        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
	        var error;
	        var action;
	        while ((action = actions[0]) && action.delay <= maxFrames) {
	            actions.shift();
	            this.frame = action.delay;
	            if ((error = action.execute(action.state, action.delay))) {
	                break;
	            }
	        }
	        if (error) {
	            while ((action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    VirtualTimeScheduler.frameTimeFactor = 10;
	    return VirtualTimeScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	VirtualTimeScheduler.VirtualTimeScheduler = VirtualTimeScheduler$1;
	var VirtualAction = (function (_super) {
	    __extends(VirtualAction, _super);
	    function VirtualAction(scheduler, work, index) {
	        if (index === void 0) { index = (scheduler.index += 1); }
	        var _this = _super.call(this, scheduler, work) || this;
	        _this.scheduler = scheduler;
	        _this.work = work;
	        _this.index = index;
	        _this.active = true;
	        _this.index = scheduler.index = index;
	        return _this;
	    }
	    VirtualAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (Number.isFinite(delay)) {
	            if (!this.id) {
	                return _super.prototype.schedule.call(this, state, delay);
	            }
	            this.active = false;
	            var action = new VirtualAction(this.scheduler, this.work);
	            this.add(action);
	            return action.schedule(state, delay);
	        }
	        else {
	            return Subscription_1.Subscription.EMPTY;
	        }
	    };
	    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.delay = scheduler.frame + delay;
	        var actions = scheduler.actions;
	        actions.push(this);
	        actions.sort(VirtualAction.sortActions);
	        return 1;
	    };
	    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        return undefined;
	    };
	    VirtualAction.prototype._execute = function (state, delay) {
	        if (this.active === true) {
	            return _super.prototype._execute.call(this, state, delay);
	        }
	    };
	    VirtualAction.sortActions = function (a, b) {
	        if (a.delay === b.delay) {
	            if (a.index === b.index) {
	                return 0;
	            }
	            else if (a.index > b.index) {
	                return 1;
	            }
	            else {
	                return -1;
	            }
	        }
	        else if (a.delay > b.delay) {
	            return 1;
	        }
	        else {
	            return -1;
	        }
	    };
	    return VirtualAction;
	}(AsyncAction_1.AsyncAction));
	VirtualTimeScheduler.VirtualAction = VirtualAction;
	
	return VirtualTimeScheduler;
}

var Notification = {};

var empty = {};

var hasRequiredEmpty;

function requireEmpty () {
	if (hasRequiredEmpty) return empty;
	hasRequiredEmpty = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.empty = exports.EMPTY = void 0;
		var Observable_1 = /*@__PURE__*/ requireObservable();
		exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
		function empty(scheduler) {
		    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
		}
		exports.empty = empty;
		function emptyScheduled(scheduler) {
		    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
		}
		
	} (empty));
	return empty;
}

var of = {};

var args = {};

var isScheduler = {};

var hasRequiredIsScheduler;

function requireIsScheduler () {
	if (hasRequiredIsScheduler) return isScheduler;
	hasRequiredIsScheduler = 1;
	Object.defineProperty(isScheduler, "__esModule", { value: true });
	isScheduler.isScheduler = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isScheduler$1(value) {
	    return value && isFunction_1.isFunction(value.schedule);
	}
	isScheduler.isScheduler = isScheduler$1;
	
	return isScheduler;
}

var hasRequiredArgs;

function requireArgs () {
	if (hasRequiredArgs) return args;
	hasRequiredArgs = 1;
	Object.defineProperty(args, "__esModule", { value: true });
	args.popNumber = args.popScheduler = args.popResultSelector = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var isScheduler_1 = /*@__PURE__*/ requireIsScheduler();
	function last(arr) {
	    return arr[arr.length - 1];
	}
	function popResultSelector(args) {
	    return isFunction_1.isFunction(last(args)) ? args.pop() : undefined;
	}
	args.popResultSelector = popResultSelector;
	function popScheduler(args) {
	    return isScheduler_1.isScheduler(last(args)) ? args.pop() : undefined;
	}
	args.popScheduler = popScheduler;
	function popNumber(args, defaultValue) {
	    return typeof last(args) === 'number' ? args.pop() : defaultValue;
	}
	args.popNumber = popNumber;
	
	return args;
}

var from = {};

var scheduled = {};

var scheduleObservable = {};

var innerFrom = {};

var isArrayLike = {};

var hasRequiredIsArrayLike$1;

function requireIsArrayLike$1 () {
	if (hasRequiredIsArrayLike$1) return isArrayLike;
	hasRequiredIsArrayLike$1 = 1;
	Object.defineProperty(isArrayLike, "__esModule", { value: true });
	isArrayLike.isArrayLike = void 0;
	isArrayLike.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });
	
	return isArrayLike;
}

var isPromise = {};

var hasRequiredIsPromise;

function requireIsPromise () {
	if (hasRequiredIsPromise) return isPromise;
	hasRequiredIsPromise = 1;
	Object.defineProperty(isPromise, "__esModule", { value: true });
	isPromise.isPromise = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isPromise$1(value) {
	    return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
	}
	isPromise.isPromise = isPromise$1;
	
	return isPromise;
}

var isInteropObservable = {};

var hasRequiredIsInteropObservable;

function requireIsInteropObservable () {
	if (hasRequiredIsInteropObservable) return isInteropObservable;
	hasRequiredIsInteropObservable = 1;
	Object.defineProperty(isInteropObservable, "__esModule", { value: true });
	isInteropObservable.isInteropObservable = void 0;
	var observable_1 = /*@__PURE__*/ requireObservable$1();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isInteropObservable$1(input) {
	    return isFunction_1.isFunction(input[observable_1.observable]);
	}
	isInteropObservable.isInteropObservable = isInteropObservable$1;
	
	return isInteropObservable;
}

var isAsyncIterable = {};

var hasRequiredIsAsyncIterable;

function requireIsAsyncIterable () {
	if (hasRequiredIsAsyncIterable) return isAsyncIterable;
	hasRequiredIsAsyncIterable = 1;
	Object.defineProperty(isAsyncIterable, "__esModule", { value: true });
	isAsyncIterable.isAsyncIterable = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isAsyncIterable$1(obj) {
	    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
	}
	isAsyncIterable.isAsyncIterable = isAsyncIterable$1;
	
	return isAsyncIterable;
}

var throwUnobservableError = {};

var hasRequiredThrowUnobservableError;

function requireThrowUnobservableError () {
	if (hasRequiredThrowUnobservableError) return throwUnobservableError;
	hasRequiredThrowUnobservableError = 1;
	Object.defineProperty(throwUnobservableError, "__esModule", { value: true });
	throwUnobservableError.createInvalidObservableTypeError = void 0;
	function createInvalidObservableTypeError(input) {
	    return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
	}
	throwUnobservableError.createInvalidObservableTypeError = createInvalidObservableTypeError;
	
	return throwUnobservableError;
}

var isIterable = {};

var iterator = {};

var hasRequiredIterator;

function requireIterator () {
	if (hasRequiredIterator) return iterator;
	hasRequiredIterator = 1;
	Object.defineProperty(iterator, "__esModule", { value: true });
	iterator.iterator = iterator.getSymbolIterator = void 0;
	function getSymbolIterator() {
	    if (typeof Symbol !== 'function' || !Symbol.iterator) {
	        return '@@iterator';
	    }
	    return Symbol.iterator;
	}
	iterator.getSymbolIterator = getSymbolIterator;
	iterator.iterator = getSymbolIterator();
	
	return iterator;
}

var hasRequiredIsIterable;

function requireIsIterable () {
	if (hasRequiredIsIterable) return isIterable;
	hasRequiredIsIterable = 1;
	Object.defineProperty(isIterable, "__esModule", { value: true });
	isIterable.isIterable = void 0;
	var iterator_1 = /*@__PURE__*/ requireIterator();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isIterable$1(input) {
	    return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
	}
	isIterable.isIterable = isIterable$1;
	
	return isIterable;
}

var isReadableStreamLike = {};

var hasRequiredIsReadableStreamLike;

function requireIsReadableStreamLike () {
	if (hasRequiredIsReadableStreamLike) return isReadableStreamLike;
	hasRequiredIsReadableStreamLike = 1;
	var __generator = (isReadableStreamLike && isReadableStreamLike.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __await = (isReadableStreamLike && isReadableStreamLike.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); };
	var __asyncGenerator = (isReadableStreamLike && isReadableStreamLike.__asyncGenerator) || function (thisArg, _arguments, generator) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var g = generator.apply(thisArg, _arguments || []), i, q = [];
	    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
	    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
	    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
	    function fulfill(value) { resume("next", value); }
	    function reject(value) { resume("throw", value); }
	    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	};
	Object.defineProperty(isReadableStreamLike, "__esModule", { value: true });
	isReadableStreamLike.isReadableStreamLike = isReadableStreamLike.readableStreamLikeToAsyncGenerator = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function readableStreamLikeToAsyncGenerator(readableStream) {
	    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
	        var reader, _a, value, done;
	        return __generator(this, function (_b) {
	            switch (_b.label) {
	                case 0:
	                    reader = readableStream.getReader();
	                    _b.label = 1;
	                case 1:
	                    _b.trys.push([1, , 9, 10]);
	                    _b.label = 2;
	                case 2:
	                    return [4, __await(reader.read())];
	                case 3:
	                    _a = _b.sent(), value = _a.value, done = _a.done;
	                    if (!done) return [3, 5];
	                    return [4, __await(void 0)];
	                case 4: return [2, _b.sent()];
	                case 5: return [4, __await(value)];
	                case 6: return [4, _b.sent()];
	                case 7:
	                    _b.sent();
	                    return [3, 2];
	                case 8: return [3, 10];
	                case 9:
	                    reader.releaseLock();
	                    return [7];
	                case 10: return [2];
	            }
	        });
	    });
	}
	isReadableStreamLike.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
	function isReadableStreamLike$1(obj) {
	    return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
	}
	isReadableStreamLike.isReadableStreamLike = isReadableStreamLike$1;
	
	return isReadableStreamLike;
}

var hasRequiredInnerFrom;

function requireInnerFrom () {
	if (hasRequiredInnerFrom) return innerFrom;
	hasRequiredInnerFrom = 1;
	var __awaiter = (innerFrom && innerFrom.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (innerFrom && innerFrom.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __asyncValues = (innerFrom && innerFrom.__asyncValues) || function (o) {
	    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	    var m = o[Symbol.asyncIterator], i;
	    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	};
	var __values = (innerFrom && innerFrom.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(innerFrom, "__esModule", { value: true });
	innerFrom.fromReadableStreamLike = innerFrom.fromAsyncIterable = innerFrom.fromIterable = innerFrom.fromPromise = innerFrom.fromArrayLike = innerFrom.fromInteropObservable = innerFrom.innerFrom = void 0;
	var isArrayLike_1 = /*@__PURE__*/ requireIsArrayLike$1();
	var isPromise_1 = /*@__PURE__*/ requireIsPromise();
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var isInteropObservable_1 = /*@__PURE__*/ requireIsInteropObservable();
	var isAsyncIterable_1 = /*@__PURE__*/ requireIsAsyncIterable();
	var throwUnobservableError_1 = /*@__PURE__*/ requireThrowUnobservableError();
	var isIterable_1 = /*@__PURE__*/ requireIsIterable();
	var isReadableStreamLike_1 = /*@__PURE__*/ requireIsReadableStreamLike();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var reportUnhandledError_1 = /*@__PURE__*/ requireReportUnhandledError();
	var observable_1 = /*@__PURE__*/ requireObservable$1();
	function innerFrom$1(input) {
	    if (input instanceof Observable_1.Observable) {
	        return input;
	    }
	    if (input != null) {
	        if (isInteropObservable_1.isInteropObservable(input)) {
	            return fromInteropObservable(input);
	        }
	        if (isArrayLike_1.isArrayLike(input)) {
	            return fromArrayLike(input);
	        }
	        if (isPromise_1.isPromise(input)) {
	            return fromPromise(input);
	        }
	        if (isAsyncIterable_1.isAsyncIterable(input)) {
	            return fromAsyncIterable(input);
	        }
	        if (isIterable_1.isIterable(input)) {
	            return fromIterable(input);
	        }
	        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
	            return fromReadableStreamLike(input);
	        }
	    }
	    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
	}
	innerFrom.innerFrom = innerFrom$1;
	function fromInteropObservable(obj) {
	    return new Observable_1.Observable(function (subscriber) {
	        var obs = obj[observable_1.observable]();
	        if (isFunction_1.isFunction(obs.subscribe)) {
	            return obs.subscribe(subscriber);
	        }
	        throw new TypeError('Provided object does not correctly implement Symbol.observable');
	    });
	}
	innerFrom.fromInteropObservable = fromInteropObservable;
	function fromArrayLike(array) {
	    return new Observable_1.Observable(function (subscriber) {
	        for (var i = 0; i < array.length && !subscriber.closed; i++) {
	            subscriber.next(array[i]);
	        }
	        subscriber.complete();
	    });
	}
	innerFrom.fromArrayLike = fromArrayLike;
	function fromPromise(promise) {
	    return new Observable_1.Observable(function (subscriber) {
	        promise
	            .then(function (value) {
	            if (!subscriber.closed) {
	                subscriber.next(value);
	                subscriber.complete();
	            }
	        }, function (err) { return subscriber.error(err); })
	            .then(null, reportUnhandledError_1.reportUnhandledError);
	    });
	}
	innerFrom.fromPromise = fromPromise;
	function fromIterable(iterable) {
	    return new Observable_1.Observable(function (subscriber) {
	        var e_1, _a;
	        try {
	            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
	                var value = iterable_1_1.value;
	                subscriber.next(value);
	                if (subscriber.closed) {
	                    return;
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        subscriber.complete();
	    });
	}
	innerFrom.fromIterable = fromIterable;
	function fromAsyncIterable(asyncIterable) {
	    return new Observable_1.Observable(function (subscriber) {
	        process(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
	    });
	}
	innerFrom.fromAsyncIterable = fromAsyncIterable;
	function fromReadableStreamLike(readableStream) {
	    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
	}
	innerFrom.fromReadableStreamLike = fromReadableStreamLike;
	function process(asyncIterable, subscriber) {
	    var asyncIterable_1, asyncIterable_1_1;
	    var e_2, _a;
	    return __awaiter(this, void 0, void 0, function () {
	        var value, e_2_1;
	        return __generator(this, function (_b) {
	            switch (_b.label) {
	                case 0:
	                    _b.trys.push([0, 5, 6, 11]);
	                    asyncIterable_1 = __asyncValues(asyncIterable);
	                    _b.label = 1;
	                case 1: return [4, asyncIterable_1.next()];
	                case 2:
	                    if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
	                    value = asyncIterable_1_1.value;
	                    subscriber.next(value);
	                    if (subscriber.closed) {
	                        return [2];
	                    }
	                    _b.label = 3;
	                case 3: return [3, 1];
	                case 4: return [3, 11];
	                case 5:
	                    e_2_1 = _b.sent();
	                    e_2 = { error: e_2_1 };
	                    return [3, 11];
	                case 6:
	                    _b.trys.push([6, , 9, 10]);
	                    if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
	                    return [4, _a.call(asyncIterable_1)];
	                case 7:
	                    _b.sent();
	                    _b.label = 8;
	                case 8: return [3, 10];
	                case 9:
	                    if (e_2) throw e_2.error;
	                    return [7];
	                case 10: return [7];
	                case 11:
	                    subscriber.complete();
	                    return [2];
	            }
	        });
	    });
	}
	
	return innerFrom;
}

var observeOn = {};

var executeSchedule = {};

var hasRequiredExecuteSchedule;

function requireExecuteSchedule () {
	if (hasRequiredExecuteSchedule) return executeSchedule;
	hasRequiredExecuteSchedule = 1;
	Object.defineProperty(executeSchedule, "__esModule", { value: true });
	executeSchedule.executeSchedule = void 0;
	function executeSchedule$1(parentSubscription, scheduler, work, delay, repeat) {
	    if (delay === void 0) { delay = 0; }
	    if (repeat === void 0) { repeat = false; }
	    var scheduleSubscription = scheduler.schedule(function () {
	        work();
	        if (repeat) {
	            parentSubscription.add(this.schedule(null, delay));
	        }
	        else {
	            this.unsubscribe();
	        }
	    }, delay);
	    parentSubscription.add(scheduleSubscription);
	    if (!repeat) {
	        return scheduleSubscription;
	    }
	}
	executeSchedule.executeSchedule = executeSchedule$1;
	
	return executeSchedule;
}

var hasRequiredObserveOn;

function requireObserveOn () {
	if (hasRequiredObserveOn) return observeOn;
	hasRequiredObserveOn = 1;
	Object.defineProperty(observeOn, "__esModule", { value: true });
	observeOn.observeOn = void 0;
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function observeOn$1(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return lift_1.operate(function (source, subscriber) {
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return executeSchedule_1.executeSchedule(subscriber, scheduler, function () { return subscriber.next(value); }, delay); }, function () { return executeSchedule_1.executeSchedule(subscriber, scheduler, function () { return subscriber.complete(); }, delay); }, function (err) { return executeSchedule_1.executeSchedule(subscriber, scheduler, function () { return subscriber.error(err); }, delay); }));
	    });
	}
	observeOn.observeOn = observeOn$1;
	
	return observeOn;
}

var subscribeOn = {};

var hasRequiredSubscribeOn;

function requireSubscribeOn () {
	if (hasRequiredSubscribeOn) return subscribeOn;
	hasRequiredSubscribeOn = 1;
	Object.defineProperty(subscribeOn, "__esModule", { value: true });
	subscribeOn.subscribeOn = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	function subscribeOn$1(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return lift_1.operate(function (source, subscriber) {
	        subscriber.add(scheduler.schedule(function () { return source.subscribe(subscriber); }, delay));
	    });
	}
	subscribeOn.subscribeOn = subscribeOn$1;
	
	return subscribeOn;
}

var hasRequiredScheduleObservable;

function requireScheduleObservable () {
	if (hasRequiredScheduleObservable) return scheduleObservable;
	hasRequiredScheduleObservable = 1;
	Object.defineProperty(scheduleObservable, "__esModule", { value: true });
	scheduleObservable.scheduleObservable = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var observeOn_1 = /*@__PURE__*/ requireObserveOn();
	var subscribeOn_1 = /*@__PURE__*/ requireSubscribeOn();
	function scheduleObservable$1(input, scheduler) {
	    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
	}
	scheduleObservable.scheduleObservable = scheduleObservable$1;
	
	return scheduleObservable;
}

var schedulePromise = {};

var hasRequiredSchedulePromise;

function requireSchedulePromise () {
	if (hasRequiredSchedulePromise) return schedulePromise;
	hasRequiredSchedulePromise = 1;
	Object.defineProperty(schedulePromise, "__esModule", { value: true });
	schedulePromise.schedulePromise = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var observeOn_1 = /*@__PURE__*/ requireObserveOn();
	var subscribeOn_1 = /*@__PURE__*/ requireSubscribeOn();
	function schedulePromise$1(input, scheduler) {
	    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
	}
	schedulePromise.schedulePromise = schedulePromise$1;
	
	return schedulePromise;
}

var scheduleArray = {};

var hasRequiredScheduleArray;

function requireScheduleArray () {
	if (hasRequiredScheduleArray) return scheduleArray;
	hasRequiredScheduleArray = 1;
	Object.defineProperty(scheduleArray, "__esModule", { value: true });
	scheduleArray.scheduleArray = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	function scheduleArray$1(input, scheduler) {
	    return new Observable_1.Observable(function (subscriber) {
	        var i = 0;
	        return scheduler.schedule(function () {
	            if (i === input.length) {
	                subscriber.complete();
	            }
	            else {
	                subscriber.next(input[i++]);
	                if (!subscriber.closed) {
	                    this.schedule();
	                }
	            }
	        });
	    });
	}
	scheduleArray.scheduleArray = scheduleArray$1;
	
	return scheduleArray;
}

var scheduleIterable = {};

var hasRequiredScheduleIterable;

function requireScheduleIterable () {
	if (hasRequiredScheduleIterable) return scheduleIterable;
	hasRequiredScheduleIterable = 1;
	Object.defineProperty(scheduleIterable, "__esModule", { value: true });
	scheduleIterable.scheduleIterable = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var iterator_1 = /*@__PURE__*/ requireIterator();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	function scheduleIterable$1(input, scheduler) {
	    return new Observable_1.Observable(function (subscriber) {
	        var iterator;
	        executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
	            iterator = input[iterator_1.iterator]();
	            executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
	                var _a;
	                var value;
	                var done;
	                try {
	                    (_a = iterator.next(), value = _a.value, done = _a.done);
	                }
	                catch (err) {
	                    subscriber.error(err);
	                    return;
	                }
	                if (done) {
	                    subscriber.complete();
	                }
	                else {
	                    subscriber.next(value);
	                }
	            }, 0, true);
	        });
	        return function () { return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return(); };
	    });
	}
	scheduleIterable.scheduleIterable = scheduleIterable$1;
	
	return scheduleIterable;
}

var scheduleAsyncIterable = {};

var hasRequiredScheduleAsyncIterable;

function requireScheduleAsyncIterable () {
	if (hasRequiredScheduleAsyncIterable) return scheduleAsyncIterable;
	hasRequiredScheduleAsyncIterable = 1;
	Object.defineProperty(scheduleAsyncIterable, "__esModule", { value: true });
	scheduleAsyncIterable.scheduleAsyncIterable = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	function scheduleAsyncIterable$1(input, scheduler) {
	    if (!input) {
	        throw new Error('Iterable cannot be null');
	    }
	    return new Observable_1.Observable(function (subscriber) {
	        executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
	            var iterator = input[Symbol.asyncIterator]();
	            executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
	                iterator.next().then(function (result) {
	                    if (result.done) {
	                        subscriber.complete();
	                    }
	                    else {
	                        subscriber.next(result.value);
	                    }
	                });
	            }, 0, true);
	        });
	    });
	}
	scheduleAsyncIterable.scheduleAsyncIterable = scheduleAsyncIterable$1;
	
	return scheduleAsyncIterable;
}

var scheduleReadableStreamLike = {};

var hasRequiredScheduleReadableStreamLike;

function requireScheduleReadableStreamLike () {
	if (hasRequiredScheduleReadableStreamLike) return scheduleReadableStreamLike;
	hasRequiredScheduleReadableStreamLike = 1;
	Object.defineProperty(scheduleReadableStreamLike, "__esModule", { value: true });
	scheduleReadableStreamLike.scheduleReadableStreamLike = void 0;
	var scheduleAsyncIterable_1 = /*@__PURE__*/ requireScheduleAsyncIterable();
	var isReadableStreamLike_1 = /*@__PURE__*/ requireIsReadableStreamLike();
	function scheduleReadableStreamLike$1(input, scheduler) {
	    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
	}
	scheduleReadableStreamLike.scheduleReadableStreamLike = scheduleReadableStreamLike$1;
	
	return scheduleReadableStreamLike;
}

var hasRequiredScheduled;

function requireScheduled () {
	if (hasRequiredScheduled) return scheduled;
	hasRequiredScheduled = 1;
	Object.defineProperty(scheduled, "__esModule", { value: true });
	scheduled.scheduled = void 0;
	var scheduleObservable_1 = /*@__PURE__*/ requireScheduleObservable();
	var schedulePromise_1 = /*@__PURE__*/ requireSchedulePromise();
	var scheduleArray_1 = /*@__PURE__*/ requireScheduleArray();
	var scheduleIterable_1 = /*@__PURE__*/ requireScheduleIterable();
	var scheduleAsyncIterable_1 = /*@__PURE__*/ requireScheduleAsyncIterable();
	var isInteropObservable_1 = /*@__PURE__*/ requireIsInteropObservable();
	var isPromise_1 = /*@__PURE__*/ requireIsPromise();
	var isArrayLike_1 = /*@__PURE__*/ requireIsArrayLike$1();
	var isIterable_1 = /*@__PURE__*/ requireIsIterable();
	var isAsyncIterable_1 = /*@__PURE__*/ requireIsAsyncIterable();
	var throwUnobservableError_1 = /*@__PURE__*/ requireThrowUnobservableError();
	var isReadableStreamLike_1 = /*@__PURE__*/ requireIsReadableStreamLike();
	var scheduleReadableStreamLike_1 = /*@__PURE__*/ requireScheduleReadableStreamLike();
	function scheduled$1(input, scheduler) {
	    if (input != null) {
	        if (isInteropObservable_1.isInteropObservable(input)) {
	            return scheduleObservable_1.scheduleObservable(input, scheduler);
	        }
	        if (isArrayLike_1.isArrayLike(input)) {
	            return scheduleArray_1.scheduleArray(input, scheduler);
	        }
	        if (isPromise_1.isPromise(input)) {
	            return schedulePromise_1.schedulePromise(input, scheduler);
	        }
	        if (isAsyncIterable_1.isAsyncIterable(input)) {
	            return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
	        }
	        if (isIterable_1.isIterable(input)) {
	            return scheduleIterable_1.scheduleIterable(input, scheduler);
	        }
	        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
	            return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
	        }
	    }
	    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
	}
	scheduled.scheduled = scheduled$1;
	
	return scheduled;
}

var hasRequiredFrom$1;

function requireFrom$1 () {
	if (hasRequiredFrom$1) return from;
	hasRequiredFrom$1 = 1;
	Object.defineProperty(from, "__esModule", { value: true });
	from.from = void 0;
	var scheduled_1 = /*@__PURE__*/ requireScheduled();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function from$1(input, scheduler) {
	    return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
	}
	from.from = from$1;
	
	return from;
}

var hasRequiredOf;

function requireOf () {
	if (hasRequiredOf) return of;
	hasRequiredOf = 1;
	Object.defineProperty(of, "__esModule", { value: true });
	of.of = void 0;
	var args_1 = /*@__PURE__*/ requireArgs();
	var from_1 = /*@__PURE__*/ requireFrom$1();
	function of$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(args);
	    return from_1.from(args, scheduler);
	}
	of.of = of$1;
	
	return of;
}

var throwError = {};

var hasRequiredThrowError;

function requireThrowError () {
	if (hasRequiredThrowError) return throwError;
	hasRequiredThrowError = 1;
	Object.defineProperty(throwError, "__esModule", { value: true });
	throwError.throwError = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function throwError$1(errorOrErrorFactory, scheduler) {
	    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function () { return errorOrErrorFactory; };
	    var init = function (subscriber) { return subscriber.error(errorFactory()); };
	    return new Observable_1.Observable(scheduler ? function (subscriber) { return scheduler.schedule(init, 0, subscriber); } : init);
	}
	throwError.throwError = throwError$1;
	
	return throwError;
}

var hasRequiredNotification;

function requireNotification () {
	if (hasRequiredNotification) return Notification;
	hasRequiredNotification = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
		var empty_1 = /*@__PURE__*/ requireEmpty();
		var of_1 = /*@__PURE__*/ requireOf();
		var throwError_1 = /*@__PURE__*/ requireThrowError();
		var isFunction_1 = /*@__PURE__*/ requireIsFunction();
		(function (NotificationKind) {
		    NotificationKind["NEXT"] = "N";
		    NotificationKind["ERROR"] = "E";
		    NotificationKind["COMPLETE"] = "C";
		})(exports.NotificationKind || (exports.NotificationKind = {}));
		var Notification = (function () {
		    function Notification(kind, value, error) {
		        this.kind = kind;
		        this.value = value;
		        this.error = error;
		        this.hasValue = kind === 'N';
		    }
		    Notification.prototype.observe = function (observer) {
		        return observeNotification(this, observer);
		    };
		    Notification.prototype.do = function (nextHandler, errorHandler, completeHandler) {
		        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
		        return kind === 'N' ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === 'E' ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
		    };
		    Notification.prototype.accept = function (nextOrObserver, error, complete) {
		        var _a;
		        return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next)
		            ? this.observe(nextOrObserver)
		            : this.do(nextOrObserver, error, complete);
		    };
		    Notification.prototype.toObservable = function () {
		        var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
		        var result = kind === 'N'
		            ?
		                of_1.of(value)
		            :
		                kind === 'E'
		                    ?
		                        throwError_1.throwError(function () { return error; })
		                    :
		                        kind === 'C'
		                            ?
		                                empty_1.EMPTY
		                            :
		                                0;
		        if (!result) {
		            throw new TypeError("Unexpected notification kind " + kind);
		        }
		        return result;
		    };
		    Notification.createNext = function (value) {
		        return new Notification('N', value);
		    };
		    Notification.createError = function (err) {
		        return new Notification('E', undefined, err);
		    };
		    Notification.createComplete = function () {
		        return Notification.completeNotification;
		    };
		    Notification.completeNotification = new Notification('C');
		    return Notification;
		}());
		exports.Notification = Notification;
		function observeNotification(notification, observer) {
		    var _a, _b, _c;
		    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
		    if (typeof kind !== 'string') {
		        throw new TypeError('Invalid notification, missing "kind"');
		    }
		    kind === 'N' ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === 'E' ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
		}
		exports.observeNotification = observeNotification;
		
	} (Notification));
	return Notification;
}

var isObservable = {};

var hasRequiredIsObservable;

function requireIsObservable () {
	if (hasRequiredIsObservable) return isObservable;
	hasRequiredIsObservable = 1;
	Object.defineProperty(isObservable, "__esModule", { value: true });
	isObservable.isObservable = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function isObservable$1(obj) {
	    return !!obj && (obj instanceof Observable_1.Observable || (isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe)));
	}
	isObservable.isObservable = isObservable$1;
	
	return isObservable;
}

var lastValueFrom = {};

var EmptyError = {};

var hasRequiredEmptyError;

function requireEmptyError () {
	if (hasRequiredEmptyError) return EmptyError;
	hasRequiredEmptyError = 1;
	Object.defineProperty(EmptyError, "__esModule", { value: true });
	EmptyError.EmptyError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	EmptyError.EmptyError = createErrorClass_1.createErrorClass(function (_super) { return function EmptyErrorImpl() {
	    _super(this);
	    this.name = 'EmptyError';
	    this.message = 'no elements in sequence';
	}; });
	
	return EmptyError;
}

var hasRequiredLastValueFrom;

function requireLastValueFrom () {
	if (hasRequiredLastValueFrom) return lastValueFrom;
	hasRequiredLastValueFrom = 1;
	Object.defineProperty(lastValueFrom, "__esModule", { value: true });
	lastValueFrom.lastValueFrom = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	function lastValueFrom$1(source, config) {
	    var hasConfig = typeof config === 'object';
	    return new Promise(function (resolve, reject) {
	        var _hasValue = false;
	        var _value;
	        source.subscribe({
	            next: function (value) {
	                _value = value;
	                _hasValue = true;
	            },
	            error: reject,
	            complete: function () {
	                if (_hasValue) {
	                    resolve(_value);
	                }
	                else if (hasConfig) {
	                    resolve(config.defaultValue);
	                }
	                else {
	                    reject(new EmptyError_1.EmptyError());
	                }
	            },
	        });
	    });
	}
	lastValueFrom.lastValueFrom = lastValueFrom$1;
	
	return lastValueFrom;
}

var firstValueFrom = {};

var hasRequiredFirstValueFrom;

function requireFirstValueFrom () {
	if (hasRequiredFirstValueFrom) return firstValueFrom;
	hasRequiredFirstValueFrom = 1;
	Object.defineProperty(firstValueFrom, "__esModule", { value: true });
	firstValueFrom.firstValueFrom = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	var Subscriber_1 = /*@__PURE__*/ requireSubscriber();
	function firstValueFrom$1(source, config) {
	    var hasConfig = typeof config === 'object';
	    return new Promise(function (resolve, reject) {
	        var subscriber = new Subscriber_1.SafeSubscriber({
	            next: function (value) {
	                resolve(value);
	                subscriber.unsubscribe();
	            },
	            error: reject,
	            complete: function () {
	                if (hasConfig) {
	                    resolve(config.defaultValue);
	                }
	                else {
	                    reject(new EmptyError_1.EmptyError());
	                }
	            },
	        });
	        source.subscribe(subscriber);
	    });
	}
	firstValueFrom.firstValueFrom = firstValueFrom$1;
	
	return firstValueFrom;
}

var ArgumentOutOfRangeError = {};

var hasRequiredArgumentOutOfRangeError;

function requireArgumentOutOfRangeError () {
	if (hasRequiredArgumentOutOfRangeError) return ArgumentOutOfRangeError;
	hasRequiredArgumentOutOfRangeError = 1;
	Object.defineProperty(ArgumentOutOfRangeError, "__esModule", { value: true });
	ArgumentOutOfRangeError.ArgumentOutOfRangeError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	ArgumentOutOfRangeError.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function (_super) {
	    return function ArgumentOutOfRangeErrorImpl() {
	        _super(this);
	        this.name = 'ArgumentOutOfRangeError';
	        this.message = 'argument out of range';
	    };
	});
	
	return ArgumentOutOfRangeError;
}

var NotFoundError = {};

var hasRequiredNotFoundError;

function requireNotFoundError () {
	if (hasRequiredNotFoundError) return NotFoundError;
	hasRequiredNotFoundError = 1;
	Object.defineProperty(NotFoundError, "__esModule", { value: true });
	NotFoundError.NotFoundError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	NotFoundError.NotFoundError = createErrorClass_1.createErrorClass(function (_super) {
	    return function NotFoundErrorImpl(message) {
	        _super(this);
	        this.name = 'NotFoundError';
	        this.message = message;
	    };
	});
	
	return NotFoundError;
}

var SequenceError = {};

var hasRequiredSequenceError;

function requireSequenceError () {
	if (hasRequiredSequenceError) return SequenceError;
	hasRequiredSequenceError = 1;
	Object.defineProperty(SequenceError, "__esModule", { value: true });
	SequenceError.SequenceError = void 0;
	var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
	SequenceError.SequenceError = createErrorClass_1.createErrorClass(function (_super) {
	    return function SequenceErrorImpl(message) {
	        _super(this);
	        this.name = 'SequenceError';
	        this.message = message;
	    };
	});
	
	return SequenceError;
}

var timeout = {};

var isDate = {};

var hasRequiredIsDate;

function requireIsDate () {
	if (hasRequiredIsDate) return isDate;
	hasRequiredIsDate = 1;
	Object.defineProperty(isDate, "__esModule", { value: true });
	isDate.isValidDate = void 0;
	function isValidDate(value) {
	    return value instanceof Date && !isNaN(value);
	}
	isDate.isValidDate = isValidDate;
	
	return isDate;
}

var hasRequiredTimeout;

function requireTimeout () {
	if (hasRequiredTimeout) return timeout;
	hasRequiredTimeout = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.timeout = exports.TimeoutError = void 0;
		var async_1 = /*@__PURE__*/ requireAsync();
		var isDate_1 = /*@__PURE__*/ requireIsDate();
		var lift_1 = /*@__PURE__*/ requireLift();
		var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
		var createErrorClass_1 = /*@__PURE__*/ requireCreateErrorClass();
		var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
		var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
		exports.TimeoutError = createErrorClass_1.createErrorClass(function (_super) {
		    return function TimeoutErrorImpl(info) {
		        if (info === void 0) { info = null; }
		        _super(this);
		        this.message = 'Timeout has occurred';
		        this.name = 'TimeoutError';
		        this.info = info;
		    };
		});
		function timeout(config, schedulerArg) {
		    var _a = (isDate_1.isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config), first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
		    if (first == null && each == null) {
		        throw new TypeError('No timeout provided.');
		    }
		    return lift_1.operate(function (source, subscriber) {
		        var originalSourceSubscription;
		        var timerSubscription;
		        var lastValue = null;
		        var seen = 0;
		        var startTimer = function (delay) {
		            timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function () {
		                try {
		                    originalSourceSubscription.unsubscribe();
		                    innerFrom_1.innerFrom(_with({
		                        meta: meta,
		                        lastValue: lastValue,
		                        seen: seen,
		                    })).subscribe(subscriber);
		                }
		                catch (err) {
		                    subscriber.error(err);
		                }
		            }, delay);
		        };
		        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
		            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
		            seen++;
		            subscriber.next((lastValue = value));
		            each > 0 && startTimer(each);
		        }, undefined, undefined, function () {
		            if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
		                timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
		            }
		            lastValue = null;
		        }));
		        !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler.now()) : each);
		    });
		}
		exports.timeout = timeout;
		function timeoutErrorFactory(info) {
		    throw new exports.TimeoutError(info);
		}
		
	} (timeout));
	return timeout;
}

var bindCallback = {};

var bindCallbackInternals = {};

var mapOneOrManyArgs = {};

var map = {};

var hasRequiredMap$1;

function requireMap$1 () {
	if (hasRequiredMap$1) return map;
	hasRequiredMap$1 = 1;
	Object.defineProperty(map, "__esModule", { value: true });
	map.map = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function map$1(project, thisArg) {
	    return lift_1.operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            subscriber.next(project.call(thisArg, value, index++));
	        }));
	    });
	}
	map.map = map$1;
	
	return map;
}

var hasRequiredMapOneOrManyArgs;

function requireMapOneOrManyArgs () {
	if (hasRequiredMapOneOrManyArgs) return mapOneOrManyArgs;
	hasRequiredMapOneOrManyArgs = 1;
	var __read = (mapOneOrManyArgs && mapOneOrManyArgs.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (mapOneOrManyArgs && mapOneOrManyArgs.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(mapOneOrManyArgs, "__esModule", { value: true });
	mapOneOrManyArgs.mapOneOrManyArgs = void 0;
	var map_1 = /*@__PURE__*/ requireMap$1();
	var isArray = Array.isArray;
	function callOrApply(fn, args) {
	    return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
	}
	function mapOneOrManyArgs$1(fn) {
	    return map_1.map(function (args) { return callOrApply(fn, args); });
	}
	mapOneOrManyArgs.mapOneOrManyArgs = mapOneOrManyArgs$1;
	
	return mapOneOrManyArgs;
}

var hasRequiredBindCallbackInternals;

function requireBindCallbackInternals () {
	if (hasRequiredBindCallbackInternals) return bindCallbackInternals;
	hasRequiredBindCallbackInternals = 1;
	var __read = (bindCallbackInternals && bindCallbackInternals.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (bindCallbackInternals && bindCallbackInternals.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(bindCallbackInternals, "__esModule", { value: true });
	bindCallbackInternals.bindCallbackInternals = void 0;
	var isScheduler_1 = /*@__PURE__*/ requireIsScheduler();
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var subscribeOn_1 = /*@__PURE__*/ requireSubscribeOn();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var observeOn_1 = /*@__PURE__*/ requireObserveOn();
	var AsyncSubject_1 = /*@__PURE__*/ requireAsyncSubject();
	function bindCallbackInternals$1(isNodeStyle, callbackFunc, resultSelector, scheduler) {
	    if (resultSelector) {
	        if (isScheduler_1.isScheduler(resultSelector)) {
	            scheduler = resultSelector;
	        }
	        else {
	            return function () {
	                var args = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    args[_i] = arguments[_i];
	                }
	                return bindCallbackInternals$1(isNodeStyle, callbackFunc, scheduler)
	                    .apply(this, args)
	                    .pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
	            };
	        }
	    }
	    if (scheduler) {
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return bindCallbackInternals$1(isNodeStyle, callbackFunc)
	                .apply(this, args)
	                .pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
	        };
	    }
	    return function () {
	        var _this = this;
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var subject = new AsyncSubject_1.AsyncSubject();
	        var uninitialized = true;
	        return new Observable_1.Observable(function (subscriber) {
	            var subs = subject.subscribe(subscriber);
	            if (uninitialized) {
	                uninitialized = false;
	                var isAsync_1 = false;
	                var isComplete_1 = false;
	                callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
	                    function () {
	                        var results = [];
	                        for (var _i = 0; _i < arguments.length; _i++) {
	                            results[_i] = arguments[_i];
	                        }
	                        if (isNodeStyle) {
	                            var err = results.shift();
	                            if (err != null) {
	                                subject.error(err);
	                                return;
	                            }
	                        }
	                        subject.next(1 < results.length ? results : results[0]);
	                        isComplete_1 = true;
	                        if (isAsync_1) {
	                            subject.complete();
	                        }
	                    },
	                ]));
	                if (isComplete_1) {
	                    subject.complete();
	                }
	                isAsync_1 = true;
	            }
	            return subs;
	        });
	    };
	}
	bindCallbackInternals.bindCallbackInternals = bindCallbackInternals$1;
	
	return bindCallbackInternals;
}

var hasRequiredBindCallback;

function requireBindCallback () {
	if (hasRequiredBindCallback) return bindCallback;
	hasRequiredBindCallback = 1;
	Object.defineProperty(bindCallback, "__esModule", { value: true });
	bindCallback.bindCallback = void 0;
	var bindCallbackInternals_1 = /*@__PURE__*/ requireBindCallbackInternals();
	function bindCallback$1(callbackFunc, resultSelector, scheduler) {
	    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
	}
	bindCallback.bindCallback = bindCallback$1;
	
	return bindCallback;
}

var bindNodeCallback = {};

var hasRequiredBindNodeCallback;

function requireBindNodeCallback () {
	if (hasRequiredBindNodeCallback) return bindNodeCallback;
	hasRequiredBindNodeCallback = 1;
	Object.defineProperty(bindNodeCallback, "__esModule", { value: true });
	bindNodeCallback.bindNodeCallback = void 0;
	var bindCallbackInternals_1 = /*@__PURE__*/ requireBindCallbackInternals();
	function bindNodeCallback$1(callbackFunc, resultSelector, scheduler) {
	    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
	}
	bindNodeCallback.bindNodeCallback = bindNodeCallback$1;
	
	return bindNodeCallback;
}

var combineLatest$1 = {};

var argsArgArrayOrObject = {};

var hasRequiredArgsArgArrayOrObject;

function requireArgsArgArrayOrObject () {
	if (hasRequiredArgsArgArrayOrObject) return argsArgArrayOrObject;
	hasRequiredArgsArgArrayOrObject = 1;
	Object.defineProperty(argsArgArrayOrObject, "__esModule", { value: true });
	argsArgArrayOrObject.argsArgArrayOrObject = void 0;
	var isArray = Array.isArray;
	var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
	function argsArgArrayOrObject$1(args) {
	    if (args.length === 1) {
	        var first_1 = args[0];
	        if (isArray(first_1)) {
	            return { args: first_1, keys: null };
	        }
	        if (isPOJO(first_1)) {
	            var keys = getKeys(first_1);
	            return {
	                args: keys.map(function (key) { return first_1[key]; }),
	                keys: keys,
	            };
	        }
	    }
	    return { args: args, keys: null };
	}
	argsArgArrayOrObject.argsArgArrayOrObject = argsArgArrayOrObject$1;
	function isPOJO(obj) {
	    return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;
	}
	
	return argsArgArrayOrObject;
}

var createObject = {};

var hasRequiredCreateObject;

function requireCreateObject () {
	if (hasRequiredCreateObject) return createObject;
	hasRequiredCreateObject = 1;
	Object.defineProperty(createObject, "__esModule", { value: true });
	createObject.createObject = void 0;
	function createObject$1(keys, values) {
	    return keys.reduce(function (result, key, i) { return ((result[key] = values[i]), result); }, {});
	}
	createObject.createObject = createObject$1;
	
	return createObject;
}

var hasRequiredCombineLatest$1;

function requireCombineLatest$1 () {
	if (hasRequiredCombineLatest$1) return combineLatest$1;
	hasRequiredCombineLatest$1 = 1;
	Object.defineProperty(combineLatest$1, "__esModule", { value: true });
	combineLatest$1.combineLatestInit = combineLatest$1.combineLatest = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var argsArgArrayOrObject_1 = /*@__PURE__*/ requireArgsArgArrayOrObject();
	var from_1 = /*@__PURE__*/ requireFrom$1();
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var args_1 = /*@__PURE__*/ requireArgs();
	var createObject_1 = /*@__PURE__*/ requireCreateObject();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	function combineLatest() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(args);
	    var resultSelector = args_1.popResultSelector(args);
	    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
	    if (observables.length === 0) {
	        return from_1.from([], scheduler);
	    }
	    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys
	        ?
	            function (values) { return createObject_1.createObject(keys, values); }
	        :
	            identity_1.identity));
	    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
	}
	combineLatest$1.combineLatest = combineLatest;
	function combineLatestInit(observables, scheduler, valueTransform) {
	    if (valueTransform === void 0) { valueTransform = identity_1.identity; }
	    return function (subscriber) {
	        maybeSchedule(scheduler, function () {
	            var length = observables.length;
	            var values = new Array(length);
	            var active = length;
	            var remainingFirstValues = length;
	            var _loop_1 = function (i) {
	                maybeSchedule(scheduler, function () {
	                    var source = from_1.from(observables[i], scheduler);
	                    var hasFirstValue = false;
	                    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                        values[i] = value;
	                        if (!hasFirstValue) {
	                            hasFirstValue = true;
	                            remainingFirstValues--;
	                        }
	                        if (!remainingFirstValues) {
	                            subscriber.next(valueTransform(values.slice()));
	                        }
	                    }, function () {
	                        if (!--active) {
	                            subscriber.complete();
	                        }
	                    }));
	                }, subscriber);
	            };
	            for (var i = 0; i < length; i++) {
	                _loop_1(i);
	            }
	        }, subscriber);
	    };
	}
	combineLatest$1.combineLatestInit = combineLatestInit;
	function maybeSchedule(scheduler, execute, subscription) {
	    if (scheduler) {
	        executeSchedule_1.executeSchedule(subscription, scheduler, execute);
	    }
	    else {
	        execute();
	    }
	}
	
	return combineLatest$1;
}

var concat$1 = {};

var concatAll = {};

var mergeAll = {};

var mergeMap = {};

var mergeInternals = {};

var hasRequiredMergeInternals;

function requireMergeInternals () {
	if (hasRequiredMergeInternals) return mergeInternals;
	hasRequiredMergeInternals = 1;
	Object.defineProperty(mergeInternals, "__esModule", { value: true });
	mergeInternals.mergeInternals = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function mergeInternals$1(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
	    var buffer = [];
	    var active = 0;
	    var index = 0;
	    var isComplete = false;
	    var checkComplete = function () {
	        if (isComplete && !buffer.length && !active) {
	            subscriber.complete();
	        }
	    };
	    var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };
	    var doInnerSub = function (value) {
	        expand && subscriber.next(value);
	        active++;
	        var innerComplete = false;
	        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (innerValue) {
	            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
	            if (expand) {
	                outerNext(innerValue);
	            }
	            else {
	                subscriber.next(innerValue);
	            }
	        }, function () {
	            innerComplete = true;
	        }, undefined, function () {
	            if (innerComplete) {
	                try {
	                    active--;
	                    var _loop_1 = function () {
	                        var bufferedValue = buffer.shift();
	                        if (innerSubScheduler) {
	                            executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function () { return doInnerSub(bufferedValue); });
	                        }
	                        else {
	                            doInnerSub(bufferedValue);
	                        }
	                    };
	                    while (buffer.length && active < concurrent) {
	                        _loop_1();
	                    }
	                    checkComplete();
	                }
	                catch (err) {
	                    subscriber.error(err);
	                }
	            }
	        }));
	    };
	    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function () {
	        isComplete = true;
	        checkComplete();
	    }));
	    return function () {
	        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
	    };
	}
	mergeInternals.mergeInternals = mergeInternals$1;
	
	return mergeInternals;
}

var hasRequiredMergeMap;

function requireMergeMap () {
	if (hasRequiredMergeMap) return mergeMap;
	hasRequiredMergeMap = 1;
	Object.defineProperty(mergeMap, "__esModule", { value: true });
	mergeMap.mergeMap = void 0;
	var map_1 = /*@__PURE__*/ requireMap$1();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var lift_1 = /*@__PURE__*/ requireLift();
	var mergeInternals_1 = /*@__PURE__*/ requireMergeInternals();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function mergeMap$1(project, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    if (isFunction_1.isFunction(resultSelector)) {
	        return mergeMap$1(function (a, i) { return map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom_1.innerFrom(project(a, i))); }, concurrent);
	    }
	    else if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	    }
	    return lift_1.operate(function (source, subscriber) { return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent); });
	}
	mergeMap.mergeMap = mergeMap$1;
	
	return mergeMap;
}

var hasRequiredMergeAll;

function requireMergeAll () {
	if (hasRequiredMergeAll) return mergeAll;
	hasRequiredMergeAll = 1;
	Object.defineProperty(mergeAll, "__esModule", { value: true });
	mergeAll.mergeAll = void 0;
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	function mergeAll$1(concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
	}
	mergeAll.mergeAll = mergeAll$1;
	
	return mergeAll;
}

var hasRequiredConcatAll;

function requireConcatAll () {
	if (hasRequiredConcatAll) return concatAll;
	hasRequiredConcatAll = 1;
	Object.defineProperty(concatAll, "__esModule", { value: true });
	concatAll.concatAll = void 0;
	var mergeAll_1 = /*@__PURE__*/ requireMergeAll();
	function concatAll$1() {
	    return mergeAll_1.mergeAll(1);
	}
	concatAll.concatAll = concatAll$1;
	
	return concatAll;
}

var hasRequiredConcat$1;

function requireConcat$1 () {
	if (hasRequiredConcat$1) return concat$1;
	hasRequiredConcat$1 = 1;
	Object.defineProperty(concat$1, "__esModule", { value: true });
	concat$1.concat = void 0;
	var concatAll_1 = /*@__PURE__*/ requireConcatAll();
	var args_1 = /*@__PURE__*/ requireArgs();
	var from_1 = /*@__PURE__*/ requireFrom$1();
	function concat() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
	}
	concat$1.concat = concat;
	
	return concat$1;
}

var connectable = {};

var defer = {};

var hasRequiredDefer;

function requireDefer () {
	if (hasRequiredDefer) return defer;
	hasRequiredDefer = 1;
	Object.defineProperty(defer, "__esModule", { value: true });
	defer.defer = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function defer$1(observableFactory) {
	    return new Observable_1.Observable(function (subscriber) {
	        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
	    });
	}
	defer.defer = defer$1;
	
	return defer;
}

var hasRequiredConnectable;

function requireConnectable () {
	if (hasRequiredConnectable) return connectable;
	hasRequiredConnectable = 1;
	Object.defineProperty(connectable, "__esModule", { value: true });
	connectable.connectable = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var defer_1 = /*@__PURE__*/ requireDefer();
	var DEFAULT_CONFIG = {
	    connector: function () { return new Subject_1.Subject(); },
	    resetOnDisconnect: true,
	};
	function connectable$1(source, config) {
	    if (config === void 0) { config = DEFAULT_CONFIG; }
	    var connection = null;
	    var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
	    var subject = connector();
	    var result = new Observable_1.Observable(function (subscriber) {
	        return subject.subscribe(subscriber);
	    });
	    result.connect = function () {
	        if (!connection || connection.closed) {
	            connection = defer_1.defer(function () { return source; }).subscribe(subject);
	            if (resetOnDisconnect) {
	                connection.add(function () { return (subject = connector()); });
	            }
	        }
	        return connection;
	    };
	    return result;
	}
	connectable.connectable = connectable$1;
	
	return connectable;
}

var forkJoin = {};

var hasRequiredForkJoin;

function requireForkJoin () {
	if (hasRequiredForkJoin) return forkJoin;
	hasRequiredForkJoin = 1;
	Object.defineProperty(forkJoin, "__esModule", { value: true });
	forkJoin.forkJoin = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var argsArgArrayOrObject_1 = /*@__PURE__*/ requireArgsArgArrayOrObject();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var args_1 = /*@__PURE__*/ requireArgs();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var createObject_1 = /*@__PURE__*/ requireCreateObject();
	function forkJoin$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var resultSelector = args_1.popResultSelector(args);
	    var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
	    var result = new Observable_1.Observable(function (subscriber) {
	        var length = sources.length;
	        if (!length) {
	            subscriber.complete();
	            return;
	        }
	        var values = new Array(length);
	        var remainingCompletions = length;
	        var remainingEmissions = length;
	        var _loop_1 = function (sourceIndex) {
	            var hasValue = false;
	            innerFrom_1.innerFrom(sources[sourceIndex]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                if (!hasValue) {
	                    hasValue = true;
	                    remainingEmissions--;
	                }
	                values[sourceIndex] = value;
	            }, function () { return remainingCompletions--; }, undefined, function () {
	                if (!remainingCompletions || !hasValue) {
	                    if (!remainingEmissions) {
	                        subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
	                    }
	                    subscriber.complete();
	                }
	            }));
	        };
	        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
	            _loop_1(sourceIndex);
	        }
	    });
	    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
	}
	forkJoin.forkJoin = forkJoin$1;
	
	return forkJoin;
}

var fromEvent = {};

var hasRequiredFromEvent;

function requireFromEvent () {
	if (hasRequiredFromEvent) return fromEvent;
	hasRequiredFromEvent = 1;
	var __read = (fromEvent && fromEvent.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	Object.defineProperty(fromEvent, "__esModule", { value: true });
	fromEvent.fromEvent = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var isArrayLike_1 = /*@__PURE__*/ requireIsArrayLike$1();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var nodeEventEmitterMethods = ['addListener', 'removeListener'];
	var eventTargetMethods = ['addEventListener', 'removeEventListener'];
	var jqueryMethods = ['on', 'off'];
	function fromEvent$1(target, eventName, options, resultSelector) {
	    if (isFunction_1.isFunction(options)) {
	        resultSelector = options;
	        options = undefined;
	    }
	    if (resultSelector) {
	        return fromEvent$1(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
	    }
	    var _a = __read(isEventTarget(target)
	        ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })
	        :
	            isNodeStyleEventEmitter(target)
	                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
	                : isJQueryStyleEventEmitter(target)
	                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
	                    : [], 2), add = _a[0], remove = _a[1];
	    if (!add) {
	        if (isArrayLike_1.isArrayLike(target)) {
	            return mergeMap_1.mergeMap(function (subTarget) { return fromEvent$1(subTarget, eventName, options); })(innerFrom_1.innerFrom(target));
	        }
	    }
	    if (!add) {
	        throw new TypeError('Invalid event target');
	    }
	    return new Observable_1.Observable(function (subscriber) {
	        var handler = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return subscriber.next(1 < args.length ? args : args[0]);
	        };
	        add(handler);
	        return function () { return remove(handler); };
	    });
	}
	fromEvent.fromEvent = fromEvent$1;
	function toCommonHandlerRegistry(target, eventName) {
	    return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };
	}
	function isNodeStyleEventEmitter(target) {
	    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
	}
	function isJQueryStyleEventEmitter(target) {
	    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
	}
	function isEventTarget(target) {
	    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
	}
	
	return fromEvent;
}

var fromEventPattern = {};

var hasRequiredFromEventPattern;

function requireFromEventPattern () {
	if (hasRequiredFromEventPattern) return fromEventPattern;
	hasRequiredFromEventPattern = 1;
	Object.defineProperty(fromEventPattern, "__esModule", { value: true });
	fromEventPattern.fromEventPattern = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	function fromEventPattern$1(addHandler, removeHandler, resultSelector) {
	    if (resultSelector) {
	        return fromEventPattern$1(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
	    }
	    return new Observable_1.Observable(function (subscriber) {
	        var handler = function () {
	            var e = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                e[_i] = arguments[_i];
	            }
	            return subscriber.next(e.length === 1 ? e[0] : e);
	        };
	        var retValue = addHandler(handler);
	        return isFunction_1.isFunction(removeHandler) ? function () { return removeHandler(handler, retValue); } : undefined;
	    });
	}
	fromEventPattern.fromEventPattern = fromEventPattern$1;
	
	return fromEventPattern;
}

var generate = {};

var hasRequiredGenerate;

function requireGenerate () {
	if (hasRequiredGenerate) return generate;
	hasRequiredGenerate = 1;
	var __generator = (generate && generate.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(generate, "__esModule", { value: true });
	generate.generate = void 0;
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	var isScheduler_1 = /*@__PURE__*/ requireIsScheduler();
	var defer_1 = /*@__PURE__*/ requireDefer();
	var scheduleIterable_1 = /*@__PURE__*/ requireScheduleIterable();
	function generate$1(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
	    var _a, _b;
	    var resultSelector;
	    var initialState;
	    if (arguments.length === 1) {
	        (_a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler);
	    }
	    else {
	        initialState = initialStateOrOptions;
	        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
	            resultSelector = identity_1.identity;
	            scheduler = resultSelectorOrScheduler;
	        }
	        else {
	            resultSelector = resultSelectorOrScheduler;
	        }
	    }
	    function gen() {
	        var state;
	        return __generator(this, function (_a) {
	            switch (_a.label) {
	                case 0:
	                    state = initialState;
	                    _a.label = 1;
	                case 1:
	                    if (!(!condition || condition(state))) return [3, 4];
	                    return [4, resultSelector(state)];
	                case 2:
	                    _a.sent();
	                    _a.label = 3;
	                case 3:
	                    state = iterate(state);
	                    return [3, 1];
	                case 4: return [2];
	            }
	        });
	    }
	    return defer_1.defer((scheduler
	        ?
	            function () { return scheduleIterable_1.scheduleIterable(gen(), scheduler); }
	        :
	            gen));
	}
	generate.generate = generate$1;
	
	return generate;
}

var iif = {};

var hasRequiredIif;

function requireIif () {
	if (hasRequiredIif) return iif;
	hasRequiredIif = 1;
	Object.defineProperty(iif, "__esModule", { value: true });
	iif.iif = void 0;
	var defer_1 = /*@__PURE__*/ requireDefer();
	function iif$1(condition, trueResult, falseResult) {
	    return defer_1.defer(function () { return (condition() ? trueResult : falseResult); });
	}
	iif.iif = iif$1;
	
	return iif;
}

var interval = {};

var timer = {};

var hasRequiredTimer;

function requireTimer () {
	if (hasRequiredTimer) return timer;
	hasRequiredTimer = 1;
	Object.defineProperty(timer, "__esModule", { value: true });
	timer.timer = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var async_1 = /*@__PURE__*/ requireAsync();
	var isScheduler_1 = /*@__PURE__*/ requireIsScheduler();
	var isDate_1 = /*@__PURE__*/ requireIsDate();
	function timer$1(dueTime, intervalOrScheduler, scheduler) {
	    if (dueTime === void 0) { dueTime = 0; }
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var intervalDuration = -1;
	    if (intervalOrScheduler != null) {
	        if (isScheduler_1.isScheduler(intervalOrScheduler)) {
	            scheduler = intervalOrScheduler;
	        }
	        else {
	            intervalDuration = intervalOrScheduler;
	        }
	    }
	    return new Observable_1.Observable(function (subscriber) {
	        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
	        if (due < 0) {
	            due = 0;
	        }
	        var n = 0;
	        return scheduler.schedule(function () {
	            if (!subscriber.closed) {
	                subscriber.next(n++);
	                if (0 <= intervalDuration) {
	                    this.schedule(undefined, intervalDuration);
	                }
	                else {
	                    subscriber.complete();
	                }
	            }
	        }, due);
	    });
	}
	timer.timer = timer$1;
	
	return timer;
}

var hasRequiredInterval;

function requireInterval () {
	if (hasRequiredInterval) return interval;
	hasRequiredInterval = 1;
	Object.defineProperty(interval, "__esModule", { value: true });
	interval.interval = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var timer_1 = /*@__PURE__*/ requireTimer();
	function interval$1(period, scheduler) {
	    if (period === void 0) { period = 0; }
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    if (period < 0) {
	        period = 0;
	    }
	    return timer_1.timer(period, period, scheduler);
	}
	interval.interval = interval$1;
	
	return interval;
}

var merge$1 = {};

var hasRequiredMerge$1;

function requireMerge$1 () {
	if (hasRequiredMerge$1) return merge$1;
	hasRequiredMerge$1 = 1;
	Object.defineProperty(merge$1, "__esModule", { value: true });
	merge$1.merge = void 0;
	var mergeAll_1 = /*@__PURE__*/ requireMergeAll();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var empty_1 = /*@__PURE__*/ requireEmpty();
	var args_1 = /*@__PURE__*/ requireArgs();
	var from_1 = /*@__PURE__*/ requireFrom$1();
	function merge() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(args);
	    var concurrent = args_1.popNumber(args, Infinity);
	    var sources = args;
	    return !sources.length
	        ?
	            empty_1.EMPTY
	        : sources.length === 1
	            ?
	                innerFrom_1.innerFrom(sources[0])
	            :
	                mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
	}
	merge$1.merge = merge;
	
	return merge$1;
}

var never = {};

var hasRequiredNever;

function requireNever () {
	if (hasRequiredNever) return never;
	hasRequiredNever = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.never = exports.NEVER = void 0;
		var Observable_1 = /*@__PURE__*/ requireObservable();
		var noop_1 = /*@__PURE__*/ requireNoop();
		exports.NEVER = new Observable_1.Observable(noop_1.noop);
		function never() {
		    return exports.NEVER;
		}
		exports.never = never;
		
	} (never));
	return never;
}

var onErrorResumeNext = {};

var argsOrArgArray = {};

var hasRequiredArgsOrArgArray;

function requireArgsOrArgArray () {
	if (hasRequiredArgsOrArgArray) return argsOrArgArray;
	hasRequiredArgsOrArgArray = 1;
	Object.defineProperty(argsOrArgArray, "__esModule", { value: true });
	argsOrArgArray.argsOrArgArray = void 0;
	var isArray = Array.isArray;
	function argsOrArgArray$1(args) {
	    return args.length === 1 && isArray(args[0]) ? args[0] : args;
	}
	argsOrArgArray.argsOrArgArray = argsOrArgArray$1;
	
	return argsOrArgArray;
}

var hasRequiredOnErrorResumeNext;

function requireOnErrorResumeNext () {
	if (hasRequiredOnErrorResumeNext) return onErrorResumeNext;
	hasRequiredOnErrorResumeNext = 1;
	Object.defineProperty(onErrorResumeNext, "__esModule", { value: true });
	onErrorResumeNext.onErrorResumeNext = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function onErrorResumeNext$1() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
	    return new Observable_1.Observable(function (subscriber) {
	        var sourceIndex = 0;
	        var subscribeNext = function () {
	            if (sourceIndex < nextSources.length) {
	                var nextSource = void 0;
	                try {
	                    nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
	                }
	                catch (err) {
	                    subscribeNext();
	                    return;
	                }
	                var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, undefined, noop_1.noop, noop_1.noop);
	                nextSource.subscribe(innerSubscriber);
	                innerSubscriber.add(subscribeNext);
	            }
	            else {
	                subscriber.complete();
	            }
	        };
	        subscribeNext();
	    });
	}
	onErrorResumeNext.onErrorResumeNext = onErrorResumeNext$1;
	
	return onErrorResumeNext;
}

var pairs = {};

var hasRequiredPairs;

function requirePairs () {
	if (hasRequiredPairs) return pairs;
	hasRequiredPairs = 1;
	Object.defineProperty(pairs, "__esModule", { value: true });
	pairs.pairs = void 0;
	var from_1 = /*@__PURE__*/ requireFrom$1();
	function pairs$1(obj, scheduler) {
	    return from_1.from(Object.entries(obj), scheduler);
	}
	pairs.pairs = pairs$1;
	
	return pairs;
}

var partition$1 = {};

var not = {};

var hasRequiredNot;

function requireNot () {
	if (hasRequiredNot) return not;
	hasRequiredNot = 1;
	Object.defineProperty(not, "__esModule", { value: true });
	not.not = void 0;
	function not$1(pred, thisArg) {
	    return function (value, index) { return !pred.call(thisArg, value, index); };
	}
	not.not = not$1;
	
	return not;
}

var filter = {};

var hasRequiredFilter$1;

function requireFilter$1 () {
	if (hasRequiredFilter$1) return filter;
	hasRequiredFilter$1 = 1;
	Object.defineProperty(filter, "__esModule", { value: true });
	filter.filter = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function filter$1(predicate, thisArg) {
	    return lift_1.operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
	    });
	}
	filter.filter = filter$1;
	
	return filter;
}

var hasRequiredPartition$1;

function requirePartition$1 () {
	if (hasRequiredPartition$1) return partition$1;
	hasRequiredPartition$1 = 1;
	Object.defineProperty(partition$1, "__esModule", { value: true });
	partition$1.partition = void 0;
	var not_1 = /*@__PURE__*/ requireNot();
	var filter_1 = /*@__PURE__*/ requireFilter$1();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function partition(source, predicate, thisArg) {
	    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
	}
	partition$1.partition = partition;
	
	return partition$1;
}

var race$1 = {};

var hasRequiredRace$1;

function requireRace$1 () {
	if (hasRequiredRace$1) return race$1;
	hasRequiredRace$1 = 1;
	Object.defineProperty(race$1, "__esModule", { value: true });
	race$1.raceInit = race$1.race = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function race() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    sources = argsOrArgArray_1.argsOrArgArray(sources);
	    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
	}
	race$1.race = race;
	function raceInit(sources) {
	    return function (subscriber) {
	        var subscriptions = [];
	        var _loop_1 = function (i) {
	            subscriptions.push(innerFrom_1.innerFrom(sources[i]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                if (subscriptions) {
	                    for (var s = 0; s < subscriptions.length; s++) {
	                        s !== i && subscriptions[s].unsubscribe();
	                    }
	                    subscriptions = null;
	                }
	                subscriber.next(value);
	            })));
	        };
	        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
	            _loop_1(i);
	        }
	    };
	}
	race$1.raceInit = raceInit;
	
	return race$1;
}

var range = {};

var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;
	Object.defineProperty(range, "__esModule", { value: true });
	range.range = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var empty_1 = /*@__PURE__*/ requireEmpty();
	function range$1(start, count, scheduler) {
	    if (count == null) {
	        count = start;
	        start = 0;
	    }
	    if (count <= 0) {
	        return empty_1.EMPTY;
	    }
	    var end = count + start;
	    return new Observable_1.Observable(scheduler
	        ?
	            function (subscriber) {
	                var n = start;
	                return scheduler.schedule(function () {
	                    if (n < end) {
	                        subscriber.next(n++);
	                        this.schedule();
	                    }
	                    else {
	                        subscriber.complete();
	                    }
	                });
	            }
	        :
	            function (subscriber) {
	                var n = start;
	                while (n < end && !subscriber.closed) {
	                    subscriber.next(n++);
	                }
	                subscriber.complete();
	            });
	}
	range.range = range$1;
	
	return range;
}

var using = {};

var hasRequiredUsing;

function requireUsing () {
	if (hasRequiredUsing) return using;
	hasRequiredUsing = 1;
	Object.defineProperty(using, "__esModule", { value: true });
	using.using = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var empty_1 = /*@__PURE__*/ requireEmpty();
	function using$1(resourceFactory, observableFactory) {
	    return new Observable_1.Observable(function (subscriber) {
	        var resource = resourceFactory();
	        var result = observableFactory(resource);
	        var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
	        source.subscribe(subscriber);
	        return function () {
	            if (resource) {
	                resource.unsubscribe();
	            }
	        };
	    });
	}
	using.using = using$1;
	
	return using;
}

var zip$1 = {};

var hasRequiredZip$1;

function requireZip$1 () {
	if (hasRequiredZip$1) return zip$1;
	hasRequiredZip$1 = 1;
	var __read = (zip$1 && zip$1.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (zip$1 && zip$1.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(zip$1, "__esModule", { value: true });
	zip$1.zip = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var empty_1 = /*@__PURE__*/ requireEmpty();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var args_1 = /*@__PURE__*/ requireArgs();
	function zip() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var resultSelector = args_1.popResultSelector(args);
	    var sources = argsOrArgArray_1.argsOrArgArray(args);
	    return sources.length
	        ? new Observable_1.Observable(function (subscriber) {
	            var buffers = sources.map(function () { return []; });
	            var completed = sources.map(function () { return false; });
	            subscriber.add(function () {
	                buffers = completed = null;
	            });
	            var _loop_1 = function (sourceIndex) {
	                innerFrom_1.innerFrom(sources[sourceIndex]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                    buffers[sourceIndex].push(value);
	                    if (buffers.every(function (buffer) { return buffer.length; })) {
	                        var result = buffers.map(function (buffer) { return buffer.shift(); });
	                        subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray([], __read(result))) : result);
	                        if (buffers.some(function (buffer, i) { return !buffer.length && completed[i]; })) {
	                            subscriber.complete();
	                        }
	                    }
	                }, function () {
	                    completed[sourceIndex] = true;
	                    !buffers[sourceIndex].length && subscriber.complete();
	                }));
	            };
	            for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
	                _loop_1(sourceIndex);
	            }
	            return function () {
	                buffers = completed = null;
	            };
	        })
	        : empty_1.EMPTY;
	}
	zip$1.zip = zip;
	
	return zip$1;
}

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	Object.defineProperty(types, "__esModule", { value: true });
	
	return types;
}

var audit = {};

var hasRequiredAudit;

function requireAudit () {
	if (hasRequiredAudit) return audit;
	hasRequiredAudit = 1;
	Object.defineProperty(audit, "__esModule", { value: true });
	audit.audit = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function audit$1(durationSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        var lastValue = null;
	        var durationSubscriber = null;
	        var isComplete = false;
	        var endDuration = function () {
	            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	            durationSubscriber = null;
	            if (hasValue) {
	                hasValue = false;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	            isComplete && subscriber.complete();
	        };
	        var cleanupDuration = function () {
	            durationSubscriber = null;
	            isComplete && subscriber.complete();
	        };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            lastValue = value;
	            if (!durationSubscriber) {
	                innerFrom_1.innerFrom(durationSelector(value)).subscribe((durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration)));
	            }
	        }, function () {
	            isComplete = true;
	            (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
	        }));
	    });
	}
	audit.audit = audit$1;
	
	return audit;
}

var auditTime = {};

var hasRequiredAuditTime;

function requireAuditTime () {
	if (hasRequiredAuditTime) return auditTime;
	hasRequiredAuditTime = 1;
	Object.defineProperty(auditTime, "__esModule", { value: true });
	auditTime.auditTime = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var audit_1 = /*@__PURE__*/ requireAudit();
	var timer_1 = /*@__PURE__*/ requireTimer();
	function auditTime$1(duration, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });
	}
	auditTime.auditTime = auditTime$1;
	
	return auditTime;
}

var buffer = {};

var hasRequiredBuffer;

function requireBuffer () {
	if (hasRequiredBuffer) return buffer;
	hasRequiredBuffer = 1;
	Object.defineProperty(buffer, "__esModule", { value: true });
	buffer.buffer = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function buffer$1(closingNotifier) {
	    return lift_1.operate(function (source, subscriber) {
	        var currentBuffer = [];
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return currentBuffer.push(value); }, function () {
	            subscriber.next(currentBuffer);
	            subscriber.complete();
	        }));
	        innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	            var b = currentBuffer;
	            currentBuffer = [];
	            subscriber.next(b);
	        }, noop_1.noop));
	        return function () {
	            currentBuffer = null;
	        };
	    });
	}
	buffer.buffer = buffer$1;
	
	return buffer;
}

var bufferCount = {};

var hasRequiredBufferCount;

function requireBufferCount () {
	if (hasRequiredBufferCount) return bufferCount;
	hasRequiredBufferCount = 1;
	var __values = (bufferCount && bufferCount.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(bufferCount, "__esModule", { value: true });
	bufferCount.bufferCount = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	function bufferCount$1(bufferSize, startBufferEvery) {
	    if (startBufferEvery === void 0) { startBufferEvery = null; }
	    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
	    return lift_1.operate(function (source, subscriber) {
	        var buffers = [];
	        var count = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a, e_2, _b;
	            var toEmit = null;
	            if (count++ % startBufferEvery === 0) {
	                buffers.push([]);
	            }
	            try {
	                for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
	                    var buffer = buffers_1_1.value;
	                    buffer.push(value);
	                    if (bufferSize <= buffer.length) {
	                        toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
	                        toEmit.push(buffer);
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            if (toEmit) {
	                try {
	                    for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
	                        var buffer = toEmit_1_1.value;
	                        arrRemove_1.arrRemove(buffers, buffer);
	                        subscriber.next(buffer);
	                    }
	                }
	                catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                finally {
	                    try {
	                        if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
	                    }
	                    finally { if (e_2) throw e_2.error; }
	                }
	            }
	        }, function () {
	            var e_3, _a;
	            try {
	                for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
	                    var buffer = buffers_2_1.value;
	                    subscriber.next(buffer);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	            subscriber.complete();
	        }, undefined, function () {
	            buffers = null;
	        }));
	    });
	}
	bufferCount.bufferCount = bufferCount$1;
	
	return bufferCount;
}

var bufferTime = {};

var hasRequiredBufferTime;

function requireBufferTime () {
	if (hasRequiredBufferTime) return bufferTime;
	hasRequiredBufferTime = 1;
	var __values = (bufferTime && bufferTime.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(bufferTime, "__esModule", { value: true });
	bufferTime.bufferTime = void 0;
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	var async_1 = /*@__PURE__*/ requireAsync();
	var args_1 = /*@__PURE__*/ requireArgs();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	function bufferTime$1(bufferTimeSpan) {
	    var _a, _b;
	    var otherArgs = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        otherArgs[_i - 1] = arguments[_i];
	    }
	    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
	    var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
	    var maxBufferSize = otherArgs[1] || Infinity;
	    return lift_1.operate(function (source, subscriber) {
	        var bufferRecords = [];
	        var restartOnEmit = false;
	        var emit = function (record) {
	            var buffer = record.buffer, subs = record.subs;
	            subs.unsubscribe();
	            arrRemove_1.arrRemove(bufferRecords, record);
	            subscriber.next(buffer);
	            restartOnEmit && startBuffer();
	        };
	        var startBuffer = function () {
	            if (bufferRecords) {
	                var subs = new Subscription_1.Subscription();
	                subscriber.add(subs);
	                var buffer = [];
	                var record_1 = {
	                    buffer: buffer,
	                    subs: subs,
	                };
	                bufferRecords.push(record_1);
	                executeSchedule_1.executeSchedule(subs, scheduler, function () { return emit(record_1); }, bufferTimeSpan);
	            }
	        };
	        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
	            executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
	        }
	        else {
	            restartOnEmit = true;
	        }
	        startBuffer();
	        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            var recordsCopy = bufferRecords.slice();
	            try {
	                for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
	                    var record = recordsCopy_1_1.value;
	                    var buffer = record.buffer;
	                    buffer.push(value);
	                    maxBufferSize <= buffer.length && emit(record);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a = recordsCopy_1.return)) _a.call(recordsCopy_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }, function () {
	            while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
	                subscriber.next(bufferRecords.shift().buffer);
	            }
	            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
	            subscriber.complete();
	            subscriber.unsubscribe();
	        }, undefined, function () { return (bufferRecords = null); });
	        source.subscribe(bufferTimeSubscriber);
	    });
	}
	bufferTime.bufferTime = bufferTime$1;
	
	return bufferTime;
}

var bufferToggle = {};

var hasRequiredBufferToggle;

function requireBufferToggle () {
	if (hasRequiredBufferToggle) return bufferToggle;
	hasRequiredBufferToggle = 1;
	var __values = (bufferToggle && bufferToggle.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(bufferToggle, "__esModule", { value: true });
	bufferToggle.bufferToggle = void 0;
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var lift_1 = /*@__PURE__*/ requireLift();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	function bufferToggle$1(openings, closingSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var buffers = [];
	        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (openValue) {
	            var buffer = [];
	            buffers.push(buffer);
	            var closingSubscription = new Subscription_1.Subscription();
	            var emitBuffer = function () {
	                arrRemove_1.arrRemove(buffers, buffer);
	                subscriber.next(buffer);
	                closingSubscription.unsubscribe();
	            };
	            closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
	        }, noop_1.noop));
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            try {
	                for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
	                    var buffer = buffers_1_1.value;
	                    buffer.push(value);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }, function () {
	            while (buffers.length > 0) {
	                subscriber.next(buffers.shift());
	            }
	            subscriber.complete();
	        }));
	    });
	}
	bufferToggle.bufferToggle = bufferToggle$1;
	
	return bufferToggle;
}

var bufferWhen = {};

var hasRequiredBufferWhen;

function requireBufferWhen () {
	if (hasRequiredBufferWhen) return bufferWhen;
	hasRequiredBufferWhen = 1;
	Object.defineProperty(bufferWhen, "__esModule", { value: true });
	bufferWhen.bufferWhen = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function bufferWhen$1(closingSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var buffer = null;
	        var closingSubscriber = null;
	        var openBuffer = function () {
	            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	            var b = buffer;
	            buffer = [];
	            b && subscriber.next(b);
	            innerFrom_1.innerFrom(closingSelector()).subscribe((closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop)));
	        };
	        openBuffer();
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return buffer === null || buffer === void 0 ? void 0 : buffer.push(value); }, function () {
	            buffer && subscriber.next(buffer);
	            subscriber.complete();
	        }, undefined, function () { return (buffer = closingSubscriber = null); }));
	    });
	}
	bufferWhen.bufferWhen = bufferWhen$1;
	
	return bufferWhen;
}

var catchError = {};

var hasRequiredCatchError;

function requireCatchError () {
	if (hasRequiredCatchError) return catchError;
	hasRequiredCatchError = 1;
	Object.defineProperty(catchError, "__esModule", { value: true });
	catchError.catchError = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var lift_1 = /*@__PURE__*/ requireLift();
	function catchError$1(selector) {
	    return lift_1.operate(function (source, subscriber) {
	        var innerSub = null;
	        var syncUnsub = false;
	        var handledResult;
	        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
	            handledResult = innerFrom_1.innerFrom(selector(err, catchError$1(selector)(source)));
	            if (innerSub) {
	                innerSub.unsubscribe();
	                innerSub = null;
	                handledResult.subscribe(subscriber);
	            }
	            else {
	                syncUnsub = true;
	            }
	        }));
	        if (syncUnsub) {
	            innerSub.unsubscribe();
	            innerSub = null;
	            handledResult.subscribe(subscriber);
	        }
	    });
	}
	catchError.catchError = catchError$1;
	
	return catchError;
}

var combineAll = {};

var combineLatestAll = {};

var joinAllInternals = {};

var toArray = {};

var reduce = {};

var scanInternals = {};

var hasRequiredScanInternals;

function requireScanInternals () {
	if (hasRequiredScanInternals) return scanInternals;
	hasRequiredScanInternals = 1;
	Object.defineProperty(scanInternals, "__esModule", { value: true });
	scanInternals.scanInternals = void 0;
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function scanInternals$1(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
	    return function (source, subscriber) {
	        var hasState = hasSeed;
	        var state = seed;
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var i = index++;
	            state = hasState
	                ?
	                    accumulator(state, value, i)
	                :
	                    ((hasState = true), value);
	            emitOnNext && subscriber.next(state);
	        }, emitBeforeComplete &&
	            (function () {
	                hasState && subscriber.next(state);
	                subscriber.complete();
	            })));
	    };
	}
	scanInternals.scanInternals = scanInternals$1;
	
	return scanInternals;
}

var hasRequiredReduce;

function requireReduce () {
	if (hasRequiredReduce) return reduce;
	hasRequiredReduce = 1;
	Object.defineProperty(reduce, "__esModule", { value: true });
	reduce.reduce = void 0;
	var scanInternals_1 = /*@__PURE__*/ requireScanInternals();
	var lift_1 = /*@__PURE__*/ requireLift();
	function reduce$1(accumulator, seed) {
	    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
	}
	reduce.reduce = reduce$1;
	
	return reduce;
}

var hasRequiredToArray;

function requireToArray () {
	if (hasRequiredToArray) return toArray;
	hasRequiredToArray = 1;
	Object.defineProperty(toArray, "__esModule", { value: true });
	toArray.toArray = void 0;
	var reduce_1 = /*@__PURE__*/ requireReduce();
	var lift_1 = /*@__PURE__*/ requireLift();
	var arrReducer = function (arr, value) { return (arr.push(value), arr); };
	function toArray$1() {
	    return lift_1.operate(function (source, subscriber) {
	        reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
	    });
	}
	toArray.toArray = toArray$1;
	
	return toArray;
}

var hasRequiredJoinAllInternals;

function requireJoinAllInternals () {
	if (hasRequiredJoinAllInternals) return joinAllInternals;
	hasRequiredJoinAllInternals = 1;
	Object.defineProperty(joinAllInternals, "__esModule", { value: true });
	joinAllInternals.joinAllInternals = void 0;
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var pipe_1 = /*@__PURE__*/ requirePipe();
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var toArray_1 = /*@__PURE__*/ requireToArray();
	function joinAllInternals$1(joinFn, project) {
	    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function (sources) { return joinFn(sources); }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
	}
	joinAllInternals.joinAllInternals = joinAllInternals$1;
	
	return joinAllInternals;
}

var hasRequiredCombineLatestAll;

function requireCombineLatestAll () {
	if (hasRequiredCombineLatestAll) return combineLatestAll;
	hasRequiredCombineLatestAll = 1;
	Object.defineProperty(combineLatestAll, "__esModule", { value: true });
	combineLatestAll.combineLatestAll = void 0;
	var combineLatest_1 = /*@__PURE__*/ requireCombineLatest$1();
	var joinAllInternals_1 = /*@__PURE__*/ requireJoinAllInternals();
	function combineLatestAll$1(project) {
	    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
	}
	combineLatestAll.combineLatestAll = combineLatestAll$1;
	
	return combineLatestAll;
}

var hasRequiredCombineAll;

function requireCombineAll () {
	if (hasRequiredCombineAll) return combineAll;
	hasRequiredCombineAll = 1;
	Object.defineProperty(combineAll, "__esModule", { value: true });
	combineAll.combineAll = void 0;
	var combineLatestAll_1 = /*@__PURE__*/ requireCombineLatestAll();
	combineAll.combineAll = combineLatestAll_1.combineLatestAll;
	
	return combineAll;
}

var combineLatestWith = {};

var combineLatest = {};

var hasRequiredCombineLatest;

function requireCombineLatest () {
	if (hasRequiredCombineLatest) return combineLatest;
	hasRequiredCombineLatest = 1;
	var __read = (combineLatest && combineLatest.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (combineLatest && combineLatest.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(combineLatest, "__esModule", { value: true });
	combineLatest.combineLatest = void 0;
	var combineLatest_1 = /*@__PURE__*/ requireCombineLatest$1();
	var lift_1 = /*@__PURE__*/ requireLift();
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var mapOneOrManyArgs_1 = /*@__PURE__*/ requireMapOneOrManyArgs();
	var pipe_1 = /*@__PURE__*/ requirePipe();
	var args_1 = /*@__PURE__*/ requireArgs();
	function combineLatest$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var resultSelector = args_1.popResultSelector(args);
	    return resultSelector
	        ? pipe_1.pipe(combineLatest$1.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector))
	        : lift_1.operate(function (source, subscriber) {
	            combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
	        });
	}
	combineLatest.combineLatest = combineLatest$1;
	
	return combineLatest;
}

var hasRequiredCombineLatestWith;

function requireCombineLatestWith () {
	if (hasRequiredCombineLatestWith) return combineLatestWith;
	hasRequiredCombineLatestWith = 1;
	var __read = (combineLatestWith && combineLatestWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (combineLatestWith && combineLatestWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(combineLatestWith, "__esModule", { value: true });
	combineLatestWith.combineLatestWith = void 0;
	var combineLatest_1 = /*@__PURE__*/ requireCombineLatest();
	function combineLatestWith$1() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return combineLatest_1.combineLatest.apply(void 0, __spreadArray([], __read(otherSources)));
	}
	combineLatestWith.combineLatestWith = combineLatestWith$1;
	
	return combineLatestWith;
}

var concatMap = {};

var hasRequiredConcatMap;

function requireConcatMap () {
	if (hasRequiredConcatMap) return concatMap;
	hasRequiredConcatMap = 1;
	Object.defineProperty(concatMap, "__esModule", { value: true });
	concatMap.concatMap = void 0;
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function concatMap$1(project, resultSelector) {
	    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
	}
	concatMap.concatMap = concatMap$1;
	
	return concatMap;
}

var concatMapTo = {};

var hasRequiredConcatMapTo;

function requireConcatMapTo () {
	if (hasRequiredConcatMapTo) return concatMapTo;
	hasRequiredConcatMapTo = 1;
	Object.defineProperty(concatMapTo, "__esModule", { value: true });
	concatMapTo.concatMapTo = void 0;
	var concatMap_1 = /*@__PURE__*/ requireConcatMap();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function concatMapTo$1(innerObservable, resultSelector) {
	    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function () { return innerObservable; }, resultSelector) : concatMap_1.concatMap(function () { return innerObservable; });
	}
	concatMapTo.concatMapTo = concatMapTo$1;
	
	return concatMapTo;
}

var concatWith = {};

var concat = {};

var hasRequiredConcat;

function requireConcat () {
	if (hasRequiredConcat) return concat;
	hasRequiredConcat = 1;
	var __read = (concat && concat.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (concat && concat.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(concat, "__esModule", { value: true });
	concat.concat = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var concatAll_1 = /*@__PURE__*/ requireConcatAll();
	var args_1 = /*@__PURE__*/ requireArgs();
	var from_1 = /*@__PURE__*/ requireFrom$1();
	function concat$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(args);
	    return lift_1.operate(function (source, subscriber) {
	        concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
	    });
	}
	concat.concat = concat$1;
	
	return concat;
}

var hasRequiredConcatWith;

function requireConcatWith () {
	if (hasRequiredConcatWith) return concatWith;
	hasRequiredConcatWith = 1;
	var __read = (concatWith && concatWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (concatWith && concatWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(concatWith, "__esModule", { value: true });
	concatWith.concatWith = void 0;
	var concat_1 = /*@__PURE__*/ requireConcat();
	function concatWith$1() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return concat_1.concat.apply(void 0, __spreadArray([], __read(otherSources)));
	}
	concatWith.concatWith = concatWith$1;
	
	return concatWith;
}

var connect = {};

var fromSubscribable = {};

var hasRequiredFromSubscribable;

function requireFromSubscribable () {
	if (hasRequiredFromSubscribable) return fromSubscribable;
	hasRequiredFromSubscribable = 1;
	Object.defineProperty(fromSubscribable, "__esModule", { value: true });
	fromSubscribable.fromSubscribable = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	function fromSubscribable$1(subscribable) {
	    return new Observable_1.Observable(function (subscriber) { return subscribable.subscribe(subscriber); });
	}
	fromSubscribable.fromSubscribable = fromSubscribable$1;
	
	return fromSubscribable;
}

var hasRequiredConnect;

function requireConnect () {
	if (hasRequiredConnect) return connect;
	hasRequiredConnect = 1;
	Object.defineProperty(connect, "__esModule", { value: true });
	connect.connect = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var lift_1 = /*@__PURE__*/ requireLift();
	var fromSubscribable_1 = /*@__PURE__*/ requireFromSubscribable();
	var DEFAULT_CONFIG = {
	    connector: function () { return new Subject_1.Subject(); },
	};
	function connect$1(selector, config) {
	    if (config === void 0) { config = DEFAULT_CONFIG; }
	    var connector = config.connector;
	    return lift_1.operate(function (source, subscriber) {
	        var subject = connector();
	        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
	        subscriber.add(source.subscribe(subject));
	    });
	}
	connect.connect = connect$1;
	
	return connect;
}

var count = {};

var hasRequiredCount;

function requireCount () {
	if (hasRequiredCount) return count;
	hasRequiredCount = 1;
	Object.defineProperty(count, "__esModule", { value: true });
	count.count = void 0;
	var reduce_1 = /*@__PURE__*/ requireReduce();
	function count$1(predicate) {
	    return reduce_1.reduce(function (total, value, i) { return (!predicate || predicate(value, i) ? total + 1 : total); }, 0);
	}
	count.count = count$1;
	
	return count;
}

var debounce = {};

var hasRequiredDebounce;

function requireDebounce () {
	if (hasRequiredDebounce) return debounce;
	hasRequiredDebounce = 1;
	Object.defineProperty(debounce, "__esModule", { value: true });
	debounce.debounce = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function debounce$1(durationSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        var lastValue = null;
	        var durationSubscriber = null;
	        var emit = function () {
	            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	            durationSubscriber = null;
	            if (hasValue) {
	                hasValue = false;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	        };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
	            hasValue = true;
	            lastValue = value;
	            durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
	            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
	        }, function () {
	            emit();
	            subscriber.complete();
	        }, undefined, function () {
	            lastValue = durationSubscriber = null;
	        }));
	    });
	}
	debounce.debounce = debounce$1;
	
	return debounce;
}

var debounceTime = {};

var hasRequiredDebounceTime;

function requireDebounceTime () {
	if (hasRequiredDebounceTime) return debounceTime;
	hasRequiredDebounceTime = 1;
	Object.defineProperty(debounceTime, "__esModule", { value: true });
	debounceTime.debounceTime = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function debounceTime$1(dueTime, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    return lift_1.operate(function (source, subscriber) {
	        var activeTask = null;
	        var lastValue = null;
	        var lastTime = null;
	        var emit = function () {
	            if (activeTask) {
	                activeTask.unsubscribe();
	                activeTask = null;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	        };
	        function emitWhenIdle() {
	            var targetTime = lastTime + dueTime;
	            var now = scheduler.now();
	            if (now < targetTime) {
	                activeTask = this.schedule(undefined, targetTime - now);
	                subscriber.add(activeTask);
	                return;
	            }
	            emit();
	        }
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            lastValue = value;
	            lastTime = scheduler.now();
	            if (!activeTask) {
	                activeTask = scheduler.schedule(emitWhenIdle, dueTime);
	                subscriber.add(activeTask);
	            }
	        }, function () {
	            emit();
	            subscriber.complete();
	        }, undefined, function () {
	            lastValue = activeTask = null;
	        }));
	    });
	}
	debounceTime.debounceTime = debounceTime$1;
	
	return debounceTime;
}

var defaultIfEmpty = {};

var hasRequiredDefaultIfEmpty;

function requireDefaultIfEmpty () {
	if (hasRequiredDefaultIfEmpty) return defaultIfEmpty;
	hasRequiredDefaultIfEmpty = 1;
	Object.defineProperty(defaultIfEmpty, "__esModule", { value: true });
	defaultIfEmpty.defaultIfEmpty = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function defaultIfEmpty$1(defaultValue) {
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            subscriber.next(value);
	        }, function () {
	            if (!hasValue) {
	                subscriber.next(defaultValue);
	            }
	            subscriber.complete();
	        }));
	    });
	}
	defaultIfEmpty.defaultIfEmpty = defaultIfEmpty$1;
	
	return defaultIfEmpty;
}

var delay = {};

var delayWhen = {};

var take = {};

var hasRequiredTake;

function requireTake () {
	if (hasRequiredTake) return take;
	hasRequiredTake = 1;
	Object.defineProperty(take, "__esModule", { value: true });
	take.take = void 0;
	var empty_1 = /*@__PURE__*/ requireEmpty();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function take$1(count) {
	    return count <= 0
	        ?
	            function () { return empty_1.EMPTY; }
	        : lift_1.operate(function (source, subscriber) {
	            var seen = 0;
	            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                if (++seen <= count) {
	                    subscriber.next(value);
	                    if (count <= seen) {
	                        subscriber.complete();
	                    }
	                }
	            }));
	        });
	}
	take.take = take$1;
	
	return take;
}

var ignoreElements = {};

var hasRequiredIgnoreElements;

function requireIgnoreElements () {
	if (hasRequiredIgnoreElements) return ignoreElements;
	hasRequiredIgnoreElements = 1;
	Object.defineProperty(ignoreElements, "__esModule", { value: true });
	ignoreElements.ignoreElements = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	function ignoreElements$1() {
	    return lift_1.operate(function (source, subscriber) {
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
	    });
	}
	ignoreElements.ignoreElements = ignoreElements$1;
	
	return ignoreElements;
}

var mapTo = {};

var hasRequiredMapTo;

function requireMapTo () {
	if (hasRequiredMapTo) return mapTo;
	hasRequiredMapTo = 1;
	Object.defineProperty(mapTo, "__esModule", { value: true });
	mapTo.mapTo = void 0;
	var map_1 = /*@__PURE__*/ requireMap$1();
	function mapTo$1(value) {
	    return map_1.map(function () { return value; });
	}
	mapTo.mapTo = mapTo$1;
	
	return mapTo;
}

var hasRequiredDelayWhen;

function requireDelayWhen () {
	if (hasRequiredDelayWhen) return delayWhen;
	hasRequiredDelayWhen = 1;
	Object.defineProperty(delayWhen, "__esModule", { value: true });
	delayWhen.delayWhen = void 0;
	var concat_1 = /*@__PURE__*/ requireConcat$1();
	var take_1 = /*@__PURE__*/ requireTake();
	var ignoreElements_1 = /*@__PURE__*/ requireIgnoreElements();
	var mapTo_1 = /*@__PURE__*/ requireMapTo();
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function delayWhen$1(delayDurationSelector, subscriptionDelay) {
	    if (subscriptionDelay) {
	        return function (source) {
	            return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen$1(delayDurationSelector)));
	        };
	    }
	    return mergeMap_1.mergeMap(function (value, index) { return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value)); });
	}
	delayWhen.delayWhen = delayWhen$1;
	
	return delayWhen;
}

var hasRequiredDelay;

function requireDelay () {
	if (hasRequiredDelay) return delay;
	hasRequiredDelay = 1;
	Object.defineProperty(delay, "__esModule", { value: true });
	delay.delay = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var delayWhen_1 = /*@__PURE__*/ requireDelayWhen();
	var timer_1 = /*@__PURE__*/ requireTimer();
	function delay$1(due, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    var duration = timer_1.timer(due, scheduler);
	    return delayWhen_1.delayWhen(function () { return duration; });
	}
	delay.delay = delay$1;
	
	return delay;
}

var dematerialize = {};

var hasRequiredDematerialize;

function requireDematerialize () {
	if (hasRequiredDematerialize) return dematerialize;
	hasRequiredDematerialize = 1;
	Object.defineProperty(dematerialize, "__esModule", { value: true });
	dematerialize.dematerialize = void 0;
	var Notification_1 = /*@__PURE__*/ requireNotification();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function dematerialize$1() {
	    return lift_1.operate(function (source, subscriber) {
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (notification) { return Notification_1.observeNotification(notification, subscriber); }));
	    });
	}
	dematerialize.dematerialize = dematerialize$1;
	
	return dematerialize;
}

var distinct = {};

var hasRequiredDistinct;

function requireDistinct () {
	if (hasRequiredDistinct) return distinct;
	hasRequiredDistinct = 1;
	Object.defineProperty(distinct, "__esModule", { value: true });
	distinct.distinct = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function distinct$1(keySelector, flushes) {
	    return lift_1.operate(function (source, subscriber) {
	        var distinctKeys = new Set();
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var key = keySelector ? keySelector(value) : value;
	            if (!distinctKeys.has(key)) {
	                distinctKeys.add(key);
	                subscriber.next(value);
	            }
	        }));
	        flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () { return distinctKeys.clear(); }, noop_1.noop));
	    });
	}
	distinct.distinct = distinct$1;
	
	return distinct;
}

var distinctUntilChanged = {};

var hasRequiredDistinctUntilChanged;

function requireDistinctUntilChanged () {
	if (hasRequiredDistinctUntilChanged) return distinctUntilChanged;
	hasRequiredDistinctUntilChanged = 1;
	Object.defineProperty(distinctUntilChanged, "__esModule", { value: true });
	distinctUntilChanged.distinctUntilChanged = void 0;
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function distinctUntilChanged$1(comparator, keySelector) {
	    if (keySelector === void 0) { keySelector = identity_1.identity; }
	    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
	    return lift_1.operate(function (source, subscriber) {
	        var previousKey;
	        var first = true;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var currentKey = keySelector(value);
	            if (first || !comparator(previousKey, currentKey)) {
	                first = false;
	                previousKey = currentKey;
	                subscriber.next(value);
	            }
	        }));
	    });
	}
	distinctUntilChanged.distinctUntilChanged = distinctUntilChanged$1;
	function defaultCompare(a, b) {
	    return a === b;
	}
	
	return distinctUntilChanged;
}

var distinctUntilKeyChanged = {};

var hasRequiredDistinctUntilKeyChanged;

function requireDistinctUntilKeyChanged () {
	if (hasRequiredDistinctUntilKeyChanged) return distinctUntilKeyChanged;
	hasRequiredDistinctUntilKeyChanged = 1;
	Object.defineProperty(distinctUntilKeyChanged, "__esModule", { value: true });
	distinctUntilKeyChanged.distinctUntilKeyChanged = void 0;
	var distinctUntilChanged_1 = /*@__PURE__*/ requireDistinctUntilChanged();
	function distinctUntilKeyChanged$1(key, compare) {
	    return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
	}
	distinctUntilKeyChanged.distinctUntilKeyChanged = distinctUntilKeyChanged$1;
	
	return distinctUntilKeyChanged;
}

var elementAt = {};

var throwIfEmpty = {};

var hasRequiredThrowIfEmpty;

function requireThrowIfEmpty () {
	if (hasRequiredThrowIfEmpty) return throwIfEmpty;
	hasRequiredThrowIfEmpty = 1;
	Object.defineProperty(throwIfEmpty, "__esModule", { value: true });
	throwIfEmpty.throwIfEmpty = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function throwIfEmpty$1(errorFactory) {
	    if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            subscriber.next(value);
	        }, function () { return (hasValue ? subscriber.complete() : subscriber.error(errorFactory())); }));
	    });
	}
	throwIfEmpty.throwIfEmpty = throwIfEmpty$1;
	function defaultErrorFactory() {
	    return new EmptyError_1.EmptyError();
	}
	
	return throwIfEmpty;
}

var hasRequiredElementAt;

function requireElementAt () {
	if (hasRequiredElementAt) return elementAt;
	hasRequiredElementAt = 1;
	Object.defineProperty(elementAt, "__esModule", { value: true });
	elementAt.elementAt = void 0;
	var ArgumentOutOfRangeError_1 = /*@__PURE__*/ requireArgumentOutOfRangeError();
	var filter_1 = /*@__PURE__*/ requireFilter$1();
	var throwIfEmpty_1 = /*@__PURE__*/ requireThrowIfEmpty();
	var defaultIfEmpty_1 = /*@__PURE__*/ requireDefaultIfEmpty();
	var take_1 = /*@__PURE__*/ requireTake();
	function elementAt$1(index, defaultValue) {
	    if (index < 0) {
	        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
	    }
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) {
	        return source.pipe(filter_1.filter(function (v, i) { return i === index; }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError(); }));
	    };
	}
	elementAt.elementAt = elementAt$1;
	
	return elementAt;
}

var endWith = {};

var hasRequiredEndWith;

function requireEndWith () {
	if (hasRequiredEndWith) return endWith;
	hasRequiredEndWith = 1;
	var __read = (endWith && endWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (endWith && endWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(endWith, "__esModule", { value: true });
	endWith.endWith = void 0;
	var concat_1 = /*@__PURE__*/ requireConcat$1();
	var of_1 = /*@__PURE__*/ requireOf();
	function endWith$1() {
	    var values = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        values[_i] = arguments[_i];
	    }
	    return function (source) { return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray([], __read(values)))); };
	}
	endWith.endWith = endWith$1;
	
	return endWith;
}

var every = {};

var hasRequiredEvery;

function requireEvery () {
	if (hasRequiredEvery) return every;
	hasRequiredEvery = 1;
	Object.defineProperty(every, "__esModule", { value: true });
	every.every = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function every$1(predicate, thisArg) {
	    return lift_1.operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            if (!predicate.call(thisArg, value, index++, source)) {
	                subscriber.next(false);
	                subscriber.complete();
	            }
	        }, function () {
	            subscriber.next(true);
	            subscriber.complete();
	        }));
	    });
	}
	every.every = every$1;
	
	return every;
}

var exhaust = {};

var exhaustAll = {};

var exhaustMap = {};

var hasRequiredExhaustMap;

function requireExhaustMap () {
	if (hasRequiredExhaustMap) return exhaustMap;
	hasRequiredExhaustMap = 1;
	Object.defineProperty(exhaustMap, "__esModule", { value: true });
	exhaustMap.exhaustMap = void 0;
	var map_1 = /*@__PURE__*/ requireMap$1();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function exhaustMap$1(project, resultSelector) {
	    if (resultSelector) {
	        return function (source) {
	            return source.pipe(exhaustMap$1(function (a, i) { return innerFrom_1.innerFrom(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }));
	        };
	    }
	    return lift_1.operate(function (source, subscriber) {
	        var index = 0;
	        var innerSub = null;
	        var isComplete = false;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (outerValue) {
	            if (!innerSub) {
	                innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function () {
	                    innerSub = null;
	                    isComplete && subscriber.complete();
	                });
	                innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
	            }
	        }, function () {
	            isComplete = true;
	            !innerSub && subscriber.complete();
	        }));
	    });
	}
	exhaustMap.exhaustMap = exhaustMap$1;
	
	return exhaustMap;
}

var hasRequiredExhaustAll;

function requireExhaustAll () {
	if (hasRequiredExhaustAll) return exhaustAll;
	hasRequiredExhaustAll = 1;
	Object.defineProperty(exhaustAll, "__esModule", { value: true });
	exhaustAll.exhaustAll = void 0;
	var exhaustMap_1 = /*@__PURE__*/ requireExhaustMap();
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	function exhaustAll$1() {
	    return exhaustMap_1.exhaustMap(identity_1.identity);
	}
	exhaustAll.exhaustAll = exhaustAll$1;
	
	return exhaustAll;
}

var hasRequiredExhaust;

function requireExhaust () {
	if (hasRequiredExhaust) return exhaust;
	hasRequiredExhaust = 1;
	Object.defineProperty(exhaust, "__esModule", { value: true });
	exhaust.exhaust = void 0;
	var exhaustAll_1 = /*@__PURE__*/ requireExhaustAll();
	exhaust.exhaust = exhaustAll_1.exhaustAll;
	
	return exhaust;
}

var expand$1 = {};

var hasRequiredExpand$1;

function requireExpand$1 () {
	if (hasRequiredExpand$1) return expand$1;
	hasRequiredExpand$1 = 1;
	Object.defineProperty(expand$1, "__esModule", { value: true });
	expand$1.expand = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var mergeInternals_1 = /*@__PURE__*/ requireMergeInternals();
	function expand(project, concurrent, scheduler) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
	    return lift_1.operate(function (source, subscriber) {
	        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
	    });
	}
	expand$1.expand = expand;
	
	return expand$1;
}

var finalize = {};

var hasRequiredFinalize;

function requireFinalize () {
	if (hasRequiredFinalize) return finalize;
	hasRequiredFinalize = 1;
	Object.defineProperty(finalize, "__esModule", { value: true });
	finalize.finalize = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	function finalize$1(callback) {
	    return lift_1.operate(function (source, subscriber) {
	        try {
	            source.subscribe(subscriber);
	        }
	        finally {
	            subscriber.add(callback);
	        }
	    });
	}
	finalize.finalize = finalize$1;
	
	return finalize;
}

var find = {};

var hasRequiredFind;

function requireFind () {
	if (hasRequiredFind) return find;
	hasRequiredFind = 1;
	Object.defineProperty(find, "__esModule", { value: true });
	find.createFind = find.find = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function find$1(predicate, thisArg) {
	    return lift_1.operate(createFind(predicate, thisArg, 'value'));
	}
	find.find = find$1;
	function createFind(predicate, thisArg, emit) {
	    var findIndex = emit === 'index';
	    return function (source, subscriber) {
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var i = index++;
	            if (predicate.call(thisArg, value, i, source)) {
	                subscriber.next(findIndex ? i : value);
	                subscriber.complete();
	            }
	        }, function () {
	            subscriber.next(findIndex ? -1 : undefined);
	            subscriber.complete();
	        }));
	    };
	}
	find.createFind = createFind;
	
	return find;
}

var findIndex = {};

var hasRequiredFindIndex;

function requireFindIndex () {
	if (hasRequiredFindIndex) return findIndex;
	hasRequiredFindIndex = 1;
	Object.defineProperty(findIndex, "__esModule", { value: true });
	findIndex.findIndex = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var find_1 = /*@__PURE__*/ requireFind();
	function findIndex$1(predicate, thisArg) {
	    return lift_1.operate(find_1.createFind(predicate, thisArg, 'index'));
	}
	findIndex.findIndex = findIndex$1;
	
	return findIndex;
}

var first = {};

var hasRequiredFirst;

function requireFirst () {
	if (hasRequiredFirst) return first;
	hasRequiredFirst = 1;
	Object.defineProperty(first, "__esModule", { value: true });
	first.first = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	var filter_1 = /*@__PURE__*/ requireFilter$1();
	var take_1 = /*@__PURE__*/ requireTake();
	var defaultIfEmpty_1 = /*@__PURE__*/ requireDefaultIfEmpty();
	var throwIfEmpty_1 = /*@__PURE__*/ requireThrowIfEmpty();
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	function first$1(predicate, defaultValue) {
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) {
	        return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); }));
	    };
	}
	first.first = first$1;
	
	return first;
}

var groupBy = {};

var hasRequiredGroupBy;

function requireGroupBy () {
	if (hasRequiredGroupBy) return groupBy;
	hasRequiredGroupBy = 1;
	Object.defineProperty(groupBy, "__esModule", { value: true });
	groupBy.groupBy = void 0;
	var Observable_1 = /*@__PURE__*/ requireObservable();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function groupBy$1(keySelector, elementOrOptions, duration, connector) {
	    return lift_1.operate(function (source, subscriber) {
	        var element;
	        if (!elementOrOptions || typeof elementOrOptions === 'function') {
	            element = elementOrOptions;
	        }
	        else {
	            (duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector);
	        }
	        var groups = new Map();
	        var notify = function (cb) {
	            groups.forEach(cb);
	            cb(subscriber);
	        };
	        var handleError = function (err) { return notify(function (consumer) { return consumer.error(err); }); };
	        var activeGroups = 0;
	        var teardownAttempted = false;
	        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function (value) {
	            try {
	                var key_1 = keySelector(value);
	                var group_1 = groups.get(key_1);
	                if (!group_1) {
	                    groups.set(key_1, (group_1 = connector ? connector() : new Subject_1.Subject()));
	                    var grouped = createGroupedObservable(key_1, group_1);
	                    subscriber.next(grouped);
	                    if (duration) {
	                        var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function () {
	                            group_1.complete();
	                            durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
	                        }, undefined, undefined, function () { return groups.delete(key_1); });
	                        groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
	                    }
	                }
	                group_1.next(element ? element(value) : value);
	            }
	            catch (err) {
	                handleError(err);
	            }
	        }, function () { return notify(function (consumer) { return consumer.complete(); }); }, handleError, function () { return groups.clear(); }, function () {
	            teardownAttempted = true;
	            return activeGroups === 0;
	        });
	        source.subscribe(groupBySourceSubscriber);
	        function createGroupedObservable(key, groupSubject) {
	            var result = new Observable_1.Observable(function (groupSubscriber) {
	                activeGroups++;
	                var innerSub = groupSubject.subscribe(groupSubscriber);
	                return function () {
	                    innerSub.unsubscribe();
	                    --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
	                };
	            });
	            result.key = key;
	            return result;
	        }
	    });
	}
	groupBy.groupBy = groupBy$1;
	
	return groupBy;
}

var isEmpty = {};

var hasRequiredIsEmpty;

function requireIsEmpty () {
	if (hasRequiredIsEmpty) return isEmpty;
	hasRequiredIsEmpty = 1;
	Object.defineProperty(isEmpty, "__esModule", { value: true });
	isEmpty.isEmpty = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function isEmpty$1() {
	    return lift_1.operate(function (source, subscriber) {
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	            subscriber.next(false);
	            subscriber.complete();
	        }, function () {
	            subscriber.next(true);
	            subscriber.complete();
	        }));
	    });
	}
	isEmpty.isEmpty = isEmpty$1;
	
	return isEmpty;
}

var last = {};

var takeLast = {};

var hasRequiredTakeLast;

function requireTakeLast () {
	if (hasRequiredTakeLast) return takeLast;
	hasRequiredTakeLast = 1;
	var __values = (takeLast && takeLast.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(takeLast, "__esModule", { value: true });
	takeLast.takeLast = void 0;
	var empty_1 = /*@__PURE__*/ requireEmpty();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function takeLast$1(count) {
	    return count <= 0
	        ? function () { return empty_1.EMPTY; }
	        : lift_1.operate(function (source, subscriber) {
	            var buffer = [];
	            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                buffer.push(value);
	                count < buffer.length && buffer.shift();
	            }, function () {
	                var e_1, _a;
	                try {
	                    for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
	                        var value = buffer_1_1.value;
	                        subscriber.next(value);
	                    }
	                }
	                catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                finally {
	                    try {
	                        if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
	                    }
	                    finally { if (e_1) throw e_1.error; }
	                }
	                subscriber.complete();
	            }, undefined, function () {
	                buffer = null;
	            }));
	        });
	}
	takeLast.takeLast = takeLast$1;
	
	return takeLast;
}

var hasRequiredLast;

function requireLast () {
	if (hasRequiredLast) return last;
	hasRequiredLast = 1;
	Object.defineProperty(last, "__esModule", { value: true });
	last.last = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	var filter_1 = /*@__PURE__*/ requireFilter$1();
	var takeLast_1 = /*@__PURE__*/ requireTakeLast();
	var throwIfEmpty_1 = /*@__PURE__*/ requireThrowIfEmpty();
	var defaultIfEmpty_1 = /*@__PURE__*/ requireDefaultIfEmpty();
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	function last$1(predicate, defaultValue) {
	    var hasDefaultValue = arguments.length >= 2;
	    return function (source) {
	        return source.pipe(predicate ? filter_1.filter(function (v, i) { return predicate(v, i, source); }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function () { return new EmptyError_1.EmptyError(); }));
	    };
	}
	last.last = last$1;
	
	return last;
}

var materialize = {};

var hasRequiredMaterialize;

function requireMaterialize () {
	if (hasRequiredMaterialize) return materialize;
	hasRequiredMaterialize = 1;
	Object.defineProperty(materialize, "__esModule", { value: true });
	materialize.materialize = void 0;
	var Notification_1 = /*@__PURE__*/ requireNotification();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function materialize$1() {
	    return lift_1.operate(function (source, subscriber) {
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            subscriber.next(Notification_1.Notification.createNext(value));
	        }, function () {
	            subscriber.next(Notification_1.Notification.createComplete());
	            subscriber.complete();
	        }, function (err) {
	            subscriber.next(Notification_1.Notification.createError(err));
	            subscriber.complete();
	        }));
	    });
	}
	materialize.materialize = materialize$1;
	
	return materialize;
}

var max = {};

var hasRequiredMax;

function requireMax () {
	if (hasRequiredMax) return max;
	hasRequiredMax = 1;
	Object.defineProperty(max, "__esModule", { value: true });
	max.max = void 0;
	var reduce_1 = /*@__PURE__*/ requireReduce();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function max$1(comparer) {
	    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function (x, y) { return (comparer(x, y) > 0 ? x : y); } : function (x, y) { return (x > y ? x : y); });
	}
	max.max = max$1;
	
	return max;
}

var flatMap = {};

var hasRequiredFlatMap;

function requireFlatMap () {
	if (hasRequiredFlatMap) return flatMap;
	hasRequiredFlatMap = 1;
	Object.defineProperty(flatMap, "__esModule", { value: true });
	flatMap.flatMap = void 0;
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	flatMap.flatMap = mergeMap_1.mergeMap;
	
	return flatMap;
}

var mergeMapTo = {};

var hasRequiredMergeMapTo;

function requireMergeMapTo () {
	if (hasRequiredMergeMapTo) return mergeMapTo;
	hasRequiredMergeMapTo = 1;
	Object.defineProperty(mergeMapTo, "__esModule", { value: true });
	mergeMapTo.mergeMapTo = void 0;
	var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function mergeMapTo$1(innerObservable, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    if (isFunction_1.isFunction(resultSelector)) {
	        return mergeMap_1.mergeMap(function () { return innerObservable; }, resultSelector, concurrent);
	    }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	    }
	    return mergeMap_1.mergeMap(function () { return innerObservable; }, concurrent);
	}
	mergeMapTo.mergeMapTo = mergeMapTo$1;
	
	return mergeMapTo;
}

var mergeScan = {};

var hasRequiredMergeScan;

function requireMergeScan () {
	if (hasRequiredMergeScan) return mergeScan;
	hasRequiredMergeScan = 1;
	Object.defineProperty(mergeScan, "__esModule", { value: true });
	mergeScan.mergeScan = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var mergeInternals_1 = /*@__PURE__*/ requireMergeInternals();
	function mergeScan$1(accumulator, seed, concurrent) {
	    if (concurrent === void 0) { concurrent = Infinity; }
	    return lift_1.operate(function (source, subscriber) {
	        var state = seed;
	        return mergeInternals_1.mergeInternals(source, subscriber, function (value, index) { return accumulator(state, value, index); }, concurrent, function (value) {
	            state = value;
	        }, false, undefined, function () { return (state = null); });
	    });
	}
	mergeScan.mergeScan = mergeScan$1;
	
	return mergeScan;
}

var mergeWith = {};

var merge = {};

var hasRequiredMerge;

function requireMerge () {
	if (hasRequiredMerge) return merge;
	hasRequiredMerge = 1;
	var __read = (merge && merge.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (merge && merge.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(merge, "__esModule", { value: true });
	merge.merge = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var mergeAll_1 = /*@__PURE__*/ requireMergeAll();
	var args_1 = /*@__PURE__*/ requireArgs();
	var from_1 = /*@__PURE__*/ requireFrom$1();
	function merge$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(args);
	    var concurrent = args_1.popNumber(args, Infinity);
	    args = argsOrArgArray_1.argsOrArgArray(args);
	    return lift_1.operate(function (source, subscriber) {
	        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
	    });
	}
	merge.merge = merge$1;
	
	return merge;
}

var hasRequiredMergeWith;

function requireMergeWith () {
	if (hasRequiredMergeWith) return mergeWith;
	hasRequiredMergeWith = 1;
	var __read = (mergeWith && mergeWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (mergeWith && mergeWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(mergeWith, "__esModule", { value: true });
	mergeWith.mergeWith = void 0;
	var merge_1 = /*@__PURE__*/ requireMerge();
	function mergeWith$1() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return merge_1.merge.apply(void 0, __spreadArray([], __read(otherSources)));
	}
	mergeWith.mergeWith = mergeWith$1;
	
	return mergeWith;
}

var min = {};

var hasRequiredMin;

function requireMin () {
	if (hasRequiredMin) return min;
	hasRequiredMin = 1;
	Object.defineProperty(min, "__esModule", { value: true });
	min.min = void 0;
	var reduce_1 = /*@__PURE__*/ requireReduce();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function min$1(comparer) {
	    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function (x, y) { return (comparer(x, y) < 0 ? x : y); } : function (x, y) { return (x < y ? x : y); });
	}
	min.min = min$1;
	
	return min;
}

var multicast = {};

var hasRequiredMulticast;

function requireMulticast () {
	if (hasRequiredMulticast) return multicast;
	hasRequiredMulticast = 1;
	Object.defineProperty(multicast, "__esModule", { value: true });
	multicast.multicast = void 0;
	var ConnectableObservable_1 = /*@__PURE__*/ requireConnectableObservable();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var connect_1 = /*@__PURE__*/ requireConnect();
	function multicast$1(subjectOrSubjectFactory, selector) {
	    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function () { return subjectOrSubjectFactory; };
	    if (isFunction_1.isFunction(selector)) {
	        return connect_1.connect(selector, {
	            connector: subjectFactory,
	        });
	    }
	    return function (source) { return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory); };
	}
	multicast.multicast = multicast$1;
	
	return multicast;
}

var onErrorResumeNextWith = {};

var hasRequiredOnErrorResumeNextWith;

function requireOnErrorResumeNextWith () {
	if (hasRequiredOnErrorResumeNextWith) return onErrorResumeNextWith;
	hasRequiredOnErrorResumeNextWith = 1;
	var __read = (onErrorResumeNextWith && onErrorResumeNextWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (onErrorResumeNextWith && onErrorResumeNextWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(onErrorResumeNextWith, "__esModule", { value: true });
	onErrorResumeNextWith.onErrorResumeNext = onErrorResumeNextWith.onErrorResumeNextWith = void 0;
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var onErrorResumeNext_1 = /*@__PURE__*/ requireOnErrorResumeNext();
	function onErrorResumeNextWith$1() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
	    return function (source) { return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray([source], __read(nextSources))); };
	}
	onErrorResumeNextWith.onErrorResumeNextWith = onErrorResumeNextWith$1;
	onErrorResumeNextWith.onErrorResumeNext = onErrorResumeNextWith$1;
	
	return onErrorResumeNextWith;
}

var pairwise = {};

var hasRequiredPairwise;

function requirePairwise () {
	if (hasRequiredPairwise) return pairwise;
	hasRequiredPairwise = 1;
	Object.defineProperty(pairwise, "__esModule", { value: true });
	pairwise.pairwise = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function pairwise$1() {
	    return lift_1.operate(function (source, subscriber) {
	        var prev;
	        var hasPrev = false;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var p = prev;
	            prev = value;
	            hasPrev && subscriber.next([p, value]);
	            hasPrev = true;
	        }));
	    });
	}
	pairwise.pairwise = pairwise$1;
	
	return pairwise;
}

var pluck = {};

var hasRequiredPluck;

function requirePluck () {
	if (hasRequiredPluck) return pluck;
	hasRequiredPluck = 1;
	Object.defineProperty(pluck, "__esModule", { value: true });
	pluck.pluck = void 0;
	var map_1 = /*@__PURE__*/ requireMap$1();
	function pluck$1() {
	    var properties = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        properties[_i] = arguments[_i];
	    }
	    var length = properties.length;
	    if (length === 0) {
	        throw new Error('list of properties cannot be empty.');
	    }
	    return map_1.map(function (x) {
	        var currentProp = x;
	        for (var i = 0; i < length; i++) {
	            var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
	            if (typeof p !== 'undefined') {
	                currentProp = p;
	            }
	            else {
	                return undefined;
	            }
	        }
	        return currentProp;
	    });
	}
	pluck.pluck = pluck$1;
	
	return pluck;
}

var publish = {};

var hasRequiredPublish;

function requirePublish () {
	if (hasRequiredPublish) return publish;
	hasRequiredPublish = 1;
	Object.defineProperty(publish, "__esModule", { value: true });
	publish.publish = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var multicast_1 = /*@__PURE__*/ requireMulticast();
	var connect_1 = /*@__PURE__*/ requireConnect();
	function publish$1(selector) {
	    return selector ? function (source) { return connect_1.connect(selector)(source); } : function (source) { return multicast_1.multicast(new Subject_1.Subject())(source); };
	}
	publish.publish = publish$1;
	
	return publish;
}

var publishBehavior = {};

var hasRequiredPublishBehavior;

function requirePublishBehavior () {
	if (hasRequiredPublishBehavior) return publishBehavior;
	hasRequiredPublishBehavior = 1;
	Object.defineProperty(publishBehavior, "__esModule", { value: true });
	publishBehavior.publishBehavior = void 0;
	var BehaviorSubject_1 = /*@__PURE__*/ requireBehaviorSubject();
	var ConnectableObservable_1 = /*@__PURE__*/ requireConnectableObservable();
	function publishBehavior$1(initialValue) {
	    return function (source) {
	        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
	        return new ConnectableObservable_1.ConnectableObservable(source, function () { return subject; });
	    };
	}
	publishBehavior.publishBehavior = publishBehavior$1;
	
	return publishBehavior;
}

var publishLast = {};

var hasRequiredPublishLast;

function requirePublishLast () {
	if (hasRequiredPublishLast) return publishLast;
	hasRequiredPublishLast = 1;
	Object.defineProperty(publishLast, "__esModule", { value: true });
	publishLast.publishLast = void 0;
	var AsyncSubject_1 = /*@__PURE__*/ requireAsyncSubject();
	var ConnectableObservable_1 = /*@__PURE__*/ requireConnectableObservable();
	function publishLast$1() {
	    return function (source) {
	        var subject = new AsyncSubject_1.AsyncSubject();
	        return new ConnectableObservable_1.ConnectableObservable(source, function () { return subject; });
	    };
	}
	publishLast.publishLast = publishLast$1;
	
	return publishLast;
}

var publishReplay = {};

var hasRequiredPublishReplay;

function requirePublishReplay () {
	if (hasRequiredPublishReplay) return publishReplay;
	hasRequiredPublishReplay = 1;
	Object.defineProperty(publishReplay, "__esModule", { value: true });
	publishReplay.publishReplay = void 0;
	var ReplaySubject_1 = /*@__PURE__*/ requireReplaySubject();
	var multicast_1 = /*@__PURE__*/ requireMulticast();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function publishReplay$1(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
	    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
	        timestampProvider = selectorOrScheduler;
	    }
	    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
	    return function (source) { return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source); };
	}
	publishReplay.publishReplay = publishReplay$1;
	
	return publishReplay;
}

var raceWith = {};

var hasRequiredRaceWith;

function requireRaceWith () {
	if (hasRequiredRaceWith) return raceWith;
	hasRequiredRaceWith = 1;
	var __read = (raceWith && raceWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (raceWith && raceWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(raceWith, "__esModule", { value: true });
	raceWith.raceWith = void 0;
	var race_1 = /*@__PURE__*/ requireRace$1();
	var lift_1 = /*@__PURE__*/ requireLift();
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	function raceWith$1() {
	    var otherSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherSources[_i] = arguments[_i];
	    }
	    return !otherSources.length
	        ? identity_1.identity
	        : lift_1.operate(function (source, subscriber) {
	            race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
	        });
	}
	raceWith.raceWith = raceWith$1;
	
	return raceWith;
}

var repeat = {};

var hasRequiredRepeat;

function requireRepeat () {
	if (hasRequiredRepeat) return repeat;
	hasRequiredRepeat = 1;
	Object.defineProperty(repeat, "__esModule", { value: true });
	repeat.repeat = void 0;
	var empty_1 = /*@__PURE__*/ requireEmpty();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var timer_1 = /*@__PURE__*/ requireTimer();
	function repeat$1(countOrConfig) {
	    var _a;
	    var count = Infinity;
	    var delay;
	    if (countOrConfig != null) {
	        if (typeof countOrConfig === 'object') {
	            (_a = countOrConfig.count, count = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay);
	        }
	        else {
	            count = countOrConfig;
	        }
	    }
	    return count <= 0
	        ? function () { return empty_1.EMPTY; }
	        : lift_1.operate(function (source, subscriber) {
	            var soFar = 0;
	            var sourceSub;
	            var resubscribe = function () {
	                sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
	                sourceSub = null;
	                if (delay != null) {
	                    var notifier = typeof delay === 'number' ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
	                    var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	                        notifierSubscriber_1.unsubscribe();
	                        subscribeToSource();
	                    });
	                    notifier.subscribe(notifierSubscriber_1);
	                }
	                else {
	                    subscribeToSource();
	                }
	            };
	            var subscribeToSource = function () {
	                var syncUnsub = false;
	                sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function () {
	                    if (++soFar < count) {
	                        if (sourceSub) {
	                            resubscribe();
	                        }
	                        else {
	                            syncUnsub = true;
	                        }
	                    }
	                    else {
	                        subscriber.complete();
	                    }
	                }));
	                if (syncUnsub) {
	                    resubscribe();
	                }
	            };
	            subscribeToSource();
	        });
	}
	repeat.repeat = repeat$1;
	
	return repeat;
}

var repeatWhen = {};

var hasRequiredRepeatWhen;

function requireRepeatWhen () {
	if (hasRequiredRepeatWhen) return repeatWhen;
	hasRequiredRepeatWhen = 1;
	Object.defineProperty(repeatWhen, "__esModule", { value: true });
	repeatWhen.repeatWhen = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function repeatWhen$1(notifier) {
	    return lift_1.operate(function (source, subscriber) {
	        var innerSub;
	        var syncResub = false;
	        var completions$;
	        var isNotifierComplete = false;
	        var isMainComplete = false;
	        var checkComplete = function () { return isMainComplete && isNotifierComplete && (subscriber.complete(), true); };
	        var getCompletionSubject = function () {
	            if (!completions$) {
	                completions$ = new Subject_1.Subject();
	                innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	                    if (innerSub) {
	                        subscribeForRepeatWhen();
	                    }
	                    else {
	                        syncResub = true;
	                    }
	                }, function () {
	                    isNotifierComplete = true;
	                    checkComplete();
	                }));
	            }
	            return completions$;
	        };
	        var subscribeForRepeatWhen = function () {
	            isMainComplete = false;
	            innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function () {
	                isMainComplete = true;
	                !checkComplete() && getCompletionSubject().next();
	            }));
	            if (syncResub) {
	                innerSub.unsubscribe();
	                innerSub = null;
	                syncResub = false;
	                subscribeForRepeatWhen();
	            }
	        };
	        subscribeForRepeatWhen();
	    });
	}
	repeatWhen.repeatWhen = repeatWhen$1;
	
	return repeatWhen;
}

var retry = {};

var hasRequiredRetry;

function requireRetry () {
	if (hasRequiredRetry) return retry;
	hasRequiredRetry = 1;
	Object.defineProperty(retry, "__esModule", { value: true });
	retry.retry = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	var timer_1 = /*@__PURE__*/ requireTimer();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function retry$1(configOrCount) {
	    if (configOrCount === void 0) { configOrCount = Infinity; }
	    var config;
	    if (configOrCount && typeof configOrCount === 'object') {
	        config = configOrCount;
	    }
	    else {
	        config = {
	            count: configOrCount,
	        };
	    }
	    var _a = config.count, count = _a === void 0 ? Infinity : _a, delay = config.delay, _b = config.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
	    return count <= 0
	        ? identity_1.identity
	        : lift_1.operate(function (source, subscriber) {
	            var soFar = 0;
	            var innerSub;
	            var subscribeForRetry = function () {
	                var syncUnsub = false;
	                innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                    if (resetOnSuccess) {
	                        soFar = 0;
	                    }
	                    subscriber.next(value);
	                }, undefined, function (err) {
	                    if (soFar++ < count) {
	                        var resub_1 = function () {
	                            if (innerSub) {
	                                innerSub.unsubscribe();
	                                innerSub = null;
	                                subscribeForRetry();
	                            }
	                            else {
	                                syncUnsub = true;
	                            }
	                        };
	                        if (delay != null) {
	                            var notifier = typeof delay === 'number' ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
	                            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	                                notifierSubscriber_1.unsubscribe();
	                                resub_1();
	                            }, function () {
	                                subscriber.complete();
	                            });
	                            notifier.subscribe(notifierSubscriber_1);
	                        }
	                        else {
	                            resub_1();
	                        }
	                    }
	                    else {
	                        subscriber.error(err);
	                    }
	                }));
	                if (syncUnsub) {
	                    innerSub.unsubscribe();
	                    innerSub = null;
	                    subscribeForRetry();
	                }
	            };
	            subscribeForRetry();
	        });
	}
	retry.retry = retry$1;
	
	return retry;
}

var retryWhen = {};

var hasRequiredRetryWhen;

function requireRetryWhen () {
	if (hasRequiredRetryWhen) return retryWhen;
	hasRequiredRetryWhen = 1;
	Object.defineProperty(retryWhen, "__esModule", { value: true });
	retryWhen.retryWhen = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function retryWhen$1(notifier) {
	    return lift_1.operate(function (source, subscriber) {
	        var innerSub;
	        var syncResub = false;
	        var errors$;
	        var subscribeForRetryWhen = function () {
	            innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function (err) {
	                if (!errors$) {
	                    errors$ = new Subject_1.Subject();
	                    innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	                        return innerSub ? subscribeForRetryWhen() : (syncResub = true);
	                    }));
	                }
	                if (errors$) {
	                    errors$.next(err);
	                }
	            }));
	            if (syncResub) {
	                innerSub.unsubscribe();
	                innerSub = null;
	                syncResub = false;
	                subscribeForRetryWhen();
	            }
	        };
	        subscribeForRetryWhen();
	    });
	}
	retryWhen.retryWhen = retryWhen$1;
	
	return retryWhen;
}

var sample$1 = {};

var hasRequiredSample;

function requireSample () {
	if (hasRequiredSample) return sample$1;
	hasRequiredSample = 1;
	Object.defineProperty(sample$1, "__esModule", { value: true });
	sample$1.sample = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var lift_1 = /*@__PURE__*/ requireLift();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function sample(notifier) {
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        var lastValue = null;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            lastValue = value;
	        }));
	        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	            if (hasValue) {
	                hasValue = false;
	                var value = lastValue;
	                lastValue = null;
	                subscriber.next(value);
	            }
	        }, noop_1.noop));
	    });
	}
	sample$1.sample = sample;
	
	return sample$1;
}

var sampleTime = {};

var hasRequiredSampleTime;

function requireSampleTime () {
	if (hasRequiredSampleTime) return sampleTime;
	hasRequiredSampleTime = 1;
	Object.defineProperty(sampleTime, "__esModule", { value: true });
	sampleTime.sampleTime = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var sample_1 = /*@__PURE__*/ requireSample();
	var interval_1 = /*@__PURE__*/ requireInterval();
	function sampleTime$1(period, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    return sample_1.sample(interval_1.interval(period, scheduler));
	}
	sampleTime.sampleTime = sampleTime$1;
	
	return sampleTime;
}

var scan = {};

var hasRequiredScan;

function requireScan () {
	if (hasRequiredScan) return scan;
	hasRequiredScan = 1;
	Object.defineProperty(scan, "__esModule", { value: true });
	scan.scan = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var scanInternals_1 = /*@__PURE__*/ requireScanInternals();
	function scan$1(accumulator, seed) {
	    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
	}
	scan.scan = scan$1;
	
	return scan;
}

var sequenceEqual = {};

var hasRequiredSequenceEqual;

function requireSequenceEqual () {
	if (hasRequiredSequenceEqual) return sequenceEqual;
	hasRequiredSequenceEqual = 1;
	Object.defineProperty(sequenceEqual, "__esModule", { value: true });
	sequenceEqual.sequenceEqual = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function sequenceEqual$1(compareTo, comparator) {
	    if (comparator === void 0) { comparator = function (a, b) { return a === b; }; }
	    return lift_1.operate(function (source, subscriber) {
	        var aState = createState();
	        var bState = createState();
	        var emit = function (isEqual) {
	            subscriber.next(isEqual);
	            subscriber.complete();
	        };
	        var createSubscriber = function (selfState, otherState) {
	            var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (a) {
	                var buffer = otherState.buffer, complete = otherState.complete;
	                if (buffer.length === 0) {
	                    complete ? emit(false) : selfState.buffer.push(a);
	                }
	                else {
	                    !comparator(a, buffer.shift()) && emit(false);
	                }
	            }, function () {
	                selfState.complete = true;
	                var complete = otherState.complete, buffer = otherState.buffer;
	                complete && emit(buffer.length === 0);
	                sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
	            });
	            return sequenceEqualSubscriber;
	        };
	        source.subscribe(createSubscriber(aState, bState));
	        innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
	    });
	}
	sequenceEqual.sequenceEqual = sequenceEqual$1;
	function createState() {
	    return {
	        buffer: [],
	        complete: false,
	    };
	}
	
	return sequenceEqual;
}

var share = {};

var hasRequiredShare;

function requireShare () {
	if (hasRequiredShare) return share;
	hasRequiredShare = 1;
	var __read = (share && share.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (share && share.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(share, "__esModule", { value: true });
	share.share = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var Subscriber_1 = /*@__PURE__*/ requireSubscriber();
	var lift_1 = /*@__PURE__*/ requireLift();
	function share$1(options) {
	    if (options === void 0) { options = {}; }
	    var _a = options.connector, connector = _a === void 0 ? function () { return new Subject_1.Subject(); } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
	    return function (wrapperSource) {
	        var connection;
	        var resetConnection;
	        var subject;
	        var refCount = 0;
	        var hasCompleted = false;
	        var hasErrored = false;
	        var cancelReset = function () {
	            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
	            resetConnection = undefined;
	        };
	        var reset = function () {
	            cancelReset();
	            connection = subject = undefined;
	            hasCompleted = hasErrored = false;
	        };
	        var resetAndUnsubscribe = function () {
	            var conn = connection;
	            reset();
	            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
	        };
	        return lift_1.operate(function (source, subscriber) {
	            refCount++;
	            if (!hasErrored && !hasCompleted) {
	                cancelReset();
	            }
	            var dest = (subject = subject !== null && subject !== void 0 ? subject : connector());
	            subscriber.add(function () {
	                refCount--;
	                if (refCount === 0 && !hasErrored && !hasCompleted) {
	                    resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
	                }
	            });
	            dest.subscribe(subscriber);
	            if (!connection &&
	                refCount > 0) {
	                connection = new Subscriber_1.SafeSubscriber({
	                    next: function (value) { return dest.next(value); },
	                    error: function (err) {
	                        hasErrored = true;
	                        cancelReset();
	                        resetConnection = handleReset(reset, resetOnError, err);
	                        dest.error(err);
	                    },
	                    complete: function () {
	                        hasCompleted = true;
	                        cancelReset();
	                        resetConnection = handleReset(reset, resetOnComplete);
	                        dest.complete();
	                    },
	                });
	                innerFrom_1.innerFrom(source).subscribe(connection);
	            }
	        })(wrapperSource);
	    };
	}
	share.share = share$1;
	function handleReset(reset, on) {
	    var args = [];
	    for (var _i = 2; _i < arguments.length; _i++) {
	        args[_i - 2] = arguments[_i];
	    }
	    if (on === true) {
	        reset();
	        return;
	    }
	    if (on === false) {
	        return;
	    }
	    var onSubscriber = new Subscriber_1.SafeSubscriber({
	        next: function () {
	            onSubscriber.unsubscribe();
	            reset();
	        },
	    });
	    return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
	}
	
	return share;
}

var shareReplay = {};

var hasRequiredShareReplay;

function requireShareReplay () {
	if (hasRequiredShareReplay) return shareReplay;
	hasRequiredShareReplay = 1;
	Object.defineProperty(shareReplay, "__esModule", { value: true });
	shareReplay.shareReplay = void 0;
	var ReplaySubject_1 = /*@__PURE__*/ requireReplaySubject();
	var share_1 = /*@__PURE__*/ requireShare();
	function shareReplay$1(configOrBufferSize, windowTime, scheduler) {
	    var _a, _b, _c;
	    var bufferSize;
	    var refCount = false;
	    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
	        (_a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler);
	    }
	    else {
	        bufferSize = (configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity);
	    }
	    return share_1.share({
	        connector: function () { return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler); },
	        resetOnError: true,
	        resetOnComplete: false,
	        resetOnRefCountZero: refCount,
	    });
	}
	shareReplay.shareReplay = shareReplay$1;
	
	return shareReplay;
}

var single = {};

var hasRequiredSingle;

function requireSingle () {
	if (hasRequiredSingle) return single;
	hasRequiredSingle = 1;
	Object.defineProperty(single, "__esModule", { value: true });
	single.single = void 0;
	var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
	var SequenceError_1 = /*@__PURE__*/ requireSequenceError();
	var NotFoundError_1 = /*@__PURE__*/ requireNotFoundError();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function single$1(predicate) {
	    return lift_1.operate(function (source, subscriber) {
	        var hasValue = false;
	        var singleValue;
	        var seenValue = false;
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            seenValue = true;
	            if (!predicate || predicate(value, index++, source)) {
	                hasValue && subscriber.error(new SequenceError_1.SequenceError('Too many matching values'));
	                hasValue = true;
	                singleValue = value;
	            }
	        }, function () {
	            if (hasValue) {
	                subscriber.next(singleValue);
	                subscriber.complete();
	            }
	            else {
	                subscriber.error(seenValue ? new NotFoundError_1.NotFoundError('No matching values') : new EmptyError_1.EmptyError());
	            }
	        }));
	    });
	}
	single.single = single$1;
	
	return single;
}

var skip = {};

var hasRequiredSkip;

function requireSkip () {
	if (hasRequiredSkip) return skip;
	hasRequiredSkip = 1;
	Object.defineProperty(skip, "__esModule", { value: true });
	skip.skip = void 0;
	var filter_1 = /*@__PURE__*/ requireFilter$1();
	function skip$1(count) {
	    return filter_1.filter(function (_, index) { return count <= index; });
	}
	skip.skip = skip$1;
	
	return skip;
}

var skipLast = {};

var hasRequiredSkipLast;

function requireSkipLast () {
	if (hasRequiredSkipLast) return skipLast;
	hasRequiredSkipLast = 1;
	Object.defineProperty(skipLast, "__esModule", { value: true });
	skipLast.skipLast = void 0;
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function skipLast$1(skipCount) {
	    return skipCount <= 0
	        ?
	            identity_1.identity
	        : lift_1.operate(function (source, subscriber) {
	            var ring = new Array(skipCount);
	            var seen = 0;
	            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                var valueIndex = seen++;
	                if (valueIndex < skipCount) {
	                    ring[valueIndex] = value;
	                }
	                else {
	                    var index = valueIndex % skipCount;
	                    var oldValue = ring[index];
	                    ring[index] = value;
	                    subscriber.next(oldValue);
	                }
	            }));
	            return function () {
	                ring = null;
	            };
	        });
	}
	skipLast.skipLast = skipLast$1;
	
	return skipLast;
}

var skipUntil = {};

var hasRequiredSkipUntil;

function requireSkipUntil () {
	if (hasRequiredSkipUntil) return skipUntil;
	hasRequiredSkipUntil = 1;
	Object.defineProperty(skipUntil, "__esModule", { value: true });
	skipUntil.skipUntil = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var noop_1 = /*@__PURE__*/ requireNoop();
	function skipUntil$1(notifier) {
	    return lift_1.operate(function (source, subscriber) {
	        var taking = false;
	        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	            skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
	            taking = true;
	        }, noop_1.noop);
	        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return taking && subscriber.next(value); }));
	    });
	}
	skipUntil.skipUntil = skipUntil$1;
	
	return skipUntil;
}

var skipWhile = {};

var hasRequiredSkipWhile;

function requireSkipWhile () {
	if (hasRequiredSkipWhile) return skipWhile;
	hasRequiredSkipWhile = 1;
	Object.defineProperty(skipWhile, "__esModule", { value: true });
	skipWhile.skipWhile = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function skipWhile$1(predicate) {
	    return lift_1.operate(function (source, subscriber) {
	        var taking = false;
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return (taking || (taking = !predicate(value, index++))) && subscriber.next(value); }));
	    });
	}
	skipWhile.skipWhile = skipWhile$1;
	
	return skipWhile;
}

var startWith = {};

var hasRequiredStartWith;

function requireStartWith () {
	if (hasRequiredStartWith) return startWith;
	hasRequiredStartWith = 1;
	Object.defineProperty(startWith, "__esModule", { value: true });
	startWith.startWith = void 0;
	var concat_1 = /*@__PURE__*/ requireConcat$1();
	var args_1 = /*@__PURE__*/ requireArgs();
	var lift_1 = /*@__PURE__*/ requireLift();
	function startWith$1() {
	    var values = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        values[_i] = arguments[_i];
	    }
	    var scheduler = args_1.popScheduler(values);
	    return lift_1.operate(function (source, subscriber) {
	        (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
	    });
	}
	startWith.startWith = startWith$1;
	
	return startWith;
}

var switchAll = {};

var switchMap = {};

var hasRequiredSwitchMap;

function requireSwitchMap () {
	if (hasRequiredSwitchMap) return switchMap;
	hasRequiredSwitchMap = 1;
	Object.defineProperty(switchMap, "__esModule", { value: true });
	switchMap.switchMap = void 0;
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function switchMap$1(project, resultSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var innerSubscriber = null;
	        var index = 0;
	        var isComplete = false;
	        var checkComplete = function () { return isComplete && !innerSubscriber && subscriber.complete(); };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
	            var innerIndex = 0;
	            var outerIndex = index++;
	            innerFrom_1.innerFrom(project(value, outerIndex)).subscribe((innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (innerValue) { return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue); }, function () {
	                innerSubscriber = null;
	                checkComplete();
	            })));
	        }, function () {
	            isComplete = true;
	            checkComplete();
	        }));
	    });
	}
	switchMap.switchMap = switchMap$1;
	
	return switchMap;
}

var hasRequiredSwitchAll;

function requireSwitchAll () {
	if (hasRequiredSwitchAll) return switchAll;
	hasRequiredSwitchAll = 1;
	Object.defineProperty(switchAll, "__esModule", { value: true });
	switchAll.switchAll = void 0;
	var switchMap_1 = /*@__PURE__*/ requireSwitchMap();
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	function switchAll$1() {
	    return switchMap_1.switchMap(identity_1.identity);
	}
	switchAll.switchAll = switchAll$1;
	
	return switchAll;
}

var switchMapTo = {};

var hasRequiredSwitchMapTo;

function requireSwitchMapTo () {
	if (hasRequiredSwitchMapTo) return switchMapTo;
	hasRequiredSwitchMapTo = 1;
	Object.defineProperty(switchMapTo, "__esModule", { value: true });
	switchMapTo.switchMapTo = void 0;
	var switchMap_1 = /*@__PURE__*/ requireSwitchMap();
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	function switchMapTo$1(innerObservable, resultSelector) {
	    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function () { return innerObservable; }, resultSelector) : switchMap_1.switchMap(function () { return innerObservable; });
	}
	switchMapTo.switchMapTo = switchMapTo$1;
	
	return switchMapTo;
}

var switchScan = {};

var hasRequiredSwitchScan;

function requireSwitchScan () {
	if (hasRequiredSwitchScan) return switchScan;
	hasRequiredSwitchScan = 1;
	Object.defineProperty(switchScan, "__esModule", { value: true });
	switchScan.switchScan = void 0;
	var switchMap_1 = /*@__PURE__*/ requireSwitchMap();
	var lift_1 = /*@__PURE__*/ requireLift();
	function switchScan$1(accumulator, seed) {
	    return lift_1.operate(function (source, subscriber) {
	        var state = seed;
	        switchMap_1.switchMap(function (value, index) { return accumulator(state, value, index); }, function (_, innerValue) { return ((state = innerValue), innerValue); })(source).subscribe(subscriber);
	        return function () {
	            state = null;
	        };
	    });
	}
	switchScan.switchScan = switchScan$1;
	
	return switchScan;
}

var takeUntil = {};

var hasRequiredTakeUntil;

function requireTakeUntil () {
	if (hasRequiredTakeUntil) return takeUntil;
	hasRequiredTakeUntil = 1;
	Object.defineProperty(takeUntil, "__esModule", { value: true });
	takeUntil.takeUntil = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var noop_1 = /*@__PURE__*/ requireNoop();
	function takeUntil$1(notifier) {
	    return lift_1.operate(function (source, subscriber) {
	        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () { return subscriber.complete(); }, noop_1.noop));
	        !subscriber.closed && source.subscribe(subscriber);
	    });
	}
	takeUntil.takeUntil = takeUntil$1;
	
	return takeUntil;
}

var takeWhile = {};

var hasRequiredTakeWhile;

function requireTakeWhile () {
	if (hasRequiredTakeWhile) return takeWhile;
	hasRequiredTakeWhile = 1;
	Object.defineProperty(takeWhile, "__esModule", { value: true });
	takeWhile.takeWhile = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function takeWhile$1(predicate, inclusive) {
	    if (inclusive === void 0) { inclusive = false; }
	    return lift_1.operate(function (source, subscriber) {
	        var index = 0;
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var result = predicate(value, index++);
	            (result || inclusive) && subscriber.next(value);
	            !result && subscriber.complete();
	        }));
	    });
	}
	takeWhile.takeWhile = takeWhile$1;
	
	return takeWhile;
}

var tap = {};

var hasRequiredTap;

function requireTap () {
	if (hasRequiredTap) return tap;
	hasRequiredTap = 1;
	Object.defineProperty(tap, "__esModule", { value: true });
	tap.tap = void 0;
	var isFunction_1 = /*@__PURE__*/ requireIsFunction();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	function tap$1(observerOrNext, error, complete) {
	    var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete
	        ?
	            { next: observerOrNext, error: error, complete: complete }
	        : observerOrNext;
	    return tapObserver
	        ? lift_1.operate(function (source, subscriber) {
	            var _a;
	            (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	            var isUnsub = true;
	            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                var _a;
	                (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
	                subscriber.next(value);
	            }, function () {
	                var _a;
	                isUnsub = false;
	                (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	                subscriber.complete();
	            }, function (err) {
	                var _a;
	                isUnsub = false;
	                (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
	                subscriber.error(err);
	            }, function () {
	                var _a, _b;
	                if (isUnsub) {
	                    (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
	                }
	                (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
	            }));
	        })
	        :
	            identity_1.identity;
	}
	tap.tap = tap$1;
	
	return tap;
}

var throttle = {};

var hasRequiredThrottle;

function requireThrottle () {
	if (hasRequiredThrottle) return throttle;
	hasRequiredThrottle = 1;
	Object.defineProperty(throttle, "__esModule", { value: true });
	throttle.throttle = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function throttle$1(durationSelector, config) {
	    return lift_1.operate(function (source, subscriber) {
	        var _a = config !== null && config !== void 0 ? config : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
	        var hasValue = false;
	        var sendValue = null;
	        var throttled = null;
	        var isComplete = false;
	        var endThrottling = function () {
	            throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
	            throttled = null;
	            if (trailing) {
	                send();
	                isComplete && subscriber.complete();
	            }
	        };
	        var cleanupThrottling = function () {
	            throttled = null;
	            isComplete && subscriber.complete();
	        };
	        var startThrottle = function (value) {
	            return (throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));
	        };
	        var send = function () {
	            if (hasValue) {
	                hasValue = false;
	                var value = sendValue;
	                sendValue = null;
	                subscriber.next(value);
	                !isComplete && startThrottle(value);
	            }
	        };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            hasValue = true;
	            sendValue = value;
	            !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
	        }, function () {
	            isComplete = true;
	            !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
	        }));
	    });
	}
	throttle.throttle = throttle$1;
	
	return throttle;
}

var throttleTime = {};

var hasRequiredThrottleTime;

function requireThrottleTime () {
	if (hasRequiredThrottleTime) return throttleTime;
	hasRequiredThrottleTime = 1;
	Object.defineProperty(throttleTime, "__esModule", { value: true });
	throttleTime.throttleTime = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var throttle_1 = /*@__PURE__*/ requireThrottle();
	var timer_1 = /*@__PURE__*/ requireTimer();
	function throttleTime$1(duration, scheduler, config) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    var duration$ = timer_1.timer(duration, scheduler);
	    return throttle_1.throttle(function () { return duration$; }, config);
	}
	throttleTime.throttleTime = throttleTime$1;
	
	return throttleTime;
}

var timeInterval = {};

var hasRequiredTimeInterval;

function requireTimeInterval () {
	if (hasRequiredTimeInterval) return timeInterval;
	hasRequiredTimeInterval = 1;
	Object.defineProperty(timeInterval, "__esModule", { value: true });
	timeInterval.TimeInterval = timeInterval.timeInterval = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function timeInterval$1(scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.asyncScheduler; }
	    return lift_1.operate(function (source, subscriber) {
	        var last = scheduler.now();
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var now = scheduler.now();
	            var interval = now - last;
	            last = now;
	            subscriber.next(new TimeInterval(value, interval));
	        }));
	    });
	}
	timeInterval.timeInterval = timeInterval$1;
	var TimeInterval = (function () {
	    function TimeInterval(value, interval) {
	        this.value = value;
	        this.interval = interval;
	    }
	    return TimeInterval;
	}());
	timeInterval.TimeInterval = TimeInterval;
	
	return timeInterval;
}

var timeoutWith = {};

var hasRequiredTimeoutWith;

function requireTimeoutWith () {
	if (hasRequiredTimeoutWith) return timeoutWith;
	hasRequiredTimeoutWith = 1;
	Object.defineProperty(timeoutWith, "__esModule", { value: true });
	timeoutWith.timeoutWith = void 0;
	var async_1 = /*@__PURE__*/ requireAsync();
	var isDate_1 = /*@__PURE__*/ requireIsDate();
	var timeout_1 = /*@__PURE__*/ requireTimeout();
	function timeoutWith$1(due, withObservable, scheduler) {
	    var first;
	    var each;
	    var _with;
	    scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
	    if (isDate_1.isValidDate(due)) {
	        first = due;
	    }
	    else if (typeof due === 'number') {
	        each = due;
	    }
	    if (withObservable) {
	        _with = function () { return withObservable; };
	    }
	    else {
	        throw new TypeError('No observable provided to switch to');
	    }
	    if (first == null && each == null) {
	        throw new TypeError('No timeout provided.');
	    }
	    return timeout_1.timeout({
	        first: first,
	        each: each,
	        scheduler: scheduler,
	        with: _with,
	    });
	}
	timeoutWith.timeoutWith = timeoutWith$1;
	
	return timeoutWith;
}

var timestamp = {};

var hasRequiredTimestamp;

function requireTimestamp () {
	if (hasRequiredTimestamp) return timestamp;
	hasRequiredTimestamp = 1;
	Object.defineProperty(timestamp, "__esModule", { value: true });
	timestamp.timestamp = void 0;
	var dateTimestampProvider_1 = /*@__PURE__*/ requireDateTimestampProvider();
	var map_1 = /*@__PURE__*/ requireMap$1();
	function timestamp$1(timestampProvider) {
	    if (timestampProvider === void 0) { timestampProvider = dateTimestampProvider_1.dateTimestampProvider; }
	    return map_1.map(function (value) { return ({ value: value, timestamp: timestampProvider.now() }); });
	}
	timestamp.timestamp = timestamp$1;
	
	return timestamp;
}

var window$1 = {};

var hasRequiredWindow;

function requireWindow () {
	if (hasRequiredWindow) return window$1;
	hasRequiredWindow = 1;
	Object.defineProperty(window$1, "__esModule", { value: true });
	window$1.window = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function window(windowBoundaries) {
	    return lift_1.operate(function (source, subscriber) {
	        var windowSubject = new Subject_1.Subject();
	        subscriber.next(windowSubject.asObservable());
	        var errorHandler = function (err) {
	            windowSubject.error(err);
	            subscriber.error(err);
	        };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value); }, function () {
	            windowSubject.complete();
	            subscriber.complete();
	        }, errorHandler));
	        innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function () {
	            windowSubject.complete();
	            subscriber.next((windowSubject = new Subject_1.Subject()));
	        }, noop_1.noop, errorHandler));
	        return function () {
	            windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
	            windowSubject = null;
	        };
	    });
	}
	window$1.window = window;
	
	return window$1;
}

var windowCount = {};

var hasRequiredWindowCount;

function requireWindowCount () {
	if (hasRequiredWindowCount) return windowCount;
	hasRequiredWindowCount = 1;
	var __values = (windowCount && windowCount.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(windowCount, "__esModule", { value: true });
	windowCount.windowCount = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	function windowCount$1(windowSize, startWindowEvery) {
	    if (startWindowEvery === void 0) { startWindowEvery = 0; }
	    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
	    return lift_1.operate(function (source, subscriber) {
	        var windows = [new Subject_1.Subject()];
	        var count = 0;
	        subscriber.next(windows[0].asObservable());
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            try {
	                for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
	                    var window_1 = windows_1_1.value;
	                    window_1.next(value);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            var c = count - windowSize + 1;
	            if (c >= 0 && c % startEvery === 0) {
	                windows.shift().complete();
	            }
	            if (++count % startEvery === 0) {
	                var window_2 = new Subject_1.Subject();
	                windows.push(window_2);
	                subscriber.next(window_2.asObservable());
	            }
	        }, function () {
	            while (windows.length > 0) {
	                windows.shift().complete();
	            }
	            subscriber.complete();
	        }, function (err) {
	            while (windows.length > 0) {
	                windows.shift().error(err);
	            }
	            subscriber.error(err);
	        }, function () {
	            windows = null;
	        }));
	    });
	}
	windowCount.windowCount = windowCount$1;
	
	return windowCount;
}

var windowTime = {};

var hasRequiredWindowTime;

function requireWindowTime () {
	if (hasRequiredWindowTime) return windowTime;
	hasRequiredWindowTime = 1;
	Object.defineProperty(windowTime, "__esModule", { value: true });
	windowTime.windowTime = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var async_1 = /*@__PURE__*/ requireAsync();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	var args_1 = /*@__PURE__*/ requireArgs();
	var executeSchedule_1 = /*@__PURE__*/ requireExecuteSchedule();
	function windowTime$1(windowTimeSpan) {
	    var _a, _b;
	    var otherArgs = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        otherArgs[_i - 1] = arguments[_i];
	    }
	    var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
	    var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
	    var maxWindowSize = otherArgs[1] || Infinity;
	    return lift_1.operate(function (source, subscriber) {
	        var windowRecords = [];
	        var restartOnClose = false;
	        var closeWindow = function (record) {
	            var window = record.window, subs = record.subs;
	            window.complete();
	            subs.unsubscribe();
	            arrRemove_1.arrRemove(windowRecords, record);
	            restartOnClose && startWindow();
	        };
	        var startWindow = function () {
	            if (windowRecords) {
	                var subs = new Subscription_1.Subscription();
	                subscriber.add(subs);
	                var window_1 = new Subject_1.Subject();
	                var record_1 = {
	                    window: window_1,
	                    subs: subs,
	                    seen: 0,
	                };
	                windowRecords.push(record_1);
	                subscriber.next(window_1.asObservable());
	                executeSchedule_1.executeSchedule(subs, scheduler, function () { return closeWindow(record_1); }, windowTimeSpan);
	            }
	        };
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
	        }
	        else {
	            restartOnClose = true;
	        }
	        startWindow();
	        var loop = function (cb) { return windowRecords.slice().forEach(cb); };
	        var terminate = function (cb) {
	            loop(function (_a) {
	                var window = _a.window;
	                return cb(window);
	            });
	            cb(subscriber);
	            subscriber.unsubscribe();
	        };
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            loop(function (record) {
	                record.window.next(value);
	                maxWindowSize <= ++record.seen && closeWindow(record);
	            });
	        }, function () { return terminate(function (consumer) { return consumer.complete(); }); }, function (err) { return terminate(function (consumer) { return consumer.error(err); }); }));
	        return function () {
	            windowRecords = null;
	        };
	    });
	}
	windowTime.windowTime = windowTime$1;
	
	return windowTime;
}

var windowToggle = {};

var hasRequiredWindowToggle;

function requireWindowToggle () {
	if (hasRequiredWindowToggle) return windowToggle;
	hasRequiredWindowToggle = 1;
	var __values = (windowToggle && windowToggle.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	Object.defineProperty(windowToggle, "__esModule", { value: true });
	windowToggle.windowToggle = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var Subscription_1 = /*@__PURE__*/ requireSubscription();
	var lift_1 = /*@__PURE__*/ requireLift();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var arrRemove_1 = /*@__PURE__*/ requireArrRemove();
	function windowToggle$1(openings, closingSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var windows = [];
	        var handleError = function (err) {
	            while (0 < windows.length) {
	                windows.shift().error(err);
	            }
	            subscriber.error(err);
	        };
	        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (openValue) {
	            var window = new Subject_1.Subject();
	            windows.push(window);
	            var closingSubscription = new Subscription_1.Subscription();
	            var closeWindow = function () {
	                arrRemove_1.arrRemove(windows, window);
	                window.complete();
	                closingSubscription.unsubscribe();
	            };
	            var closingNotifier;
	            try {
	                closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
	            }
	            catch (err) {
	                handleError(err);
	                return;
	            }
	            subscriber.next(window.asObservable());
	            closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
	        }, noop_1.noop));
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            var e_1, _a;
	            var windowsCopy = windows.slice();
	            try {
	                for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
	                    var window_1 = windowsCopy_1_1.value;
	                    window_1.next(value);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }, function () {
	            while (0 < windows.length) {
	                windows.shift().complete();
	            }
	            subscriber.complete();
	        }, handleError, function () {
	            while (0 < windows.length) {
	                windows.shift().unsubscribe();
	            }
	        }));
	    });
	}
	windowToggle.windowToggle = windowToggle$1;
	
	return windowToggle;
}

var windowWhen = {};

var hasRequiredWindowWhen;

function requireWindowWhen () {
	if (hasRequiredWindowWhen) return windowWhen;
	hasRequiredWindowWhen = 1;
	Object.defineProperty(windowWhen, "__esModule", { value: true });
	windowWhen.windowWhen = void 0;
	var Subject_1 = /*@__PURE__*/ requireSubject();
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	function windowWhen$1(closingSelector) {
	    return lift_1.operate(function (source, subscriber) {
	        var window;
	        var closingSubscriber;
	        var handleError = function (err) {
	            window.error(err);
	            subscriber.error(err);
	        };
	        var openWindow = function () {
	            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	            window === null || window === void 0 ? void 0 : window.complete();
	            window = new Subject_1.Subject();
	            subscriber.next(window.asObservable());
	            var closingNotifier;
	            try {
	                closingNotifier = innerFrom_1.innerFrom(closingSelector());
	            }
	            catch (err) {
	                handleError(err);
	                return;
	            }
	            closingNotifier.subscribe((closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));
	        };
	        openWindow();
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) { return window.next(value); }, function () {
	            window.complete();
	            subscriber.complete();
	        }, handleError, function () {
	            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
	            window = null;
	        }));
	    });
	}
	windowWhen.windowWhen = windowWhen$1;
	
	return windowWhen;
}

var withLatestFrom = {};

var hasRequiredWithLatestFrom;

function requireWithLatestFrom () {
	if (hasRequiredWithLatestFrom) return withLatestFrom;
	hasRequiredWithLatestFrom = 1;
	var __read = (withLatestFrom && withLatestFrom.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (withLatestFrom && withLatestFrom.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(withLatestFrom, "__esModule", { value: true });
	withLatestFrom.withLatestFrom = void 0;
	var lift_1 = /*@__PURE__*/ requireLift();
	var OperatorSubscriber_1 = /*@__PURE__*/ requireOperatorSubscriber();
	var innerFrom_1 = /*@__PURE__*/ requireInnerFrom();
	var identity_1 = /*@__PURE__*/ requireIdentity$1();
	var noop_1 = /*@__PURE__*/ requireNoop();
	var args_1 = /*@__PURE__*/ requireArgs();
	function withLatestFrom$1() {
	    var inputs = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        inputs[_i] = arguments[_i];
	    }
	    var project = args_1.popResultSelector(inputs);
	    return lift_1.operate(function (source, subscriber) {
	        var len = inputs.length;
	        var otherValues = new Array(len);
	        var hasValue = inputs.map(function () { return false; });
	        var ready = false;
	        var _loop_1 = function (i) {
	            innerFrom_1.innerFrom(inputs[i]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	                otherValues[i] = value;
	                if (!ready && !hasValue[i]) {
	                    hasValue[i] = true;
	                    (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
	                }
	            }, noop_1.noop));
	        };
	        for (var i = 0; i < len; i++) {
	            _loop_1(i);
	        }
	        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function (value) {
	            if (ready) {
	                var values = __spreadArray([value], __read(otherValues));
	                subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
	            }
	        }));
	    });
	}
	withLatestFrom.withLatestFrom = withLatestFrom$1;
	
	return withLatestFrom;
}

var zipAll = {};

var hasRequiredZipAll;

function requireZipAll () {
	if (hasRequiredZipAll) return zipAll;
	hasRequiredZipAll = 1;
	Object.defineProperty(zipAll, "__esModule", { value: true });
	zipAll.zipAll = void 0;
	var zip_1 = /*@__PURE__*/ requireZip$1();
	var joinAllInternals_1 = /*@__PURE__*/ requireJoinAllInternals();
	function zipAll$1(project) {
	    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
	}
	zipAll.zipAll = zipAll$1;
	
	return zipAll;
}

var zipWith = {};

var zip = {};

var hasRequiredZip;

function requireZip () {
	if (hasRequiredZip) return zip;
	hasRequiredZip = 1;
	var __read = (zip && zip.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (zip && zip.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(zip, "__esModule", { value: true });
	zip.zip = void 0;
	var zip_1 = /*@__PURE__*/ requireZip$1();
	var lift_1 = /*@__PURE__*/ requireLift();
	function zip$1() {
	    var sources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        sources[_i] = arguments[_i];
	    }
	    return lift_1.operate(function (source, subscriber) {
	        zip_1.zip.apply(void 0, __spreadArray([source], __read(sources))).subscribe(subscriber);
	    });
	}
	zip.zip = zip$1;
	
	return zip;
}

var hasRequiredZipWith;

function requireZipWith () {
	if (hasRequiredZipWith) return zipWith;
	hasRequiredZipWith = 1;
	var __read = (zipWith && zipWith.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (zipWith && zipWith.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(zipWith, "__esModule", { value: true });
	zipWith.zipWith = void 0;
	var zip_1 = /*@__PURE__*/ requireZip();
	function zipWith$1() {
	    var otherInputs = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        otherInputs[_i] = arguments[_i];
	    }
	    return zip_1.zip.apply(void 0, __spreadArray([], __read(otherInputs)));
	}
	zipWith.zipWith = zipWith$1;
	
	return zipWith;
}

var hasRequiredCjs$1;

function requireCjs$1 () {
	if (hasRequiredCjs$1) return cjs;
	hasRequiredCjs$1 = 1;
	(function (exports) {
		var __createBinding = (cjs && cjs.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (cjs && cjs.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
		exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
		exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
		exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
		var Observable_1 = /*@__PURE__*/ requireObservable();
		Object.defineProperty(exports, "Observable", { enumerable: true, get: function () { return Observable_1.Observable; } });
		var ConnectableObservable_1 = /*@__PURE__*/ requireConnectableObservable();
		Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function () { return ConnectableObservable_1.ConnectableObservable; } });
		var observable_1 = /*@__PURE__*/ requireObservable$1();
		Object.defineProperty(exports, "observable", { enumerable: true, get: function () { return observable_1.observable; } });
		var animationFrames_1 = /*@__PURE__*/ requireAnimationFrames();
		Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function () { return animationFrames_1.animationFrames; } });
		var Subject_1 = /*@__PURE__*/ requireSubject();
		Object.defineProperty(exports, "Subject", { enumerable: true, get: function () { return Subject_1.Subject; } });
		var BehaviorSubject_1 = /*@__PURE__*/ requireBehaviorSubject();
		Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function () { return BehaviorSubject_1.BehaviorSubject; } });
		var ReplaySubject_1 = /*@__PURE__*/ requireReplaySubject();
		Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function () { return ReplaySubject_1.ReplaySubject; } });
		var AsyncSubject_1 = /*@__PURE__*/ requireAsyncSubject();
		Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function () { return AsyncSubject_1.AsyncSubject; } });
		var asap_1 = /*@__PURE__*/ requireAsap();
		Object.defineProperty(exports, "asap", { enumerable: true, get: function () { return asap_1.asap; } });
		Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function () { return asap_1.asapScheduler; } });
		var async_1 = /*@__PURE__*/ requireAsync();
		Object.defineProperty(exports, "async", { enumerable: true, get: function () { return async_1.async; } });
		Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function () { return async_1.asyncScheduler; } });
		var queue_1 = /*@__PURE__*/ requireQueue();
		Object.defineProperty(exports, "queue", { enumerable: true, get: function () { return queue_1.queue; } });
		Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function () { return queue_1.queueScheduler; } });
		var animationFrame_1 = /*@__PURE__*/ requireAnimationFrame();
		Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function () { return animationFrame_1.animationFrame; } });
		Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function () { return animationFrame_1.animationFrameScheduler; } });
		var VirtualTimeScheduler_1 = /*@__PURE__*/ requireVirtualTimeScheduler();
		Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualTimeScheduler; } });
		Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function () { return VirtualTimeScheduler_1.VirtualAction; } });
		var Scheduler_1 = /*@__PURE__*/ requireScheduler();
		Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function () { return Scheduler_1.Scheduler; } });
		var Subscription_1 = /*@__PURE__*/ requireSubscription();
		Object.defineProperty(exports, "Subscription", { enumerable: true, get: function () { return Subscription_1.Subscription; } });
		var Subscriber_1 = /*@__PURE__*/ requireSubscriber();
		Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function () { return Subscriber_1.Subscriber; } });
		var Notification_1 = /*@__PURE__*/ requireNotification();
		Object.defineProperty(exports, "Notification", { enumerable: true, get: function () { return Notification_1.Notification; } });
		Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function () { return Notification_1.NotificationKind; } });
		var pipe_1 = /*@__PURE__*/ requirePipe();
		Object.defineProperty(exports, "pipe", { enumerable: true, get: function () { return pipe_1.pipe; } });
		var noop_1 = /*@__PURE__*/ requireNoop();
		Object.defineProperty(exports, "noop", { enumerable: true, get: function () { return noop_1.noop; } });
		var identity_1 = /*@__PURE__*/ requireIdentity$1();
		Object.defineProperty(exports, "identity", { enumerable: true, get: function () { return identity_1.identity; } });
		var isObservable_1 = /*@__PURE__*/ requireIsObservable();
		Object.defineProperty(exports, "isObservable", { enumerable: true, get: function () { return isObservable_1.isObservable; } });
		var lastValueFrom_1 = /*@__PURE__*/ requireLastValueFrom();
		Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function () { return lastValueFrom_1.lastValueFrom; } });
		var firstValueFrom_1 = /*@__PURE__*/ requireFirstValueFrom();
		Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function () { return firstValueFrom_1.firstValueFrom; } });
		var ArgumentOutOfRangeError_1 = /*@__PURE__*/ requireArgumentOutOfRangeError();
		Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function () { return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError; } });
		var EmptyError_1 = /*@__PURE__*/ requireEmptyError();
		Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function () { return EmptyError_1.EmptyError; } });
		var NotFoundError_1 = /*@__PURE__*/ requireNotFoundError();
		Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function () { return NotFoundError_1.NotFoundError; } });
		var ObjectUnsubscribedError_1 = /*@__PURE__*/ requireObjectUnsubscribedError();
		Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function () { return ObjectUnsubscribedError_1.ObjectUnsubscribedError; } });
		var SequenceError_1 = /*@__PURE__*/ requireSequenceError();
		Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function () { return SequenceError_1.SequenceError; } });
		var timeout_1 = /*@__PURE__*/ requireTimeout();
		Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function () { return timeout_1.TimeoutError; } });
		var UnsubscriptionError_1 = /*@__PURE__*/ requireUnsubscriptionError();
		Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function () { return UnsubscriptionError_1.UnsubscriptionError; } });
		var bindCallback_1 = /*@__PURE__*/ requireBindCallback();
		Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function () { return bindCallback_1.bindCallback; } });
		var bindNodeCallback_1 = /*@__PURE__*/ requireBindNodeCallback();
		Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function () { return bindNodeCallback_1.bindNodeCallback; } });
		var combineLatest_1 = /*@__PURE__*/ requireCombineLatest$1();
		Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function () { return combineLatest_1.combineLatest; } });
		var concat_1 = /*@__PURE__*/ requireConcat$1();
		Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_1.concat; } });
		var connectable_1 = /*@__PURE__*/ requireConnectable();
		Object.defineProperty(exports, "connectable", { enumerable: true, get: function () { return connectable_1.connectable; } });
		var defer_1 = /*@__PURE__*/ requireDefer();
		Object.defineProperty(exports, "defer", { enumerable: true, get: function () { return defer_1.defer; } });
		var empty_1 = /*@__PURE__*/ requireEmpty();
		Object.defineProperty(exports, "empty", { enumerable: true, get: function () { return empty_1.empty; } });
		var forkJoin_1 = /*@__PURE__*/ requireForkJoin();
		Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function () { return forkJoin_1.forkJoin; } });
		var from_1 = /*@__PURE__*/ requireFrom$1();
		Object.defineProperty(exports, "from", { enumerable: true, get: function () { return from_1.from; } });
		var fromEvent_1 = /*@__PURE__*/ requireFromEvent();
		Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function () { return fromEvent_1.fromEvent; } });
		var fromEventPattern_1 = /*@__PURE__*/ requireFromEventPattern();
		Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function () { return fromEventPattern_1.fromEventPattern; } });
		var generate_1 = /*@__PURE__*/ requireGenerate();
		Object.defineProperty(exports, "generate", { enumerable: true, get: function () { return generate_1.generate; } });
		var iif_1 = /*@__PURE__*/ requireIif();
		Object.defineProperty(exports, "iif", { enumerable: true, get: function () { return iif_1.iif; } });
		var interval_1 = /*@__PURE__*/ requireInterval();
		Object.defineProperty(exports, "interval", { enumerable: true, get: function () { return interval_1.interval; } });
		var merge_1 = /*@__PURE__*/ requireMerge$1();
		Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return merge_1.merge; } });
		var never_1 = /*@__PURE__*/ requireNever();
		Object.defineProperty(exports, "never", { enumerable: true, get: function () { return never_1.never; } });
		var of_1 = /*@__PURE__*/ requireOf();
		Object.defineProperty(exports, "of", { enumerable: true, get: function () { return of_1.of; } });
		var onErrorResumeNext_1 = /*@__PURE__*/ requireOnErrorResumeNext();
		Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function () { return onErrorResumeNext_1.onErrorResumeNext; } });
		var pairs_1 = /*@__PURE__*/ requirePairs();
		Object.defineProperty(exports, "pairs", { enumerable: true, get: function () { return pairs_1.pairs; } });
		var partition_1 = /*@__PURE__*/ requirePartition$1();
		Object.defineProperty(exports, "partition", { enumerable: true, get: function () { return partition_1.partition; } });
		var race_1 = /*@__PURE__*/ requireRace$1();
		Object.defineProperty(exports, "race", { enumerable: true, get: function () { return race_1.race; } });
		var range_1 = /*@__PURE__*/ requireRange();
		Object.defineProperty(exports, "range", { enumerable: true, get: function () { return range_1.range; } });
		var throwError_1 = /*@__PURE__*/ requireThrowError();
		Object.defineProperty(exports, "throwError", { enumerable: true, get: function () { return throwError_1.throwError; } });
		var timer_1 = /*@__PURE__*/ requireTimer();
		Object.defineProperty(exports, "timer", { enumerable: true, get: function () { return timer_1.timer; } });
		var using_1 = /*@__PURE__*/ requireUsing();
		Object.defineProperty(exports, "using", { enumerable: true, get: function () { return using_1.using; } });
		var zip_1 = /*@__PURE__*/ requireZip$1();
		Object.defineProperty(exports, "zip", { enumerable: true, get: function () { return zip_1.zip; } });
		var scheduled_1 = /*@__PURE__*/ requireScheduled();
		Object.defineProperty(exports, "scheduled", { enumerable: true, get: function () { return scheduled_1.scheduled; } });
		var empty_2 = /*@__PURE__*/ requireEmpty();
		Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function () { return empty_2.EMPTY; } });
		var never_2 = /*@__PURE__*/ requireNever();
		Object.defineProperty(exports, "NEVER", { enumerable: true, get: function () { return never_2.NEVER; } });
		__exportStar(/*@__PURE__*/ requireTypes(), exports);
		var config_1 = /*@__PURE__*/ requireConfig();
		Object.defineProperty(exports, "config", { enumerable: true, get: function () { return config_1.config; } });
		var audit_1 = /*@__PURE__*/ requireAudit();
		Object.defineProperty(exports, "audit", { enumerable: true, get: function () { return audit_1.audit; } });
		var auditTime_1 = /*@__PURE__*/ requireAuditTime();
		Object.defineProperty(exports, "auditTime", { enumerable: true, get: function () { return auditTime_1.auditTime; } });
		var buffer_1 = /*@__PURE__*/ requireBuffer();
		Object.defineProperty(exports, "buffer", { enumerable: true, get: function () { return buffer_1.buffer; } });
		var bufferCount_1 = /*@__PURE__*/ requireBufferCount();
		Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function () { return bufferCount_1.bufferCount; } });
		var bufferTime_1 = /*@__PURE__*/ requireBufferTime();
		Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function () { return bufferTime_1.bufferTime; } });
		var bufferToggle_1 = /*@__PURE__*/ requireBufferToggle();
		Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } });
		var bufferWhen_1 = /*@__PURE__*/ requireBufferWhen();
		Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } });
		var catchError_1 = /*@__PURE__*/ requireCatchError();
		Object.defineProperty(exports, "catchError", { enumerable: true, get: function () { return catchError_1.catchError; } });
		var combineAll_1 = /*@__PURE__*/ requireCombineAll();
		Object.defineProperty(exports, "combineAll", { enumerable: true, get: function () { return combineAll_1.combineAll; } });
		var combineLatestAll_1 = /*@__PURE__*/ requireCombineLatestAll();
		Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } });
		var combineLatestWith_1 = /*@__PURE__*/ requireCombineLatestWith();
		Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } });
		var concatAll_1 = /*@__PURE__*/ requireConcatAll();
		Object.defineProperty(exports, "concatAll", { enumerable: true, get: function () { return concatAll_1.concatAll; } });
		var concatMap_1 = /*@__PURE__*/ requireConcatMap();
		Object.defineProperty(exports, "concatMap", { enumerable: true, get: function () { return concatMap_1.concatMap; } });
		var concatMapTo_1 = /*@__PURE__*/ requireConcatMapTo();
		Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } });
		var concatWith_1 = /*@__PURE__*/ requireConcatWith();
		Object.defineProperty(exports, "concatWith", { enumerable: true, get: function () { return concatWith_1.concatWith; } });
		var connect_1 = /*@__PURE__*/ requireConnect();
		Object.defineProperty(exports, "connect", { enumerable: true, get: function () { return connect_1.connect; } });
		var count_1 = /*@__PURE__*/ requireCount();
		Object.defineProperty(exports, "count", { enumerable: true, get: function () { return count_1.count; } });
		var debounce_1 = /*@__PURE__*/ requireDebounce();
		Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return debounce_1.debounce; } });
		var debounceTime_1 = /*@__PURE__*/ requireDebounceTime();
		Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function () { return debounceTime_1.debounceTime; } });
		var defaultIfEmpty_1 = /*@__PURE__*/ requireDefaultIfEmpty();
		Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } });
		var delay_1 = /*@__PURE__*/ requireDelay();
		Object.defineProperty(exports, "delay", { enumerable: true, get: function () { return delay_1.delay; } });
		var delayWhen_1 = /*@__PURE__*/ requireDelayWhen();
		Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function () { return delayWhen_1.delayWhen; } });
		var dematerialize_1 = /*@__PURE__*/ requireDematerialize();
		Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function () { return dematerialize_1.dematerialize; } });
		var distinct_1 = /*@__PURE__*/ requireDistinct();
		Object.defineProperty(exports, "distinct", { enumerable: true, get: function () { return distinct_1.distinct; } });
		var distinctUntilChanged_1 = /*@__PURE__*/ requireDistinctUntilChanged();
		Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } });
		var distinctUntilKeyChanged_1 = /*@__PURE__*/ requireDistinctUntilKeyChanged();
		Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } });
		var elementAt_1 = /*@__PURE__*/ requireElementAt();
		Object.defineProperty(exports, "elementAt", { enumerable: true, get: function () { return elementAt_1.elementAt; } });
		var endWith_1 = /*@__PURE__*/ requireEndWith();
		Object.defineProperty(exports, "endWith", { enumerable: true, get: function () { return endWith_1.endWith; } });
		var every_1 = /*@__PURE__*/ requireEvery();
		Object.defineProperty(exports, "every", { enumerable: true, get: function () { return every_1.every; } });
		var exhaust_1 = /*@__PURE__*/ requireExhaust();
		Object.defineProperty(exports, "exhaust", { enumerable: true, get: function () { return exhaust_1.exhaust; } });
		var exhaustAll_1 = /*@__PURE__*/ requireExhaustAll();
		Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } });
		var exhaustMap_1 = /*@__PURE__*/ requireExhaustMap();
		Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } });
		var expand_1 = /*@__PURE__*/ requireExpand$1();
		Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_1.expand; } });
		var filter_1 = /*@__PURE__*/ requireFilter$1();
		Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return filter_1.filter; } });
		var finalize_1 = /*@__PURE__*/ requireFinalize();
		Object.defineProperty(exports, "finalize", { enumerable: true, get: function () { return finalize_1.finalize; } });
		var find_1 = /*@__PURE__*/ requireFind();
		Object.defineProperty(exports, "find", { enumerable: true, get: function () { return find_1.find; } });
		var findIndex_1 = /*@__PURE__*/ requireFindIndex();
		Object.defineProperty(exports, "findIndex", { enumerable: true, get: function () { return findIndex_1.findIndex; } });
		var first_1 = /*@__PURE__*/ requireFirst();
		Object.defineProperty(exports, "first", { enumerable: true, get: function () { return first_1.first; } });
		var groupBy_1 = /*@__PURE__*/ requireGroupBy();
		Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return groupBy_1.groupBy; } });
		var ignoreElements_1 = /*@__PURE__*/ requireIgnoreElements();
		Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } });
		var isEmpty_1 = /*@__PURE__*/ requireIsEmpty();
		Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return isEmpty_1.isEmpty; } });
		var last_1 = /*@__PURE__*/ requireLast();
		Object.defineProperty(exports, "last", { enumerable: true, get: function () { return last_1.last; } });
		var map_1 = /*@__PURE__*/ requireMap$1();
		Object.defineProperty(exports, "map", { enumerable: true, get: function () { return map_1.map; } });
		var mapTo_1 = /*@__PURE__*/ requireMapTo();
		Object.defineProperty(exports, "mapTo", { enumerable: true, get: function () { return mapTo_1.mapTo; } });
		var materialize_1 = /*@__PURE__*/ requireMaterialize();
		Object.defineProperty(exports, "materialize", { enumerable: true, get: function () { return materialize_1.materialize; } });
		var max_1 = /*@__PURE__*/ requireMax();
		Object.defineProperty(exports, "max", { enumerable: true, get: function () { return max_1.max; } });
		var mergeAll_1 = /*@__PURE__*/ requireMergeAll();
		Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function () { return mergeAll_1.mergeAll; } });
		var flatMap_1 = /*@__PURE__*/ requireFlatMap();
		Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatMap_1.flatMap; } });
		var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
		Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function () { return mergeMap_1.mergeMap; } });
		var mergeMapTo_1 = /*@__PURE__*/ requireMergeMapTo();
		Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } });
		var mergeScan_1 = /*@__PURE__*/ requireMergeScan();
		Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function () { return mergeScan_1.mergeScan; } });
		var mergeWith_1 = /*@__PURE__*/ requireMergeWith();
		Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function () { return mergeWith_1.mergeWith; } });
		var min_1 = /*@__PURE__*/ requireMin();
		Object.defineProperty(exports, "min", { enumerable: true, get: function () { return min_1.min; } });
		var multicast_1 = /*@__PURE__*/ requireMulticast();
		Object.defineProperty(exports, "multicast", { enumerable: true, get: function () { return multicast_1.multicast; } });
		var observeOn_1 = /*@__PURE__*/ requireObserveOn();
		Object.defineProperty(exports, "observeOn", { enumerable: true, get: function () { return observeOn_1.observeOn; } });
		var onErrorResumeNextWith_1 = /*@__PURE__*/ requireOnErrorResumeNextWith();
		Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNextWith; } });
		var pairwise_1 = /*@__PURE__*/ requirePairwise();
		Object.defineProperty(exports, "pairwise", { enumerable: true, get: function () { return pairwise_1.pairwise; } });
		var pluck_1 = /*@__PURE__*/ requirePluck();
		Object.defineProperty(exports, "pluck", { enumerable: true, get: function () { return pluck_1.pluck; } });
		var publish_1 = /*@__PURE__*/ requirePublish();
		Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
		var publishBehavior_1 = /*@__PURE__*/ requirePublishBehavior();
		Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } });
		var publishLast_1 = /*@__PURE__*/ requirePublishLast();
		Object.defineProperty(exports, "publishLast", { enumerable: true, get: function () { return publishLast_1.publishLast; } });
		var publishReplay_1 = /*@__PURE__*/ requirePublishReplay();
		Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function () { return publishReplay_1.publishReplay; } });
		var raceWith_1 = /*@__PURE__*/ requireRaceWith();
		Object.defineProperty(exports, "raceWith", { enumerable: true, get: function () { return raceWith_1.raceWith; } });
		var reduce_1 = /*@__PURE__*/ requireReduce();
		Object.defineProperty(exports, "reduce", { enumerable: true, get: function () { return reduce_1.reduce; } });
		var repeat_1 = /*@__PURE__*/ requireRepeat();
		Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return repeat_1.repeat; } });
		var repeatWhen_1 = /*@__PURE__*/ requireRepeatWhen();
		Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } });
		var retry_1 = /*@__PURE__*/ requireRetry();
		Object.defineProperty(exports, "retry", { enumerable: true, get: function () { return retry_1.retry; } });
		var retryWhen_1 = /*@__PURE__*/ requireRetryWhen();
		Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function () { return retryWhen_1.retryWhen; } });
		var refCount_1 = /*@__PURE__*/ requireRefCount();
		Object.defineProperty(exports, "refCount", { enumerable: true, get: function () { return refCount_1.refCount; } });
		var sample_1 = /*@__PURE__*/ requireSample();
		Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return sample_1.sample; } });
		var sampleTime_1 = /*@__PURE__*/ requireSampleTime();
		Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function () { return sampleTime_1.sampleTime; } });
		var scan_1 = /*@__PURE__*/ requireScan();
		Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scan_1.scan; } });
		var sequenceEqual_1 = /*@__PURE__*/ requireSequenceEqual();
		Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } });
		var share_1 = /*@__PURE__*/ requireShare();
		Object.defineProperty(exports, "share", { enumerable: true, get: function () { return share_1.share; } });
		var shareReplay_1 = /*@__PURE__*/ requireShareReplay();
		Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function () { return shareReplay_1.shareReplay; } });
		var single_1 = /*@__PURE__*/ requireSingle();
		Object.defineProperty(exports, "single", { enumerable: true, get: function () { return single_1.single; } });
		var skip_1 = /*@__PURE__*/ requireSkip();
		Object.defineProperty(exports, "skip", { enumerable: true, get: function () { return skip_1.skip; } });
		var skipLast_1 = /*@__PURE__*/ requireSkipLast();
		Object.defineProperty(exports, "skipLast", { enumerable: true, get: function () { return skipLast_1.skipLast; } });
		var skipUntil_1 = /*@__PURE__*/ requireSkipUntil();
		Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function () { return skipUntil_1.skipUntil; } });
		var skipWhile_1 = /*@__PURE__*/ requireSkipWhile();
		Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function () { return skipWhile_1.skipWhile; } });
		var startWith_1 = /*@__PURE__*/ requireStartWith();
		Object.defineProperty(exports, "startWith", { enumerable: true, get: function () { return startWith_1.startWith; } });
		var subscribeOn_1 = /*@__PURE__*/ requireSubscribeOn();
		Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } });
		var switchAll_1 = /*@__PURE__*/ requireSwitchAll();
		Object.defineProperty(exports, "switchAll", { enumerable: true, get: function () { return switchAll_1.switchAll; } });
		var switchMap_1 = /*@__PURE__*/ requireSwitchMap();
		Object.defineProperty(exports, "switchMap", { enumerable: true, get: function () { return switchMap_1.switchMap; } });
		var switchMapTo_1 = /*@__PURE__*/ requireSwitchMapTo();
		Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } });
		var switchScan_1 = /*@__PURE__*/ requireSwitchScan();
		Object.defineProperty(exports, "switchScan", { enumerable: true, get: function () { return switchScan_1.switchScan; } });
		var take_1 = /*@__PURE__*/ requireTake();
		Object.defineProperty(exports, "take", { enumerable: true, get: function () { return take_1.take; } });
		var takeLast_1 = /*@__PURE__*/ requireTakeLast();
		Object.defineProperty(exports, "takeLast", { enumerable: true, get: function () { return takeLast_1.takeLast; } });
		var takeUntil_1 = /*@__PURE__*/ requireTakeUntil();
		Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function () { return takeUntil_1.takeUntil; } });
		var takeWhile_1 = /*@__PURE__*/ requireTakeWhile();
		Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function () { return takeWhile_1.takeWhile; } });
		var tap_1 = /*@__PURE__*/ requireTap();
		Object.defineProperty(exports, "tap", { enumerable: true, get: function () { return tap_1.tap; } });
		var throttle_1 = /*@__PURE__*/ requireThrottle();
		Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
		var throttleTime_1 = /*@__PURE__*/ requireThrottleTime();
		Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function () { return throttleTime_1.throttleTime; } });
		var throwIfEmpty_1 = /*@__PURE__*/ requireThrowIfEmpty();
		Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } });
		var timeInterval_1 = /*@__PURE__*/ requireTimeInterval();
		Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function () { return timeInterval_1.timeInterval; } });
		var timeout_2 = /*@__PURE__*/ requireTimeout();
		Object.defineProperty(exports, "timeout", { enumerable: true, get: function () { return timeout_2.timeout; } });
		var timeoutWith_1 = /*@__PURE__*/ requireTimeoutWith();
		Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } });
		var timestamp_1 = /*@__PURE__*/ requireTimestamp();
		Object.defineProperty(exports, "timestamp", { enumerable: true, get: function () { return timestamp_1.timestamp; } });
		var toArray_1 = /*@__PURE__*/ requireToArray();
		Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.toArray; } });
		var window_1 = /*@__PURE__*/ requireWindow();
		Object.defineProperty(exports, "window", { enumerable: true, get: function () { return window_1.window; } });
		var windowCount_1 = /*@__PURE__*/ requireWindowCount();
		Object.defineProperty(exports, "windowCount", { enumerable: true, get: function () { return windowCount_1.windowCount; } });
		var windowTime_1 = /*@__PURE__*/ requireWindowTime();
		Object.defineProperty(exports, "windowTime", { enumerable: true, get: function () { return windowTime_1.windowTime; } });
		var windowToggle_1 = /*@__PURE__*/ requireWindowToggle();
		Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function () { return windowToggle_1.windowToggle; } });
		var windowWhen_1 = /*@__PURE__*/ requireWindowWhen();
		Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function () { return windowWhen_1.windowWhen; } });
		var withLatestFrom_1 = /*@__PURE__*/ requireWithLatestFrom();
		Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } });
		var zipAll_1 = /*@__PURE__*/ requireZipAll();
		Object.defineProperty(exports, "zipAll", { enumerable: true, get: function () { return zipAll_1.zipAll; } });
		var zipWith_1 = /*@__PURE__*/ requireZipWith();
		Object.defineProperty(exports, "zipWith", { enumerable: true, get: function () { return zipWith_1.zipWith; } });
		
	} (cjs));
	return cjs;
}

var operators = {};

var partition = {};

var hasRequiredPartition;

function requirePartition () {
	if (hasRequiredPartition) return partition;
	hasRequiredPartition = 1;
	Object.defineProperty(partition, "__esModule", { value: true });
	partition.partition = void 0;
	var not_1 = /*@__PURE__*/ requireNot();
	var filter_1 = /*@__PURE__*/ requireFilter$1();
	function partition$1(predicate, thisArg) {
	    return function (source) {
	        return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];
	    };
	}
	partition.partition = partition$1;
	
	return partition;
}

var race = {};

var hasRequiredRace;

function requireRace () {
	if (hasRequiredRace) return race;
	hasRequiredRace = 1;
	var __read = (race && race.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (race && race.__spreadArray) || function (to, from) {
	    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
	        to[j] = from[i];
	    return to;
	};
	Object.defineProperty(race, "__esModule", { value: true });
	race.race = void 0;
	var argsOrArgArray_1 = /*@__PURE__*/ requireArgsOrArgArray();
	var raceWith_1 = /*@__PURE__*/ requireRaceWith();
	function race$1() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    return raceWith_1.raceWith.apply(void 0, __spreadArray([], __read(argsOrArgArray_1.argsOrArgArray(args))));
	}
	race.race = race$1;
	
	return race;
}

var hasRequiredOperators;

function requireOperators () {
	if (hasRequiredOperators) return operators;
	hasRequiredOperators = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.mergeAll = exports.merge = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.concat = exports.combineLatestWith = exports.combineLatest = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = void 0;
		exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.race = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.partition = exports.pairwise = exports.onErrorResumeNext = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = void 0;
		exports.zipWith = exports.zipAll = exports.zip = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = void 0;
		var audit_1 = /*@__PURE__*/ requireAudit();
		Object.defineProperty(exports, "audit", { enumerable: true, get: function () { return audit_1.audit; } });
		var auditTime_1 = /*@__PURE__*/ requireAuditTime();
		Object.defineProperty(exports, "auditTime", { enumerable: true, get: function () { return auditTime_1.auditTime; } });
		var buffer_1 = /*@__PURE__*/ requireBuffer();
		Object.defineProperty(exports, "buffer", { enumerable: true, get: function () { return buffer_1.buffer; } });
		var bufferCount_1 = /*@__PURE__*/ requireBufferCount();
		Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function () { return bufferCount_1.bufferCount; } });
		var bufferTime_1 = /*@__PURE__*/ requireBufferTime();
		Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function () { return bufferTime_1.bufferTime; } });
		var bufferToggle_1 = /*@__PURE__*/ requireBufferToggle();
		Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function () { return bufferToggle_1.bufferToggle; } });
		var bufferWhen_1 = /*@__PURE__*/ requireBufferWhen();
		Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function () { return bufferWhen_1.bufferWhen; } });
		var catchError_1 = /*@__PURE__*/ requireCatchError();
		Object.defineProperty(exports, "catchError", { enumerable: true, get: function () { return catchError_1.catchError; } });
		var combineAll_1 = /*@__PURE__*/ requireCombineAll();
		Object.defineProperty(exports, "combineAll", { enumerable: true, get: function () { return combineAll_1.combineAll; } });
		var combineLatestAll_1 = /*@__PURE__*/ requireCombineLatestAll();
		Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function () { return combineLatestAll_1.combineLatestAll; } });
		var combineLatest_1 = /*@__PURE__*/ requireCombineLatest();
		Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function () { return combineLatest_1.combineLatest; } });
		var combineLatestWith_1 = /*@__PURE__*/ requireCombineLatestWith();
		Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function () { return combineLatestWith_1.combineLatestWith; } });
		var concat_1 = /*@__PURE__*/ requireConcat();
		Object.defineProperty(exports, "concat", { enumerable: true, get: function () { return concat_1.concat; } });
		var concatAll_1 = /*@__PURE__*/ requireConcatAll();
		Object.defineProperty(exports, "concatAll", { enumerable: true, get: function () { return concatAll_1.concatAll; } });
		var concatMap_1 = /*@__PURE__*/ requireConcatMap();
		Object.defineProperty(exports, "concatMap", { enumerable: true, get: function () { return concatMap_1.concatMap; } });
		var concatMapTo_1 = /*@__PURE__*/ requireConcatMapTo();
		Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function () { return concatMapTo_1.concatMapTo; } });
		var concatWith_1 = /*@__PURE__*/ requireConcatWith();
		Object.defineProperty(exports, "concatWith", { enumerable: true, get: function () { return concatWith_1.concatWith; } });
		var connect_1 = /*@__PURE__*/ requireConnect();
		Object.defineProperty(exports, "connect", { enumerable: true, get: function () { return connect_1.connect; } });
		var count_1 = /*@__PURE__*/ requireCount();
		Object.defineProperty(exports, "count", { enumerable: true, get: function () { return count_1.count; } });
		var debounce_1 = /*@__PURE__*/ requireDebounce();
		Object.defineProperty(exports, "debounce", { enumerable: true, get: function () { return debounce_1.debounce; } });
		var debounceTime_1 = /*@__PURE__*/ requireDebounceTime();
		Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function () { return debounceTime_1.debounceTime; } });
		var defaultIfEmpty_1 = /*@__PURE__*/ requireDefaultIfEmpty();
		Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function () { return defaultIfEmpty_1.defaultIfEmpty; } });
		var delay_1 = /*@__PURE__*/ requireDelay();
		Object.defineProperty(exports, "delay", { enumerable: true, get: function () { return delay_1.delay; } });
		var delayWhen_1 = /*@__PURE__*/ requireDelayWhen();
		Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function () { return delayWhen_1.delayWhen; } });
		var dematerialize_1 = /*@__PURE__*/ requireDematerialize();
		Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function () { return dematerialize_1.dematerialize; } });
		var distinct_1 = /*@__PURE__*/ requireDistinct();
		Object.defineProperty(exports, "distinct", { enumerable: true, get: function () { return distinct_1.distinct; } });
		var distinctUntilChanged_1 = /*@__PURE__*/ requireDistinctUntilChanged();
		Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function () { return distinctUntilChanged_1.distinctUntilChanged; } });
		var distinctUntilKeyChanged_1 = /*@__PURE__*/ requireDistinctUntilKeyChanged();
		Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function () { return distinctUntilKeyChanged_1.distinctUntilKeyChanged; } });
		var elementAt_1 = /*@__PURE__*/ requireElementAt();
		Object.defineProperty(exports, "elementAt", { enumerable: true, get: function () { return elementAt_1.elementAt; } });
		var endWith_1 = /*@__PURE__*/ requireEndWith();
		Object.defineProperty(exports, "endWith", { enumerable: true, get: function () { return endWith_1.endWith; } });
		var every_1 = /*@__PURE__*/ requireEvery();
		Object.defineProperty(exports, "every", { enumerable: true, get: function () { return every_1.every; } });
		var exhaust_1 = /*@__PURE__*/ requireExhaust();
		Object.defineProperty(exports, "exhaust", { enumerable: true, get: function () { return exhaust_1.exhaust; } });
		var exhaustAll_1 = /*@__PURE__*/ requireExhaustAll();
		Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function () { return exhaustAll_1.exhaustAll; } });
		var exhaustMap_1 = /*@__PURE__*/ requireExhaustMap();
		Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function () { return exhaustMap_1.exhaustMap; } });
		var expand_1 = /*@__PURE__*/ requireExpand$1();
		Object.defineProperty(exports, "expand", { enumerable: true, get: function () { return expand_1.expand; } });
		var filter_1 = /*@__PURE__*/ requireFilter$1();
		Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return filter_1.filter; } });
		var finalize_1 = /*@__PURE__*/ requireFinalize();
		Object.defineProperty(exports, "finalize", { enumerable: true, get: function () { return finalize_1.finalize; } });
		var find_1 = /*@__PURE__*/ requireFind();
		Object.defineProperty(exports, "find", { enumerable: true, get: function () { return find_1.find; } });
		var findIndex_1 = /*@__PURE__*/ requireFindIndex();
		Object.defineProperty(exports, "findIndex", { enumerable: true, get: function () { return findIndex_1.findIndex; } });
		var first_1 = /*@__PURE__*/ requireFirst();
		Object.defineProperty(exports, "first", { enumerable: true, get: function () { return first_1.first; } });
		var groupBy_1 = /*@__PURE__*/ requireGroupBy();
		Object.defineProperty(exports, "groupBy", { enumerable: true, get: function () { return groupBy_1.groupBy; } });
		var ignoreElements_1 = /*@__PURE__*/ requireIgnoreElements();
		Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function () { return ignoreElements_1.ignoreElements; } });
		var isEmpty_1 = /*@__PURE__*/ requireIsEmpty();
		Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function () { return isEmpty_1.isEmpty; } });
		var last_1 = /*@__PURE__*/ requireLast();
		Object.defineProperty(exports, "last", { enumerable: true, get: function () { return last_1.last; } });
		var map_1 = /*@__PURE__*/ requireMap$1();
		Object.defineProperty(exports, "map", { enumerable: true, get: function () { return map_1.map; } });
		var mapTo_1 = /*@__PURE__*/ requireMapTo();
		Object.defineProperty(exports, "mapTo", { enumerable: true, get: function () { return mapTo_1.mapTo; } });
		var materialize_1 = /*@__PURE__*/ requireMaterialize();
		Object.defineProperty(exports, "materialize", { enumerable: true, get: function () { return materialize_1.materialize; } });
		var max_1 = /*@__PURE__*/ requireMax();
		Object.defineProperty(exports, "max", { enumerable: true, get: function () { return max_1.max; } });
		var merge_1 = /*@__PURE__*/ requireMerge();
		Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return merge_1.merge; } });
		var mergeAll_1 = /*@__PURE__*/ requireMergeAll();
		Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function () { return mergeAll_1.mergeAll; } });
		var flatMap_1 = /*@__PURE__*/ requireFlatMap();
		Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatMap_1.flatMap; } });
		var mergeMap_1 = /*@__PURE__*/ requireMergeMap();
		Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function () { return mergeMap_1.mergeMap; } });
		var mergeMapTo_1 = /*@__PURE__*/ requireMergeMapTo();
		Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function () { return mergeMapTo_1.mergeMapTo; } });
		var mergeScan_1 = /*@__PURE__*/ requireMergeScan();
		Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function () { return mergeScan_1.mergeScan; } });
		var mergeWith_1 = /*@__PURE__*/ requireMergeWith();
		Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function () { return mergeWith_1.mergeWith; } });
		var min_1 = /*@__PURE__*/ requireMin();
		Object.defineProperty(exports, "min", { enumerable: true, get: function () { return min_1.min; } });
		var multicast_1 = /*@__PURE__*/ requireMulticast();
		Object.defineProperty(exports, "multicast", { enumerable: true, get: function () { return multicast_1.multicast; } });
		var observeOn_1 = /*@__PURE__*/ requireObserveOn();
		Object.defineProperty(exports, "observeOn", { enumerable: true, get: function () { return observeOn_1.observeOn; } });
		var onErrorResumeNextWith_1 = /*@__PURE__*/ requireOnErrorResumeNextWith();
		Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function () { return onErrorResumeNextWith_1.onErrorResumeNext; } });
		var pairwise_1 = /*@__PURE__*/ requirePairwise();
		Object.defineProperty(exports, "pairwise", { enumerable: true, get: function () { return pairwise_1.pairwise; } });
		var partition_1 = /*@__PURE__*/ requirePartition();
		Object.defineProperty(exports, "partition", { enumerable: true, get: function () { return partition_1.partition; } });
		var pluck_1 = /*@__PURE__*/ requirePluck();
		Object.defineProperty(exports, "pluck", { enumerable: true, get: function () { return pluck_1.pluck; } });
		var publish_1 = /*@__PURE__*/ requirePublish();
		Object.defineProperty(exports, "publish", { enumerable: true, get: function () { return publish_1.publish; } });
		var publishBehavior_1 = /*@__PURE__*/ requirePublishBehavior();
		Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function () { return publishBehavior_1.publishBehavior; } });
		var publishLast_1 = /*@__PURE__*/ requirePublishLast();
		Object.defineProperty(exports, "publishLast", { enumerable: true, get: function () { return publishLast_1.publishLast; } });
		var publishReplay_1 = /*@__PURE__*/ requirePublishReplay();
		Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function () { return publishReplay_1.publishReplay; } });
		var race_1 = /*@__PURE__*/ requireRace();
		Object.defineProperty(exports, "race", { enumerable: true, get: function () { return race_1.race; } });
		var raceWith_1 = /*@__PURE__*/ requireRaceWith();
		Object.defineProperty(exports, "raceWith", { enumerable: true, get: function () { return raceWith_1.raceWith; } });
		var reduce_1 = /*@__PURE__*/ requireReduce();
		Object.defineProperty(exports, "reduce", { enumerable: true, get: function () { return reduce_1.reduce; } });
		var repeat_1 = /*@__PURE__*/ requireRepeat();
		Object.defineProperty(exports, "repeat", { enumerable: true, get: function () { return repeat_1.repeat; } });
		var repeatWhen_1 = /*@__PURE__*/ requireRepeatWhen();
		Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function () { return repeatWhen_1.repeatWhen; } });
		var retry_1 = /*@__PURE__*/ requireRetry();
		Object.defineProperty(exports, "retry", { enumerable: true, get: function () { return retry_1.retry; } });
		var retryWhen_1 = /*@__PURE__*/ requireRetryWhen();
		Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function () { return retryWhen_1.retryWhen; } });
		var refCount_1 = /*@__PURE__*/ requireRefCount();
		Object.defineProperty(exports, "refCount", { enumerable: true, get: function () { return refCount_1.refCount; } });
		var sample_1 = /*@__PURE__*/ requireSample();
		Object.defineProperty(exports, "sample", { enumerable: true, get: function () { return sample_1.sample; } });
		var sampleTime_1 = /*@__PURE__*/ requireSampleTime();
		Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function () { return sampleTime_1.sampleTime; } });
		var scan_1 = /*@__PURE__*/ requireScan();
		Object.defineProperty(exports, "scan", { enumerable: true, get: function () { return scan_1.scan; } });
		var sequenceEqual_1 = /*@__PURE__*/ requireSequenceEqual();
		Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function () { return sequenceEqual_1.sequenceEqual; } });
		var share_1 = /*@__PURE__*/ requireShare();
		Object.defineProperty(exports, "share", { enumerable: true, get: function () { return share_1.share; } });
		var shareReplay_1 = /*@__PURE__*/ requireShareReplay();
		Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function () { return shareReplay_1.shareReplay; } });
		var single_1 = /*@__PURE__*/ requireSingle();
		Object.defineProperty(exports, "single", { enumerable: true, get: function () { return single_1.single; } });
		var skip_1 = /*@__PURE__*/ requireSkip();
		Object.defineProperty(exports, "skip", { enumerable: true, get: function () { return skip_1.skip; } });
		var skipLast_1 = /*@__PURE__*/ requireSkipLast();
		Object.defineProperty(exports, "skipLast", { enumerable: true, get: function () { return skipLast_1.skipLast; } });
		var skipUntil_1 = /*@__PURE__*/ requireSkipUntil();
		Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function () { return skipUntil_1.skipUntil; } });
		var skipWhile_1 = /*@__PURE__*/ requireSkipWhile();
		Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function () { return skipWhile_1.skipWhile; } });
		var startWith_1 = /*@__PURE__*/ requireStartWith();
		Object.defineProperty(exports, "startWith", { enumerable: true, get: function () { return startWith_1.startWith; } });
		var subscribeOn_1 = /*@__PURE__*/ requireSubscribeOn();
		Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function () { return subscribeOn_1.subscribeOn; } });
		var switchAll_1 = /*@__PURE__*/ requireSwitchAll();
		Object.defineProperty(exports, "switchAll", { enumerable: true, get: function () { return switchAll_1.switchAll; } });
		var switchMap_1 = /*@__PURE__*/ requireSwitchMap();
		Object.defineProperty(exports, "switchMap", { enumerable: true, get: function () { return switchMap_1.switchMap; } });
		var switchMapTo_1 = /*@__PURE__*/ requireSwitchMapTo();
		Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function () { return switchMapTo_1.switchMapTo; } });
		var switchScan_1 = /*@__PURE__*/ requireSwitchScan();
		Object.defineProperty(exports, "switchScan", { enumerable: true, get: function () { return switchScan_1.switchScan; } });
		var take_1 = /*@__PURE__*/ requireTake();
		Object.defineProperty(exports, "take", { enumerable: true, get: function () { return take_1.take; } });
		var takeLast_1 = /*@__PURE__*/ requireTakeLast();
		Object.defineProperty(exports, "takeLast", { enumerable: true, get: function () { return takeLast_1.takeLast; } });
		var takeUntil_1 = /*@__PURE__*/ requireTakeUntil();
		Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function () { return takeUntil_1.takeUntil; } });
		var takeWhile_1 = /*@__PURE__*/ requireTakeWhile();
		Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function () { return takeWhile_1.takeWhile; } });
		var tap_1 = /*@__PURE__*/ requireTap();
		Object.defineProperty(exports, "tap", { enumerable: true, get: function () { return tap_1.tap; } });
		var throttle_1 = /*@__PURE__*/ requireThrottle();
		Object.defineProperty(exports, "throttle", { enumerable: true, get: function () { return throttle_1.throttle; } });
		var throttleTime_1 = /*@__PURE__*/ requireThrottleTime();
		Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function () { return throttleTime_1.throttleTime; } });
		var throwIfEmpty_1 = /*@__PURE__*/ requireThrowIfEmpty();
		Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function () { return throwIfEmpty_1.throwIfEmpty; } });
		var timeInterval_1 = /*@__PURE__*/ requireTimeInterval();
		Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function () { return timeInterval_1.timeInterval; } });
		var timeout_1 = /*@__PURE__*/ requireTimeout();
		Object.defineProperty(exports, "timeout", { enumerable: true, get: function () { return timeout_1.timeout; } });
		var timeoutWith_1 = /*@__PURE__*/ requireTimeoutWith();
		Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function () { return timeoutWith_1.timeoutWith; } });
		var timestamp_1 = /*@__PURE__*/ requireTimestamp();
		Object.defineProperty(exports, "timestamp", { enumerable: true, get: function () { return timestamp_1.timestamp; } });
		var toArray_1 = /*@__PURE__*/ requireToArray();
		Object.defineProperty(exports, "toArray", { enumerable: true, get: function () { return toArray_1.toArray; } });
		var window_1 = /*@__PURE__*/ requireWindow();
		Object.defineProperty(exports, "window", { enumerable: true, get: function () { return window_1.window; } });
		var windowCount_1 = /*@__PURE__*/ requireWindowCount();
		Object.defineProperty(exports, "windowCount", { enumerable: true, get: function () { return windowCount_1.windowCount; } });
		var windowTime_1 = /*@__PURE__*/ requireWindowTime();
		Object.defineProperty(exports, "windowTime", { enumerable: true, get: function () { return windowTime_1.windowTime; } });
		var windowToggle_1 = /*@__PURE__*/ requireWindowToggle();
		Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function () { return windowToggle_1.windowToggle; } });
		var windowWhen_1 = /*@__PURE__*/ requireWindowWhen();
		Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function () { return windowWhen_1.windowWhen; } });
		var withLatestFrom_1 = /*@__PURE__*/ requireWithLatestFrom();
		Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function () { return withLatestFrom_1.withLatestFrom; } });
		var zip_1 = /*@__PURE__*/ requireZip();
		Object.defineProperty(exports, "zip", { enumerable: true, get: function () { return zip_1.zip; } });
		var zipAll_1 = /*@__PURE__*/ requireZipAll();
		Object.defineProperty(exports, "zipAll", { enumerable: true, get: function () { return zipAll_1.zipAll; } });
		var zipWith_1 = /*@__PURE__*/ requireZipWith();
		Object.defineProperty(exports, "zipWith", { enumerable: true, get: function () { return zipWith_1.zipWith; } });
		
	} (operators));
	return operators;
}

var runAsync = {exports: {}};

var hasRequiredRunAsync;

function requireRunAsync () {
	if (hasRequiredRunAsync) return runAsync.exports;
	hasRequiredRunAsync = 1;

	function isPromise(obj) {
	  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
	}

	/**
	 * Return a function that will run a function asynchronously or synchronously
	 *
	 * example:
	 * runAsync(wrappedFunction, callback)(...args);
	 *
	 * @param   {Function} func  Function to run
	 * @param   {Function} cb    Callback function passed the `func` returned value
	 * @return  {Function(arguments)} Arguments to pass to `func`. This function will in turn
	 *                                return a Promise (Node >= 0.12) or call the callbacks.
	 */

	var runAsync$1 = runAsync.exports = function (func, cb) {
	  cb = cb || function () {};

	  return function () {

	    var args = arguments;

	    var promise = new Promise(function (resolve, reject) {
	      var resolved = false;
	      const wrappedResolve = function (value) {
	        if (resolved) {
	          console.warn('Run-async promise already resolved.');
	        }
	        resolved = true;
	        resolve(value);
	      };

	      var rejected = false;
	      const wrappedReject = function (value) {
	        if (rejected) {
	          console.warn('Run-async promise already rejected.');
	        }
	        rejected = true;
	        reject(value);
	      };

	      var usingCallback = false;
	      var callbackConflict = false;
	      var contextEnded = false;

	      var answer = func.apply({
	        async: function () {
	          if (contextEnded) {
	            console.warn('Run-async async() called outside a valid run-async context, callback will be ignored.');
	            return function() {};
	          }
	          if (callbackConflict) {
	            console.warn('Run-async wrapped function (async) returned a promise.\nCalls to async() callback can have unexpected results.');
	          }
	          usingCallback = true;
	          return function (err, value) {
	            if (err) {
	              wrappedReject(err);
	            } else {
	              wrappedResolve(value);
	            }
	          };
	        }
	      }, Array.prototype.slice.call(args));

	      if (usingCallback) {
	        if (isPromise(answer)) {
	          console.warn('Run-async wrapped function (sync) returned a promise but async() callback must be executed to resolve.');
	        }
	      } else {
	        if (isPromise(answer)) {
	          callbackConflict = true;
	          answer.then(wrappedResolve, wrappedReject);
	        } else {
	          wrappedResolve(answer);
	        }
	      }
	      contextEnded = true;
	    });

	    promise.then(cb.bind(null, null), cb);

	    return promise;
	  }
	};

	runAsync$1.cb = function (func, cb) {
	  return runAsync$1(function () {
	    var args = Array.prototype.slice.call(arguments);
	    if (args.length === func.length - 1) {
	      args.push(this.async());
	    }
	    return func.apply(this, args);
	  }, cb);
	};
	return runAsync.exports;
}

var utils = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	const { from, of } = /*@__PURE__*/ requireCjs$1();
	const runAsync = requireRunAsync();

	/**
	 * Resolve a question property value if it is passed as a function.
	 * This method will overwrite the property on the question object with the received value.
	 * @param  {Object} question - Question object
	 * @param  {String} prop     - Property to fetch name
	 * @param  {Object} answers  - Answers object
	 * @return {Rx.Observable}   - Observable emitting once value is known
	 */

	utils.fetchAsyncQuestionProperty = function (question, prop, answers) {
	  if (typeof question[prop] !== 'function') {
	    return of(question);
	  }

	  return from(
	    runAsync(question[prop])(answers).then((value) => {
	      question[prop] = value;
	      return question;
	    })
	  );
	};
	return utils;
}

var prompt;
var hasRequiredPrompt;

function requirePrompt () {
	if (hasRequiredPrompt) return prompt;
	hasRequiredPrompt = 1;
	const _ = {
	  isPlainObject: requireIsPlainObject(),
	  get: requireGet(),
	  set: requireSet(),
	};
	const { defer, empty, from, of } = /*@__PURE__*/ requireCjs$1();
	const { concatMap, filter, publish, reduce } = /*@__PURE__*/ requireOperators();
	const runAsync = requireRunAsync();
	const utils = requireUtils();
	const Base = requireBaseUI();

	/**
	 * Base interface class other can inherits from
	 */

	class PromptUI extends Base {
	  constructor(prompts, opt) {
	    super(opt);
	    this.prompts = prompts;
	  }

	  run(questions, answers) {
	    // Keep global reference to the answers
	    if (_.isPlainObject(answers)) {
	      this.answers = { ...answers };
	    } else {
	      this.answers = {};
	    }

	    // Make sure questions is an array.
	    if (_.isPlainObject(questions)) {
	      // It's either an object of questions or a single question
	      questions = Object.values(questions).every(
	        (v) => _.isPlainObject(v) && v.name === undefined
	      )
	        ? Object.entries(questions).map(([name, question]) => ({ name, ...question }))
	        : [questions];
	    }

	    // Create an observable, unless we received one as parameter.
	    // Note: As this is a public interface, we cannot do an instanceof check as we won't
	    // be using the exact same object in memory.
	    const obs = Array.isArray(questions) ? from(questions) : questions;

	    this.process = obs.pipe(
	      concatMap(this.processQuestion.bind(this)),
	      publish() // Creates a hot Observable. It prevents duplicating prompts.
	    );

	    this.process.connect();

	    return this.process
	      .pipe(
	        reduce((answers, answer) => {
	          _.set(answers, answer.name, answer.answer);
	          return answers;
	        }, this.answers)
	      )
	      .toPromise(Promise)
	      .then(this.onCompletion.bind(this), this.onError.bind(this));
	  }

	  /**
	   * Once all prompt are over
	   */

	  onCompletion() {
	    this.close();

	    return this.answers;
	  }

	  onError(error) {
	    this.close();
	    return Promise.reject(error);
	  }

	  processQuestion(question) {
	    question = { ...question };
	    return defer(() => {
	      const obs = of(question);

	      return obs.pipe(
	        concatMap(this.setDefaultType.bind(this)),
	        concatMap(this.filterIfRunnable.bind(this)),
	        concatMap(() =>
	          utils.fetchAsyncQuestionProperty(question, 'message', this.answers)
	        ),
	        concatMap(() =>
	          utils.fetchAsyncQuestionProperty(question, 'default', this.answers)
	        ),
	        concatMap(() =>
	          utils.fetchAsyncQuestionProperty(question, 'choices', this.answers)
	        ),
	        concatMap(this.fetchAnswer.bind(this))
	      );
	    });
	  }

	  fetchAnswer(question) {
	    const Prompt = this.prompts[question.type];
	    this.activePrompt = new Prompt(question, this.rl, this.answers);
	    return defer(() =>
	      from(this.activePrompt.run().then((answer) => ({ name: question.name, answer })))
	    );
	  }

	  setDefaultType(question) {
	    // Default type to input
	    if (!this.prompts[question.type]) {
	      question.type = 'input';
	    }

	    return defer(() => of(question));
	  }

	  filterIfRunnable(question) {
	    if (
	      question.askAnswered !== true &&
	      _.get(this.answers, question.name) !== undefined
	    ) {
	      return empty();
	    }

	    if (question.when === false) {
	      return empty();
	    }

	    if (typeof question.when !== 'function') {
	      return of(question);
	    }

	    const { answers } = this;
	    return defer(() =>
	      from(
	        runAsync(question.when)(answers).then((shouldRun) => {
	          if (shouldRun) {
	            return question;
	          }
	        })
	      ).pipe(filter((val) => val != null))
	    );
	  }
	}

	prompt = PromptUI;
	return prompt;
}

var cliCursor = {};

var onetime = {exports: {}};

var mimicFn = {exports: {}};

var hasRequiredMimicFn;

function requireMimicFn () {
	if (hasRequiredMimicFn) return mimicFn.exports;
	hasRequiredMimicFn = 1;

	const mimicFn$1 = (to, from) => {
		for (const prop of Reflect.ownKeys(from)) {
			Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
		}

		return to;
	};

	mimicFn.exports = mimicFn$1;
	// TODO: Remove this for the next major release
	mimicFn.exports.default = mimicFn$1;
	return mimicFn.exports;
}

var hasRequiredOnetime;

function requireOnetime () {
	if (hasRequiredOnetime) return onetime.exports;
	hasRequiredOnetime = 1;
	const mimicFn = requireMimicFn();

	const calledFunctions = new WeakMap();

	const onetime$1 = (function_, options = {}) => {
		if (typeof function_ !== 'function') {
			throw new TypeError('Expected a function');
		}

		let returnValue;
		let callCount = 0;
		const functionName = function_.displayName || function_.name || '<anonymous>';

		const onetime = function (...arguments_) {
			calledFunctions.set(onetime, ++callCount);

			if (callCount === 1) {
				returnValue = function_.apply(this, arguments_);
				function_ = null;
			} else if (options.throw === true) {
				throw new Error(`Function \`${functionName}\` can only be called once`);
			}

			return returnValue;
		};

		mimicFn(onetime, function_);
		calledFunctions.set(onetime, callCount);

		return onetime;
	};

	onetime.exports = onetime$1;
	// TODO: Remove this for the next major release
	onetime.exports.default = onetime$1;

	onetime.exports.callCount = function_ => {
		if (!calledFunctions.has(function_)) {
			throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
		}

		return calledFunctions.get(function_);
	};
	return onetime.exports;
}

var signalExit = {exports: {}};

var signals = {exports: {}};

var hasRequiredSignals;

function requireSignals () {
	if (hasRequiredSignals) return signals.exports;
	hasRequiredSignals = 1;
	(function (module) {
		// This is not the set of all possible signals.
		//
		// It IS, however, the set of all signals that trigger
		// an exit on either Linux or BSD systems.  Linux is a
		// superset of the signal names supported on BSD, and
		// the unknown signals just fail to register, so we can
		// catch that easily enough.
		//
		// Don't bother with SIGKILL.  It's uncatchable, which
		// means that we can't fire any callbacks anyway.
		//
		// If a user does happen to register a handler on a non-
		// fatal signal like SIGWINCH or something, and then
		// exit, it'll end up firing `process.emit('exit')`, so
		// the handler will be fired anyway.
		//
		// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
		// artificially, inherently leave the process in a
		// state from which it is not safe to try and enter JS
		// listeners.
		module.exports = [
		  'SIGABRT',
		  'SIGALRM',
		  'SIGHUP',
		  'SIGINT',
		  'SIGTERM'
		];

		if (process.platform !== 'win32') {
		  module.exports.push(
		    'SIGVTALRM',
		    'SIGXCPU',
		    'SIGXFSZ',
		    'SIGUSR2',
		    'SIGTRAP',
		    'SIGSYS',
		    'SIGQUIT',
		    'SIGIOT'
		    // should detect profiler and enable/disable accordingly.
		    // see #21
		    // 'SIGPROF'
		  );
		}

		if (process.platform === 'linux') {
		  module.exports.push(
		    'SIGIO',
		    'SIGPOLL',
		    'SIGPWR',
		    'SIGSTKFLT',
		    'SIGUNUSED'
		  );
		} 
	} (signals));
	return signals.exports;
}

var hasRequiredSignalExit;

function requireSignalExit () {
	if (hasRequiredSignalExit) return signalExit.exports;
	hasRequiredSignalExit = 1;
	// Note: since nyc uses this module to output coverage, any lines
	// that are in the direct sync flow of nyc's outputCoverage are
	// ignored, since we can never get coverage for them.
	// grab a reference to node's real process object right away
	var process = commonjsGlobal.process;

	const processOk = function (process) {
	  return process &&
	    typeof process === 'object' &&
	    typeof process.removeListener === 'function' &&
	    typeof process.emit === 'function' &&
	    typeof process.reallyExit === 'function' &&
	    typeof process.listeners === 'function' &&
	    typeof process.kill === 'function' &&
	    typeof process.pid === 'number' &&
	    typeof process.on === 'function'
	};

	// some kind of non-node environment, just no-op
	/* istanbul ignore if */
	if (!processOk(process)) {
	  signalExit.exports = function () {
	    return function () {}
	  };
	} else {
	  var assert = require$$0$c;
	  var signals = requireSignals();
	  var isWin = /^win/i.test(process.platform);

	  var EE = require$$0$b;
	  /* istanbul ignore if */
	  if (typeof EE !== 'function') {
	    EE = EE.EventEmitter;
	  }

	  var emitter;
	  if (process.__signal_exit_emitter__) {
	    emitter = process.__signal_exit_emitter__;
	  } else {
	    emitter = process.__signal_exit_emitter__ = new EE();
	    emitter.count = 0;
	    emitter.emitted = {};
	  }

	  // Because this emitter is a global, we have to check to see if a
	  // previous version of this library failed to enable infinite listeners.
	  // I know what you're about to say.  But literally everything about
	  // signal-exit is a compromise with evil.  Get used to it.
	  if (!emitter.infinite) {
	    emitter.setMaxListeners(Infinity);
	    emitter.infinite = true;
	  }

	  signalExit.exports = function (cb, opts) {
	    /* istanbul ignore if */
	    if (!processOk(commonjsGlobal.process)) {
	      return function () {}
	    }
	    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');

	    if (loaded === false) {
	      load();
	    }

	    var ev = 'exit';
	    if (opts && opts.alwaysLast) {
	      ev = 'afterexit';
	    }

	    var remove = function () {
	      emitter.removeListener(ev, cb);
	      if (emitter.listeners('exit').length === 0 &&
	          emitter.listeners('afterexit').length === 0) {
	        unload();
	      }
	    };
	    emitter.on(ev, cb);

	    return remove
	  };

	  var unload = function unload () {
	    if (!loaded || !processOk(commonjsGlobal.process)) {
	      return
	    }
	    loaded = false;

	    signals.forEach(function (sig) {
	      try {
	        process.removeListener(sig, sigListeners[sig]);
	      } catch (er) {}
	    });
	    process.emit = originalProcessEmit;
	    process.reallyExit = originalProcessReallyExit;
	    emitter.count -= 1;
	  };
	  signalExit.exports.unload = unload;

	  var emit = function emit (event, code, signal) {
	    /* istanbul ignore if */
	    if (emitter.emitted[event]) {
	      return
	    }
	    emitter.emitted[event] = true;
	    emitter.emit(event, code, signal);
	  };

	  // { <signal>: <listener fn>, ... }
	  var sigListeners = {};
	  signals.forEach(function (sig) {
	    sigListeners[sig] = function listener () {
	      /* istanbul ignore if */
	      if (!processOk(commonjsGlobal.process)) {
	        return
	      }
	      // If there are no other listeners, an exit is coming!
	      // Simplest way: remove us and then re-send the signal.
	      // We know that this will kill the process, so we can
	      // safely emit now.
	      var listeners = process.listeners(sig);
	      if (listeners.length === emitter.count) {
	        unload();
	        emit('exit', null, sig);
	        /* istanbul ignore next */
	        emit('afterexit', null, sig);
	        /* istanbul ignore next */
	        if (isWin && sig === 'SIGHUP') {
	          // "SIGHUP" throws an `ENOSYS` error on Windows,
	          // so use a supported signal instead
	          sig = 'SIGINT';
	        }
	        /* istanbul ignore next */
	        process.kill(process.pid, sig);
	      }
	    };
	  });

	  signalExit.exports.signals = function () {
	    return signals
	  };

	  var loaded = false;

	  var load = function load () {
	    if (loaded || !processOk(commonjsGlobal.process)) {
	      return
	    }
	    loaded = true;

	    // This is the number of onSignalExit's that are in play.
	    // It's important so that we can count the correct number of
	    // listeners on signals, and don't wait for the other one to
	    // handle it instead of us.
	    emitter.count += 1;

	    signals = signals.filter(function (sig) {
	      try {
	        process.on(sig, sigListeners[sig]);
	        return true
	      } catch (er) {
	        return false
	      }
	    });

	    process.emit = processEmit;
	    process.reallyExit = processReallyExit;
	  };
	  signalExit.exports.load = load;

	  var originalProcessReallyExit = process.reallyExit;
	  var processReallyExit = function processReallyExit (code) {
	    /* istanbul ignore if */
	    if (!processOk(commonjsGlobal.process)) {
	      return
	    }
	    process.exitCode = code || /* istanbul ignore next */ 0;
	    emit('exit', process.exitCode, null);
	    /* istanbul ignore next */
	    emit('afterexit', process.exitCode, null);
	    /* istanbul ignore next */
	    originalProcessReallyExit.call(process, process.exitCode);
	  };

	  var originalProcessEmit = process.emit;
	  var processEmit = function processEmit (ev, arg) {
	    if (ev === 'exit' && processOk(commonjsGlobal.process)) {
	      /* istanbul ignore else */
	      if (arg !== undefined) {
	        process.exitCode = arg;
	      }
	      var ret = originalProcessEmit.apply(this, arguments);
	      /* istanbul ignore next */
	      emit('exit', process.exitCode, null);
	      /* istanbul ignore next */
	      emit('afterexit', process.exitCode, null);
	      /* istanbul ignore next */
	      return ret
	    } else {
	      return originalProcessEmit.apply(this, arguments)
	    }
	  };
	}
	return signalExit.exports;
}

var restoreCursor;
var hasRequiredRestoreCursor;

function requireRestoreCursor () {
	if (hasRequiredRestoreCursor) return restoreCursor;
	hasRequiredRestoreCursor = 1;
	const onetime = requireOnetime();
	const signalExit = requireSignalExit();

	restoreCursor = onetime(() => {
		signalExit(() => {
			process.stderr.write('\u001B[?25h');
		}, {alwaysLast: true});
	});
	return restoreCursor;
}

var hasRequiredCliCursor;

function requireCliCursor () {
	if (hasRequiredCliCursor) return cliCursor;
	hasRequiredCliCursor = 1;
	(function (exports) {
		const restoreCursor = requireRestoreCursor();

		let isHidden = false;

		exports.show = (writableStream = process.stderr) => {
			if (!writableStream.isTTY) {
				return;
			}

			isHidden = false;
			writableStream.write('\u001B[?25h');
		};

		exports.hide = (writableStream = process.stderr) => {
			if (!writableStream.isTTY) {
				return;
			}

			restoreCursor();
			isHidden = true;
			writableStream.write('\u001B[?25l');
		};

		exports.toggle = (force, writableStream) => {
			if (force !== undefined) {
				isHidden = force;
			}

			if (isHidden) {
				exports.show(writableStream);
			} else {
				exports.hide(writableStream);
			}
		}; 
	} (cliCursor));
	return cliCursor;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */

var identity_1;
var hasRequiredIdentity;

function requireIdentity () {
	if (hasRequiredIdentity) return identity_1;
	hasRequiredIdentity = 1;
	function identity(value) {
	  return value;
	}

	identity_1 = identity;
	return identity_1;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */

var _apply;
var hasRequired_apply;

function require_apply () {
	if (hasRequired_apply) return _apply;
	hasRequired_apply = 1;
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	_apply = apply;
	return _apply;
}

var _overRest;
var hasRequired_overRest;

function require_overRest () {
	if (hasRequired_overRest) return _overRest;
	hasRequired_overRest = 1;
	var apply = require_apply();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	_overRest = overRest;
	return _overRest;
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */

var constant_1;
var hasRequiredConstant;

function requireConstant () {
	if (hasRequiredConstant) return constant_1;
	hasRequiredConstant = 1;
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	constant_1 = constant;
	return constant_1;
}

var _baseSetToString;
var hasRequired_baseSetToString;

function require_baseSetToString () {
	if (hasRequired_baseSetToString) return _baseSetToString;
	hasRequired_baseSetToString = 1;
	var constant = requireConstant(),
	    defineProperty = require_defineProperty(),
	    identity = requireIdentity();

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	_baseSetToString = baseSetToString;
	return _baseSetToString;
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */

var _shortOut;
var hasRequired_shortOut;

function require_shortOut () {
	if (hasRequired_shortOut) return _shortOut;
	hasRequired_shortOut = 1;
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	_shortOut = shortOut;
	return _shortOut;
}

var _setToString;
var hasRequired_setToString;

function require_setToString () {
	if (hasRequired_setToString) return _setToString;
	hasRequired_setToString = 1;
	var baseSetToString = require_baseSetToString(),
	    shortOut = require_shortOut();

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	_setToString = setToString;
	return _setToString;
}

var _baseRest;
var hasRequired_baseRest;

function require_baseRest () {
	if (hasRequired_baseRest) return _baseRest;
	hasRequired_baseRest = 1;
	var identity = requireIdentity(),
	    overRest = require_overRest(),
	    setToString = require_setToString();

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	_baseRest = baseRest;
	return _baseRest;
}

/** Used as references for various `Number` constants. */

var isLength_1;
var hasRequiredIsLength;

function requireIsLength () {
	if (hasRequiredIsLength) return isLength_1;
	hasRequiredIsLength = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	isLength_1 = isLength;
	return isLength_1;
}

var isArrayLike_1;
var hasRequiredIsArrayLike;

function requireIsArrayLike () {
	if (hasRequiredIsArrayLike) return isArrayLike_1;
	hasRequiredIsArrayLike = 1;
	var isFunction = requireIsFunction$1(),
	    isLength = requireIsLength();

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	isArrayLike_1 = isArrayLike;
	return isArrayLike_1;
}

var _isIterateeCall;
var hasRequired_isIterateeCall;

function require_isIterateeCall () {
	if (hasRequired_isIterateeCall) return _isIterateeCall;
	hasRequired_isIterateeCall = 1;
	var eq = requireEq(),
	    isArrayLike = requireIsArrayLike(),
	    isIndex = require_isIndex(),
	    isObject = requireIsObject();

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	_isIterateeCall = isIterateeCall;
	return _isIterateeCall;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */

var _baseTimes;
var hasRequired_baseTimes;

function require_baseTimes () {
	if (hasRequired_baseTimes) return _baseTimes;
	hasRequired_baseTimes = 1;
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	_baseTimes = baseTimes;
	return _baseTimes;
}

var _baseIsArguments;
var hasRequired_baseIsArguments;

function require_baseIsArguments () {
	if (hasRequired_baseIsArguments) return _baseIsArguments;
	hasRequired_baseIsArguments = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	_baseIsArguments = baseIsArguments;
	return _baseIsArguments;
}

var isArguments_1;
var hasRequiredIsArguments;

function requireIsArguments () {
	if (hasRequiredIsArguments) return isArguments_1;
	hasRequiredIsArguments = 1;
	var baseIsArguments = require_baseIsArguments(),
	    isObjectLike = requireIsObjectLike();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	isArguments_1 = isArguments;
	return isArguments_1;
}

var isBuffer = {exports: {}};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

var stubFalse_1;
var hasRequiredStubFalse;

function requireStubFalse () {
	if (hasRequiredStubFalse) return stubFalse_1;
	hasRequiredStubFalse = 1;
	function stubFalse() {
	  return false;
	}

	stubFalse_1 = stubFalse;
	return stubFalse_1;
}

isBuffer.exports;

var hasRequiredIsBuffer;

function requireIsBuffer () {
	if (hasRequiredIsBuffer) return isBuffer.exports;
	hasRequiredIsBuffer = 1;
	(function (module, exports) {
		var root = require_root(),
		    stubFalse = requireStubFalse();

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined;

		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;

		module.exports = isBuffer; 
	} (isBuffer, isBuffer.exports));
	return isBuffer.exports;
}

var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;

function require_baseIsTypedArray () {
	if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
	hasRequired_baseIsTypedArray = 1;
	var baseGetTag = require_baseGetTag(),
	    isLength = requireIsLength(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	_baseIsTypedArray = baseIsTypedArray;
	return _baseIsTypedArray;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */

var _baseUnary;
var hasRequired_baseUnary;

function require_baseUnary () {
	if (hasRequired_baseUnary) return _baseUnary;
	hasRequired_baseUnary = 1;
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	_baseUnary = baseUnary;
	return _baseUnary;
}

var _nodeUtil = {exports: {}};

_nodeUtil.exports;

var hasRequired_nodeUtil;

function require_nodeUtil () {
	if (hasRequired_nodeUtil) return _nodeUtil.exports;
	hasRequired_nodeUtil = 1;
	(function (module, exports) {
		var freeGlobal = require_freeGlobal();

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Detect free variable `process` from Node.js. */
		var freeProcess = moduleExports && freeGlobal.process;

		/** Used to access faster Node.js helpers. */
		var nodeUtil = (function() {
		  try {
		    // Use `util.types` for Node.js 10+.
		    var types = freeModule && freeModule.require && freeModule.require('util').types;

		    if (types) {
		      return types;
		    }

		    // Legacy `process.binding('util')` for Node.js < 10.
		    return freeProcess && freeProcess.binding && freeProcess.binding('util');
		  } catch (e) {}
		}());

		module.exports = nodeUtil; 
	} (_nodeUtil, _nodeUtil.exports));
	return _nodeUtil.exports;
}

var isTypedArray_1;
var hasRequiredIsTypedArray;

function requireIsTypedArray () {
	if (hasRequiredIsTypedArray) return isTypedArray_1;
	hasRequiredIsTypedArray = 1;
	var baseIsTypedArray = require_baseIsTypedArray(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	isTypedArray_1 = isTypedArray;
	return isTypedArray_1;
}

var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;

function require_arrayLikeKeys () {
	if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
	hasRequired_arrayLikeKeys = 1;
	var baseTimes = require_baseTimes(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isIndex = require_isIndex(),
	    isTypedArray = requireIsTypedArray();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_arrayLikeKeys = arrayLikeKeys;
	return _arrayLikeKeys;
}

/** Used for built-in method references. */

var _isPrototype;
var hasRequired_isPrototype;

function require_isPrototype () {
	if (hasRequired_isPrototype) return _isPrototype;
	hasRequired_isPrototype = 1;
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	_isPrototype = isPrototype;
	return _isPrototype;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

var _nativeKeysIn;
var hasRequired_nativeKeysIn;

function require_nativeKeysIn () {
	if (hasRequired_nativeKeysIn) return _nativeKeysIn;
	hasRequired_nativeKeysIn = 1;
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_nativeKeysIn = nativeKeysIn;
	return _nativeKeysIn;
}

var _baseKeysIn;
var hasRequired_baseKeysIn;

function require_baseKeysIn () {
	if (hasRequired_baseKeysIn) return _baseKeysIn;
	hasRequired_baseKeysIn = 1;
	var isObject = requireIsObject(),
	    isPrototype = require_isPrototype(),
	    nativeKeysIn = require_nativeKeysIn();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_baseKeysIn = baseKeysIn;
	return _baseKeysIn;
}

var keysIn_1;
var hasRequiredKeysIn;

function requireKeysIn () {
	if (hasRequiredKeysIn) return keysIn_1;
	hasRequiredKeysIn = 1;
	var arrayLikeKeys = require_arrayLikeKeys(),
	    baseKeysIn = require_baseKeysIn(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	keysIn_1 = keysIn;
	return keysIn_1;
}

var defaults_1;
var hasRequiredDefaults$1;

function requireDefaults$1 () {
	if (hasRequiredDefaults$1) return defaults_1;
	hasRequiredDefaults$1 = 1;
	var baseRest = require_baseRest(),
	    eq = requireEq(),
	    isIterateeCall = require_isIterateeCall(),
	    keysIn = requireKeysIn();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults = baseRest(function(object, sources) {
	  object = Object(object);

	  var index = -1;
	  var length = sources.length;
	  var guard = length > 2 ? sources[2] : undefined;

	  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	    length = 1;
	  }

	  while (++index < length) {
	    var source = sources[index];
	    var props = keysIn(source);
	    var propsIndex = -1;
	    var propsLength = props.length;

	    while (++propsIndex < propsLength) {
	      var key = props[propsIndex];
	      var value = object[key];

	      if (value === undefined ||
	          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        object[key] = source[key];
	      }
	    }
	  }

	  return object;
	});

	defaults_1 = defaults;
	return defaults_1;
}

var _stackClear;
var hasRequired_stackClear;

function require_stackClear () {
	if (hasRequired_stackClear) return _stackClear;
	hasRequired_stackClear = 1;
	var ListCache = require_ListCache();

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	_stackClear = stackClear;
	return _stackClear;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _stackDelete;
var hasRequired_stackDelete;

function require_stackDelete () {
	if (hasRequired_stackDelete) return _stackDelete;
	hasRequired_stackDelete = 1;
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	_stackDelete = stackDelete;
	return _stackDelete;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

var _stackGet;
var hasRequired_stackGet;

function require_stackGet () {
	if (hasRequired_stackGet) return _stackGet;
	hasRequired_stackGet = 1;
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	_stackGet = stackGet;
	return _stackGet;
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

var _stackHas;
var hasRequired_stackHas;

function require_stackHas () {
	if (hasRequired_stackHas) return _stackHas;
	hasRequired_stackHas = 1;
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	_stackHas = stackHas;
	return _stackHas;
}

var _stackSet;
var hasRequired_stackSet;

function require_stackSet () {
	if (hasRequired_stackSet) return _stackSet;
	hasRequired_stackSet = 1;
	var ListCache = require_ListCache(),
	    Map = require_Map(),
	    MapCache = require_MapCache();

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	_stackSet = stackSet;
	return _stackSet;
}

var _Stack;
var hasRequired_Stack;

function require_Stack () {
	if (hasRequired_Stack) return _Stack;
	hasRequired_Stack = 1;
	var ListCache = require_ListCache(),
	    stackClear = require_stackClear(),
	    stackDelete = require_stackDelete(),
	    stackGet = require_stackGet(),
	    stackHas = require_stackHas(),
	    stackSet = require_stackSet();

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	_Stack = Stack;
	return _Stack;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */

var _arrayEach;
var hasRequired_arrayEach;

function require_arrayEach () {
	if (hasRequired_arrayEach) return _arrayEach;
	hasRequired_arrayEach = 1;
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	_arrayEach = arrayEach;
	return _arrayEach;
}

var _copyObject;
var hasRequired_copyObject;

function require_copyObject () {
	if (hasRequired_copyObject) return _copyObject;
	hasRequired_copyObject = 1;
	var assignValue = require_assignValue(),
	    baseAssignValue = require_baseAssignValue();

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	_copyObject = copyObject;
	return _copyObject;
}

var _nativeKeys;
var hasRequired_nativeKeys;

function require_nativeKeys () {
	if (hasRequired_nativeKeys) return _nativeKeys;
	hasRequired_nativeKeys = 1;
	var overArg = require_overArg();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	_nativeKeys = nativeKeys;
	return _nativeKeys;
}

var _baseKeys;
var hasRequired_baseKeys;

function require_baseKeys () {
	if (hasRequired_baseKeys) return _baseKeys;
	hasRequired_baseKeys = 1;
	var isPrototype = require_isPrototype(),
	    nativeKeys = require_nativeKeys();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_baseKeys = baseKeys;
	return _baseKeys;
}

var keys_1;
var hasRequiredKeys;

function requireKeys () {
	if (hasRequiredKeys) return keys_1;
	hasRequiredKeys = 1;
	var arrayLikeKeys = require_arrayLikeKeys(),
	    baseKeys = require_baseKeys(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	keys_1 = keys;
	return keys_1;
}

var _baseAssign;
var hasRequired_baseAssign;

function require_baseAssign () {
	if (hasRequired_baseAssign) return _baseAssign;
	hasRequired_baseAssign = 1;
	var copyObject = require_copyObject(),
	    keys = requireKeys();

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	_baseAssign = baseAssign;
	return _baseAssign;
}

var _baseAssignIn;
var hasRequired_baseAssignIn;

function require_baseAssignIn () {
	if (hasRequired_baseAssignIn) return _baseAssignIn;
	hasRequired_baseAssignIn = 1;
	var copyObject = require_copyObject(),
	    keysIn = requireKeysIn();

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && copyObject(source, keysIn(source), object);
	}

	_baseAssignIn = baseAssignIn;
	return _baseAssignIn;
}

var _cloneBuffer = {exports: {}};

_cloneBuffer.exports;

var hasRequired_cloneBuffer;

function require_cloneBuffer () {
	if (hasRequired_cloneBuffer) return _cloneBuffer.exports;
	hasRequired_cloneBuffer = 1;
	(function (module, exports) {
		var root = require_root();

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined,
		    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

		/**
		 * Creates a clone of  `buffer`.
		 *
		 * @private
		 * @param {Buffer} buffer The buffer to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Buffer} Returns the cloned buffer.
		 */
		function cloneBuffer(buffer, isDeep) {
		  if (isDeep) {
		    return buffer.slice();
		  }
		  var length = buffer.length,
		      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		  buffer.copy(result);
		  return result;
		}

		module.exports = cloneBuffer; 
	} (_cloneBuffer, _cloneBuffer.exports));
	return _cloneBuffer.exports;
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */

var _copyArray;
var hasRequired_copyArray;

function require_copyArray () {
	if (hasRequired_copyArray) return _copyArray;
	hasRequired_copyArray = 1;
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	_copyArray = copyArray;
	return _copyArray;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */

var _arrayFilter;
var hasRequired_arrayFilter;

function require_arrayFilter () {
	if (hasRequired_arrayFilter) return _arrayFilter;
	hasRequired_arrayFilter = 1;
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	_arrayFilter = arrayFilter;
	return _arrayFilter;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */

var stubArray_1;
var hasRequiredStubArray;

function requireStubArray () {
	if (hasRequiredStubArray) return stubArray_1;
	hasRequiredStubArray = 1;
	function stubArray() {
	  return [];
	}

	stubArray_1 = stubArray;
	return stubArray_1;
}

var _getSymbols;
var hasRequired_getSymbols;

function require_getSymbols () {
	if (hasRequired_getSymbols) return _getSymbols;
	hasRequired_getSymbols = 1;
	var arrayFilter = require_arrayFilter(),
	    stubArray = requireStubArray();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	_getSymbols = getSymbols;
	return _getSymbols;
}

var _copySymbols;
var hasRequired_copySymbols;

function require_copySymbols () {
	if (hasRequired_copySymbols) return _copySymbols;
	hasRequired_copySymbols = 1;
	var copyObject = require_copyObject(),
	    getSymbols = require_getSymbols();

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols(source), object);
	}

	_copySymbols = copySymbols;
	return _copySymbols;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */

var _arrayPush;
var hasRequired_arrayPush;

function require_arrayPush () {
	if (hasRequired_arrayPush) return _arrayPush;
	hasRequired_arrayPush = 1;
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	_arrayPush = arrayPush;
	return _arrayPush;
}

var _getSymbolsIn;
var hasRequired_getSymbolsIn;

function require_getSymbolsIn () {
	if (hasRequired_getSymbolsIn) return _getSymbolsIn;
	hasRequired_getSymbolsIn = 1;
	var arrayPush = require_arrayPush(),
	    getPrototype = require_getPrototype(),
	    getSymbols = require_getSymbols(),
	    stubArray = requireStubArray();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush(result, getSymbols(object));
	    object = getPrototype(object);
	  }
	  return result;
	};

	_getSymbolsIn = getSymbolsIn;
	return _getSymbolsIn;
}

var _copySymbolsIn;
var hasRequired_copySymbolsIn;

function require_copySymbolsIn () {
	if (hasRequired_copySymbolsIn) return _copySymbolsIn;
	hasRequired_copySymbolsIn = 1;
	var copyObject = require_copyObject(),
	    getSymbolsIn = require_getSymbolsIn();

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return copyObject(source, getSymbolsIn(source), object);
	}

	_copySymbolsIn = copySymbolsIn;
	return _copySymbolsIn;
}

var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;

function require_baseGetAllKeys () {
	if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
	hasRequired_baseGetAllKeys = 1;
	var arrayPush = require_arrayPush(),
	    isArray = requireIsArray();

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	_baseGetAllKeys = baseGetAllKeys;
	return _baseGetAllKeys;
}

var _getAllKeys;
var hasRequired_getAllKeys;

function require_getAllKeys () {
	if (hasRequired_getAllKeys) return _getAllKeys;
	hasRequired_getAllKeys = 1;
	var baseGetAllKeys = require_baseGetAllKeys(),
	    getSymbols = require_getSymbols(),
	    keys = requireKeys();

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	_getAllKeys = getAllKeys;
	return _getAllKeys;
}

var _getAllKeysIn;
var hasRequired_getAllKeysIn;

function require_getAllKeysIn () {
	if (hasRequired_getAllKeysIn) return _getAllKeysIn;
	hasRequired_getAllKeysIn = 1;
	var baseGetAllKeys = require_baseGetAllKeys(),
	    getSymbolsIn = require_getSymbolsIn(),
	    keysIn = requireKeysIn();

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return baseGetAllKeys(object, keysIn, getSymbolsIn);
	}

	_getAllKeysIn = getAllKeysIn;
	return _getAllKeysIn;
}

var _DataView;
var hasRequired_DataView;

function require_DataView () {
	if (hasRequired_DataView) return _DataView;
	hasRequired_DataView = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	_DataView = DataView;
	return _DataView;
}

var _Promise;
var hasRequired_Promise;

function require_Promise () {
	if (hasRequired_Promise) return _Promise;
	hasRequired_Promise = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	_Promise = Promise;
	return _Promise;
}

var _Set;
var hasRequired_Set;

function require_Set () {
	if (hasRequired_Set) return _Set;
	hasRequired_Set = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	_Set = Set;
	return _Set;
}

var _WeakMap;
var hasRequired_WeakMap;

function require_WeakMap () {
	if (hasRequired_WeakMap) return _WeakMap;
	hasRequired_WeakMap = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	_WeakMap = WeakMap;
	return _WeakMap;
}

var _getTag;
var hasRequired_getTag;

function require_getTag () {
	if (hasRequired_getTag) return _getTag;
	hasRequired_getTag = 1;
	var DataView = require_DataView(),
	    Map = require_Map(),
	    Promise = require_Promise(),
	    Set = require_Set(),
	    WeakMap = require_WeakMap(),
	    baseGetTag = require_baseGetTag(),
	    toSource = require_toSource();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	_getTag = getTag;
	return _getTag;
}

/** Used for built-in method references. */

var _initCloneArray;
var hasRequired_initCloneArray;

function require_initCloneArray () {
	if (hasRequired_initCloneArray) return _initCloneArray;
	hasRequired_initCloneArray = 1;
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	_initCloneArray = initCloneArray;
	return _initCloneArray;
}

var _Uint8Array;
var hasRequired_Uint8Array;

function require_Uint8Array () {
	if (hasRequired_Uint8Array) return _Uint8Array;
	hasRequired_Uint8Array = 1;
	var root = require_root();

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	_Uint8Array = Uint8Array;
	return _Uint8Array;
}

var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;

function require_cloneArrayBuffer () {
	if (hasRequired_cloneArrayBuffer) return _cloneArrayBuffer;
	hasRequired_cloneArrayBuffer = 1;
	var Uint8Array = require_Uint8Array();

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	_cloneArrayBuffer = cloneArrayBuffer;
	return _cloneArrayBuffer;
}

var _cloneDataView;
var hasRequired_cloneDataView;

function require_cloneDataView () {
	if (hasRequired_cloneDataView) return _cloneDataView;
	hasRequired_cloneDataView = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer();

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	_cloneDataView = cloneDataView;
	return _cloneDataView;
}

/** Used to match `RegExp` flags from their coerced string values. */

var _cloneRegExp;
var hasRequired_cloneRegExp;

function require_cloneRegExp () {
	if (hasRequired_cloneRegExp) return _cloneRegExp;
	hasRequired_cloneRegExp = 1;
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	_cloneRegExp = cloneRegExp;
	return _cloneRegExp;
}

var _cloneSymbol;
var hasRequired_cloneSymbol;

function require_cloneSymbol () {
	if (hasRequired_cloneSymbol) return _cloneSymbol;
	hasRequired_cloneSymbol = 1;
	var Symbol = require_Symbol();

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	_cloneSymbol = cloneSymbol;
	return _cloneSymbol;
}

var _cloneTypedArray;
var hasRequired_cloneTypedArray;

function require_cloneTypedArray () {
	if (hasRequired_cloneTypedArray) return _cloneTypedArray;
	hasRequired_cloneTypedArray = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer();

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	_cloneTypedArray = cloneTypedArray;
	return _cloneTypedArray;
}

var _initCloneByTag;
var hasRequired_initCloneByTag;

function require_initCloneByTag () {
	if (hasRequired_initCloneByTag) return _initCloneByTag;
	hasRequired_initCloneByTag = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer(),
	    cloneDataView = require_cloneDataView(),
	    cloneRegExp = require_cloneRegExp(),
	    cloneSymbol = require_cloneSymbol(),
	    cloneTypedArray = require_cloneTypedArray();

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag:
	      return cloneArrayBuffer(object);

	    case boolTag:
	    case dateTag:
	      return new Ctor(+object);

	    case dataViewTag:
	      return cloneDataView(object, isDeep);

	    case float32Tag: case float64Tag:
	    case int8Tag: case int16Tag: case int32Tag:
	    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	      return cloneTypedArray(object, isDeep);

	    case mapTag:
	      return new Ctor;

	    case numberTag:
	    case stringTag:
	      return new Ctor(object);

	    case regexpTag:
	      return cloneRegExp(object);

	    case setTag:
	      return new Ctor;

	    case symbolTag:
	      return cloneSymbol(object);
	  }
	}

	_initCloneByTag = initCloneByTag;
	return _initCloneByTag;
}

var _baseCreate;
var hasRequired_baseCreate;

function require_baseCreate () {
	if (hasRequired_baseCreate) return _baseCreate;
	hasRequired_baseCreate = 1;
	var isObject = requireIsObject();

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	_baseCreate = baseCreate;
	return _baseCreate;
}

var _initCloneObject;
var hasRequired_initCloneObject;

function require_initCloneObject () {
	if (hasRequired_initCloneObject) return _initCloneObject;
	hasRequired_initCloneObject = 1;
	var baseCreate = require_baseCreate(),
	    getPrototype = require_getPrototype(),
	    isPrototype = require_isPrototype();

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	_initCloneObject = initCloneObject;
	return _initCloneObject;
}

var _baseIsMap;
var hasRequired_baseIsMap;

function require_baseIsMap () {
	if (hasRequired_baseIsMap) return _baseIsMap;
	hasRequired_baseIsMap = 1;
	var getTag = require_getTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike(value) && getTag(value) == mapTag;
	}

	_baseIsMap = baseIsMap;
	return _baseIsMap;
}

var isMap_1;
var hasRequiredIsMap;

function requireIsMap () {
	if (hasRequiredIsMap) return isMap_1;
	hasRequiredIsMap = 1;
	var baseIsMap = require_baseIsMap(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil && nodeUtil.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	isMap_1 = isMap;
	return isMap_1;
}

var _baseIsSet;
var hasRequired_baseIsSet;

function require_baseIsSet () {
	if (hasRequired_baseIsSet) return _baseIsSet;
	hasRequired_baseIsSet = 1;
	var getTag = require_getTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var setTag = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike(value) && getTag(value) == setTag;
	}

	_baseIsSet = baseIsSet;
	return _baseIsSet;
}

var isSet_1;
var hasRequiredIsSet;

function requireIsSet () {
	if (hasRequiredIsSet) return isSet_1;
	hasRequiredIsSet = 1;
	var baseIsSet = require_baseIsSet(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	isSet_1 = isSet;
	return isSet_1;
}

var _baseClone;
var hasRequired_baseClone;

function require_baseClone () {
	if (hasRequired_baseClone) return _baseClone;
	hasRequired_baseClone = 1;
	var Stack = require_Stack(),
	    arrayEach = require_arrayEach(),
	    assignValue = require_assignValue(),
	    baseAssign = require_baseAssign(),
	    baseAssignIn = require_baseAssignIn(),
	    cloneBuffer = require_cloneBuffer(),
	    copyArray = require_copyArray(),
	    copySymbols = require_copySymbols(),
	    copySymbolsIn = require_copySymbolsIn(),
	    getAllKeys = require_getAllKeys(),
	    getAllKeysIn = require_getAllKeysIn(),
	    getTag = require_getTag(),
	    initCloneArray = require_initCloneArray(),
	    initCloneByTag = require_initCloneByTag(),
	    initCloneObject = require_initCloneObject(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isMap = requireIsMap(),
	    isObject = requireIsObject(),
	    isSet = requireIsSet(),
	    keys = requireKeys(),
	    keysIn = requireKeysIn();

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	cloneableTags[boolTag] = cloneableTags[dateTag] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[setTag] =
	cloneableTags[stringTag] = cloneableTags[symbolTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys)
	    : (isFlat ? keysIn : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	_baseClone = baseClone;
	return _baseClone;
}

var clone_1;
var hasRequiredClone$1;

function requireClone$1 () {
	if (hasRequiredClone$1) return clone_1;
	hasRequiredClone$1 = 1;
	var baseClone = require_baseClone();

	/** Used to compose bitmasks for cloning. */
	var CLONE_SYMBOLS_FLAG = 4;

	/**
	 * Creates a shallow clone of `value`.
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	 * and supports cloning arrays, array buffers, booleans, date objects, maps,
	 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	 * arrays. The own enumerable properties of `arguments` objects are cloned
	 * as plain objects. An empty object is returned for uncloneable values such
	 * as error objects, functions, DOM nodes, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to clone.
	 * @returns {*} Returns the cloned value.
	 * @see _.cloneDeep
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var shallow = _.clone(objects);
	 * console.log(shallow[0] === objects[0]);
	 * // => true
	 */
	function clone(value) {
	  return baseClone(value, CLONE_SYMBOLS_FLAG);
	}

	clone_1 = clone;
	return clone_1;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

var _createBaseFor;
var hasRequired_createBaseFor;

function require_createBaseFor () {
	if (hasRequired_createBaseFor) return _createBaseFor;
	hasRequired_createBaseFor = 1;
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	_createBaseFor = createBaseFor;
	return _createBaseFor;
}

var _baseFor;
var hasRequired_baseFor;

function require_baseFor () {
	if (hasRequired_baseFor) return _baseFor;
	hasRequired_baseFor = 1;
	var createBaseFor = require_createBaseFor();

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	_baseFor = baseFor;
	return _baseFor;
}

var _baseForOwn;
var hasRequired_baseForOwn;

function require_baseForOwn () {
	if (hasRequired_baseForOwn) return _baseForOwn;
	hasRequired_baseForOwn = 1;
	var baseFor = require_baseFor(),
	    keys = requireKeys();

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	_baseForOwn = baseForOwn;
	return _baseForOwn;
}

var _createBaseEach;
var hasRequired_createBaseEach;

function require_createBaseEach () {
	if (hasRequired_createBaseEach) return _createBaseEach;
	hasRequired_createBaseEach = 1;
	var isArrayLike = requireIsArrayLike();

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	_createBaseEach = createBaseEach;
	return _createBaseEach;
}

var _baseEach;
var hasRequired_baseEach;

function require_baseEach () {
	if (hasRequired_baseEach) return _baseEach;
	hasRequired_baseEach = 1;
	var baseForOwn = require_baseForOwn(),
	    createBaseEach = require_createBaseEach();

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	_baseEach = baseEach;
	return _baseEach;
}

var _baseFilter;
var hasRequired_baseFilter;

function require_baseFilter () {
	if (hasRequired_baseFilter) return _baseFilter;
	hasRequired_baseFilter = 1;
	var baseEach = require_baseEach();

	/**
	 * The base implementation of `_.filter` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function baseFilter(collection, predicate) {
	  var result = [];
	  baseEach(collection, function(value, index, collection) {
	    if (predicate(value, index, collection)) {
	      result.push(value);
	    }
	  });
	  return result;
	}

	_baseFilter = baseFilter;
	return _baseFilter;
}

/** Used to stand-in for `undefined` hash values. */

var _setCacheAdd;
var hasRequired_setCacheAdd;

function require_setCacheAdd () {
	if (hasRequired_setCacheAdd) return _setCacheAdd;
	hasRequired_setCacheAdd = 1;
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	_setCacheAdd = setCacheAdd;
	return _setCacheAdd;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */

var _setCacheHas;
var hasRequired_setCacheHas;

function require_setCacheHas () {
	if (hasRequired_setCacheHas) return _setCacheHas;
	hasRequired_setCacheHas = 1;
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	_setCacheHas = setCacheHas;
	return _setCacheHas;
}

var _SetCache;
var hasRequired_SetCache;

function require_SetCache () {
	if (hasRequired_SetCache) return _SetCache;
	hasRequired_SetCache = 1;
	var MapCache = require_MapCache(),
	    setCacheAdd = require_setCacheAdd(),
	    setCacheHas = require_setCacheHas();

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	_SetCache = SetCache;
	return _SetCache;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */

var _arraySome;
var hasRequired_arraySome;

function require_arraySome () {
	if (hasRequired_arraySome) return _arraySome;
	hasRequired_arraySome = 1;
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	_arraySome = arraySome;
	return _arraySome;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

var _cacheHas;
var hasRequired_cacheHas;

function require_cacheHas () {
	if (hasRequired_cacheHas) return _cacheHas;
	hasRequired_cacheHas = 1;
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	_cacheHas = cacheHas;
	return _cacheHas;
}

var _equalArrays;
var hasRequired_equalArrays;

function require_equalArrays () {
	if (hasRequired_equalArrays) return _equalArrays;
	hasRequired_equalArrays = 1;
	var SetCache = require_SetCache(),
	    arraySome = require_arraySome(),
	    cacheHas = require_cacheHas();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	_equalArrays = equalArrays;
	return _equalArrays;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */

var _mapToArray;
var hasRequired_mapToArray;

function require_mapToArray () {
	if (hasRequired_mapToArray) return _mapToArray;
	hasRequired_mapToArray = 1;
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	_mapToArray = mapToArray;
	return _mapToArray;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */

var _setToArray;
var hasRequired_setToArray;

function require_setToArray () {
	if (hasRequired_setToArray) return _setToArray;
	hasRequired_setToArray = 1;
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	_setToArray = setToArray;
	return _setToArray;
}

var _equalByTag;
var hasRequired_equalByTag;

function require_equalByTag () {
	if (hasRequired_equalByTag) return _equalByTag;
	hasRequired_equalByTag = 1;
	var Symbol = require_Symbol(),
	    Uint8Array = require_Uint8Array(),
	    eq = requireEq(),
	    equalArrays = require_equalArrays(),
	    mapToArray = require_mapToArray(),
	    setToArray = require_setToArray();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	_equalByTag = equalByTag;
	return _equalByTag;
}

var _equalObjects;
var hasRequired_equalObjects;

function require_equalObjects () {
	if (hasRequired_equalObjects) return _equalObjects;
	hasRequired_equalObjects = 1;
	var getAllKeys = require_getAllKeys();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	_equalObjects = equalObjects;
	return _equalObjects;
}

var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;

function require_baseIsEqualDeep () {
	if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
	hasRequired_baseIsEqualDeep = 1;
	var Stack = require_Stack(),
	    equalArrays = require_equalArrays(),
	    equalByTag = require_equalByTag(),
	    equalObjects = require_equalObjects(),
	    getTag = require_getTag(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isTypedArray = requireIsTypedArray();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	_baseIsEqualDeep = baseIsEqualDeep;
	return _baseIsEqualDeep;
}

var _baseIsEqual;
var hasRequired_baseIsEqual;

function require_baseIsEqual () {
	if (hasRequired_baseIsEqual) return _baseIsEqual;
	hasRequired_baseIsEqual = 1;
	var baseIsEqualDeep = require_baseIsEqualDeep(),
	    isObjectLike = requireIsObjectLike();

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	_baseIsEqual = baseIsEqual;
	return _baseIsEqual;
}

var _baseIsMatch;
var hasRequired_baseIsMatch;

function require_baseIsMatch () {
	if (hasRequired_baseIsMatch) return _baseIsMatch;
	hasRequired_baseIsMatch = 1;
	var Stack = require_Stack(),
	    baseIsEqual = require_baseIsEqual();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	_baseIsMatch = baseIsMatch;
	return _baseIsMatch;
}

var _isStrictComparable;
var hasRequired_isStrictComparable;

function require_isStrictComparable () {
	if (hasRequired_isStrictComparable) return _isStrictComparable;
	hasRequired_isStrictComparable = 1;
	var isObject = requireIsObject();

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	_isStrictComparable = isStrictComparable;
	return _isStrictComparable;
}

var _getMatchData;
var hasRequired_getMatchData;

function require_getMatchData () {
	if (hasRequired_getMatchData) return _getMatchData;
	hasRequired_getMatchData = 1;
	var isStrictComparable = require_isStrictComparable(),
	    keys = requireKeys();

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	_getMatchData = getMatchData;
	return _getMatchData;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;

function require_matchesStrictComparable () {
	if (hasRequired_matchesStrictComparable) return _matchesStrictComparable;
	hasRequired_matchesStrictComparable = 1;
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	_matchesStrictComparable = matchesStrictComparable;
	return _matchesStrictComparable;
}

var _baseMatches;
var hasRequired_baseMatches;

function require_baseMatches () {
	if (hasRequired_baseMatches) return _baseMatches;
	hasRequired_baseMatches = 1;
	var baseIsMatch = require_baseIsMatch(),
	    getMatchData = require_getMatchData(),
	    matchesStrictComparable = require_matchesStrictComparable();

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	_baseMatches = baseMatches;
	return _baseMatches;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

var _baseHasIn;
var hasRequired_baseHasIn;

function require_baseHasIn () {
	if (hasRequired_baseHasIn) return _baseHasIn;
	hasRequired_baseHasIn = 1;
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	_baseHasIn = baseHasIn;
	return _baseHasIn;
}

var _hasPath;
var hasRequired_hasPath;

function require_hasPath () {
	if (hasRequired_hasPath) return _hasPath;
	hasRequired_hasPath = 1;
	var castPath = require_castPath(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isIndex = require_isIndex(),
	    isLength = requireIsLength(),
	    toKey = require_toKey();

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	_hasPath = hasPath;
	return _hasPath;
}

var hasIn_1;
var hasRequiredHasIn;

function requireHasIn () {
	if (hasRequiredHasIn) return hasIn_1;
	hasRequiredHasIn = 1;
	var baseHasIn = require_baseHasIn(),
	    hasPath = require_hasPath();

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	hasIn_1 = hasIn;
	return hasIn_1;
}

var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;

function require_baseMatchesProperty () {
	if (hasRequired_baseMatchesProperty) return _baseMatchesProperty;
	hasRequired_baseMatchesProperty = 1;
	var baseIsEqual = require_baseIsEqual(),
	    get = requireGet(),
	    hasIn = requireHasIn(),
	    isKey = require_isKey(),
	    isStrictComparable = require_isStrictComparable(),
	    matchesStrictComparable = require_matchesStrictComparable(),
	    toKey = require_toKey();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	_baseMatchesProperty = baseMatchesProperty;
	return _baseMatchesProperty;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

var _baseProperty;
var hasRequired_baseProperty;

function require_baseProperty () {
	if (hasRequired_baseProperty) return _baseProperty;
	hasRequired_baseProperty = 1;
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	_baseProperty = baseProperty;
	return _baseProperty;
}

var _basePropertyDeep;
var hasRequired_basePropertyDeep;

function require_basePropertyDeep () {
	if (hasRequired_basePropertyDeep) return _basePropertyDeep;
	hasRequired_basePropertyDeep = 1;
	var baseGet = require_baseGet();

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	_basePropertyDeep = basePropertyDeep;
	return _basePropertyDeep;
}

var property_1;
var hasRequiredProperty;

function requireProperty () {
	if (hasRequiredProperty) return property_1;
	hasRequiredProperty = 1;
	var baseProperty = require_baseProperty(),
	    basePropertyDeep = require_basePropertyDeep(),
	    isKey = require_isKey(),
	    toKey = require_toKey();

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	property_1 = property;
	return property_1;
}

var _baseIteratee;
var hasRequired_baseIteratee;

function require_baseIteratee () {
	if (hasRequired_baseIteratee) return _baseIteratee;
	hasRequired_baseIteratee = 1;
	var baseMatches = require_baseMatches(),
	    baseMatchesProperty = require_baseMatchesProperty(),
	    identity = requireIdentity(),
	    isArray = requireIsArray(),
	    property = requireProperty();

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	_baseIteratee = baseIteratee;
	return _baseIteratee;
}

var filter_1;
var hasRequiredFilter;

function requireFilter () {
	if (hasRequiredFilter) return filter_1;
	hasRequiredFilter = 1;
	var arrayFilter = require_arrayFilter(),
	    baseFilter = require_baseFilter(),
	    baseIteratee = require_baseIteratee(),
	    isArray = requireIsArray();

	/**
	 * Iterates over elements of `collection`, returning an array of all elements
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * **Note:** Unlike `_.remove`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 * @see _.reject
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * _.filter(users, function(o) { return !o.active; });
	 * // => objects for ['fred']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.filter(users, { 'age': 36, 'active': true });
	 * // => objects for ['barney']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.filter(users, ['active', false]);
	 * // => objects for ['fred']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.filter(users, 'active');
	 * // => objects for ['barney']
	 *
	 * // Combining several predicates using `_.overEvery` or `_.overSome`.
	 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
	 * // => objects for ['fred', 'barney']
	 */
	function filter(collection, predicate) {
	  var func = isArray(collection) ? arrayFilter : baseFilter;
	  return func(collection, baseIteratee(predicate, 3));
	}

	filter_1 = filter;
	return filter_1;
}

var _baseMap;
var hasRequired_baseMap;

function require_baseMap () {
	if (hasRequired_baseMap) return _baseMap;
	hasRequired_baseMap = 1;
	var baseEach = require_baseEach(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	_baseMap = baseMap;
	return _baseMap;
}

var map_1;
var hasRequiredMap;

function requireMap () {
	if (hasRequiredMap) return map_1;
	hasRequiredMap = 1;
	var arrayMap = require_arrayMap(),
	    baseIteratee = require_baseIteratee(),
	    baseMap = require_baseMap(),
	    isArray = requireIsArray();

	/**
	 * Creates an array of values by running each element in `collection` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * _.map([4, 8], square);
	 * // => [16, 64]
	 *
	 * _.map({ 'a': 4, 'b': 8 }, square);
	 * // => [16, 64] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  return func(collection, baseIteratee(iteratee, 3));
	}

	map_1 = map;
	return map_1;
}

var choice;
var hasRequiredChoice;

function requireChoice () {
	if (hasRequiredChoice) return choice;
	hasRequiredChoice = 1;

	/**
	 * Choice object
	 * Normalize input as choice object
	 * @constructor
	 * @param {Number|String|Object} val  Choice value. If an object is passed, it should contains
	 *                                    at least one of `value` or `name` property
	 */

	choice = class Choice {
	  constructor(val, answers) {
	    // Don't process Choice and Separator object
	    if (val instanceof Choice || val.type === 'separator') {
	      // eslint-disable-next-line no-constructor-return
	      return val;
	    }

	    if (typeof val === 'string' || typeof val === 'number') {
	      this.name = String(val);
	      this.value = val;
	      this.short = String(val);
	    } else {
	      Object.assign(this, val, {
	        name: val.name || val.value,
	        value: 'value' in val ? val.value : val.name,
	        short: val.short || val.name || val.value,
	      });
	    }

	    if (typeof val.disabled === 'function') {
	      this.disabled = val.disabled(answers);
	    } else {
	      this.disabled = val.disabled;
	    }
	  }
	};
	return choice;
}

var choices;
var hasRequiredChoices;

function requireChoices () {
	if (hasRequiredChoices) return choices;
	hasRequiredChoices = 1;
	const assert = require$$0$c;
	const _ = {
	  filter: requireFilter(),
	  map: requireMap(),
	};
	const Separator = requireSeparator();
	const Choice = requireChoice();

	/**
	 * Choices collection
	 * Collection of multiple `choice` object
	 */
	choices = class Choices {
	  /** @param {Array} choices  All `choice` to keep in the collection */
	  constructor(choices, answers) {
	    this.choices = choices.map((val) => {
	      if (val.type === 'separator') {
	        if (!(val instanceof Separator)) {
	          val = new Separator(val.line);
	        }

	        return val;
	      }

	      return new Choice(val, answers);
	    });

	    this.realChoices = this.choices
	      .filter(Separator.exclude)
	      .filter((item) => !item.disabled);

	    Object.defineProperty(this, 'length', {
	      get() {
	        return this.choices.length;
	      },
	      set(val) {
	        this.choices.length = val;
	      },
	    });

	    Object.defineProperty(this, 'realLength', {
	      get() {
	        return this.realChoices.length;
	      },
	      set() {
	        throw new Error('Cannot set `realLength` of a Choices collection');
	      },
	    });
	  }

	  /**
	   * Get a valid choice from the collection
	   * @param  {Number} selector  The selected choice index
	   * @return {Choice|Undefined} Return the matched choice or undefined
	   */

	  getChoice(selector) {
	    assert(typeof selector === 'number');
	    return this.realChoices[selector];
	  }

	  /**
	   * Get a raw element from the collection
	   * @param  {Number} selector  The selected index value
	   * @return {Choice|Undefined} Return the matched choice or undefined
	   */

	  get(selector) {
	    assert(typeof selector === 'number');
	    return this.choices[selector];
	  }

	  /**
	   * Match the valid choices against a where clause
	   * @param  {Object} whereClause Lodash `where` clause
	   * @return {Array}              Matching choices or empty array
	   */

	  where(whereClause) {
	    return _.filter(this.realChoices, whereClause);
	  }

	  /**
	   * Pluck a particular key from the choices
	   * @param  {String} propertyName Property name to select
	   * @return {Array}               Selected properties
	   */

	  pluck(propertyName) {
	    return _.map(this.realChoices, propertyName);
	  }

	  // Expose usual Array methods
	  indexOf(...args) {
	    return this.choices.indexOf(...args);
	  }

	  forEach(...args) {
	    return this.choices.forEach(...args);
	  }

	  filter(...args) {
	    return this.choices.filter(...args);
	  }

	  reduce(...args) {
	    return this.choices.reduce(...args);
	  }

	  find(func) {
	    return this.choices.find(func);
	  }

	  push(...args) {
	    const objs = args.map((val) => new Choice(val));
	    this.choices.push(...objs);
	    this.realChoices = this.choices
	      .filter(Separator.exclude)
	      .filter((item) => !item.disabled);
	    return this.choices;
	  }
	};
	return choices;
}

var cliWidth = {exports: {}};

var hasRequiredCliWidth;

function requireCliWidth () {
	if (hasRequiredCliWidth) return cliWidth.exports;
	hasRequiredCliWidth = 1;
	(function (module, exports) {

		module.exports = cliWidth;

		function normalizeOpts(options) {
		  let defaultOpts = {
		    defaultWidth: 0,
		    output: process.stdout,
		    tty: require$$3$1,
		  };

		  if (!options) {
		    return defaultOpts;
		  }

		  Object.keys(defaultOpts).forEach(function (key) {
		    if (!options[key]) {
		      options[key] = defaultOpts[key];
		    }
		  });

		  return options;
		}

		function cliWidth(options) {
		  let opts = normalizeOpts(options);

		  if (opts.output.getWindowSize) {
		    return opts.output.getWindowSize()[0] || opts.defaultWidth;
		  }

		  if (opts.tty.getWindowSize) {
		    return opts.tty.getWindowSize()[1] || opts.defaultWidth;
		  }

		  if (opts.output.columns) {
		    return opts.output.columns;
		  }

		  if (process.env.CLI_WIDTH) {
		    let width = parseInt(process.env.CLI_WIDTH, 10);

		    if (!isNaN(width) && width !== 0) {
		      return width;
		    }
		  }

		  return opts.defaultWidth;
		} 
	} (cliWidth));
	return cliWidth.exports;
}

var wrapAnsi_1;
var hasRequiredWrapAnsi;

function requireWrapAnsi () {
	if (hasRequiredWrapAnsi) return wrapAnsi_1;
	hasRequiredWrapAnsi = 1;
	const stringWidth = requireStringWidth();
	const stripAnsi = requireStripAnsi();
	const ansiStyles = requireAnsiStyles();

	const ESCAPES = new Set([
		'\u001B',
		'\u009B'
	]);

	const END_CODE = 39;

	const wrapAnsi = code => `${ESCAPES.values().next().value}[${code}m`;

	// Calculate the length of words split on ' ', ignoring
	// the extra characters added by ansi escape codes
	const wordLengths = string => string.split(' ').map(character => stringWidth(character));

	// Wrap a long word across multiple rows
	// Ansi escape codes do not count towards length
	const wrapWord = (rows, word, columns) => {
		const characters = [...word];

		let isInsideEscape = false;
		let visible = stringWidth(stripAnsi(rows[rows.length - 1]));

		for (const [index, character] of characters.entries()) {
			const characterLength = stringWidth(character);

			if (visible + characterLength <= columns) {
				rows[rows.length - 1] += character;
			} else {
				rows.push(character);
				visible = 0;
			}

			if (ESCAPES.has(character)) {
				isInsideEscape = true;
			} else if (isInsideEscape && character === 'm') {
				isInsideEscape = false;
				continue;
			}

			if (isInsideEscape) {
				continue;
			}

			visible += characterLength;

			if (visible === columns && index < characters.length - 1) {
				rows.push('');
				visible = 0;
			}
		}

		// It's possible that the last row we copy over is only
		// ansi escape characters, handle this edge-case
		if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
			rows[rows.length - 2] += rows.pop();
		}
	};

	// Trims spaces from a string ignoring invisible sequences
	const stringVisibleTrimSpacesRight = str => {
		const words = str.split(' ');
		let last = words.length;

		while (last > 0) {
			if (stringWidth(words[last - 1]) > 0) {
				break;
			}

			last--;
		}

		if (last === words.length) {
			return str;
		}

		return words.slice(0, last).join(' ') + words.slice(last).join('');
	};

	// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
	//
	// 'hard' will never allow a string to take up more than columns characters
	//
	// 'soft' allows long words to expand past the column length
	const exec = (string, columns, options = {}) => {
		if (options.trim !== false && string.trim() === '') {
			return '';
		}

		let pre = '';
		let ret = '';
		let escapeCode;

		const lengths = wordLengths(string);
		let rows = [''];

		for (const [index, word] of string.split(' ').entries()) {
			if (options.trim !== false) {
				rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
			}

			let rowLength = stringWidth(rows[rows.length - 1]);

			if (index !== 0) {
				if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
					// If we start with a new word but the current row length equals the length of the columns, add a new row
					rows.push('');
					rowLength = 0;
				}

				if (rowLength > 0 || options.trim === false) {
					rows[rows.length - 1] += ' ';
					rowLength++;
				}
			}

			// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
			if (options.hard && lengths[index] > columns) {
				const remainingColumns = (columns - rowLength);
				const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
				const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
				if (breaksStartingNextLine < breaksStartingThisLine) {
					rows.push('');
				}

				wrapWord(rows, word, columns);
				continue;
			}

			if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
				if (options.wordWrap === false && rowLength < columns) {
					wrapWord(rows, word, columns);
					continue;
				}

				rows.push('');
			}

			if (rowLength + lengths[index] > columns && options.wordWrap === false) {
				wrapWord(rows, word, columns);
				continue;
			}

			rows[rows.length - 1] += word;
		}

		if (options.trim !== false) {
			rows = rows.map(stringVisibleTrimSpacesRight);
		}

		pre = rows.join('\n');

		for (const [index, character] of [...pre].entries()) {
			ret += character;

			if (ESCAPES.has(character)) {
				const code = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
				escapeCode = code === END_CODE ? null : code;
			}

			const code = ansiStyles.codes.get(Number(escapeCode));

			if (escapeCode && code) {
				if (pre[index + 1] === '\n') {
					ret += wrapAnsi(code);
				} else if (character === '\n') {
					ret += wrapAnsi(escapeCode);
				}
			}
		}

		return ret;
	};

	// For each newline, invoke the method separately
	wrapAnsi_1 = (string, columns, options) => {
		return String(string)
			.normalize()
			.replace(/\r\n/g, '\n')
			.split('\n')
			.map(line => exec(line, columns, options))
			.join('\n');
	};
	return wrapAnsi_1;
}

var ora = {exports: {}};

var dots = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots2 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots3 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots4 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots5 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots6 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots7 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots8 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots9 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots10 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots11 = {
	interval: 100,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots12 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots13 = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dots8Bit = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var sand = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var line = {
	interval: 130,
	frames: [
		"-",
		"\\",
		"|",
		"/"
	]
};
var line2 = {
	interval: 100,
	frames: [
		"",
		"-",
		"",
		"",
		"",
		"-"
	]
};
var pipe = {
	interval: 100,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var simpleDots = {
	interval: 400,
	frames: [
		".  ",
		".. ",
		"...",
		"   "
	]
};
var simpleDotsScrolling = {
	interval: 200,
	frames: [
		".  ",
		".. ",
		"...",
		" ..",
		"  .",
		"   "
	]
};
var star = {
	interval: 70,
	frames: [
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var star2 = {
	interval: 80,
	frames: [
		"+",
		"x",
		"*"
	]
};
var flip = {
	interval: 70,
	frames: [
		"_",
		"_",
		"_",
		"-",
		"`",
		"`",
		"'",
		"",
		"-",
		"_",
		"_",
		"_"
	]
};
var hamburger = {
	interval: 100,
	frames: [
		"",
		"",
		""
	]
};
var growVertical = {
	interval: 120,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var growHorizontal = {
	interval: 120,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var balloon = {
	interval: 140,
	frames: [
		" ",
		".",
		"o",
		"O",
		"@",
		"*",
		" "
	]
};
var balloon2 = {
	interval: 120,
	frames: [
		".",
		"o",
		"O",
		"",
		"O",
		"o",
		"."
	]
};
var noise = {
	interval: 100,
	frames: [
		"",
		"",
		""
	]
};
var bounce = {
	interval: 120,
	frames: [
		"",
		"",
		"",
		""
	]
};
var boxBounce = {
	interval: 120,
	frames: [
		"",
		"",
		"",
		""
	]
};
var boxBounce2 = {
	interval: 100,
	frames: [
		"",
		"",
		"",
		""
	]
};
var triangle = {
	interval: 50,
	frames: [
		"",
		"",
		"",
		""
	]
};
var binary = {
	interval: 80,
	frames: [
		"010010",
		"001100",
		"100101",
		"111010",
		"111101",
		"010111",
		"101011",
		"111000",
		"110011",
		"110101"
	]
};
var arc = {
	interval: 100,
	frames: [
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var circle = {
	interval: 120,
	frames: [
		"",
		"",
		""
	]
};
var squareCorners = {
	interval: 180,
	frames: [
		"",
		"",
		"",
		""
	]
};
var circleQuarters = {
	interval: 120,
	frames: [
		"",
		"",
		"",
		""
	]
};
var circleHalves = {
	interval: 50,
	frames: [
		"",
		"",
		"",
		""
	]
};
var squish = {
	interval: 100,
	frames: [
		"",
		""
	]
};
var toggle = {
	interval: 250,
	frames: [
		"",
		""
	]
};
var toggle2 = {
	interval: 80,
	frames: [
		"",
		""
	]
};
var toggle3 = {
	interval: 120,
	frames: [
		"",
		""
	]
};
var toggle4 = {
	interval: 100,
	frames: [
		"",
		"",
		"",
		""
	]
};
var toggle5 = {
	interval: 100,
	frames: [
		"",
		""
	]
};
var toggle6 = {
	interval: 300,
	frames: [
		"",
		""
	]
};
var toggle7 = {
	interval: 80,
	frames: [
		"",
		""
	]
};
var toggle8 = {
	interval: 100,
	frames: [
		"",
		""
	]
};
var toggle9 = {
	interval: 100,
	frames: [
		"",
		""
	]
};
var toggle10 = {
	interval: 100,
	frames: [
		"",
		"",
		""
	]
};
var toggle11 = {
	interval: 50,
	frames: [
		"",
		""
	]
};
var toggle12 = {
	interval: 120,
	frames: [
		"",
		""
	]
};
var toggle13 = {
	interval: 80,
	frames: [
		"=",
		"*",
		"-"
	]
};
var arrow = {
	interval: 100,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var arrow2 = {
	interval: 80,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var arrow3 = {
	interval: 120,
	frames: [
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var bouncingBar = {
	interval: 80,
	frames: [
		"[    ]",
		"[=   ]",
		"[==  ]",
		"[=== ]",
		"[====]",
		"[ ===]",
		"[  ==]",
		"[   =]",
		"[    ]",
		"[   =]",
		"[  ==]",
		"[ ===]",
		"[====]",
		"[=== ]",
		"[==  ]",
		"[=   ]"
	]
};
var bouncingBall = {
	interval: 80,
	frames: [
		"(     )",
		"(     )",
		"(     )",
		"(     )",
		"(     )",
		"(     )",
		"(     )",
		"(     )",
		"(     )",
		"(     )"
	]
};
var smiley = {
	interval: 200,
	frames: [
		" ",
		" "
	]
};
var monkey = {
	interval: 300,
	frames: [
		" ",
		" ",
		" ",
		" "
	]
};
var hearts = {
	interval: 100,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var clock = {
	interval: 100,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var earth = {
	interval: 180,
	frames: [
		" ",
		" ",
		" "
	]
};
var material = {
	interval: 17,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var moon = {
	interval: 80,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var runner = {
	interval: 140,
	frames: [
		" ",
		" "
	]
};
var pong = {
	interval: 80,
	frames: [
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       "
	]
};
var shark = {
	interval: 120,
	frames: [
		"|\\____________",
		"_|\\___________",
		"__|\\__________",
		"___|\\_________",
		"____|\\________",
		"_____|\\_______",
		"______|\\______",
		"_______|\\_____",
		"________|\\____",
		"_________|\\___",
		"__________|\\__",
		"___________|\\_",
		"____________|\\",
		"____________/|",
		"___________/|_",
		"__________/|__",
		"_________/|___",
		"________/|____",
		"_______/|_____",
		"______/|______",
		"_____/|_______",
		"____/|________",
		"___/|_________",
		"__/|__________",
		"_/|___________",
		"/|____________"
	]
};
var dqpb = {
	interval: 100,
	frames: [
		"d",
		"q",
		"p",
		"b"
	]
};
var weather = {
	interval: 100,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var christmas = {
	interval: 400,
	frames: [
		"",
		""
	]
};
var grenade = {
	interval: 80,
	frames: [
		"  ",
		"  ",
		"  ",
		"  ",
		"  ",
		"  ",
		"  |",
		"  ",
		"  ",
		"  ",
		"  ",
		"   ",
		"   ",
		"   "
	]
};
var point = {
	interval: 125,
	frames: [
		"",
		"",
		"",
		"",
		""
	]
};
var layer = {
	interval: 150,
	frames: [
		"-",
		"=",
		""
	]
};
var betaWave = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var fingerDance = {
	interval: 160,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var fistBump = {
	interval: 80,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var soccerHeader = {
	interval: 80,
	frames: [
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         "
	]
};
var mindblown = {
	interval: 160,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var speaker = {
	interval: 160,
	frames: [
		" ",
		" ",
		" ",
		" "
	]
};
var orangePulse = {
	interval: 100,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var bluePulse = {
	interval: 100,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var orangeBluePulse = {
	interval: 100,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var timeTravel = {
	interval: 100,
	frames: [
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" ",
		" "
	]
};
var aesthetic = {
	interval: 80,
	frames: [
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	]
};
var dwarfFortress = {
	interval: 80,
	frames: [
		"   ",
		"  ",
		"  ",
		"  ",
		"  ",
		"  ",
		"  ",
		"  ",
		"  ",
		"   ",
		"   ",
		"   ",
		"   ",
		"   ",
		"   ",
		"   ",
		"   ",
		"   ",
		"    ",
		"    ",
		"    ",
		"    ",
		"    ",
		"    ",
		"    ",
		"    ",
		"    ",
		"     ",
		"     ",
		"     ",
		"     ",
		"     ",
		"     ",
		"     ",
		"     ",
		"     ",
		"      ",
		"      ",
		"      ",
		"      ",
		"      ",
		"      ",
		"      ",
		"      ",
		"      ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"       ",
		"        ",
		"        ",
		"        ",
		"        ",
		"        ",
		"        ",
		"        ",
		"        ",
		"        ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"         ",
		"          ",
		"          ",
		"          ",
		"          ",
		"          ",
		"          ",
		"          ",
		"          ",
		"          ",
		"           ",
		"          &",
		"         &",
		"         &",
		"         &",
		"        & ",
		"         & ",
		"        &  ",
		"        &  ",
		"       &   ",
		"       &   ",
		"      &    ",
		"      &    ",
		"      &     ",
		"      &     ",
		"     &     ",
		"     &     ",
		"    &      ",
		"    &      ",
		"   &      ",
		"   &      ",
		"  &       ",
		"  &       ",
		" &       ",
		" &       ",
		"&        ",
		"&        ",
		"        ",
		"        ",
		"        ",
		"        ",
		"       ",
		"       ",
		"       ",
		"       ",
		"      ",
		"      ",
		"      ",
		"      ",
		"     ",
		"     ",
		"     ",
		"     ",
		"    ",
		"    ",
		"    ",
		"    ",
		"   ",
		"   ",
		"   ",
		"   ",
		"   "
	]
};
var require$$0$1 = {
	dots: dots,
	dots2: dots2,
	dots3: dots3,
	dots4: dots4,
	dots5: dots5,
	dots6: dots6,
	dots7: dots7,
	dots8: dots8,
	dots9: dots9,
	dots10: dots10,
	dots11: dots11,
	dots12: dots12,
	dots13: dots13,
	dots8Bit: dots8Bit,
	sand: sand,
	line: line,
	line2: line2,
	pipe: pipe,
	simpleDots: simpleDots,
	simpleDotsScrolling: simpleDotsScrolling,
	star: star,
	star2: star2,
	flip: flip,
	hamburger: hamburger,
	growVertical: growVertical,
	growHorizontal: growHorizontal,
	balloon: balloon,
	balloon2: balloon2,
	noise: noise,
	bounce: bounce,
	boxBounce: boxBounce,
	boxBounce2: boxBounce2,
	triangle: triangle,
	binary: binary,
	arc: arc,
	circle: circle,
	squareCorners: squareCorners,
	circleQuarters: circleQuarters,
	circleHalves: circleHalves,
	squish: squish,
	toggle: toggle,
	toggle2: toggle2,
	toggle3: toggle3,
	toggle4: toggle4,
	toggle5: toggle5,
	toggle6: toggle6,
	toggle7: toggle7,
	toggle8: toggle8,
	toggle9: toggle9,
	toggle10: toggle10,
	toggle11: toggle11,
	toggle12: toggle12,
	toggle13: toggle13,
	arrow: arrow,
	arrow2: arrow2,
	arrow3: arrow3,
	bouncingBar: bouncingBar,
	bouncingBall: bouncingBall,
	smiley: smiley,
	monkey: monkey,
	hearts: hearts,
	clock: clock,
	earth: earth,
	material: material,
	moon: moon,
	runner: runner,
	pong: pong,
	shark: shark,
	dqpb: dqpb,
	weather: weather,
	christmas: christmas,
	grenade: grenade,
	point: point,
	layer: layer,
	betaWave: betaWave,
	fingerDance: fingerDance,
	fistBump: fistBump,
	soccerHeader: soccerHeader,
	mindblown: mindblown,
	speaker: speaker,
	orangePulse: orangePulse,
	bluePulse: bluePulse,
	orangeBluePulse: orangeBluePulse,
	timeTravel: timeTravel,
	aesthetic: aesthetic,
	dwarfFortress: dwarfFortress
};

var cliSpinners;
var hasRequiredCliSpinners;

function requireCliSpinners () {
	if (hasRequiredCliSpinners) return cliSpinners;
	hasRequiredCliSpinners = 1;

	const spinners = Object.assign({}, require$$0$1); // eslint-disable-line import/extensions

	const spinnersList = Object.keys(spinners);

	Object.defineProperty(spinners, 'random', {
		get() {
			const randomIndex = Math.floor(Math.random() * spinnersList.length);
			const spinnerName = spinnersList[randomIndex];
			return spinners[spinnerName];
		}
	});

	cliSpinners = spinners;
	return cliSpinners;
}

var isUnicodeSupported;
var hasRequiredIsUnicodeSupported;

function requireIsUnicodeSupported () {
	if (hasRequiredIsUnicodeSupported) return isUnicodeSupported;
	hasRequiredIsUnicodeSupported = 1;

	isUnicodeSupported = () => {
		if (process.platform !== 'win32') {
			return true;
		}

		return Boolean(process.env.CI) ||
			Boolean(process.env.WT_SESSION) || // Windows Terminal
			process.env.TERM_PROGRAM === 'vscode' ||
			process.env.TERM === 'xterm-256color' ||
			process.env.TERM === 'alacritty';
	};
	return isUnicodeSupported;
}

var logSymbols;
var hasRequiredLogSymbols;

function requireLogSymbols () {
	if (hasRequiredLogSymbols) return logSymbols;
	hasRequiredLogSymbols = 1;
	const chalk = requireSource();
	const isUnicodeSupported = requireIsUnicodeSupported();

	const main = {
		info: chalk.blue(''),
		success: chalk.green(''),
		warning: chalk.yellow(''),
		error: chalk.red('')
	};

	const fallback = {
		info: chalk.blue('i'),
		success: chalk.green(''),
		warning: chalk.yellow(''),
		error: chalk.red('')
	};

	logSymbols = isUnicodeSupported() ? main : fallback;
	return logSymbols;
}

var wcwidth = {exports: {}};

var clone = {exports: {}};

var hasRequiredClone;

function requireClone () {
	if (hasRequiredClone) return clone.exports;
	hasRequiredClone = 1;
	(function (module) {
		var clone = (function() {

		/**
		 * Clones (copies) an Object using deep copying.
		 *
		 * This function supports circular references by default, but if you are certain
		 * there are no circular references in your object, you can save some CPU time
		 * by calling clone(obj, false).
		 *
		 * Caution: if `circular` is false and `parent` contains circular references,
		 * your program may enter an infinite loop and crash.
		 *
		 * @param `parent` - the object to be cloned
		 * @param `circular` - set to true if the object to be cloned may contain
		 *    circular references. (optional - true by default)
		 * @param `depth` - set to a number if the object is only to be cloned to
		 *    a particular depth. (optional - defaults to Infinity)
		 * @param `prototype` - sets the prototype to be used when cloning an object.
		 *    (optional - defaults to parent prototype).
		*/
		function clone(parent, circular, depth, prototype) {
		  if (typeof circular === 'object') {
		    depth = circular.depth;
		    prototype = circular.prototype;
		    circular.filter;
		    circular = circular.circular;
		  }
		  // maintain two arrays for circular references, where corresponding parents
		  // and children have the same index
		  var allParents = [];
		  var allChildren = [];

		  var useBuffer = typeof Buffer != 'undefined';

		  if (typeof circular == 'undefined')
		    circular = true;

		  if (typeof depth == 'undefined')
		    depth = Infinity;

		  // recurse this function so we don't reset allParents and allChildren
		  function _clone(parent, depth) {
		    // cloning null always returns null
		    if (parent === null)
		      return null;

		    if (depth == 0)
		      return parent;

		    var child;
		    var proto;
		    if (typeof parent != 'object') {
		      return parent;
		    }

		    if (clone.__isArray(parent)) {
		      child = [];
		    } else if (clone.__isRegExp(parent)) {
		      child = new RegExp(parent.source, __getRegExpFlags(parent));
		      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
		    } else if (clone.__isDate(parent)) {
		      child = new Date(parent.getTime());
		    } else if (useBuffer && Buffer.isBuffer(parent)) {
		      if (Buffer.allocUnsafe) {
		        // Node.js >= 4.5.0
		        child = Buffer.allocUnsafe(parent.length);
		      } else {
		        // Older Node.js versions
		        child = new Buffer(parent.length);
		      }
		      parent.copy(child);
		      return child;
		    } else {
		      if (typeof prototype == 'undefined') {
		        proto = Object.getPrototypeOf(parent);
		        child = Object.create(proto);
		      }
		      else {
		        child = Object.create(prototype);
		        proto = prototype;
		      }
		    }

		    if (circular) {
		      var index = allParents.indexOf(parent);

		      if (index != -1) {
		        return allChildren[index];
		      }
		      allParents.push(parent);
		      allChildren.push(child);
		    }

		    for (var i in parent) {
		      var attrs;
		      if (proto) {
		        attrs = Object.getOwnPropertyDescriptor(proto, i);
		      }

		      if (attrs && attrs.set == null) {
		        continue;
		      }
		      child[i] = _clone(parent[i], depth - 1);
		    }

		    return child;
		  }

		  return _clone(parent, depth);
		}

		/**
		 * Simple flat clone using prototype, accepts only objects, usefull for property
		 * override on FLAT configuration object (no nested props).
		 *
		 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
		 * works.
		 */
		clone.clonePrototype = function clonePrototype(parent) {
		  if (parent === null)
		    return null;

		  var c = function () {};
		  c.prototype = parent;
		  return new c();
		};

		// private utility functions

		function __objToStr(o) {
		  return Object.prototype.toString.call(o);
		}		clone.__objToStr = __objToStr;

		function __isDate(o) {
		  return typeof o === 'object' && __objToStr(o) === '[object Date]';
		}		clone.__isDate = __isDate;

		function __isArray(o) {
		  return typeof o === 'object' && __objToStr(o) === '[object Array]';
		}		clone.__isArray = __isArray;

		function __isRegExp(o) {
		  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
		}		clone.__isRegExp = __isRegExp;

		function __getRegExpFlags(re) {
		  var flags = '';
		  if (re.global) flags += 'g';
		  if (re.ignoreCase) flags += 'i';
		  if (re.multiline) flags += 'm';
		  return flags;
		}		clone.__getRegExpFlags = __getRegExpFlags;

		return clone;
		})();

		if (module.exports) {
		  module.exports = clone;
		} 
	} (clone));
	return clone.exports;
}

var defaults;
var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults;
	hasRequiredDefaults = 1;
	var clone = requireClone();

	defaults = function(options, defaults) {
	  options = options || {};

	  Object.keys(defaults).forEach(function(key) {
	    if (typeof options[key] === 'undefined') {
	      options[key] = clone(defaults[key]);
	    }
	  });

	  return options;
	};
	return defaults;
}

var combining;
var hasRequiredCombining;

function requireCombining () {
	if (hasRequiredCombining) return combining;
	hasRequiredCombining = 1;
	combining = [
	    [ 0x0300, 0x036F ], [ 0x0483, 0x0486 ], [ 0x0488, 0x0489 ],
	    [ 0x0591, 0x05BD ], [ 0x05BF, 0x05BF ], [ 0x05C1, 0x05C2 ],
	    [ 0x05C4, 0x05C5 ], [ 0x05C7, 0x05C7 ], [ 0x0600, 0x0603 ],
	    [ 0x0610, 0x0615 ], [ 0x064B, 0x065E ], [ 0x0670, 0x0670 ],
	    [ 0x06D6, 0x06E4 ], [ 0x06E7, 0x06E8 ], [ 0x06EA, 0x06ED ],
	    [ 0x070F, 0x070F ], [ 0x0711, 0x0711 ], [ 0x0730, 0x074A ],
	    [ 0x07A6, 0x07B0 ], [ 0x07EB, 0x07F3 ], [ 0x0901, 0x0902 ],
	    [ 0x093C, 0x093C ], [ 0x0941, 0x0948 ], [ 0x094D, 0x094D ],
	    [ 0x0951, 0x0954 ], [ 0x0962, 0x0963 ], [ 0x0981, 0x0981 ],
	    [ 0x09BC, 0x09BC ], [ 0x09C1, 0x09C4 ], [ 0x09CD, 0x09CD ],
	    [ 0x09E2, 0x09E3 ], [ 0x0A01, 0x0A02 ], [ 0x0A3C, 0x0A3C ],
	    [ 0x0A41, 0x0A42 ], [ 0x0A47, 0x0A48 ], [ 0x0A4B, 0x0A4D ],
	    [ 0x0A70, 0x0A71 ], [ 0x0A81, 0x0A82 ], [ 0x0ABC, 0x0ABC ],
	    [ 0x0AC1, 0x0AC5 ], [ 0x0AC7, 0x0AC8 ], [ 0x0ACD, 0x0ACD ],
	    [ 0x0AE2, 0x0AE3 ], [ 0x0B01, 0x0B01 ], [ 0x0B3C, 0x0B3C ],
	    [ 0x0B3F, 0x0B3F ], [ 0x0B41, 0x0B43 ], [ 0x0B4D, 0x0B4D ],
	    [ 0x0B56, 0x0B56 ], [ 0x0B82, 0x0B82 ], [ 0x0BC0, 0x0BC0 ],
	    [ 0x0BCD, 0x0BCD ], [ 0x0C3E, 0x0C40 ], [ 0x0C46, 0x0C48 ],
	    [ 0x0C4A, 0x0C4D ], [ 0x0C55, 0x0C56 ], [ 0x0CBC, 0x0CBC ],
	    [ 0x0CBF, 0x0CBF ], [ 0x0CC6, 0x0CC6 ], [ 0x0CCC, 0x0CCD ],
	    [ 0x0CE2, 0x0CE3 ], [ 0x0D41, 0x0D43 ], [ 0x0D4D, 0x0D4D ],
	    [ 0x0DCA, 0x0DCA ], [ 0x0DD2, 0x0DD4 ], [ 0x0DD6, 0x0DD6 ],
	    [ 0x0E31, 0x0E31 ], [ 0x0E34, 0x0E3A ], [ 0x0E47, 0x0E4E ],
	    [ 0x0EB1, 0x0EB1 ], [ 0x0EB4, 0x0EB9 ], [ 0x0EBB, 0x0EBC ],
	    [ 0x0EC8, 0x0ECD ], [ 0x0F18, 0x0F19 ], [ 0x0F35, 0x0F35 ],
	    [ 0x0F37, 0x0F37 ], [ 0x0F39, 0x0F39 ], [ 0x0F71, 0x0F7E ],
	    [ 0x0F80, 0x0F84 ], [ 0x0F86, 0x0F87 ], [ 0x0F90, 0x0F97 ],
	    [ 0x0F99, 0x0FBC ], [ 0x0FC6, 0x0FC6 ], [ 0x102D, 0x1030 ],
	    [ 0x1032, 0x1032 ], [ 0x1036, 0x1037 ], [ 0x1039, 0x1039 ],
	    [ 0x1058, 0x1059 ], [ 0x1160, 0x11FF ], [ 0x135F, 0x135F ],
	    [ 0x1712, 0x1714 ], [ 0x1732, 0x1734 ], [ 0x1752, 0x1753 ],
	    [ 0x1772, 0x1773 ], [ 0x17B4, 0x17B5 ], [ 0x17B7, 0x17BD ],
	    [ 0x17C6, 0x17C6 ], [ 0x17C9, 0x17D3 ], [ 0x17DD, 0x17DD ],
	    [ 0x180B, 0x180D ], [ 0x18A9, 0x18A9 ], [ 0x1920, 0x1922 ],
	    [ 0x1927, 0x1928 ], [ 0x1932, 0x1932 ], [ 0x1939, 0x193B ],
	    [ 0x1A17, 0x1A18 ], [ 0x1B00, 0x1B03 ], [ 0x1B34, 0x1B34 ],
	    [ 0x1B36, 0x1B3A ], [ 0x1B3C, 0x1B3C ], [ 0x1B42, 0x1B42 ],
	    [ 0x1B6B, 0x1B73 ], [ 0x1DC0, 0x1DCA ], [ 0x1DFE, 0x1DFF ],
	    [ 0x200B, 0x200F ], [ 0x202A, 0x202E ], [ 0x2060, 0x2063 ],
	    [ 0x206A, 0x206F ], [ 0x20D0, 0x20EF ], [ 0x302A, 0x302F ],
	    [ 0x3099, 0x309A ], [ 0xA806, 0xA806 ], [ 0xA80B, 0xA80B ],
	    [ 0xA825, 0xA826 ], [ 0xFB1E, 0xFB1E ], [ 0xFE00, 0xFE0F ],
	    [ 0xFE20, 0xFE23 ], [ 0xFEFF, 0xFEFF ], [ 0xFFF9, 0xFFFB ],
	    [ 0x10A01, 0x10A03 ], [ 0x10A05, 0x10A06 ], [ 0x10A0C, 0x10A0F ],
	    [ 0x10A38, 0x10A3A ], [ 0x10A3F, 0x10A3F ], [ 0x1D167, 0x1D169 ],
	    [ 0x1D173, 0x1D182 ], [ 0x1D185, 0x1D18B ], [ 0x1D1AA, 0x1D1AD ],
	    [ 0x1D242, 0x1D244 ], [ 0xE0001, 0xE0001 ], [ 0xE0020, 0xE007F ],
	    [ 0xE0100, 0xE01EF ]
	];
	return combining;
}

var hasRequiredWcwidth;

function requireWcwidth () {
	if (hasRequiredWcwidth) return wcwidth.exports;
	hasRequiredWcwidth = 1;

	var defaults = requireDefaults();
	var combining = requireCombining();

	var DEFAULTS = {
	  nul: 0,
	  control: 0
	};

	wcwidth.exports = function wcwidth(str) {
	  return wcswidth(str, DEFAULTS)
	};

	wcwidth.exports.config = function(opts) {
	  opts = defaults(opts || {}, DEFAULTS);
	  return function wcwidth(str) {
	    return wcswidth(str, opts)
	  }
	};

	/*
	 *  The following functions define the column width of an ISO 10646
	 *  character as follows:
	 *  - The null character (U+0000) has a column width of 0.
	 *  - Other C0/C1 control characters and DEL will lead to a return value
	 *    of -1.
	 *  - Non-spacing and enclosing combining characters (general category
	 *    code Mn or Me in the
	 *    Unicode database) have a column width of 0.
	 *  - SOFT HYPHEN (U+00AD) has a column width of 1.
	 *  - Other format characters (general category code Cf in the Unicode
	 *    database) and ZERO WIDTH
	 *    SPACE (U+200B) have a column width of 0.
	 *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
	 *    have a column width of 0.
	 *  - Spacing characters in the East Asian Wide (W) or East Asian
	 *    Full-width (F) category as
	 *    defined in Unicode Technical Report #11 have a column width of 2.
	 *  - All remaining characters (including all printable ISO 8859-1 and
	 *    WGL4 characters, Unicode control characters, etc.) have a column
	 *    width of 1.
	 *  This implementation assumes that characters are encoded in ISO 10646.
	*/

	function wcswidth(str, opts) {
	  if (typeof str !== 'string') return wcwidth$1(str, opts)

	  var s = 0;
	  for (var i = 0; i < str.length; i++) {
	    var n = wcwidth$1(str.charCodeAt(i), opts);
	    if (n < 0) return -1
	    s += n;
	  }

	  return s
	}

	function wcwidth$1(ucs, opts) {
	  // test for 8-bit control characters
	  if (ucs === 0) return opts.nul
	  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return opts.control

	  // binary search in table of non-spacing characters
	  if (bisearch(ucs)) return 0

	  // if we arrive here, ucs is not a combining or C0/C1 control character
	  return 1 +
	      (ucs >= 0x1100 &&
	       (ucs <= 0x115f ||                       // Hangul Jamo init. consonants
	        ucs == 0x2329 || ucs == 0x232a ||
	        (ucs >= 0x2e80 && ucs <= 0xa4cf &&
	         ucs != 0x303f) ||                     // CJK ... Yi
	        (ucs >= 0xac00 && ucs <= 0xd7a3) ||    // Hangul Syllables
	        (ucs >= 0xf900 && ucs <= 0xfaff) ||    // CJK Compatibility Ideographs
	        (ucs >= 0xfe10 && ucs <= 0xfe19) ||    // Vertical forms
	        (ucs >= 0xfe30 && ucs <= 0xfe6f) ||    // CJK Compatibility Forms
	        (ucs >= 0xff00 && ucs <= 0xff60) ||    // Fullwidth Forms
	        (ucs >= 0xffe0 && ucs <= 0xffe6) ||
	        (ucs >= 0x20000 && ucs <= 0x2fffd) ||
	        (ucs >= 0x30000 && ucs <= 0x3fffd)));
	}

	function bisearch(ucs) {
	  var min = 0;
	  var max = combining.length - 1;
	  var mid;

	  if (ucs < combining[0][0] || ucs > combining[max][1]) return false

	  while (max >= min) {
	    mid = Math.floor((min + max) / 2);
	    if (ucs > combining[mid][1]) min = mid + 1;
	    else if (ucs < combining[mid][0]) max = mid - 1;
	    else return true
	  }

	  return false
	}
	return wcwidth.exports;
}

var isInteractive;
var hasRequiredIsInteractive;

function requireIsInteractive () {
	if (hasRequiredIsInteractive) return isInteractive;
	hasRequiredIsInteractive = 1;

	isInteractive = ({stream = process.stdout} = {}) => {
		return Boolean(
			stream && stream.isTTY &&
			process.env.TERM !== 'dumb' &&
			!('CI' in process.env)
		);
	};
	return isInteractive;
}

var bl = {exports: {}};

var readable = {exports: {}};

var stream;
var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream;
	hasRequiredStream = 1;
	stream = require$$0$a;
	return stream;
}

var buffer_list;
var hasRequiredBuffer_list;

function requireBuffer_list () {
	if (hasRequiredBuffer_list) return buffer_list;
	hasRequiredBuffer_list = 1;

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var _require = require$$0$9,
	  Buffer = _require.Buffer;
	var _require2 = require$$0$d,
	  inspect = _require2.inspect;
	var custom = inspect && inspect.custom || 'inspect';
	function copyBuffer(src, target, offset) {
	  Buffer.prototype.copy.call(src, target, offset);
	}
	buffer_list = /*#__PURE__*/function () {
	  function BufferList() {
	    _classCallCheck(this, BufferList);
	    this.head = null;
	    this.tail = null;
	    this.length = 0;
	  }
	  _createClass(BufferList, [{
	    key: "push",
	    value: function push(v) {
	      var entry = {
	        data: v,
	        next: null
	      };
	      if (this.length > 0) this.tail.next = entry;else this.head = entry;
	      this.tail = entry;
	      ++this.length;
	    }
	  }, {
	    key: "unshift",
	    value: function unshift(v) {
	      var entry = {
	        data: v,
	        next: this.head
	      };
	      if (this.length === 0) this.tail = entry;
	      this.head = entry;
	      ++this.length;
	    }
	  }, {
	    key: "shift",
	    value: function shift() {
	      if (this.length === 0) return;
	      var ret = this.head.data;
	      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	      --this.length;
	      return ret;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.head = this.tail = null;
	      this.length = 0;
	    }
	  }, {
	    key: "join",
	    value: function join(s) {
	      if (this.length === 0) return '';
	      var p = this.head;
	      var ret = '' + p.data;
	      while (p = p.next) ret += s + p.data;
	      return ret;
	    }
	  }, {
	    key: "concat",
	    value: function concat(n) {
	      if (this.length === 0) return Buffer.alloc(0);
	      var ret = Buffer.allocUnsafe(n >>> 0);
	      var p = this.head;
	      var i = 0;
	      while (p) {
	        copyBuffer(p.data, ret, i);
	        i += p.data.length;
	        p = p.next;
	      }
	      return ret;
	    }

	    // Consumes a specified amount of bytes or characters from the buffered data.
	  }, {
	    key: "consume",
	    value: function consume(n, hasStrings) {
	      var ret;
	      if (n < this.head.data.length) {
	        // `slice` is the same for buffers and strings.
	        ret = this.head.data.slice(0, n);
	        this.head.data = this.head.data.slice(n);
	      } else if (n === this.head.data.length) {
	        // First chunk is a perfect match.
	        ret = this.shift();
	      } else {
	        // Result spans more than one buffer.
	        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
	      }
	      return ret;
	    }
	  }, {
	    key: "first",
	    value: function first() {
	      return this.head.data;
	    }

	    // Consumes a specified amount of characters from the buffered data.
	  }, {
	    key: "_getString",
	    value: function _getString(n) {
	      var p = this.head;
	      var c = 1;
	      var ret = p.data;
	      n -= ret.length;
	      while (p = p.next) {
	        var str = p.data;
	        var nb = n > str.length ? str.length : n;
	        if (nb === str.length) ret += str;else ret += str.slice(0, n);
	        n -= nb;
	        if (n === 0) {
	          if (nb === str.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = str.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Consumes a specified amount of bytes from the buffered data.
	  }, {
	    key: "_getBuffer",
	    value: function _getBuffer(n) {
	      var ret = Buffer.allocUnsafe(n);
	      var p = this.head;
	      var c = 1;
	      p.data.copy(ret);
	      n -= p.data.length;
	      while (p = p.next) {
	        var buf = p.data;
	        var nb = n > buf.length ? buf.length : n;
	        buf.copy(ret, ret.length - n, 0, nb);
	        n -= nb;
	        if (n === 0) {
	          if (nb === buf.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = buf.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Make sure the linked list only shows the minimal necessary information.
	  }, {
	    key: custom,
	    value: function value(_, options) {
	      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
	        // Only inspect one level.
	        depth: 0,
	        // It should not recurse.
	        customInspect: false
	      }));
	    }
	  }]);
	  return BufferList;
	}();
	return buffer_list;
}

var destroy_1;
var hasRequiredDestroy;

function requireDestroy () {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;

	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
	  var _this = this;
	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;
	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        process.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorNT, this, err);
	      }
	    }
	    return this;
	  }

	  // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks

	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  }

	  // if this is a duplex stream mark the writable part as destroyed as well
	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }
	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        process.nextTick(emitErrorAndCloseNT, _this, err);
	      } else {
	        process.nextTick(emitCloseNT, _this);
	      }
	    } else if (cb) {
	      process.nextTick(emitCloseNT, _this);
	      cb(err);
	    } else {
	      process.nextTick(emitCloseNT, _this);
	    }
	  });
	  return this;
	}
	function emitErrorAndCloseNT(self, err) {
	  emitErrorNT(self, err);
	  emitCloseNT(self);
	}
	function emitCloseNT(self) {
	  if (self._writableState && !self._writableState.emitClose) return;
	  if (self._readableState && !self._readableState.emitClose) return;
	  self.emit('close');
	}
	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }
	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}
	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}
	function errorOrDestroy(stream, err) {
	  // We have tests that rely on errors being emitted
	  // in the same tick, so changing this is semver major.
	  // For now when you opt-in to autoDestroy we allow
	  // the error to be emitted nextTick. In a future
	  // semver major update we should change the default to this.

	  var rState = stream._readableState;
	  var wState = stream._writableState;
	  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
	}
	destroy_1 = {
	  destroy: destroy,
	  undestroy: undestroy,
	  errorOrDestroy: errorOrDestroy
	};
	return destroy_1;
}

var errors = {};

var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	const codes = {};

	function createErrorType(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }

	  function getMessage (arg1, arg2, arg3) {
	    if (typeof message === 'string') {
	      return message
	    } else {
	      return message(arg1, arg2, arg3)
	    }
	  }

	  class NodeError extends Base {
	    constructor (arg1, arg2, arg3) {
	      super(getMessage(arg1, arg2, arg3));
	    }
	  }

	  NodeError.prototype.name = Base.name;
	  NodeError.prototype.code = code;

	  codes[code] = NodeError;
	}

	// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
	function oneOf(expected, thing) {
	  if (Array.isArray(expected)) {
	    const len = expected.length;
	    expected = expected.map((i) => String(i));
	    if (len > 2) {
	      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +
	             expected[len - 1];
	    } else if (len === 2) {
	      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
	    } else {
	      return `of ${thing} ${expected[0]}`;
	    }
	  } else {
	    return `of ${thing} ${String(expected)}`;
	  }
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
	function startsWith(str, search, pos) {
		return str.substr(0 , search.length) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
	function endsWith(str, search, this_len) {
		if (this_len === undefined || this_len > str.length) {
			this_len = str.length;
		}
		return str.substring(this_len - search.length, this_len) === search;
	}

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
	function includes(str, search, start) {
	  if (typeof start !== 'number') {
	    start = 0;
	  }

	  if (start + search.length > str.length) {
	    return false;
	  } else {
	    return str.indexOf(search, start) !== -1;
	  }
	}

	createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
	  return 'The value "' + value + '" is invalid for option "' + name + '"'
	}, TypeError);
	createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
	  // determiner: 'must be' or 'must not be'
	  let determiner;
	  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
	    determiner = 'must not be';
	    expected = expected.replace(/^not /, '');
	  } else {
	    determiner = 'must be';
	  }

	  let msg;
	  if (endsWith(name, ' argument')) {
	    // For cases like 'first argument'
	    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
	  } else {
	    const type = includes(name, '.') ? 'property' : 'argument';
	    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
	  }

	  msg += `. Received type ${typeof actual}`;
	  return msg;
	}, TypeError);
	createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
	createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
	  return 'The ' + name + ' method is not implemented'
	});
	createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
	createErrorType('ERR_STREAM_DESTROYED', function (name) {
	  return 'Cannot call ' + name + ' after a stream was destroyed';
	});
	createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
	createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
	createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
	createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
	  return 'Unknown encoding: ' + arg
	}, TypeError);
	createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');

	errors.codes = codes;
	return errors;
}

var state;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state;
	hasRequiredState = 1;

	var ERR_INVALID_OPT_VALUE = requireErrors().codes.ERR_INVALID_OPT_VALUE;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}
	function getHighWaterMark(state, options, duplexKey, isDuplex) {
	  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
	  if (hwm != null) {
	    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
	      var name = isDuplex ? duplexKey : 'highWaterMark';
	      throw new ERR_INVALID_OPT_VALUE(name, hwm);
	    }
	    return Math.floor(hwm);
	  }

	  // Default value
	  return state.objectMode ? 16 : 16 * 1024;
	}
	state = {
	  getHighWaterMark: getHighWaterMark
	};
	return state;
}

var inherits = {exports: {}};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	try {
	  var util = require('util');
	  /* istanbul ignore next */
	  if (typeof util.inherits !== 'function') throw '';
	  inherits.exports = util.inherits;
	} catch (e) {
	  /* istanbul ignore next */
	  inherits.exports = requireInherits_browser();
	}
	return inherits.exports;
}

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	/**
	 * For Node.js, simply re-export the core `util.deprecate` function.
	 */

	node = require$$0$d.deprecate;
	return node;
}

var _stream_writable;
var hasRequired_stream_writable;

function require_stream_writable () {
	if (hasRequired_stream_writable) return _stream_writable;
	hasRequired_stream_writable = 1;

	_stream_writable = Writable;

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	  this.next = null;
	  this.entry = null;
	  this.finish = function () {
	    onCorkedFinish(_this, state);
	  };
	}
	/* </replacement> */

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var internalUtil = {
	  deprecate: requireNode()
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStream();
	/*</replacement>*/

	var Buffer = require$$0$9.Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	var destroyImpl = requireDestroy();
	var _require = requireState(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrors().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
	  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
	  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
	  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	requireInherits()(Writable, Stream);
	function nop() {}
	function WritableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream,
	  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

	  // if _final has been called
	  this.finalCalled = false;

	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // has it been destroyed
	  this.destroyed = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'finish' (and potentially 'end')
	  this.autoDestroy = !!options.autoDestroy;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function writableStateBufferGetter() {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	    });
	  } catch (_) {}
	})();

	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function value(object) {
	      if (realHasInstance.call(this, object)) return true;
	      if (this !== Writable) return false;
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function realHasInstance(object) {
	    return object instanceof this;
	  };
	}
	function Writable(options) {
	  Duplex = Duplex || require_stream_duplex();

	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the WritableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
	  this._writableState = new WritableState(options, this, isDuplex);

	  // legacy.
	  this.writable = true;
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	    if (typeof options.writev === 'function') this._writev = options.writev;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.final === 'function') this._final = options.final;
	  }
	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function writeAfterEnd(stream, cb) {
	  var er = new ERR_STREAM_WRITE_AFTER_END();
	  // TODO: defer error events consistently everywhere, not just the cb
	  errorOrDestroy(stream, er);
	  process.nextTick(cb, er);
	}

	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var er;
	  if (chunk === null) {
	    er = new ERR_STREAM_NULL_VALUES();
	  } else if (typeof chunk !== 'string' && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
	  }
	  if (er) {
	    errorOrDestroy(stream, er);
	    process.nextTick(cb, er);
	    return false;
	  }
	  return true;
	}
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = !state.objectMode && _isUint8Array(chunk);
	  if (isBuf && !Buffer.isBuffer(chunk)) {
	    chunk = _uint8ArrayToBuffer(chunk);
	  }
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	  if (typeof cb !== 'function') cb = nop;
	  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }
	  return ret;
	};
	Writable.prototype.cork = function () {
	  this._writableState.corked++;
	};
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	  if (state.corked) {
	    state.corked--;
	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer.from(chunk, encoding);
	  }
	  return chunk;
	}
	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    var newChunk = decodeChunk(state, chunk, encoding);
	    if (chunk !== newChunk) {
	      isBuf = true;
	      encoding = 'buffer';
	      chunk = newChunk;
	    }
	  }
	  var len = state.objectMode ? 1 : chunk.length;
	  state.length += len;
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = {
	      chunk: chunk,
	      encoding: encoding,
	      isBuf: isBuf,
	      callback: cb,
	      next: null
	    };
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	  return ret;
	}
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) {
	    // defer the callback if we are being called synchronously
	    // to avoid piling up things on the stack
	    process.nextTick(cb, er);
	    // this can emit finish, and it will always happen
	    // after error
	    process.nextTick(finishMaybe, stream, state);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	  } else {
	    // the caller expect this to happen before if
	    // it is async
	    cb(er);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	    // this can emit finish, but finish must
	    // always follow error
	    finishMaybe(stream, state);
	  }
	}
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
	  onwriteStateUpdate(state);
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state) || stream.destroyed;
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	    if (sync) {
	      process.nextTick(afterWrite, stream, state, finished, cb);
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	    var count = 0;
	    var allBuffers = true;
	    while (entry) {
	      buffer[count] = entry;
	      if (!entry.isBuf) allBuffers = false;
	      entry = entry.next;
	      count += 1;
	    }
	    buffer.allBuffers = allBuffers;
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	    state.bufferedRequestCount = 0;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      state.bufferedRequestCount--;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending) endWritable(this, state, cb);
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
	  stream._final(function (err) {
	    state.pendingcb--;
	    if (err) {
	      errorOrDestroy(stream, err);
	    }
	    state.prefinished = true;
	    stream.emit('prefinish');
	    finishMaybe(stream, state);
	  });
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function' && !state.destroyed) {
	      state.pendingcb++;
	      state.finalCalled = true;
	      process.nextTick(callFinal, stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      state.finished = true;
	      stream.emit('finish');
	      if (state.autoDestroy) {
	        // In case of duplex streams we need a way to detect
	        // if the readable side is ready for autoDestroy as well
	        var rState = stream._readableState;
	        if (!rState || rState.autoDestroy && rState.endEmitted) {
	          stream.destroy();
	        }
	      }
	    }
	  }
	  return need;
	}
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	function onCorkedFinish(corkReq, state, err) {
	  var entry = corkReq.entry;
	  corkReq.entry = null;
	  while (entry) {
	    var cb = entry.callback;
	    state.pendingcb--;
	    cb(err);
	    entry = entry.next;
	  }

	  // reuse the free corkReq.
	  state.corkedRequestsFree.next = corkReq;
	}
	Object.defineProperty(Writable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._writableState === undefined) {
	      return false;
	    }
	    return this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._writableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._writableState.destroyed = value;
	  }
	});
	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  cb(err);
	};
	return _stream_writable;
}

var _stream_duplex;
var hasRequired_stream_duplex;

function require_stream_duplex () {
	if (hasRequired_stream_duplex) return _stream_duplex;
	hasRequired_stream_duplex = 1;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	};
	/*</replacement>*/

	_stream_duplex = Duplex;
	var Readable = require_stream_readable();
	var Writable = require_stream_writable();
	requireInherits()(Duplex, Readable);
	{
	  // Allow the keys array to be GC'ed.
	  var keys = objectKeys(Writable.prototype);
	  for (var v = 0; v < keys.length; v++) {
	    var method = keys[v];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	  Readable.call(this, options);
	  Writable.call(this, options);
	  this.allowHalfOpen = true;
	  if (options) {
	    if (options.readable === false) this.readable = false;
	    if (options.writable === false) this.writable = false;
	    if (options.allowHalfOpen === false) {
	      this.allowHalfOpen = false;
	      this.once('end', onend);
	    }
	  }
	}
	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});

	// the no-half-open enforcer
	function onend() {
	  // If the writable side ended, then we're ok.
	  if (this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(onEndNT, this);
	}
	function onEndNT(self) {
	  self.end();
	}
	Object.defineProperty(Duplex.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed && this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	    this._writableState.destroyed = value;
	  }
	});
	return _stream_duplex;
}

var string_decoder = {};

var safeBuffer = {exports: {}};

/* eslint-disable node/no-deprecated-api */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports) {
		var buffer = require$$0$9;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

var hasRequiredString_decoder;

function requireString_decoder () {
	if (hasRequiredString_decoder) return string_decoder;
	hasRequiredString_decoder = 1;

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	/*</replacement>*/

	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	string_decoder.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}
	return string_decoder;
}

var endOfStream;
var hasRequiredEndOfStream;

function requireEndOfStream () {
	if (hasRequiredEndOfStream) return endOfStream;
	hasRequiredEndOfStream = 1;

	var ERR_STREAM_PREMATURE_CLOSE = requireErrors().codes.ERR_STREAM_PREMATURE_CLOSE;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    callback.apply(this, args);
	  };
	}
	function noop() {}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function eos(stream, opts, callback) {
	  if (typeof opts === 'function') return eos(stream, null, opts);
	  if (!opts) opts = {};
	  callback = once(callback || noop);
	  var readable = opts.readable || opts.readable !== false && stream.readable;
	  var writable = opts.writable || opts.writable !== false && stream.writable;
	  var onlegacyfinish = function onlegacyfinish() {
	    if (!stream.writable) onfinish();
	  };
	  var writableEnded = stream._writableState && stream._writableState.finished;
	  var onfinish = function onfinish() {
	    writable = false;
	    writableEnded = true;
	    if (!readable) callback.call(stream);
	  };
	  var readableEnded = stream._readableState && stream._readableState.endEmitted;
	  var onend = function onend() {
	    readable = false;
	    readableEnded = true;
	    if (!writable) callback.call(stream);
	  };
	  var onerror = function onerror(err) {
	    callback.call(stream, err);
	  };
	  var onclose = function onclose() {
	    var err;
	    if (readable && !readableEnded) {
	      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	    if (writable && !writableEnded) {
	      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	  };
	  var onrequest = function onrequest() {
	    stream.req.on('finish', onfinish);
	  };
	  if (isRequest(stream)) {
	    stream.on('complete', onfinish);
	    stream.on('abort', onclose);
	    if (stream.req) onrequest();else stream.on('request', onrequest);
	  } else if (writable && !stream._writableState) {
	    // legacy streams
	    stream.on('end', onlegacyfinish);
	    stream.on('close', onlegacyfinish);
	  }
	  stream.on('end', onend);
	  stream.on('finish', onfinish);
	  if (opts.error !== false) stream.on('error', onerror);
	  stream.on('close', onclose);
	  return function () {
	    stream.removeListener('complete', onfinish);
	    stream.removeListener('abort', onclose);
	    stream.removeListener('request', onrequest);
	    if (stream.req) stream.req.removeListener('finish', onfinish);
	    stream.removeListener('end', onlegacyfinish);
	    stream.removeListener('close', onlegacyfinish);
	    stream.removeListener('finish', onfinish);
	    stream.removeListener('end', onend);
	    stream.removeListener('error', onerror);
	    stream.removeListener('close', onclose);
	  };
	}
	endOfStream = eos;
	return endOfStream;
}

var async_iterator;
var hasRequiredAsync_iterator;

function requireAsync_iterator () {
	if (hasRequiredAsync_iterator) return async_iterator;
	hasRequiredAsync_iterator = 1;

	var _Object$setPrototypeO;
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var finished = requireEndOfStream();
	var kLastResolve = Symbol('lastResolve');
	var kLastReject = Symbol('lastReject');
	var kError = Symbol('error');
	var kEnded = Symbol('ended');
	var kLastPromise = Symbol('lastPromise');
	var kHandlePromise = Symbol('handlePromise');
	var kStream = Symbol('stream');
	function createIterResult(value, done) {
	  return {
	    value: value,
	    done: done
	  };
	}
	function readAndResolve(iter) {
	  var resolve = iter[kLastResolve];
	  if (resolve !== null) {
	    var data = iter[kStream].read();
	    // we defer if data is null
	    // we can be expecting either 'end' or
	    // 'error'
	    if (data !== null) {
	      iter[kLastPromise] = null;
	      iter[kLastResolve] = null;
	      iter[kLastReject] = null;
	      resolve(createIterResult(data, false));
	    }
	  }
	}
	function onReadable(iter) {
	  // we wait for the next tick, because it might
	  // emit an error with process.nextTick
	  process.nextTick(readAndResolve, iter);
	}
	function wrapForNext(lastPromise, iter) {
	  return function (resolve, reject) {
	    lastPromise.then(function () {
	      if (iter[kEnded]) {
	        resolve(createIterResult(undefined, true));
	        return;
	      }
	      iter[kHandlePromise](resolve, reject);
	    }, reject);
	  };
	}
	var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
	var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
	  get stream() {
	    return this[kStream];
	  },
	  next: function next() {
	    var _this = this;
	    // if we have detected an error in the meanwhile
	    // reject straight away
	    var error = this[kError];
	    if (error !== null) {
	      return Promise.reject(error);
	    }
	    if (this[kEnded]) {
	      return Promise.resolve(createIterResult(undefined, true));
	    }
	    if (this[kStream].destroyed) {
	      // We need to defer via nextTick because if .destroy(err) is
	      // called, the error will be emitted via nextTick, and
	      // we cannot guarantee that there is no error lingering around
	      // waiting to be emitted.
	      return new Promise(function (resolve, reject) {
	        process.nextTick(function () {
	          if (_this[kError]) {
	            reject(_this[kError]);
	          } else {
	            resolve(createIterResult(undefined, true));
	          }
	        });
	      });
	    }

	    // if we have multiple next() calls
	    // we will wait for the previous Promise to finish
	    // this logic is optimized to support for await loops,
	    // where next() is only called once at a time
	    var lastPromise = this[kLastPromise];
	    var promise;
	    if (lastPromise) {
	      promise = new Promise(wrapForNext(lastPromise, this));
	    } else {
	      // fast path needed to support multiple this.push()
	      // without triggering the next() queue
	      var data = this[kStream].read();
	      if (data !== null) {
	        return Promise.resolve(createIterResult(data, false));
	      }
	      promise = new Promise(this[kHandlePromise]);
	    }
	    this[kLastPromise] = promise;
	    return promise;
	  }
	}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
	  return this;
	}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
	  var _this2 = this;
	  // destroy(err, cb) is a private API
	  // we can guarantee we have that here, because we control the
	  // Readable class this is attached to
	  return new Promise(function (resolve, reject) {
	    _this2[kStream].destroy(null, function (err) {
	      if (err) {
	        reject(err);
	        return;
	      }
	      resolve(createIterResult(undefined, true));
	    });
	  });
	}), _Object$setPrototypeO), AsyncIteratorPrototype);
	var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
	  var _Object$create;
	  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
	    value: stream,
	    writable: true
	  }), _defineProperty(_Object$create, kLastResolve, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kLastReject, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kError, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kEnded, {
	    value: stream._readableState.endEmitted,
	    writable: true
	  }), _defineProperty(_Object$create, kHandlePromise, {
	    value: function value(resolve, reject) {
	      var data = iterator[kStream].read();
	      if (data) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        resolve(createIterResult(data, false));
	      } else {
	        iterator[kLastResolve] = resolve;
	        iterator[kLastReject] = reject;
	      }
	    },
	    writable: true
	  }), _Object$create));
	  iterator[kLastPromise] = null;
	  finished(stream, function (err) {
	    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	      var reject = iterator[kLastReject];
	      // reject if we are waiting for data in the Promise
	      // returned by next() and store the error
	      if (reject !== null) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        reject(err);
	      }
	      iterator[kError] = err;
	      return;
	    }
	    var resolve = iterator[kLastResolve];
	    if (resolve !== null) {
	      iterator[kLastPromise] = null;
	      iterator[kLastResolve] = null;
	      iterator[kLastReject] = null;
	      resolve(createIterResult(undefined, true));
	    }
	    iterator[kEnded] = true;
	  });
	  stream.on('readable', onReadable.bind(null, iterator));
	  return iterator;
	};
	async_iterator = createReadableStreamAsyncIterator;
	return async_iterator;
}

var from_1;
var hasRequiredFrom;

function requireFrom () {
	if (hasRequiredFrom) return from_1;
	hasRequiredFrom = 1;

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
	function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var ERR_INVALID_ARG_TYPE = requireErrors().codes.ERR_INVALID_ARG_TYPE;
	function from(Readable, iterable, opts) {
	  var iterator;
	  if (iterable && typeof iterable.next === 'function') {
	    iterator = iterable;
	  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
	  var readable = new Readable(_objectSpread({
	    objectMode: true
	  }, opts));
	  // Reading boolean to protect against _read
	  // being called before last iteration completion.
	  var reading = false;
	  readable._read = function () {
	    if (!reading) {
	      reading = true;
	      next();
	    }
	  };
	  function next() {
	    return _next2.apply(this, arguments);
	  }
	  function _next2() {
	    _next2 = _asyncToGenerator(function* () {
	      try {
	        var _yield$iterator$next = yield iterator.next(),
	          value = _yield$iterator$next.value,
	          done = _yield$iterator$next.done;
	        if (done) {
	          readable.push(null);
	        } else if (readable.push(yield value)) {
	          next();
	        } else {
	          reading = false;
	        }
	      } catch (err) {
	        readable.destroy(err);
	      }
	    });
	    return _next2.apply(this, arguments);
	  }
	  return readable;
	}
	from_1 = from;
	return from_1;
}

var _stream_readable;
var hasRequired_stream_readable;

function require_stream_readable () {
	if (hasRequired_stream_readable) return _stream_readable;
	hasRequired_stream_readable = 1;

	_stream_readable = Readable;

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	/*<replacement>*/
	require$$0$b.EventEmitter;
	var EElistenerCount = function EElistenerCount(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStream();
	/*</replacement>*/

	var Buffer = require$$0$9.Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}

	/*<replacement>*/
	var debugUtil = require$$0$d;
	var debug;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function debug() {};
	}
	/*</replacement>*/

	var BufferList = requireBuffer_list();
	var destroyImpl = requireDestroy();
	var _require = requireState(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrors().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

	// Lazy loaded to improve the startup performance.
	var StringDecoder;
	var createReadableStreamAsyncIterator;
	var from;
	requireInherits()(Readable, Stream);
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}
	function ReadableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	  this.paused = true;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'end' (and potentially 'finish')
	  this.autoDestroy = !!options.autoDestroy;

	  // has it been destroyed
	  this.destroyed = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {
	  Duplex = Duplex || require_stream_duplex();
	  if (!(this instanceof Readable)) return new Readable(options);

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the ReadableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  this._readableState = new ReadableState(options, this, isDuplex);

	  // legacy
	  this.readable = true;
	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	  }
	  Stream.call(this);
	}
	Object.defineProperty(Readable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._readableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	  }
	});
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  cb(err);
	};

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  var skipChunkCheck;
	  if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (encoding !== state.encoding) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = '';
	      }
	      skipChunkCheck = true;
	    }
	  } else {
	    skipChunkCheck = true;
	  }
	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  return readableAddChunk(this, chunk, null, true, false);
	};
	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	  debug('readableAddChunk', chunk);
	  var state = stream._readableState;
	  if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else {
	    var er;
	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
	    if (er) {
	      errorOrDestroy(stream, er);
	    } else if (state.objectMode || chunk && chunk.length > 0) {
	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
	        chunk = _uint8ArrayToBuffer(chunk);
	      }
	      if (addToFront) {
	        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
	      } else if (state.ended) {
	        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
	      } else if (state.destroyed) {
	        return false;
	      } else {
	        state.reading = false;
	        if (state.decoder && !encoding) {
	          chunk = state.decoder.write(chunk);
	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	        } else {
	          addChunk(stream, state, chunk, false);
	        }
	      }
	    } else if (!addToFront) {
	      state.reading = false;
	      maybeReadMore(stream, state);
	    }
	  }

	  // We can push more data if we are below the highWaterMark.
	  // Also, if we have no data yet, we can stand some more bytes.
	  // This is to work around cases where hwm=0, such as the repl.
	  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	}
	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync) {
	    state.awaitDrain = 0;
	    stream.emit('data', chunk);
	  } else {
	    // update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	    if (state.needReadable) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}
	function chunkInvalid(state, chunk) {
	  var er;
	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
	  }
	  return er;
	}
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	  var decoder = new StringDecoder(enc);
	  this._readableState.decoder = decoder;
	  // If setEncoding(null), decoder.encoding equals utf8
	  this._readableState.encoding = this._readableState.decoder.encoding;

	  // Iterate over current buffer to convert already stored Buffers:
	  var p = this._readableState.buffer.head;
	  var content = '';
	  while (p !== null) {
	    content += decoder.write(p.data);
	    p = p.next;
	  }
	  this._readableState.buffer.clear();
	  if (content !== '') this._readableState.buffer.push(content);
	  this._readableState.length = content.length;
	  return this;
	};

	// Don't raise the hwm > 1GB
	var MAX_HWM = 0x40000000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	  if (ret === null) {
	    state.needReadable = state.length <= state.highWaterMark;
	    n = 0;
	  } else {
	    state.length -= n;
	    state.awaitDrain = 0;
	  }
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	  if (ret !== null) this.emit('data', ret);
	  return ret;
	};
	function onEofChunk(stream, state) {
	  debug('onEofChunk');
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	  if (state.sync) {
	    // if we are sync, wait until next tick to emit the data.
	    // Otherwise we risk emitting data in the flow()
	    // the readable code triggers during a read() call
	    emitReadable(stream);
	  } else {
	    // emit 'readable' now to make sure it gets picked up.
	    state.needReadable = false;
	    if (!state.emittedReadable) {
	      state.emittedReadable = true;
	      emitReadable_(stream);
	    }
	  }
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  debug('emitReadable', state.needReadable, state.emittedReadable);
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    process.nextTick(emitReadable_, stream);
	  }
	}
	function emitReadable_(stream) {
	  var state = stream._readableState;
	  debug('emitReadable_', state.destroyed, state.length, state.ended);
	  if (!state.destroyed && (state.length || state.ended)) {
	    stream.emit('readable');
	    state.emittedReadable = false;
	  }

	  // The stream needs another readable event if
	  // 1. It is not flowing, as the flow mechanism will take
	  //    care of it.
	  // 2. It is not ended.
	  // 3. It is below the highWaterMark, so we can schedule
	  //    another readable later.
	  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(maybeReadMore_, stream, state);
	  }
	}
	function maybeReadMore_(stream, state) {
	  // Attempt to read more data if we should.
	  //
	  // The conditions for reading more data are (one of):
	  // - Not enough data buffered (state.length < state.highWaterMark). The loop
	  //   is responsible for filling the buffer with enough data if such data
	  //   is available. If highWaterMark is 0 and we are not in the flowing mode
	  //   we should _not_ attempt to buffer any extra data. We'll get more data
	  //   when the stream consumer calls read() instead.
	  // - No data in the buffer, and the stream is in flowing mode. In this mode
	  //   the loop below is responsible for ensuring read() is called. Failing to
	  //   call read here would abort the flow and there's no other mechanism for
	  //   continuing the flow if the stream consumer has just subscribed to the
	  //   'data' event.
	  //
	  // In addition to the above conditions to keep reading data, the following
	  // conditions prevent the data from being read:
	  // - The stream has ended (state.ended).
	  // - There is already a pending 'read' operation (state.reading). This is a
	  //   case where the the stream has called the implementation defined _read()
	  //   method, but they are processing the call asynchronously and have _not_
	  //   called push() with new data. In this case we skip performing more
	  //   read()s. The execution ends in this method again after the _read() ends
	  //   up calling push() with more data.
	  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
	    var len = state.length;
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
	};
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	  var endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }
	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);
	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    debug('dest.write', ret);
	    if (ret === false) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', state.awaitDrain);
	        state.awaitDrain++;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	  return dest;
	};
	function pipeOnDrain(src) {
	  return function pipeOnDrainFunctionResult() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	  var unpipeInfo = {
	    hasUnpiped: false
	  };

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
	      hasUnpiped: false
	    });
	    return this;
	  }

	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	  dest.emit('unpipe', this, unpipeInfo);
	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	  var state = this._readableState;
	  if (ev === 'data') {
	    // update readableListening so that resume() may be a no-op
	    // a few lines down. This is needed to support once('readable').
	    state.readableListening = this.listenerCount('readable') > 0;

	    // Try start flowing on next tick if stream isn't explicitly paused
	    if (state.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.flowing = false;
	      state.emittedReadable = false;
	      debug('on readable', state.length, state.reading);
	      if (state.length) {
	        emitReadable(this);
	      } else if (!state.reading) {
	        process.nextTick(nReadingNextTick, this);
	      }
	    }
	  }
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	Readable.prototype.removeListener = function (ev, fn) {
	  var res = Stream.prototype.removeListener.call(this, ev, fn);
	  if (ev === 'readable') {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	Readable.prototype.removeAllListeners = function (ev) {
	  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
	  if (ev === 'readable' || ev === undefined) {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	function updateReadableListening(self) {
	  var state = self._readableState;
	  state.readableListening = self.listenerCount('readable') > 0;
	  if (state.resumeScheduled && !state.paused) {
	    // flowing needs to be set to true now, otherwise
	    // the upcoming resume will not flow.
	    state.flowing = true;

	    // crude way to check if we should resume
	  } else if (self.listenerCount('data') > 0) {
	    self.resume();
	  }
	}
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    // we flow only if there is no one listening
	    // for readable, but we still have to call
	    // resume()
	    state.flowing = !state.readableListening;
	    resume(this, state);
	  }
	  state.paused = false;
	  return this;
	};
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(resume_, stream, state);
	  }
	}
	function resume_(stream, state) {
	  debug('resume', state.reading);
	  if (!state.reading) {
	    stream.read(0);
	  }
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (this._readableState.flowing !== false) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  this._readableState.paused = true;
	  return this;
	};
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null);
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var _this = this;
	  var state = this._readableState;
	  var paused = false;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) _this.push(chunk);
	    }
	    _this.push(null);
	  });
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	    var ret = _this.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function methodWrap(method) {
	        return function methodWrapReturnFunction() {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  for (var n = 0; n < kProxyEvents.length; n++) {
	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	  }

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  this._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	  return this;
	};
	if (typeof Symbol === 'function') {
	  Readable.prototype[Symbol.asyncIterator] = function () {
	    if (createReadableStreamAsyncIterator === undefined) {
	      createReadableStreamAsyncIterator = requireAsync_iterator();
	    }
	    return createReadableStreamAsyncIterator(this);
	  };
	}
	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.highWaterMark;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState && this._readableState.buffer;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableFlowing', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.flowing;
	  },
	  set: function set(state) {
	    if (this._readableState) {
	      this._readableState.flowing = state;
	    }
	  }
	});

	// exposed for testing purposes only.
	Readable._fromList = fromList;
	Object.defineProperty(Readable.prototype, 'readableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.length;
	  }
	});

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = state.buffer.consume(n, state.decoder);
	  }
	  return ret;
	}
	function endReadable(stream) {
	  var state = stream._readableState;
	  debug('endReadable', state.endEmitted);
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(endReadableNT, state, stream);
	  }
	}
	function endReadableNT(state, stream) {
	  debug('endReadableNT', state.endEmitted, state.length);

	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	    if (state.autoDestroy) {
	      // In case of duplex streams we need a way to detect
	      // if the writable side is ready for autoDestroy as well
	      var wState = stream._writableState;
	      if (!wState || wState.autoDestroy && wState.finished) {
	        stream.destroy();
	      }
	    }
	  }
	}
	if (typeof Symbol === 'function') {
	  Readable.from = function (iterable, opts) {
	    if (from === undefined) {
	      from = requireFrom();
	    }
	    return from(Readable, iterable, opts);
	  };
	}
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	return _stream_readable;
}

var _stream_transform;
var hasRequired_stream_transform;

function require_stream_transform () {
	if (hasRequired_stream_transform) return _stream_transform;
	hasRequired_stream_transform = 1;

	_stream_transform = Transform;
	var _require$codes = requireErrors().codes,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
	  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
	var Duplex = require_stream_duplex();
	requireInherits()(Transform, Duplex);
	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;
	  var cb = ts.writecb;
	  if (cb === null) {
	    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
	  }
	  ts.writechunk = null;
	  ts.writecb = null;
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    this.push(data);
	  cb(er);
	  var rs = this._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	  Duplex.call(this, options);
	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  };

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  this.on('prefinish', prefinish);
	}
	function prefinish() {
	  var _this = this;
	  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
	};
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	  if (ts.writechunk !== null && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	Transform.prototype._destroy = function (err, cb) {
	  Duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	  });
	};
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    stream.push(data);

	  // TODO(BridgeAR): Write a test for these two error cases
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
	  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
	  return stream.push(null);
	}
	return _stream_transform;
}

var _stream_passthrough;
var hasRequired_stream_passthrough;

function require_stream_passthrough () {
	if (hasRequired_stream_passthrough) return _stream_passthrough;
	hasRequired_stream_passthrough = 1;

	_stream_passthrough = PassThrough;
	var Transform = require_stream_transform();
	requireInherits()(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	  Transform.call(this, options);
	}
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return _stream_passthrough;
}

var pipeline_1;
var hasRequiredPipeline;

function requirePipeline () {
	if (hasRequiredPipeline) return pipeline_1;
	hasRequiredPipeline = 1;

	var eos;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    callback.apply(void 0, arguments);
	  };
	}
	var _require$codes = requireErrors().codes,
	  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
	function noop(err) {
	  // Rethrow the error if it exists to avoid swallowing it
	  if (err) throw err;
	}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function destroyer(stream, reading, writing, callback) {
	  callback = once(callback);
	  var closed = false;
	  stream.on('close', function () {
	    closed = true;
	  });
	  if (eos === undefined) eos = requireEndOfStream();
	  eos(stream, {
	    readable: reading,
	    writable: writing
	  }, function (err) {
	    if (err) return callback(err);
	    closed = true;
	    callback();
	  });
	  var destroyed = false;
	  return function (err) {
	    if (closed) return;
	    if (destroyed) return;
	    destroyed = true;

	    // request.destroy just do .end - .abort is what we want
	    if (isRequest(stream)) return stream.abort();
	    if (typeof stream.destroy === 'function') return stream.destroy();
	    callback(err || new ERR_STREAM_DESTROYED('pipe'));
	  };
	}
	function call(fn) {
	  fn();
	}
	function pipe(from, to) {
	  return from.pipe(to);
	}
	function popCallback(streams) {
	  if (!streams.length) return noop;
	  if (typeof streams[streams.length - 1] !== 'function') return noop;
	  return streams.pop();
	}
	function pipeline() {
	  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
	    streams[_key] = arguments[_key];
	  }
	  var callback = popCallback(streams);
	  if (Array.isArray(streams[0])) streams = streams[0];
	  if (streams.length < 2) {
	    throw new ERR_MISSING_ARGS('streams');
	  }
	  var error;
	  var destroys = streams.map(function (stream, i) {
	    var reading = i < streams.length - 1;
	    var writing = i > 0;
	    return destroyer(stream, reading, writing, function (err) {
	      if (!error) error = err;
	      if (err) destroys.forEach(call);
	      if (reading) return;
	      destroys.forEach(call);
	      callback(error);
	    });
	  });
	  return streams.reduce(pipe);
	}
	pipeline_1 = pipeline;
	return pipeline_1;
}

var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable.exports;
	hasRequiredReadable = 1;
	(function (module, exports) {
		var Stream = require$$0$a;
		if (process.env.READABLE_STREAM === 'disable' && Stream) {
		  module.exports = Stream.Readable;
		  Object.assign(module.exports, Stream);
		  module.exports.Stream = Stream;
		} else {
		  exports = module.exports = require_stream_readable();
		  exports.Stream = Stream || exports;
		  exports.Readable = exports;
		  exports.Writable = require_stream_writable();
		  exports.Duplex = require_stream_duplex();
		  exports.Transform = require_stream_transform();
		  exports.PassThrough = require_stream_passthrough();
		  exports.finished = requireEndOfStream();
		  exports.pipeline = requirePipeline();
		} 
	} (readable, readable.exports));
	return readable.exports;
}

var BufferList_1;
var hasRequiredBufferList;

function requireBufferList () {
	if (hasRequiredBufferList) return BufferList_1;
	hasRequiredBufferList = 1;

	const { Buffer } = require$$0$9;
	const symbol = Symbol.for('BufferList');

	function BufferList (buf) {
	  if (!(this instanceof BufferList)) {
	    return new BufferList(buf)
	  }

	  BufferList._init.call(this, buf);
	}

	BufferList._init = function _init (buf) {
	  Object.defineProperty(this, symbol, { value: true });

	  this._bufs = [];
	  this.length = 0;

	  if (buf) {
	    this.append(buf);
	  }
	};

	BufferList.prototype._new = function _new (buf) {
	  return new BufferList(buf)
	};

	BufferList.prototype._offset = function _offset (offset) {
	  if (offset === 0) {
	    return [0, 0]
	  }

	  let tot = 0;

	  for (let i = 0; i < this._bufs.length; i++) {
	    const _t = tot + this._bufs[i].length;
	    if (offset < _t || i === this._bufs.length - 1) {
	      return [i, offset - tot]
	    }
	    tot = _t;
	  }
	};

	BufferList.prototype._reverseOffset = function (blOffset) {
	  const bufferId = blOffset[0];
	  let offset = blOffset[1];

	  for (let i = 0; i < bufferId; i++) {
	    offset += this._bufs[i].length;
	  }

	  return offset
	};

	BufferList.prototype.get = function get (index) {
	  if (index > this.length || index < 0) {
	    return undefined
	  }

	  const offset = this._offset(index);

	  return this._bufs[offset[0]][offset[1]]
	};

	BufferList.prototype.slice = function slice (start, end) {
	  if (typeof start === 'number' && start < 0) {
	    start += this.length;
	  }

	  if (typeof end === 'number' && end < 0) {
	    end += this.length;
	  }

	  return this.copy(null, 0, start, end)
	};

	BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
	  if (typeof srcStart !== 'number' || srcStart < 0) {
	    srcStart = 0;
	  }

	  if (typeof srcEnd !== 'number' || srcEnd > this.length) {
	    srcEnd = this.length;
	  }

	  if (srcStart >= this.length) {
	    return dst || Buffer.alloc(0)
	  }

	  if (srcEnd <= 0) {
	    return dst || Buffer.alloc(0)
	  }

	  const copy = !!dst;
	  const off = this._offset(srcStart);
	  const len = srcEnd - srcStart;
	  let bytes = len;
	  let bufoff = (copy && dstStart) || 0;
	  let start = off[1];

	  // copy/slice everything
	  if (srcStart === 0 && srcEnd === this.length) {
	    if (!copy) {
	      // slice, but full concat if multiple buffers
	      return this._bufs.length === 1
	        ? this._bufs[0]
	        : Buffer.concat(this._bufs, this.length)
	    }

	    // copy, need to copy individual buffers
	    for (let i = 0; i < this._bufs.length; i++) {
	      this._bufs[i].copy(dst, bufoff);
	      bufoff += this._bufs[i].length;
	    }

	    return dst
	  }

	  // easy, cheap case where it's a subset of one of the buffers
	  if (bytes <= this._bufs[off[0]].length - start) {
	    return copy
	      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
	      : this._bufs[off[0]].slice(start, start + bytes)
	  }

	  if (!copy) {
	    // a slice, we need something to copy in to
	    dst = Buffer.allocUnsafe(len);
	  }

	  for (let i = off[0]; i < this._bufs.length; i++) {
	    const l = this._bufs[i].length - start;

	    if (bytes > l) {
	      this._bufs[i].copy(dst, bufoff, start);
	      bufoff += l;
	    } else {
	      this._bufs[i].copy(dst, bufoff, start, start + bytes);
	      bufoff += l;
	      break
	    }

	    bytes -= l;

	    if (start) {
	      start = 0;
	    }
	  }

	  // safeguard so that we don't return uninitialized memory
	  if (dst.length > bufoff) return dst.slice(0, bufoff)

	  return dst
	};

	BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
	  start = start || 0;
	  end = typeof end !== 'number' ? this.length : end;

	  if (start < 0) {
	    start += this.length;
	  }

	  if (end < 0) {
	    end += this.length;
	  }

	  if (start === end) {
	    return this._new()
	  }

	  const startOffset = this._offset(start);
	  const endOffset = this._offset(end);
	  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);

	  if (endOffset[1] === 0) {
	    buffers.pop();
	  } else {
	    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
	  }

	  if (startOffset[1] !== 0) {
	    buffers[0] = buffers[0].slice(startOffset[1]);
	  }

	  return this._new(buffers)
	};

	BufferList.prototype.toString = function toString (encoding, start, end) {
	  return this.slice(start, end).toString(encoding)
	};

	BufferList.prototype.consume = function consume (bytes) {
	  // first, normalize the argument, in accordance with how Buffer does it
	  bytes = Math.trunc(bytes);
	  // do nothing if not a positive number
	  if (Number.isNaN(bytes) || bytes <= 0) return this

	  while (this._bufs.length) {
	    if (bytes >= this._bufs[0].length) {
	      bytes -= this._bufs[0].length;
	      this.length -= this._bufs[0].length;
	      this._bufs.shift();
	    } else {
	      this._bufs[0] = this._bufs[0].slice(bytes);
	      this.length -= bytes;
	      break
	    }
	  }

	  return this
	};

	BufferList.prototype.duplicate = function duplicate () {
	  const copy = this._new();

	  for (let i = 0; i < this._bufs.length; i++) {
	    copy.append(this._bufs[i]);
	  }

	  return copy
	};

	BufferList.prototype.append = function append (buf) {
	  if (buf == null) {
	    return this
	  }

	  if (buf.buffer) {
	    // append a view of the underlying ArrayBuffer
	    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
	  } else if (Array.isArray(buf)) {
	    for (let i = 0; i < buf.length; i++) {
	      this.append(buf[i]);
	    }
	  } else if (this._isBufferList(buf)) {
	    // unwrap argument into individual BufferLists
	    for (let i = 0; i < buf._bufs.length; i++) {
	      this.append(buf._bufs[i]);
	    }
	  } else {
	    // coerce number arguments to strings, since Buffer(number) does
	    // uninitialized memory allocation
	    if (typeof buf === 'number') {
	      buf = buf.toString();
	    }

	    this._appendBuffer(Buffer.from(buf));
	  }

	  return this
	};

	BufferList.prototype._appendBuffer = function appendBuffer (buf) {
	  this._bufs.push(buf);
	  this.length += buf.length;
	};

	BufferList.prototype.indexOf = function (search, offset, encoding) {
	  if (encoding === undefined && typeof offset === 'string') {
	    encoding = offset;
	    offset = undefined;
	  }

	  if (typeof search === 'function' || Array.isArray(search)) {
	    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
	  } else if (typeof search === 'number') {
	    search = Buffer.from([search]);
	  } else if (typeof search === 'string') {
	    search = Buffer.from(search, encoding);
	  } else if (this._isBufferList(search)) {
	    search = search.slice();
	  } else if (Array.isArray(search.buffer)) {
	    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
	  } else if (!Buffer.isBuffer(search)) {
	    search = Buffer.from(search);
	  }

	  offset = Number(offset || 0);

	  if (isNaN(offset)) {
	    offset = 0;
	  }

	  if (offset < 0) {
	    offset = this.length + offset;
	  }

	  if (offset < 0) {
	    offset = 0;
	  }

	  if (search.length === 0) {
	    return offset > this.length ? this.length : offset
	  }

	  const blOffset = this._offset(offset);
	  let blIndex = blOffset[0]; // index of which internal buffer we're working on
	  let buffOffset = blOffset[1]; // offset of the internal buffer we're working on

	  // scan over each buffer
	  for (; blIndex < this._bufs.length; blIndex++) {
	    const buff = this._bufs[blIndex];

	    while (buffOffset < buff.length) {
	      const availableWindow = buff.length - buffOffset;

	      if (availableWindow >= search.length) {
	        const nativeSearchResult = buff.indexOf(search, buffOffset);

	        if (nativeSearchResult !== -1) {
	          return this._reverseOffset([blIndex, nativeSearchResult])
	        }

	        buffOffset = buff.length - search.length + 1; // end of native search window
	      } else {
	        const revOffset = this._reverseOffset([blIndex, buffOffset]);

	        if (this._match(revOffset, search)) {
	          return revOffset
	        }

	        buffOffset++;
	      }
	    }

	    buffOffset = 0;
	  }

	  return -1
	};

	BufferList.prototype._match = function (offset, search) {
	  if (this.length - offset < search.length) {
	    return false
	  }

	  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
	    if (this.get(offset + searchOffset) !== search[searchOffset]) {
	      return false
	    }
	  }
	  return true
	}

	;(function () {
	  const methods = {
	    readDoubleBE: 8,
	    readDoubleLE: 8,
	    readFloatBE: 4,
	    readFloatLE: 4,
	    readInt32BE: 4,
	    readInt32LE: 4,
	    readUInt32BE: 4,
	    readUInt32LE: 4,
	    readInt16BE: 2,
	    readInt16LE: 2,
	    readUInt16BE: 2,
	    readUInt16LE: 2,
	    readInt8: 1,
	    readUInt8: 1,
	    readIntBE: null,
	    readIntLE: null,
	    readUIntBE: null,
	    readUIntLE: null
	  };

	  for (const m in methods) {
	    (function (m) {
	      if (methods[m] === null) {
	        BufferList.prototype[m] = function (offset, byteLength) {
	          return this.slice(offset, offset + byteLength)[m](0, byteLength)
	        };
	      } else {
	        BufferList.prototype[m] = function (offset = 0) {
	          return this.slice(offset, offset + methods[m])[m](0)
	        };
	      }
	    }(m));
	  }
	}());

	// Used internally by the class and also as an indicator of this object being
	// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
	// environment because there could be multiple different copies of the
	// BufferList class and some `BufferList`s might be `BufferList`s.
	BufferList.prototype._isBufferList = function _isBufferList (b) {
	  return b instanceof BufferList || BufferList.isBufferList(b)
	};

	BufferList.isBufferList = function isBufferList (b) {
	  return b != null && b[symbol]
	};

	BufferList_1 = BufferList;
	return BufferList_1;
}

var hasRequiredBl;

function requireBl () {
	if (hasRequiredBl) return bl.exports;
	hasRequiredBl = 1;

	const DuplexStream = requireReadable().Duplex;
	const inherits = requireInherits();
	const BufferList = requireBufferList();

	function BufferListStream (callback) {
	  if (!(this instanceof BufferListStream)) {
	    return new BufferListStream(callback)
	  }

	  if (typeof callback === 'function') {
	    this._callback = callback;

	    const piper = function piper (err) {
	      if (this._callback) {
	        this._callback(err);
	        this._callback = null;
	      }
	    }.bind(this);

	    this.on('pipe', function onPipe (src) {
	      src.on('error', piper);
	    });
	    this.on('unpipe', function onUnpipe (src) {
	      src.removeListener('error', piper);
	    });

	    callback = null;
	  }

	  BufferList._init.call(this, callback);
	  DuplexStream.call(this);
	}

	inherits(BufferListStream, DuplexStream);
	Object.assign(BufferListStream.prototype, BufferList.prototype);

	BufferListStream.prototype._new = function _new (callback) {
	  return new BufferListStream(callback)
	};

	BufferListStream.prototype._write = function _write (buf, encoding, callback) {
	  this._appendBuffer(buf);

	  if (typeof callback === 'function') {
	    callback();
	  }
	};

	BufferListStream.prototype._read = function _read (size) {
	  if (!this.length) {
	    return this.push(null)
	  }

	  size = Math.min(size, this.length);
	  this.push(this.slice(0, size));
	  this.consume(size);
	};

	BufferListStream.prototype.end = function end (chunk) {
	  DuplexStream.prototype.end.call(this, chunk);

	  if (this._callback) {
	    this._callback(null, this.slice());
	    this._callback = null;
	  }
	};

	BufferListStream.prototype._destroy = function _destroy (err, cb) {
	  this._bufs.length = 0;
	  this.length = 0;
	  cb(err);
	};

	BufferListStream.prototype._isBufferList = function _isBufferList (b) {
	  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)
	};

	BufferListStream.isBufferList = BufferList.isBufferList;

	bl.exports = BufferListStream;
	bl.exports.BufferListStream = BufferListStream;
	bl.exports.BufferList = BufferList;
	return bl.exports;
}

var hasRequiredOra;

function requireOra () {
	if (hasRequiredOra) return ora.exports;
	hasRequiredOra = 1;
	const readline = require$$1$3;
	const chalk = requireSource();
	const cliCursor = requireCliCursor();
	const cliSpinners = requireCliSpinners();
	const logSymbols = requireLogSymbols();
	const stripAnsi = requireStripAnsi();
	const wcwidth = requireWcwidth();
	const isInteractive = requireIsInteractive();
	const isUnicodeSupported = requireIsUnicodeSupported();
	const {BufferListStream} = requireBl();

	const TEXT = Symbol('text');
	const PREFIX_TEXT = Symbol('prefixText');
	const ASCII_ETX_CODE = 0x03; // Ctrl+C emits this code

	class StdinDiscarder {
		constructor() {
			this.requests = 0;

			this.mutedStream = new BufferListStream();
			this.mutedStream.pipe(process.stdout);

			const self = this; // eslint-disable-line unicorn/no-this-assignment
			this.ourEmit = function (event, data, ...args) {
				const {stdin} = process;
				if (self.requests > 0 || stdin.emit === self.ourEmit) {
					if (event === 'keypress') { // Fixes readline behavior
						return;
					}

					if (event === 'data' && data.includes(ASCII_ETX_CODE)) {
						process.emit('SIGINT');
					}

					Reflect.apply(self.oldEmit, this, [event, data, ...args]);
				} else {
					Reflect.apply(process.stdin.emit, this, [event, data, ...args]);
				}
			};
		}

		start() {
			this.requests++;

			if (this.requests === 1) {
				this.realStart();
			}
		}

		stop() {
			if (this.requests <= 0) {
				throw new Error('`stop` called more times than `start`');
			}

			this.requests--;

			if (this.requests === 0) {
				this.realStop();
			}
		}

		realStart() {
			// No known way to make it work reliably on Windows
			if (process.platform === 'win32') {
				return;
			}

			this.rl = readline.createInterface({
				input: process.stdin,
				output: this.mutedStream
			});

			this.rl.on('SIGINT', () => {
				if (process.listenerCount('SIGINT') === 0) {
					process.emit('SIGINT');
				} else {
					this.rl.close();
					process.kill(process.pid, 'SIGINT');
				}
			});
		}

		realStop() {
			if (process.platform === 'win32') {
				return;
			}

			this.rl.close();
			this.rl = undefined;
		}
	}

	let stdinDiscarder;

	class Ora {
		constructor(options) {
			if (!stdinDiscarder) {
				stdinDiscarder = new StdinDiscarder();
			}

			if (typeof options === 'string') {
				options = {
					text: options
				};
			}

			this.options = {
				text: '',
				color: 'cyan',
				stream: process.stderr,
				discardStdin: true,
				...options
			};

			this.spinner = this.options.spinner;

			this.color = this.options.color;
			this.hideCursor = this.options.hideCursor !== false;
			this.interval = this.options.interval || this.spinner.interval || 100;
			this.stream = this.options.stream;
			this.id = undefined;
			this.isEnabled = typeof this.options.isEnabled === 'boolean' ? this.options.isEnabled : isInteractive({stream: this.stream});
			this.isSilent = typeof this.options.isSilent === 'boolean' ? this.options.isSilent : false;

			// Set *after* `this.stream`
			this.text = this.options.text;
			this.prefixText = this.options.prefixText;
			this.linesToClear = 0;
			this.indent = this.options.indent;
			this.discardStdin = this.options.discardStdin;
			this.isDiscardingStdin = false;
		}

		get indent() {
			return this._indent;
		}

		set indent(indent = 0) {
			if (!(indent >= 0 && Number.isInteger(indent))) {
				throw new Error('The `indent` option must be an integer from 0 and up');
			}

			this._indent = indent;
		}

		_updateInterval(interval) {
			if (interval !== undefined) {
				this.interval = interval;
			}
		}

		get spinner() {
			return this._spinner;
		}

		set spinner(spinner) {
			this.frameIndex = 0;

			if (typeof spinner === 'object') {
				if (spinner.frames === undefined) {
					throw new Error('The given spinner must have a `frames` property');
				}

				this._spinner = spinner;
			} else if (!isUnicodeSupported()) {
				this._spinner = cliSpinners.line;
			} else if (spinner === undefined) {
				// Set default spinner
				this._spinner = cliSpinners.dots;
			} else if (spinner !== 'default' && cliSpinners[spinner]) {
				this._spinner = cliSpinners[spinner];
			} else {
				throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
			}

			this._updateInterval(this._spinner.interval);
		}

		get text() {
			return this[TEXT];
		}

		set text(value) {
			this[TEXT] = value;
			this.updateLineCount();
		}

		get prefixText() {
			return this[PREFIX_TEXT];
		}

		set prefixText(value) {
			this[PREFIX_TEXT] = value;
			this.updateLineCount();
		}

		get isSpinning() {
			return this.id !== undefined;
		}

		getFullPrefixText(prefixText = this[PREFIX_TEXT], postfix = ' ') {
			if (typeof prefixText === 'string') {
				return prefixText + postfix;
			}

			if (typeof prefixText === 'function') {
				return prefixText() + postfix;
			}

			return '';
		}

		updateLineCount() {
			const columns = this.stream.columns || 80;
			const fullPrefixText = this.getFullPrefixText(this.prefixText, '-');
			this.lineCount = 0;
			for (const line of stripAnsi(fullPrefixText + '--' + this[TEXT]).split('\n')) {
				this.lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));
			}
		}

		get isEnabled() {
			return this._isEnabled && !this.isSilent;
		}

		set isEnabled(value) {
			if (typeof value !== 'boolean') {
				throw new TypeError('The `isEnabled` option must be a boolean');
			}

			this._isEnabled = value;
		}

		get isSilent() {
			return this._isSilent;
		}

		set isSilent(value) {
			if (typeof value !== 'boolean') {
				throw new TypeError('The `isSilent` option must be a boolean');
			}

			this._isSilent = value;
		}

		frame() {
			const {frames} = this.spinner;
			let frame = frames[this.frameIndex];

			if (this.color) {
				frame = chalk[this.color](frame);
			}

			this.frameIndex = ++this.frameIndex % frames.length;
			const fullPrefixText = (typeof this.prefixText === 'string' && this.prefixText !== '') ? this.prefixText + ' ' : '';
			const fullText = typeof this.text === 'string' ? ' ' + this.text : '';

			return fullPrefixText + frame + fullText;
		}

		clear() {
			if (!this.isEnabled || !this.stream.isTTY) {
				return this;
			}

			for (let i = 0; i < this.linesToClear; i++) {
				if (i > 0) {
					this.stream.moveCursor(0, -1);
				}

				this.stream.clearLine();
				this.stream.cursorTo(this.indent);
			}

			this.linesToClear = 0;

			return this;
		}

		render() {
			if (this.isSilent) {
				return this;
			}

			this.clear();
			this.stream.write(this.frame());
			this.linesToClear = this.lineCount;

			return this;
		}

		start(text) {
			if (text) {
				this.text = text;
			}

			if (this.isSilent) {
				return this;
			}

			if (!this.isEnabled) {
				if (this.text) {
					this.stream.write(`- ${this.text}\n`);
				}

				return this;
			}

			if (this.isSpinning) {
				return this;
			}

			if (this.hideCursor) {
				cliCursor.hide(this.stream);
			}

			if (this.discardStdin && process.stdin.isTTY) {
				this.isDiscardingStdin = true;
				stdinDiscarder.start();
			}

			this.render();
			this.id = setInterval(this.render.bind(this), this.interval);

			return this;
		}

		stop() {
			if (!this.isEnabled) {
				return this;
			}

			clearInterval(this.id);
			this.id = undefined;
			this.frameIndex = 0;
			this.clear();
			if (this.hideCursor) {
				cliCursor.show(this.stream);
			}

			if (this.discardStdin && process.stdin.isTTY && this.isDiscardingStdin) {
				stdinDiscarder.stop();
				this.isDiscardingStdin = false;
			}

			return this;
		}

		succeed(text) {
			return this.stopAndPersist({symbol: logSymbols.success, text});
		}

		fail(text) {
			return this.stopAndPersist({symbol: logSymbols.error, text});
		}

		warn(text) {
			return this.stopAndPersist({symbol: logSymbols.warning, text});
		}

		info(text) {
			return this.stopAndPersist({symbol: logSymbols.info, text});
		}

		stopAndPersist(options = {}) {
			if (this.isSilent) {
				return this;
			}

			const prefixText = options.prefixText || this.prefixText;
			const text = options.text || this.text;
			const fullText = (typeof text === 'string') ? ' ' + text : '';

			this.stop();
			this.stream.write(`${this.getFullPrefixText(prefixText, ' ')}${options.symbol || ' '}${fullText}\n`);

			return this;
		}
	}

	const oraFactory = function (options) {
		return new Ora(options);
	};

	ora.exports = oraFactory;

	ora.exports.promise = (action, options) => {
		// eslint-disable-next-line promise/prefer-await-to-then
		if (typeof action.then !== 'function') {
			throw new TypeError('Parameter `action` must be a Promise');
		}

		const spinner = new Ora(options);
		spinner.start();

		(async () => {
			try {
				await action;
				spinner.succeed();
			} catch {
				spinner.fail();
			}
		})();

		return spinner;
	};
	return ora.exports;
}

var screenManager;
var hasRequiredScreenManager;

function requireScreenManager () {
	if (hasRequiredScreenManager) return screenManager;
	hasRequiredScreenManager = 1;
	const util = requireReadline();
	const cliWidth = requireCliWidth();
	const wrapAnsi = requireWrapAnsi();
	const stripAnsi = requireStripAnsi();
	const stringWidth = requireStringWidth();
	const ora = requireOra();

	function height(content) {
	  return content.split('\n').length;
	}

	/** @param {string} content */
	function lastLine(content) {
	  return content.split('\n').pop();
	}

	class ScreenManager {
	  constructor(rl) {
	    // These variables are keeping information to allow correct prompt re-rendering
	    this.height = 0;
	    this.extraLinesUnderPrompt = 0;

	    this.rl = rl;
	  }

	  renderWithSpinner(content, bottomContent) {
	    if (this.spinnerId) {
	      clearInterval(this.spinnerId);
	    }

	    let spinner;
	    let contentFunc;
	    let bottomContentFunc;

	    if (bottomContent) {
	      spinner = ora(bottomContent);
	      contentFunc = () => content;
	      bottomContentFunc = () => spinner.frame();
	    } else {
	      spinner = ora(content);
	      contentFunc = () => spinner.frame();
	      bottomContentFunc = () => '';
	    }

	    this.spinnerId = setInterval(
	      () => this.render(contentFunc(), bottomContentFunc(), true),
	      spinner.interval
	    );
	  }

	  render(content, bottomContent, spinning = false) {
	    if (this.spinnerId && !spinning) {
	      clearInterval(this.spinnerId);
	    }

	    this.rl.output.unmute();
	    this.clean(this.extraLinesUnderPrompt);

	    /**
	     * Write message to screen and setPrompt to control backspace
	     */

	    const promptLine = lastLine(content);
	    const rawPromptLine = stripAnsi(promptLine);

	    // Remove the rl.line from our prompt. We can't rely on the content of
	    // rl.line (mainly because of the password prompt), so just rely on it's
	    // length.
	    let prompt = rawPromptLine;
	    if (this.rl.line.length) {
	      prompt = prompt.slice(0, -this.rl.line.length);
	    }

	    this.rl.setPrompt(prompt);

	    // SetPrompt will change cursor position, now we can get correct value
	    const cursorPos = this.rl._getCursorPos();
	    const width = this.normalizedCliWidth();

	    content = this.forceLineReturn(content, width);
	    if (bottomContent) {
	      bottomContent = this.forceLineReturn(bottomContent, width);
	    }

	    // Manually insert an extra line if we're at the end of the line.
	    // This prevent the cursor from appearing at the beginning of the
	    // current line.
	    if (rawPromptLine.length % width === 0) {
	      content += '\n';
	    }

	    const fullContent = content + (bottomContent ? '\n' + bottomContent : '');
	    this.rl.output.write(fullContent);

	    /**
	     * Re-adjust the cursor at the correct position.
	     */

	    // We need to consider parts of the prompt under the cursor as part of the bottom
	    // content in order to correctly cleanup and re-render.
	    const promptLineUpDiff = Math.floor(rawPromptLine.length / width) - cursorPos.rows;
	    const bottomContentHeight =
	      promptLineUpDiff + (bottomContent ? height(bottomContent) : 0);
	    if (bottomContentHeight > 0) {
	      util.up(this.rl, bottomContentHeight);
	    }

	    // Reset cursor at the beginning of the line
	    util.left(this.rl, stringWidth(lastLine(fullContent)));

	    // Adjust cursor on the right
	    if (cursorPos.cols > 0) {
	      util.right(this.rl, cursorPos.cols);
	    }

	    /**
	     * Set up state for next re-rendering
	     */
	    this.extraLinesUnderPrompt = bottomContentHeight;
	    this.height = height(fullContent);

	    this.rl.output.mute();
	  }

	  clean(extraLines) {
	    if (extraLines > 0) {
	      util.down(this.rl, extraLines);
	    }

	    util.clearLine(this.rl, this.height);
	  }

	  done() {
	    this.rl.setPrompt('');
	    this.rl.output.unmute();
	    this.rl.output.write('\n');
	  }

	  releaseCursor() {
	    if (this.extraLinesUnderPrompt > 0) {
	      util.down(this.rl, this.extraLinesUnderPrompt);
	    }
	  }

	  normalizedCliWidth() {
	    const width = cliWidth({
	      defaultWidth: 80,
	      output: this.rl.output,
	    });
	    return width;
	  }

	  /**
	   * @param {string[]} lines
	   */
	  breakLines(lines, width = this.normalizedCliWidth()) {
	    // Break lines who're longer than the cli width so we can normalize the natural line
	    // returns behavior across terminals.
	    // re: trim: false; by default, `wrap-ansi` trims whitespace, which
	    // is not what we want.
	    // re: hard: true; by default', `wrap-ansi` does soft wrapping
	    return lines.map((line) =>
	      wrapAnsi(line, width, { trim: false, hard: true }).split('\n')
	    );
	  }

	  /**
	   * @param {string} content
	   */
	  forceLineReturn(content, width = this.normalizedCliWidth()) {
	    return this.breakLines(content.split('\n'), width).flat().join('\n');
	  }
	}

	screenManager = ScreenManager;
	return screenManager;
}

var base;
var hasRequiredBase;

function requireBase () {
	if (hasRequiredBase) return base;
	hasRequiredBase = 1;
	/**
	 * Base prompt implementation
	 * Should be extended by prompt types.
	 */
	const _ = {
	  defaults: requireDefaults$1(),
	  clone: requireClone$1(),
	};
	const chalk = requireSource();
	const runAsync = requireRunAsync();
	const { filter, flatMap, share, take, takeUntil } = /*@__PURE__*/ requireOperators();
	const Choices = requireChoices();
	const ScreenManager = requireScreenManager();

	class Prompt {
	  constructor(question, rl, answers) {
	    // Setup instance defaults property
	    Object.assign(this, {
	      answers,
	      status: 'pending',
	    });

	    // Set defaults prompt options
	    this.opt = _.defaults(_.clone(question), {
	      validate: () => true,
	      validatingText: '',
	      filter: (val) => val,
	      filteringText: '',
	      when: () => true,
	      suffix: '',
	      prefix: chalk.green('?'),
	    });

	    // Make sure name is present
	    if (!this.opt.name) {
	      this.throwParamError('name');
	    }

	    // Set default message if no message defined
	    if (!this.opt.message) {
	      this.opt.message = this.opt.name + ':';
	    }

	    // Normalize choices
	    if (Array.isArray(this.opt.choices)) {
	      this.opt.choices = new Choices(this.opt.choices, answers);
	    }

	    this.rl = rl;
	    this.screen = new ScreenManager(this.rl);
	  }

	  /**
	   * Start the Inquiry session and manage output value filtering
	   * @return {Promise}
	   */

	  run() {
	    return new Promise((resolve, reject) => {
	      this._run(
	        (value) => resolve(value),
	        (error) => reject(error)
	      );
	    });
	  }

	  // Default noop (this one should be overwritten in prompts)
	  _run(cb) {
	    cb();
	  }

	  /**
	   * Throw an error telling a required parameter is missing
	   * @param  {String} name Name of the missing param
	   * @return {Throw Error}
	   */

	  throwParamError(name) {
	    throw new Error('You must provide a `' + name + '` parameter');
	  }

	  /**
	   * Called when the UI closes. Override to do any specific cleanup necessary
	   */
	  close() {
	    this.screen.releaseCursor();
	  }

	  /**
	   * Run the provided validation method each time a submit event occur.
	   * @param  {Rx.Observable} submit - submit event flow
	   * @return {Object}        Object containing two observables: `success` and `error`
	   */
	  handleSubmitEvents(submit) {
	    const self = this;
	    const validate = runAsync(this.opt.validate);
	    const asyncFilter = runAsync(this.opt.filter);
	    const validation = submit.pipe(
	      flatMap((value) => {
	        this.startSpinner(value, this.opt.filteringText);
	        return asyncFilter(value, self.answers).then(
	          (filteredValue) => {
	            this.startSpinner(filteredValue, this.opt.validatingText);
	            return validate(filteredValue, self.answers).then(
	              (isValid) => ({ isValid, value: filteredValue }),
	              (err) => ({ isValid: err, value: filteredValue })
	            );
	          },
	          (err) => ({ isValid: err })
	        );
	      }),
	      share()
	    );

	    const success = validation.pipe(
	      filter((state) => state.isValid === true),
	      take(1)
	    );
	    const error = validation.pipe(
	      filter((state) => state.isValid !== true),
	      takeUntil(success)
	    );

	    return {
	      success,
	      error,
	    };
	  }

	  startSpinner(value, bottomContent) {
	    value = this.getSpinningValue(value);
	    // If the question will spin, cut off the prefix (for layout purposes)
	    const content = bottomContent
	      ? this.getQuestion() + value
	      : this.getQuestion().slice(this.opt.prefix.length + 1) + value;

	    this.screen.renderWithSpinner(content, bottomContent);
	  }

	  /**
	   * Allow override, e.g. for password prompts
	   * See: https://github.com/SBoudrias/Inquirer.js/issues/1022
	   *
	   * @return {String} value to display while spinning
	   */
	  getSpinningValue(value) {
	    return value;
	  }

	  /**
	   * Generate the prompt question string
	   * @return {String} prompt question string
	   */
	  getQuestion() {
	    let message =
	      (this.opt.prefix ? this.opt.prefix + ' ' : '') +
	      chalk.bold(this.opt.message) +
	      this.opt.suffix +
	      chalk.reset(' ');

	    // Append the default if available, and if question isn't touched/answered
	    if (
	      this.opt.default != null &&
	      this.status !== 'touched' &&
	      this.status !== 'answered'
	    ) {
	      // If default password is supplied, hide it
	      if (this.opt.type === 'password') {
	        message += chalk.italic.dim('[hidden] ');
	      } else {
	        message += chalk.dim('(' + this.opt.default + ') ');
	      }
	    }

	    return message;
	  }
	}

	base = Prompt;
	return base;
}

var events;
var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events;
	hasRequiredEvents = 1;
	const { fromEvent } = /*@__PURE__*/ requireCjs$1();
	const { filter, map, share, takeUntil } = /*@__PURE__*/ requireOperators();

	function normalizeKeypressEvents(value, key) {
	  return { value, key: key || {} };
	}

	events = function (rl) {
	  const keypress = fromEvent(rl.input, 'keypress', normalizeKeypressEvents)
	    .pipe(takeUntil(fromEvent(rl, 'close')))
	    // Ignore `enter` key. On the readline, we only care about the `line` event.
	    .pipe(filter(({ key }) => key.name !== 'enter' && key.name !== 'return'));

	  return {
	    line: fromEvent(rl, 'line'),
	    keypress,

	    normalizedUpKey: keypress.pipe(
	      filter(
	        ({ key }) =>
	          key.name === 'up' || key.name === 'k' || (key.name === 'p' && key.ctrl)
	      ),
	      share()
	    ),

	    normalizedDownKey: keypress.pipe(
	      filter(
	        ({ key }) =>
	          key.name === 'down' || key.name === 'j' || (key.name === 'n' && key.ctrl)
	      ),
	      share()
	    ),

	    numberKey: keypress.pipe(
	      filter((e) => e.value && '123456789'.indexOf(e.value) >= 0),
	      map((e) => Number(e.value)),
	      share()
	    ),

	    spaceKey: keypress.pipe(
	      filter(({ key }) => key && key.name === 'space'),
	      share()
	    ),
	    aKey: keypress.pipe(
	      filter(({ key }) => key && key.name === 'a'),
	      share()
	    ),
	    iKey: keypress.pipe(
	      filter(({ key }) => key && key.name === 'i'),
	      share()
	    ),
	  };
	};
	return events;
}

var paginator;
var hasRequiredPaginator;

function requirePaginator () {
	if (hasRequiredPaginator) return paginator;
	hasRequiredPaginator = 1;

	const chalk = requireSource();

	/**
	 * The paginator returns a subset of the choices if the list is too long.
	 */

	class Paginator {
	  /**
	   * @param {import("./screen-manager")} [screen]
	   * @param {{isInfinite?: boolean}} [options]
	   */
	  constructor(screen, options = {}) {
	    const { isInfinite = true } = options;
	    this.lastIndex = 0;
	    this.screen = screen;
	    this.isInfinite = isInfinite;
	  }

	  paginate(output, active, pageSize) {
	    pageSize = pageSize || 7;
	    let lines = output.split('\n');

	    if (this.screen) {
	      lines = this.screen.breakLines(lines);
	      active = lines
	        .map((lineParts) => lineParts.length)
	        .splice(0, active)
	        .reduce((a, b) => a + b, 0);
	      lines = lines.flat();
	    }

	    // Make sure there's enough lines to paginate
	    if (lines.length <= pageSize) {
	      return output;
	    }
	    const visibleLines = this.isInfinite
	      ? this.getInfiniteLines(lines, active, pageSize)
	      : this.getFiniteLines(lines, active, pageSize);
	    this.lastIndex = active;
	    return (
	      visibleLines.join('\n') +
	      '\n' +
	      chalk.dim('(Move up and down to reveal more choices)')
	    );
	  }

	  getInfiniteLines(lines, active, pageSize) {
	    if (this.pointer === undefined) {
	      this.pointer = 0;
	    }
	    const middleOfList = Math.floor(pageSize / 2);
	    // Move the pointer only when the user go down and limit it to the middle of the list
	    if (
	      this.pointer < middleOfList &&
	      this.lastIndex < active &&
	      active - this.lastIndex < pageSize
	    ) {
	      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);
	    }

	    // Duplicate the lines so it give an infinite list look
	    const infinite = [lines, lines, lines].flat();
	    const topIndex = Math.max(0, active + lines.length - this.pointer);

	    return infinite.splice(topIndex, pageSize);
	  }

	  getFiniteLines(lines, active, pageSize) {
	    let topIndex = active - pageSize / 2;
	    if (topIndex < 0) {
	      topIndex = 0;
	    } else if (topIndex + pageSize > lines.length) {
	      topIndex = lines.length - pageSize;
	    }
	    return lines.splice(topIndex, pageSize);
	  }
	}

	paginator = Paginator;
	return paginator;
}

var incrementListIndex_1;
var hasRequiredIncrementListIndex;

function requireIncrementListIndex () {
	if (hasRequiredIncrementListIndex) return incrementListIndex_1;
	hasRequiredIncrementListIndex = 1;
	function incrementListIndex(current, dir, opt) {
	  const len = opt.choices.realLength;
	  const shouldLoop = 'loop' in opt ? Boolean(opt.loop) : true;
	  if (dir === 'up') {
	    if (current > 0) {
	      return current - 1;
	    }
	    return shouldLoop ? len - 1 : current;
	  }
	  if (dir === 'down') {
	    if (current < len - 1) {
	      return current + 1;
	    }
	    return shouldLoop ? 0 : current;
	  }
	  throw new Error('dir must be up or down');
	}

	incrementListIndex_1 = incrementListIndex;
	return incrementListIndex_1;
}

var list;
var hasRequiredList;

function requireList () {
	if (hasRequiredList) return list;
	hasRequiredList = 1;
	/**
	 * `list` type prompt
	 */

	const chalk = requireSource();
	const figures = requireFigures();
	const cliCursor = requireCliCursor();
	const runAsync = requireRunAsync();
	const { flatMap, map, take, takeUntil } = /*@__PURE__*/ requireOperators();
	const Base = requireBase();
	const observe = requireEvents();
	const Paginator = requirePaginator();
	const incrementListIndex = requireIncrementListIndex();

	class ListPrompt extends Base {
	  constructor(questions, rl, answers) {
	    super(questions, rl, answers);

	    if (!this.opt.choices) {
	      this.throwParamError('choices');
	    }

	    this.firstRender = true;
	    this.selected = 0;

	    const def = this.opt.default;

	    // If def is a Number, then use as index. Otherwise, check for value.
	    if (typeof def === 'number' && def >= 0 && def < this.opt.choices.realLength) {
	      this.selected = def;
	    } else if (typeof def !== 'number' && def != null) {
	      const index = this.opt.choices.realChoices.findIndex(({ value }) => value === def);
	      this.selected = Math.max(index, 0);
	    }

	    // Make sure no default is set (so it won't be printed)
	    this.opt.default = null;

	    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
	    this.paginator = new Paginator(this.screen, { isInfinite: shouldLoop });
	  }

	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    const self = this;

	    const events = observe(this.rl);
	    events.normalizedUpKey.pipe(takeUntil(events.line)).forEach(this.onUpKey.bind(this));
	    events.normalizedDownKey
	      .pipe(takeUntil(events.line))
	      .forEach(this.onDownKey.bind(this));
	    events.numberKey.pipe(takeUntil(events.line)).forEach(this.onNumberKey.bind(this));
	    events.line
	      .pipe(
	        take(1),
	        map(this.getCurrentValue.bind(this)),
	        flatMap((value) =>
	          runAsync(self.opt.filter)(value, self.answers).catch((err) => err)
	        )
	      )
	      .forEach(this.onSubmit.bind(this));

	    // Init the prompt
	    cliCursor.hide();
	    this.render();

	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {ListPrompt} self
	   */

	  render() {
	    // Render question
	    let message = this.getQuestion();

	    if (this.firstRender) {
	      message += chalk.dim('(Use arrow keys)');
	    }

	    // Render choices or answer depending on the state
	    if (this.status === 'answered') {
	      message += chalk.cyan(this.opt.choices.getChoice(this.selected).short);
	    } else {
	      const choicesStr = listRender(this.opt.choices, this.selected);
	      const indexPosition = this.opt.choices.indexOf(
	        this.opt.choices.getChoice(this.selected)
	      );
	      const realIndexPosition =
	        this.opt.choices.reduce((acc, value, i) => {
	          // Dont count lines past the choice we are looking at
	          if (i > indexPosition) {
	            return acc;
	          }
	          // Add line if it's a separator
	          if (value.type === 'separator') {
	            return acc + 1;
	          }

	          let l = value.name;
	          // Non-strings take up one line
	          if (typeof l !== 'string') {
	            return acc + 1;
	          }

	          // Calculate lines taken up by string
	          l = l.split('\n');
	          return acc + l.length;
	        }, 0) - 1;
	      message +=
	        '\n' + this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);
	    }

	    this.firstRender = false;

	    this.screen.render(message);
	  }

	  /**
	   * When user press `enter` key
	   */

	  onSubmit(value) {
	    this.status = 'answered';

	    // Rerender prompt
	    this.render();

	    this.screen.done();
	    cliCursor.show();
	    this.done(value);
	  }

	  getCurrentValue() {
	    return this.opt.choices.getChoice(this.selected).value;
	  }

	  /**
	   * When user press a key
	   */
	  onUpKey() {
	    this.selected = incrementListIndex(this.selected, 'up', this.opt);
	    this.render();
	  }

	  onDownKey() {
	    this.selected = incrementListIndex(this.selected, 'down', this.opt);
	    this.render();
	  }

	  onNumberKey(input) {
	    if (input <= this.opt.choices.realLength) {
	      this.selected = input - 1;
	    }

	    this.render();
	  }
	}

	/**
	 * Function for rendering list choices
	 * @param  {Number} pointer Position of the pointer
	 * @return {String}         Rendered content
	 */
	function listRender(choices, pointer) {
	  let output = '';
	  let separatorOffset = 0;

	  choices.forEach((choice, i) => {
	    if (choice.type === 'separator') {
	      separatorOffset++;
	      output += '  ' + choice + '\n';
	      return;
	    }

	    if (choice.disabled) {
	      separatorOffset++;
	      output += '  - ' + choice.name;
	      output += ` (${
	        typeof choice.disabled === 'string' ? choice.disabled : 'Disabled'
	      })`;
	      output += '\n';
	      return;
	    }

	    const isSelected = i - separatorOffset === pointer;
	    let line = (isSelected ? figures.pointer + ' ' : '  ') + choice.name;
	    if (isSelected) {
	      line = chalk.cyan(line);
	    }

	    output += line + ' \n';
	  });

	  return output.replace(/\n$/, '');
	}

	list = ListPrompt;
	return list;
}

var input;
var hasRequiredInput;

function requireInput () {
	if (hasRequiredInput) return input;
	hasRequiredInput = 1;
	/**
	 * `input` type prompt
	 */

	const chalk = requireSource();
	const { map, takeUntil } = /*@__PURE__*/ requireOperators();
	const Base = requireBase();
	const observe = requireEvents();

	class InputPrompt extends Base {
	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    // Once user confirm (enter key)
	    const events = observe(this.rl);
	    const submit = events.line.pipe(map(this.filterInput.bind(this)));

	    const validation = this.handleSubmitEvents(submit);
	    validation.success.forEach(this.onEnd.bind(this));
	    validation.error.forEach(this.onError.bind(this));

	    events.keypress
	      .pipe(takeUntil(validation.success))
	      .forEach(this.onKeypress.bind(this));

	    // Init
	    this.render();

	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {InputPrompt} self
	   */

	  render(error) {
	    let bottomContent = '';
	    let appendContent = '';
	    let message = this.getQuestion();
	    const { transformer } = this.opt;
	    const isFinal = this.status === 'answered';

	    if (isFinal) {
	      appendContent = this.answer;
	    } else {
	      appendContent = this.rl.line;
	    }

	    if (transformer) {
	      message += transformer(appendContent, this.answers, { isFinal });
	    } else {
	      message += isFinal ? chalk.cyan(appendContent) : appendContent;
	    }

	    if (error) {
	      bottomContent = chalk.red('>> ') + error;
	    }

	    this.screen.render(message, bottomContent);
	  }

	  /**
	   * When user press `enter` key
	   */

	  filterInput(input) {
	    if (!input) {
	      return this.opt.default == null ? '' : this.opt.default;
	    }

	    return input;
	  }

	  onEnd(state) {
	    this.answer = state.value;
	    this.status = 'answered';

	    // Re-render prompt
	    this.render();

	    this.screen.done();
	    this.done(state.value);
	  }

	  onError({ value = '', isValid }) {
	    this.rl.line += value;
	    this.rl.cursor += value.length;
	    this.render(isValid);
	  }

	  /**
	   * When user press a key
	   */

	  onKeypress() {
	    this.status = 'touched';

	    this.render();
	  }
	}

	input = InputPrompt;
	return input;
}

var number;
var hasRequiredNumber;

function requireNumber () {
	if (hasRequiredNumber) return number;
	hasRequiredNumber = 1;
	/**
	 * `input` type prompt
	 */

	const Input = requireInput();

	/**
	 * Extention of the Input prompt specifically for use with number inputs.
	 */

	class NumberPrompt extends Input {
	  filterInput(input) {
	    if (input && typeof input === 'string') {
	      input = input.trim();
	      // Match a number in the input
	      const numberMatch = input.match(/(^-?\d+|^-?\d+\.\d*|^\d*\.\d+)(e\d+)?$/);
	      // If a number is found, return that input.
	      if (numberMatch) {
	        return Number(numberMatch[0]);
	      }
	    }

	    // If the input was invalid return the default value.
	    return this.opt.default == null ? NaN : this.opt.default;
	  }
	}

	number = NumberPrompt;
	return number;
}

var confirm;
var hasRequiredConfirm;

function requireConfirm () {
	if (hasRequiredConfirm) return confirm;
	hasRequiredConfirm = 1;
	/**
	 * `confirm` type prompt
	 */

	const chalk = requireSource();
	const { take, takeUntil } = /*@__PURE__*/ requireOperators();
	const Base = requireBase();
	const observe = requireEvents();

	class ConfirmPrompt extends Base {
	  constructor(questions, rl, answers) {
	    super(questions, rl, answers);

	    let rawDefault = true;

	    Object.assign(this.opt, {
	      filter(input) {
	        let value = rawDefault;
	        if (input != null && input !== '') {
	          value = /^y(es)?/i.test(input);
	        }

	        return value;
	      },
	    });

	    if (this.opt.default != null) {
	      rawDefault = Boolean(this.opt.default);
	    }

	    this.opt.default = rawDefault ? 'Y/n' : 'y/N';
	  }

	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb   Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    // Once user confirm (enter key)
	    const events = observe(this.rl);
	    events.keypress.pipe(takeUntil(events.line)).forEach(this.onKeypress.bind(this));

	    events.line.pipe(take(1)).forEach(this.onEnd.bind(this));

	    // Init
	    this.render();

	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {ConfirmPrompt} self
	   */

	  render(answer) {
	    let message = this.getQuestion();

	    if (typeof answer === 'boolean') {
	      message += chalk.cyan(answer ? 'Yes' : 'No');
	    } else {
	      message += this.rl.line;
	    }

	    this.screen.render(message);

	    return this;
	  }

	  /**
	   * When user press `enter` key
	   */

	  onEnd(input) {
	    this.status = 'answered';

	    const output = this.opt.filter(input);
	    this.render(output);

	    this.screen.done();
	    this.done(output);
	  }

	  /**
	   * When user press a key
	   */

	  onKeypress() {
	    this.render();
	  }
	}

	confirm = ConfirmPrompt;
	return confirm;
}

var rawlist;
var hasRequiredRawlist;

function requireRawlist () {
	if (hasRequiredRawlist) return rawlist;
	hasRequiredRawlist = 1;
	/**
	 * `rawlist` type prompt
	 */

	const chalk = requireSource();
	const { map, takeUntil } = /*@__PURE__*/ requireOperators();
	const Base = requireBase();
	const Separator = requireSeparator();
	const observe = requireEvents();
	const Paginator = requirePaginator();
	const incrementListIndex = requireIncrementListIndex();

	class RawListPrompt extends Base {
	  constructor(questions, rl, answers) {
	    super(questions, rl, answers);

	    this.hiddenLine = '';
	    this.lastKey = '';

	    if (!this.opt.choices) {
	      this.throwParamError('choices');
	    }

	    this.opt.validChoices = this.opt.choices.filter(Separator.exclude);

	    this.selected = 0;
	    this.rawDefault = 0;

	    Object.assign(this.opt, {
	      validate(val) {
	        return val != null;
	      },
	    });

	    const def = this.opt.default;
	    if (typeof def === 'number' && def >= 0 && def < this.opt.choices.realLength) {
	      this.selected = def;
	      this.rawDefault = def;
	    } else if (typeof def !== 'number' && def != null) {
	      const index = this.opt.choices.realChoices.findIndex(({ value }) => value === def);
	      const safeIndex = Math.max(index, 0);
	      this.selected = safeIndex;
	      this.rawDefault = safeIndex;
	    }

	    // Make sure no default is set (so it won't be printed)
	    this.opt.default = null;

	    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
	    this.paginator = new Paginator(undefined, { isInfinite: shouldLoop });
	  }

	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    // Once user confirm (enter key)
	    const events = observe(this.rl);
	    const submit = events.line.pipe(map(this.getCurrentValue.bind(this)));

	    const validation = this.handleSubmitEvents(submit);
	    validation.success.forEach(this.onEnd.bind(this));
	    validation.error.forEach(this.onError.bind(this));

	    events.normalizedUpKey
	      .pipe(takeUntil(validation.success))
	      .forEach(this.onUpKey.bind(this));
	    events.normalizedDownKey
	      .pipe(takeUntil(validation.success))
	      .forEach(this.onDownKey.bind(this));
	    events.keypress
	      .pipe(takeUntil(validation.success))
	      .forEach(this.onKeypress.bind(this));
	    // Init the prompt
	    this.render();

	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {RawListPrompt} self
	   */

	  render(error) {
	    // Render question
	    let message = this.getQuestion();
	    let bottomContent = '';

	    if (this.status === 'answered') {
	      message += chalk.cyan(this.opt.choices.getChoice(this.selected).short);
	    } else {
	      const choicesStr = renderChoices(this.opt.choices, this.selected);
	      message +=
	        '\n' + this.paginator.paginate(choicesStr, this.selected, this.opt.pageSize);
	      message += '\n  Answer: ';
	    }
	    message += this.rl.line;

	    if (error) {
	      bottomContent = '\n' + chalk.red('>> ') + error;
	    }

	    this.screen.render(message, bottomContent);
	  }

	  /**
	   * When user press `enter` key
	   */

	  getCurrentValue(index) {
	    if (index == null) {
	      index = this.rawDefault;
	    } else if (index === '') {
	      this.selected = this.selected === undefined ? -1 : this.selected;
	      index = this.selected;
	    } else {
	      index -= 1;
	    }

	    const choice = this.opt.choices.getChoice(index);
	    return choice ? choice.value : null;
	  }

	  onEnd(state) {
	    this.status = 'answered';
	    this.answer = state.value;

	    // Re-render prompt
	    this.render();

	    this.screen.done();
	    this.done(state.value);
	  }

	  onError() {
	    this.render('Please enter a valid index');
	  }

	  /**
	   * When user press a key
	   */

	  onKeypress() {
	    let index;

	    if (this.lastKey === 'arrow') {
	      index = this.hiddenLine.length ? Number(this.hiddenLine) - 1 : 0;
	    } else {
	      index = this.rl.line.length ? Number(this.rl.line) - 1 : 0;
	    }
	    this.lastKey = '';

	    if (this.opt.choices.getChoice(index)) {
	      this.selected = index;
	    } else {
	      this.selected = undefined;
	    }
	    this.render();
	  }

	  /**
	   * When user press up key
	   */

	  onUpKey() {
	    this.onArrowKey('up');
	  }

	  /**
	   * When user press down key
	   */

	  onDownKey() {
	    this.onArrowKey('down');
	  }

	  /**
	   * When user press up or down key
	   * @param {String} type Arrow type: up or down
	   */

	  onArrowKey(type) {
	    this.selected = incrementListIndex(this.selected, type, this.opt) || 0;
	    this.hiddenLine = String(this.selected + 1);
	    this.rl.line = '';
	    this.lastKey = 'arrow';
	  }
	}

	/**
	 * Function for rendering list choices
	 * @param  {Number} pointer Position of the pointer
	 * @return {String}         Rendered content
	 */

	function renderChoices(choices, pointer) {
	  let output = '';
	  let separatorOffset = 0;

	  choices.forEach((choice, i) => {
	    output += output ? '\n  ' : '  ';

	    if (choice.type === 'separator') {
	      separatorOffset++;
	      output += ' ' + choice;
	      return;
	    }

	    const index = i - separatorOffset;
	    let display = index + 1 + ') ' + choice.name;
	    if (index === pointer) {
	      display = chalk.cyan(display);
	    }

	    output += display;
	  });

	  return output;
	}

	rawlist = RawListPrompt;
	return rawlist;
}

var expand;
var hasRequiredExpand;

function requireExpand () {
	if (hasRequiredExpand) return expand;
	hasRequiredExpand = 1;
	/**
	 * `rawlist` type prompt
	 */

	const chalk = requireSource();
	const { map, takeUntil } = /*@__PURE__*/ requireOperators();
	const Base = requireBase();
	const Separator = requireSeparator();
	const observe = requireEvents();
	const Paginator = requirePaginator();

	class ExpandPrompt extends Base {
	  constructor(questions, rl, answers) {
	    super(questions, rl, answers);

	    if (!this.opt.choices) {
	      this.throwParamError('choices');
	    }

	    this.validateChoices(this.opt.choices);

	    // Add the default `help` (/expand) option
	    this.opt.choices.push({
	      key: 'h',
	      name: 'Help, list all options',
	      value: 'help',
	    });

	    this.opt.validate = (choice) => {
	      if (choice == null) {
	        return 'Please enter a valid command';
	      }

	      return choice !== 'help';
	    };

	    // Setup the default string (capitalize the default key)
	    this.opt.default = this.generateChoicesString(this.opt.choices, this.opt.default);

	    this.paginator = new Paginator(this.screen);
	  }

	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    // Save user answer and update prompt to show selected option.
	    const events = observe(this.rl);
	    const validation = this.handleSubmitEvents(
	      events.line.pipe(map(this.getCurrentValue.bind(this)))
	    );
	    validation.success.forEach(this.onSubmit.bind(this));
	    validation.error.forEach(this.onError.bind(this));
	    this.keypressObs = events.keypress
	      .pipe(takeUntil(validation.success))
	      .forEach(this.onKeypress.bind(this));

	    // Init the prompt
	    this.render();

	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {ExpandPrompt} self
	   */

	  render(error, hint) {
	    let message = this.getQuestion();
	    let bottomContent = '';

	    if (this.status === 'answered') {
	      message += chalk.cyan(this.answer);
	    } else if (this.status === 'expanded') {
	      const choicesStr = renderChoices(this.opt.choices, this.selectedKey);
	      message += this.paginator.paginate(choicesStr, this.selectedKey, this.opt.pageSize);
	      message += '\n  Answer: ';
	    }

	    message += this.rl.line;

	    if (error) {
	      bottomContent = chalk.red('>> ') + error;
	    }

	    if (hint) {
	      bottomContent = chalk.cyan('>> ') + hint;
	    }

	    this.screen.render(message, bottomContent);
	  }

	  getCurrentValue(input) {
	    if (!input) {
	      input = this.rawDefault;
	    }

	    const selected = this.opt.choices.where({ key: input.toLowerCase().trim() })[0];
	    if (!selected) {
	      return null;
	    }

	    return selected.value;
	  }

	  /**
	   * Generate the prompt choices string
	   * @return {String}  Choices string
	   */

	  getChoices() {
	    let output = '';

	    this.opt.choices.forEach((choice) => {
	      output += '\n  ';

	      if (choice.type === 'separator') {
	        output += ' ' + choice;
	        return;
	      }

	      let choiceStr = choice.key + ') ' + choice.name;
	      if (this.selectedKey === choice.key) {
	        choiceStr = chalk.cyan(choiceStr);
	      }

	      output += choiceStr;
	    });

	    return output;
	  }

	  onError(state) {
	    if (state.value === 'help') {
	      this.selectedKey = '';
	      this.status = 'expanded';
	      this.render();
	      return;
	    }

	    this.render(state.isValid);
	  }

	  /**
	   * When user press `enter` key
	   */

	  onSubmit(state) {
	    this.status = 'answered';
	    const choice = this.opt.choices.where({ value: state.value })[0];
	    this.answer = choice.short || choice.name;

	    // Re-render prompt
	    this.render();
	    this.screen.done();
	    this.done(state.value);
	  }

	  /**
	   * When user press a key
	   */

	  onKeypress() {
	    this.selectedKey = this.rl.line.toLowerCase();
	    const selected = this.opt.choices.where({ key: this.selectedKey })[0];
	    if (this.status === 'expanded') {
	      this.render();
	    } else {
	      this.render(null, selected ? selected.name : null);
	    }
	  }

	  /**
	   * Validate the choices
	   * @param {Array} choices
	   */

	  validateChoices(choices) {
	    let formatError;
	    const errors = [];
	    const keymap = {};
	    choices.filter(Separator.exclude).forEach((choice) => {
	      if (!choice.key || choice.key.length !== 1) {
	        formatError = true;
	      }

	      choice.key = String(choice.key).toLowerCase();

	      if (keymap[choice.key]) {
	        errors.push(choice.key);
	      }

	      keymap[choice.key] = true;
	    });

	    if (formatError) {
	      throw new Error(
	        'Format error: `key` param must be a single letter and is required.'
	      );
	    }

	    if (keymap.h) {
	      throw new Error(
	        'Reserved key error: `key` param cannot be `h` - this value is reserved.'
	      );
	    }

	    if (errors.length) {
	      throw new Error(
	        'Duplicate key error: `key` param must be unique. Duplicates: ' +
	          [...new Set(errors)].join(',')
	      );
	    }
	  }

	  /**
	   * Generate a string out of the choices keys
	   * @param  {Array}  choices
	   * @param  {Number|String} default - the choice index or name to capitalize
	   * @return {String} The rendered choices key string
	   */
	  generateChoicesString(choices, defaultChoice) {
	    let defIndex = choices.realLength - 1;
	    if (typeof defaultChoice === 'number' && this.opt.choices.getChoice(defaultChoice)) {
	      defIndex = defaultChoice;
	    } else if (typeof defaultChoice === 'string') {
	      const index = choices.realChoices.findIndex(({ value }) => value === defaultChoice);
	      defIndex = index === -1 ? defIndex : index;
	    }

	    const defStr = this.opt.choices.pluck('key');
	    this.rawDefault = defStr[defIndex];
	    defStr[defIndex] = String(defStr[defIndex]).toUpperCase();
	    return defStr.join('');
	  }
	}

	/**
	 * Function for rendering checkbox choices
	 * @param  {String} pointer Selected key
	 * @return {String}         Rendered content
	 */

	function renderChoices(choices, pointer) {
	  let output = '';

	  choices.forEach((choice) => {
	    output += '\n  ';

	    if (choice.type === 'separator') {
	      output += ' ' + choice;
	      return;
	    }

	    let choiceStr = choice.key + ') ' + choice.name;
	    if (pointer === choice.key) {
	      choiceStr = chalk.cyan(choiceStr);
	    }

	    output += choiceStr;
	  });

	  return output;
	}

	expand = ExpandPrompt;
	return expand;
}

var checkbox;
var hasRequiredCheckbox;

function requireCheckbox () {
	if (hasRequiredCheckbox) return checkbox;
	hasRequiredCheckbox = 1;
	/**
	 * `list` type prompt
	 */

	const chalk = requireSource();
	const cliCursor = requireCliCursor();
	const figures = requireFigures();
	const { map, takeUntil } = /*@__PURE__*/ requireOperators();
	const Base = requireBase();
	const observe = requireEvents();
	const Paginator = requirePaginator();
	const incrementListIndex = requireIncrementListIndex();

	class CheckboxPrompt extends Base {
	  constructor(questions, rl, answers) {
	    super(questions, rl, answers);

	    if (!this.opt.choices) {
	      this.throwParamError('choices');
	    }

	    if (Array.isArray(this.opt.default)) {
	      this.opt.choices.forEach(function (choice) {
	        if (this.opt.default.indexOf(choice.value) >= 0) {
	          choice.checked = true;
	        }
	      }, this);
	    }

	    this.pointer = 0;

	    // Make sure no default is set (so it won't be printed)
	    this.opt.default = null;

	    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
	    this.paginator = new Paginator(this.screen, { isInfinite: shouldLoop });
	  }

	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    const events = observe(this.rl);

	    const validation = this.handleSubmitEvents(
	      events.line.pipe(map(this.getCurrentValue.bind(this)))
	    );
	    validation.success.forEach(this.onEnd.bind(this));
	    validation.error.forEach(this.onError.bind(this));

	    events.normalizedUpKey
	      .pipe(takeUntil(validation.success))
	      .forEach(this.onUpKey.bind(this));
	    events.normalizedDownKey
	      .pipe(takeUntil(validation.success))
	      .forEach(this.onDownKey.bind(this));
	    events.numberKey
	      .pipe(takeUntil(validation.success))
	      .forEach(this.onNumberKey.bind(this));
	    events.spaceKey
	      .pipe(takeUntil(validation.success))
	      .forEach(this.onSpaceKey.bind(this));
	    events.aKey.pipe(takeUntil(validation.success)).forEach(this.onAllKey.bind(this));
	    events.iKey.pipe(takeUntil(validation.success)).forEach(this.onInverseKey.bind(this));

	    // Init the prompt
	    cliCursor.hide();
	    this.render();
	    this.firstRender = false;

	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {CheckboxPrompt} self
	   */

	  render(error) {
	    // Render question
	    let message = this.getQuestion();
	    let bottomContent = '';

	    if (!this.dontShowHints) {
	      message +=
	        '(Press ' +
	        chalk.cyan.bold('<space>') +
	        ' to select, ' +
	        chalk.cyan.bold('<a>') +
	        ' to toggle all, ' +
	        chalk.cyan.bold('<i>') +
	        ' to invert selection, and ' +
	        chalk.cyan.bold('<enter>') +
	        ' to proceed)';
	    }

	    // Render choices or answer depending on the state
	    if (this.status === 'answered') {
	      message += chalk.cyan(this.selection.join(', '));
	    } else {
	      const choicesStr = renderChoices(this.opt.choices, this.pointer);
	      const indexPosition = this.opt.choices.indexOf(
	        this.opt.choices.getChoice(this.pointer)
	      );
	      const realIndexPosition =
	        this.opt.choices.reduce((acc, value, i) => {
	          // Dont count lines past the choice we are looking at
	          if (i > indexPosition) {
	            return acc;
	          }
	          // Add line if it's a separator
	          if (value.type === 'separator') {
	            return acc + 1;
	          }

	          let l = value.name;
	          // Non-strings take up one line
	          if (typeof l !== 'string') {
	            return acc + 1;
	          }

	          // Calculate lines taken up by string
	          l = l.split('\n');
	          return acc + l.length;
	        }, 0) - 1;
	      message +=
	        '\n' + this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);
	    }

	    if (error) {
	      bottomContent = chalk.red('>> ') + error;
	    }

	    this.screen.render(message, bottomContent);
	  }

	  /**
	   * When user press `enter` key
	   */

	  onEnd(state) {
	    this.status = 'answered';
	    this.dontShowHints = true;
	    // Rerender prompt (and clean subline error)
	    this.render();

	    this.screen.done();
	    cliCursor.show();
	    this.done(state.value);
	  }

	  onError(state) {
	    this.render(state.isValid);
	  }

	  getCurrentValue() {
	    const choices = this.opt.choices.filter(
	      (choice) => Boolean(choice.checked) && !choice.disabled
	    );

	    this.selection = choices.map((choice) => choice.short);
	    return choices.map((choice) => choice.value);
	  }

	  onUpKey() {
	    this.pointer = incrementListIndex(this.pointer, 'up', this.opt);
	    this.render();
	  }

	  onDownKey() {
	    this.pointer = incrementListIndex(this.pointer, 'down', this.opt);
	    this.render();
	  }

	  onNumberKey(input) {
	    if (input <= this.opt.choices.realLength) {
	      this.pointer = input - 1;
	      this.toggleChoice(this.pointer);
	    }

	    this.render();
	  }

	  onSpaceKey() {
	    this.toggleChoice(this.pointer);
	    this.render();
	  }

	  onAllKey() {
	    const shouldBeChecked = Boolean(
	      this.opt.choices.find((choice) => choice.type !== 'separator' && !choice.checked)
	    );

	    this.opt.choices.forEach((choice) => {
	      if (choice.type !== 'separator') {
	        choice.checked = shouldBeChecked;
	      }
	    });

	    this.render();
	  }

	  onInverseKey() {
	    this.opt.choices.forEach((choice) => {
	      if (choice.type !== 'separator') {
	        choice.checked = !choice.checked;
	      }
	    });

	    this.render();
	  }

	  toggleChoice(index) {
	    const item = this.opt.choices.getChoice(index);
	    if (item !== undefined) {
	      this.opt.choices.getChoice(index).checked = !item.checked;
	    }
	  }
	}

	/**
	 * Function for rendering checkbox choices
	 * @param  {Number} pointer Position of the pointer
	 * @return {String}         Rendered content
	 */

	function renderChoices(choices, pointer) {
	  let output = '';
	  let separatorOffset = 0;

	  choices.forEach((choice, i) => {
	    if (choice.type === 'separator') {
	      separatorOffset++;
	      output += ' ' + choice + '\n';
	      return;
	    }

	    if (choice.disabled) {
	      separatorOffset++;
	      output += ' - ' + choice.name;
	      output += ` (${
	        typeof choice.disabled === 'string' ? choice.disabled : 'Disabled'
	      })`;
	    } else {
	      const line = getCheckbox(choice.checked) + ' ' + choice.name;
	      if (i - separatorOffset === pointer) {
	        output += chalk.cyan(figures.pointer + line);
	      } else {
	        output += ' ' + line;
	      }
	    }

	    output += '\n';
	  });

	  return output.replace(/\n$/, '');
	}

	/**
	 * Get the checkbox
	 * @param  {Boolean} checked - add a X or not to the checkbox
	 * @return {String} Composited checkbox string
	 */

	function getCheckbox(checked) {
	  return checked ? chalk.green(figures.radioOn) : figures.radioOff;
	}

	checkbox = CheckboxPrompt;
	return checkbox;
}

var password;
var hasRequiredPassword;

function requirePassword () {
	if (hasRequiredPassword) return password;
	hasRequiredPassword = 1;
	/**
	 * `password` type prompt
	 */

	const chalk = requireSource();
	const { map, takeUntil } = /*@__PURE__*/ requireOperators();
	const Base = requireBase();
	const observe = requireEvents();

	function mask(input, maskChar) {
	  input = String(input);
	  maskChar = typeof maskChar === 'string' ? maskChar : '*';
	  if (input.length === 0) {
	    return '';
	  }

	  return new Array(input.length + 1).join(maskChar);
	}

	class PasswordPrompt extends Base {
	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    const events = observe(this.rl);

	    // Once user confirm (enter key)
	    const submit = events.line.pipe(map(this.filterInput.bind(this)));

	    const validation = this.handleSubmitEvents(submit);
	    validation.success.forEach(this.onEnd.bind(this));
	    validation.error.forEach(this.onError.bind(this));

	    events.keypress
	      .pipe(takeUntil(validation.success))
	      .forEach(this.onKeypress.bind(this));

	    // Init
	    this.render();

	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {PasswordPrompt} self
	   */

	  render(error) {
	    let message = this.getQuestion();
	    let bottomContent = '';

	    if (this.status === 'answered') {
	      message += this.getMaskedValue(this.answer);
	    } else {
	      message += this.getMaskedValue(this.rl.line || '');
	    }

	    if (error) {
	      bottomContent = '\n' + chalk.red('>> ') + error;
	    }

	    this.screen.render(message, bottomContent);
	  }

	  getMaskedValue(value) {
	    if (this.status === 'answered') {
	      return this.opt.mask
	        ? chalk.cyan(mask(value, this.opt.mask))
	        : chalk.italic.dim('[hidden]');
	    }
	    return this.opt.mask
	      ? mask(value, this.opt.mask)
	      : chalk.italic.dim('[input is hidden] ');
	  }

	  /**
	   * Mask value during async filter/validation.
	   */
	  getSpinningValue(value) {
	    return this.getMaskedValue(value);
	  }

	  /**
	   * When user press `enter` key
	   */

	  filterInput(input) {
	    if (!input) {
	      return this.opt.default == null ? '' : this.opt.default;
	    }

	    return input;
	  }

	  onEnd(state) {
	    this.status = 'answered';
	    this.answer = state.value;

	    // Re-render prompt
	    this.render();

	    this.screen.done();
	    this.done(state.value);
	  }

	  onError(state) {
	    this.render(state.isValid);
	  }

	  onKeypress() {
	    // If user press a key, just clear the default value
	    if (this.opt.default) {
	      this.opt.default = undefined;
	    }

	    this.render();
	  }
	}

	password = PasswordPrompt;
	return password;
}

var main = {};

var chardet = {};

var match;
var hasRequiredMatch;

function requireMatch () {
	if (hasRequiredMatch) return match;
	hasRequiredMatch = 1;
	match = function(det, rec, confidence, name, lang) {
	  this.confidence = confidence;
	  this.name = name || rec.name(det);
	  this.lang = lang;
	};
	return match;
}

var utf8;
var hasRequiredUtf8;

function requireUtf8 () {
	if (hasRequiredUtf8) return utf8;
	hasRequiredUtf8 = 1;
	var Match = requireMatch();

	/**
	 * Charset recognizer for UTF-8
	 */
	utf8 = function() {
	  this.name = function() {
	    return 'UTF-8';
	  };
	  this.match = function(det) {

	    var hasBOM = false,
	      numValid = 0,
	      numInvalid = 0,
	      input = det.fRawInput,
	      trailBytes = 0,
	      confidence;

	    if (det.fRawLength >= 3 &&
	      (input[0] & 0xff) == 0xef && (input[1] & 0xff) == 0xbb && (input[2] & 0xff) == 0xbf) {
	      hasBOM = true;
	    }

	    // Scan for multi-byte sequences
	    for (var i = 0; i < det.fRawLength; i++) {
	      var b = input[i];
	      if ((b & 0x80) == 0)
	        continue; // ASCII

	      // Hi bit on char found.  Figure out how long the sequence should be
	      if ((b & 0x0e0) == 0x0c0) {
	        trailBytes = 1;
	      } else if ((b & 0x0f0) == 0x0e0) {
	        trailBytes = 2;
	      } else if ((b & 0x0f8) == 0xf0) {
	        trailBytes = 3;
	      } else {
	        numInvalid++;
	        if (numInvalid > 5)
	          break;
	        trailBytes = 0;
	      }

	      // Verify that we've got the right number of trail bytes in the sequence
	      for (;;) {
	        i++;
	        if (i >= det.fRawLength)
	          break;

	        if ((input[i] & 0xc0) != 0x080) {
	          numInvalid++;
	          break;
	        }
	        if (--trailBytes == 0) {
	          numValid++;
	          break;
	        }
	      }
	    }

	    // Cook up some sort of confidence score, based on presense of a BOM
	    //    and the existence of valid and/or invalid multi-byte sequences.
	    confidence = 0;
	    if (hasBOM && numInvalid == 0)
	      confidence = 100;
	    else if (hasBOM && numValid > numInvalid * 10)
	      confidence = 80;
	    else if (numValid > 3 && numInvalid == 0)
	      confidence = 100;
	    else if (numValid > 0 && numInvalid == 0)
	      confidence = 80;
	    else if (numValid == 0 && numInvalid == 0)
	      // Plain ASCII.
	      confidence = 10;
	    else if (numValid > numInvalid * 10)
	      // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.
	      confidence = 25;
	    else
	      return null

	    return new Match(det, this, confidence);
	  };
	};
	return utf8;
}

var unicode = {exports: {}};

var hasRequiredUnicode;

function requireUnicode () {
	if (hasRequiredUnicode) return unicode.exports;
	hasRequiredUnicode = 1;
	(function (module) {
		var util = require$$0$d,
		  Match = requireMatch();

		/**
		 * This class matches UTF-16 and UTF-32, both big- and little-endian. The
		 * BOM will be used if it is present.
		 */
		module.exports.UTF_16BE = function() {
		  this.name = function() {
		    return 'UTF-16BE';
		  };
		  this.match = function(det) {
		    var input = det.fRawInput;

		    if (input.length >= 2 && ((input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff)) {
		      return new Match(det, this, 100); // confidence = 100
		    }

		    // TODO: Do some statistics to check for unsigned UTF-16BE
		    return null;
		  };
		};

		module.exports.UTF_16LE = function() {
		  this.name = function() {
		    return 'UTF-16LE';
		  };
		  this.match = function(det) {
		    var input = det.fRawInput;

		    if (input.length >= 2 && ((input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe)) {
		      // LE BOM is present.
		      if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00) {
		        // It is probably UTF-32 LE, not UTF-16
		        return null;
		      }
		      return new Match(det, this, 100); // confidence = 100
		    }

		    // TODO: Do some statistics to check for unsigned UTF-16LE
		    return null;
		  };
		};

		function UTF_32() {}		UTF_32.prototype.match = function(det) {
		  var input      = det.fRawInput,
		    limit      = (det.fRawLength / 4) * 4,
		    numValid   = 0,
		    numInvalid = 0,
		    hasBOM     = false,
		    confidence = 0;

		  if (limit == 0) {
		    return null;
		  }

		  if (this.getChar(input, 0) == 0x0000FEFF) {
		    hasBOM = true;
		  }

		  for (var i = 0; i < limit; i += 4) {
		    var ch = this.getChar(input, i);

		    if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF)) {
		      numInvalid += 1;
		    } else {
		      numValid += 1;
		    }
		  }

		  // Cook up some sort of confidence score, based on presence of a BOM
		  //    and the existence of valid and/or invalid multi-byte sequences.
		  if (hasBOM && numInvalid == 0) {
		    confidence = 100;
		  } else if (hasBOM && numValid > numInvalid * 10) {
		    confidence = 80;
		  } else if (numValid > 3 && numInvalid == 0) {
		    confidence = 100;
		  } else if (numValid > 0 && numInvalid == 0) {
		    confidence = 80;
		  } else if (numValid > numInvalid * 10) {
		    // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.
		    confidence = 25;
		  }

		  // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
		  return confidence == 0 ? null : new Match(det, this, confidence);
		};

		module.exports.UTF_32BE = function() {
		  this.name = function() {
		    return 'UTF-32BE';
		  };
		  this.getChar = function(input, index) {
		    return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 |
		         (input[index + 2] & 0xff) <<  8 | (input[index + 3] & 0xff);
		  };
		};
		util.inherits(module.exports.UTF_32BE, UTF_32);

		module.exports.UTF_32LE = function() {
		  this.name = function() {
		    return 'UTF-32LE';
		  };
		  this.getChar = function(input, index) {
		    return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 |
		         (input[index + 1] & 0xff) <<  8 | (input[index + 0] & 0xff);
		  };
		};
		util.inherits(module.exports.UTF_32LE, UTF_32); 
	} (unicode));
	return unicode.exports;
}

var mbcs = {exports: {}};

var hasRequiredMbcs;

function requireMbcs () {
	if (hasRequiredMbcs) return mbcs.exports;
	hasRequiredMbcs = 1;
	(function (module) {
		var util = require$$0$d,
		  Match = requireMatch();

		/**
		 * Binary search implementation (recursive)
		 */
		function binarySearch(arr, searchValue) {
		  function find(arr, searchValue, left, right) {
		    if (right < left)
		      return -1;

		    /*
		    int mid = mid = (left + right) / 2;
		    There is a bug in the above line;
		    Joshua Bloch suggests the following replacement:
		    */
		    var mid = Math.floor((left + right) >>> 1);
		    if (searchValue > arr[mid])
		      return find(arr, searchValue, mid + 1, right);

		    if (searchValue < arr[mid])
		      return find(arr, searchValue, left, mid - 1);

		    return mid;
		  }
		  return find(arr, searchValue, 0, arr.length - 1);
		}
		// 'Character'  iterated character class.
		//    Recognizers for specific mbcs encodings make their 'characters' available
		//    by providing a nextChar() function that fills in an instance of iteratedChar
		//    with the next char from the input.
		//    The returned characters are not converted to Unicode, but remain as the raw
		//    bytes (concatenated into an int) from the codepage data.
		//
		//  For Asian charsets, use the raw input rather than the input that has been
		//   stripped of markup.  Detection only considers multi-byte chars, effectively
		//   stripping markup anyway, and double byte chars do occur in markup too.
		//
		function IteratedChar() {

		  this.charValue = 0; // 1-4 bytes from the raw input data
		  this.index     = 0;
		  this.nextIndex = 0;
		  this.error     = false;
		  this.done      = false;

		  this.reset = function() {
		    this.charValue = 0;
		    this.index     = -1;
		    this.nextIndex = 0;
		    this.error     = false;
		    this.done      = false;
		  };

		  this.nextByte = function(det) {
		    if (this.nextIndex >= det.fRawLength) {
		      this.done = true;
		      return -1;
		    }
		    var byteValue = det.fRawInput[this.nextIndex++] & 0x00ff;
		    return byteValue;
		  };
		}


		/**
		 * Asian double or multi-byte - charsets.
		 * Match is determined mostly by the input data adhering to the
		 * encoding scheme for the charset, and, optionally,
		 * frequency-of-occurence of characters.
		 */

		function mbcs() {}
		/**
		 * Test the match of this charset with the input text data
		 *      which is obtained via the CharsetDetector object.
		 *
		 * @param det  The CharsetDetector, which contains the input text
		 *             to be checked for being in this charset.
		 * @return     Two values packed into one int  (Damn java, anyhow)
		 *             bits 0-7:  the match confidence, ranging from 0-100
		 *             bits 8-15: The match reason, an enum-like value.
		 */
		mbcs.prototype.match = function(det) {

		  var doubleByteCharCount = 0,
		    commonCharCount     = 0,
		    badCharCount        = 0,
		    totalCharCount      = 0,
		    confidence          = 0;

		  var iter = new IteratedChar();

		  detectBlock: {
		    for (iter.reset(); this.nextChar(iter, det);) {
		      totalCharCount++;
		      if (iter.error) {
		        badCharCount++;
		      } else {
		        var cv = iter.charValue & 0xFFFFFFFF;

		        if (cv <= 0xff) ; else {
		          doubleByteCharCount++;
		          if (this.commonChars != null) {
		            // NOTE: This assumes that there are no 4-byte common chars.
		            if (binarySearch(this.commonChars, cv) >= 0) {
		              commonCharCount++;
		            }
		          }
		        }
		      }
		      if (badCharCount >= 2 && badCharCount * 5 >= doubleByteCharCount) {
		        // console.log('its here!')
		        // Bail out early if the byte data is not matching the encoding scheme.
		        break detectBlock;
		      }
		    }

		    if (doubleByteCharCount <= 10 && badCharCount== 0) {
		      // Not many multi-byte chars.
		      if (doubleByteCharCount == 0 && totalCharCount < 10) {
		        // There weren't any multibyte sequences, and there was a low density of non-ASCII single bytes.
		        // We don't have enough data to have any confidence.
		        // Statistical analysis of single byte non-ASCII charcters would probably help here.
		        confidence = 0;
		      }
		      else {
		        //   ASCII or ISO file?  It's probably not our encoding,
		        //   but is not incompatible with our encoding, so don't give it a zero.
		        confidence = 10;
		      }
		      break detectBlock;
		    }

		    //
		    //  No match if there are too many characters that don't fit the encoding scheme.
		    //    (should we have zero tolerance for these?)
		    //
		    if (doubleByteCharCount < 20 * badCharCount) {
		      confidence = 0;
		      break detectBlock;
		    }

		    if (this.commonChars == null) {
		      // We have no statistics on frequently occuring characters.
		      //  Assess confidence purely on having a reasonable number of
		      //  multi-byte characters (the more the better
		      confidence = 30 + doubleByteCharCount - 20 * badCharCount;
		      if (confidence > 100) {
		        confidence = 100;
		      }
		    } else {
		      //
		      // Frequency of occurence statistics exist.
		      //
		      var maxVal = Math.log(parseFloat(doubleByteCharCount) / 4);
		      var scaleFactor = 90.0 / maxVal;
		      confidence = Math.floor(Math.log(commonCharCount + 1) * scaleFactor + 10);
		      confidence = Math.min(confidence, 100);
		    }
		  }   // end of detectBlock:

		  return confidence == 0 ? null : new Match(det, this, confidence);
		};

		/**
		 * Get the next character (however many bytes it is) from the input data
		 *    Subclasses for specific charset encodings must implement this function
		 *    to get characters according to the rules of their encoding scheme.
		 *
		 *  This function is not a method of class iteratedChar only because
		 *   that would require a lot of extra derived classes, which is awkward.
		 * @param it  The iteratedChar 'struct' into which the returned char is placed.
		 * @param det The charset detector, which is needed to get at the input byte data
		 *            being iterated over.
		 * @return    True if a character was returned, false at end of input.
		 */

		mbcs.prototype.nextChar = function(iter, det) {};



		/**
		 * Shift-JIS charset recognizer.
		 */
		module.exports.sjis = function() {
		  this.name = function() {
		    return 'Shift-JIS';
		  };
		  this.language = function() {
		    return 'ja';
		  };

		  // TODO:  This set of data comes from the character frequency-
		  //        of-occurence analysis tool.  The data needs to be moved
		  //        into a resource and loaded from there.
		  this.commonChars = [
		    0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0,
		    0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5,
		    0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc,
		    0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341,
		    0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389,
		    0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa
		  ];

		  this.nextChar = function(iter, det) {
		    iter.index = iter.nextIndex;
		    iter.error = false;

		    var firstByte;
		    firstByte = iter.charValue = iter.nextByte(det);
		    if (firstByte < 0)
		      return false;

		    if (firstByte <= 0x7f || (firstByte > 0xa0 && firstByte <= 0xdf))
		      return true;

		    var secondByte = iter.nextByte(det);
		    if (secondByte < 0)
		      return false;

		    iter.charValue = (firstByte << 8) | secondByte;
		    if (! ((secondByte >= 0x40 && secondByte <= 0x7f) || (secondByte >= 0x80 && secondByte <= 0xff))) {
		      // Illegal second byte value.
		      iter.error = true;
		    }
		    return true;
		  };
		};
		util.inherits(module.exports.sjis, mbcs);



		/**
		 *   Big5 charset recognizer.
		 */
		module.exports.big5 = function() {
		  this.name = function() {
		    return 'Big5';
		  };
		  this.language = function() {
		    return 'zh';
		  };
		  // TODO:  This set of data comes from the character frequency-
		  //        of-occurence analysis tool.  The data needs to be moved
		  //        into a resource and loaded from there.
		  this.commonChars = [
		    0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446,
		    0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3,
		    0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548,
		    0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8,
		    0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da,
		    0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3,
		    0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59,
		    0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c,
		    0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44,
		    0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f
		  ];
		  this.nextChar = function(iter, det) {
		    iter.index = iter.nextIndex;
		    iter.error = false;

		    var firstByte = iter.charValue = iter.nextByte(det);

		    if (firstByte < 0)
		      return false;

		    // single byte character.
		    if (firstByte <= 0x7f || firstByte == 0xff)
		      return true;

		    var secondByte = iter.nextByte(det);

		    if (secondByte < 0)
		      return false;

		    iter.charValue = (iter.charValue << 8) | secondByte;

		    if (secondByte < 0x40 || secondByte == 0x7f || secondByte == 0xff)
		      iter.error = true;

		    return true;
		  };
		};
		util.inherits(module.exports.big5, mbcs);



		/**
		 *  EUC charset recognizers.  One abstract class that provides the common function
		 *  for getting the next character according to the EUC encoding scheme,
		 *  and nested derived classes for EUC_KR, EUC_JP, EUC_CN.
		 *
		 *  Get the next character value for EUC based encodings.
		 *  Character 'value' is simply the raw bytes that make up the character
		 *     packed into an int.
		 */
		function eucNextChar(iter, det) {
		  iter.index = iter.nextIndex;
		  iter.error = false;
		  var firstByte  = 0;
		  var secondByte = 0;
		  var thirdByte  = 0;
		  //int fourthByte = 0;
		  buildChar: {
		    firstByte = iter.charValue = iter.nextByte(det);
		    if (firstByte < 0) {
		      // Ran off the end of the input data
		      iter.done = true;
		      break buildChar;
		    }
		    if (firstByte <= 0x8d) {
		      // single byte char
		      break buildChar;
		    }
		    secondByte = iter.nextByte(det);
		    iter.charValue = (iter.charValue << 8) | secondByte;
		    if (firstByte >= 0xA1 && firstByte <= 0xfe) {
		      // Two byte Char
		      if (secondByte < 0xa1) {
		        iter.error = true;
		      }
		      break buildChar;
		    }
		    if (firstByte == 0x8e) {
		      // Code Set 2.
		      //   In EUC-JP, total char size is 2 bytes, only one byte of actual char value.
		      //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.
		      // We don't know which we've got.
		      // Treat it like EUC-JP.  If the data really was EUC-TW, the following two
		      //   bytes will look like a well formed 2 byte char.
		      if (secondByte < 0xa1) {
		        iter.error = true;
		      }
		      break buildChar;
		    }
		    if (firstByte == 0x8f) {
		      // Code set 3.
		      // Three byte total char size, two bytes of actual char value.
		      thirdByte = iter.nextByte(det);
		      iter.charValue = (iter.charValue << 8) | thirdByte;
		      if (thirdByte < 0xa1) {
		        iter.error = true;
		      }
		    }
		  }
		  return iter.done == false;
		}


		/**
		 * The charset recognize for EUC-JP.  A singleton instance of this class
		 *    is created and kept by the public CharsetDetector class
		 */
		module.exports.euc_jp = function() {
		  this.name = function() {
		    return 'EUC-JP';
		  };
		  this.language = function() {
		    return 'ja';
		  };

		  // TODO:  This set of data comes from the character frequency-
		  //        of-occurence analysis tool.  The data needs to be moved
		  //        into a resource and loaded from there.
		  this.commonChars = [
		    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2,
		    0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3,
		    0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4,
		    0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de,
		    0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef,
		    0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af,
		    0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7,
		    0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1,
		    0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee,
		    0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1
		  ];

		  this.nextChar = eucNextChar;
		};
		util.inherits(module.exports.euc_jp, mbcs);



		/**
		 * The charset recognize for EUC-KR.  A singleton instance of this class
		 *    is created and kept by the public CharsetDetector class
		 */
		module.exports.euc_kr = function() {
		  this.name = function() {
		    return 'EUC-KR';
		  };
		  this.language = function() {
		    return 'ko';
		  };

		  // TODO:  This set of data comes from the character frequency-
		  //        of-occurence analysis tool.  The data needs to be moved
		  //        into a resource and loaded from there.
		  this.commonChars = [
		    0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc,
		    0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9,
		    0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce,
		    0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce,
		    0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba,
		    0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee,
		    0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7,
		    0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6,
		    0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6,
		    0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad
		  ];

		  this.nextChar = eucNextChar;
		};
		util.inherits(module.exports.euc_kr, mbcs);



		/**
		 *   GB-18030 recognizer. Uses simplified Chinese statistics.
		 */
		module.exports.gb_18030 = function() {
		  this.name = function() {
		    return 'GB18030';
		  };
		  this.language = function() {
		    return 'zh';
		  };

		  /*
		   *  Get the next character value for EUC based encodings.
		   *  Character 'value' is simply the raw bytes that make up the character
		   *     packed into an int.
		   */
		  this.nextChar = function(iter, det) {
		    iter.index = iter.nextIndex;
		    iter.error = false;
		    var firstByte  = 0;
		    var secondByte = 0;
		    var thirdByte  = 0;
		    var fourthByte = 0;
		    buildChar: {
		      firstByte = iter.charValue = iter.nextByte(det);
		      if (firstByte < 0) {
		        // Ran off the end of the input data
		        iter.done = true;
		        break buildChar;
		      }
		      if (firstByte <= 0x80) {
		        // single byte char
		        break buildChar;
		      }
		      secondByte = iter.nextByte(det);
		      iter.charValue = (iter.charValue << 8) | secondByte;
		      if (firstByte >= 0x81 && firstByte <= 0xFE) {
		        // Two byte Char
		        if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >=80 && secondByte <= 0xFE)) {
		          break buildChar;
		        }
		        // Four byte char
		        if (secondByte >= 0x30 && secondByte <= 0x39) {
		          thirdByte = iter.nextByte(det);
		          if (thirdByte >= 0x81 && thirdByte <= 0xFE) {
		            fourthByte = iter.nextByte(det);
		            if (fourthByte >= 0x30 && fourthByte <= 0x39) {
		              iter.charValue = (iter.charValue << 16) | (thirdByte << 8) | fourthByte;
		              break buildChar;
		            }
		          }
		        }
		        iter.error = true;
		        break buildChar;
		      }
		    }
		    return iter.done == false;
		  };

		  // TODO:  This set of data comes from the character frequency-
		  //        of-occurence analysis tool.  The data needs to be moved
		  //        into a resource and loaded from there.
		  this.commonChars = [
		    0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac,
		    0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4,
		    0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4,
		    0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6,
		    0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6,
		    0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7,
		    0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7,
		    0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5,
		    0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2,
		    0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0
		  ];
		};
		util.inherits(module.exports.gb_18030, mbcs); 
	} (mbcs));
	return mbcs.exports;
}

var sbcs = {exports: {}};

var hasRequiredSbcs;

function requireSbcs () {
	if (hasRequiredSbcs) return sbcs.exports;
	hasRequiredSbcs = 1;
	(function (module) {
		var util = require$$0$d,
		  Match = requireMatch();

		/**
		 * This class recognizes single-byte encodings. Because the encoding scheme is so
		 * simple, language statistics are used to do the matching.
		 */

		function NGramParser(theNgramList, theByteMap) {
		  var N_GRAM_MASK = 0xFFFFFF;

		  this.byteIndex = 0;
		  this.ngram = 0;

		  this.ngramList = theNgramList;
		  this.byteMap = theByteMap;

		  this.ngramCount = 0;
		  this.hitCount = 0;

		  this.spaceChar;

		  /*
		   * Binary search for value in table, which must have exactly 64 entries.
		   */
		  this.search = function(table, value) {
		    var index = 0;

		    if (table[index + 32] <= value) index += 32;
		    if (table[index + 16] <= value) index += 16;
		    if (table[index + 8]  <= value) index += 8;
		    if (table[index + 4]  <= value) index += 4;
		    if (table[index + 2]  <= value) index += 2;
		    if (table[index + 1]  <= value) index += 1;
		    if (table[index]      > value)  index -= 1;

		    if (index < 0 || table[index] != value)
		      return -1;

		    return index;
		  };

		  this.lookup = function(thisNgram) {
		    this.ngramCount += 1;
		    if (this.search(this.ngramList, thisNgram) >= 0) {
		      this.hitCount += 1;
		    }
		  };

		  this.addByte = function(b) {
		    this.ngram = ((this.ngram << 8) + (b & 0xFF)) & N_GRAM_MASK;
		    this.lookup(this.ngram);
		  };

		  this.nextByte = function(det) {
		    if (this.byteIndex >= det.fInputLen)
		      return -1;

		    return det.fInputBytes[this.byteIndex++] & 0xFF;
		  };

		  this.parse = function(det, spaceCh) {
		    var b, ignoreSpace = false;
		    this.spaceChar = spaceCh;

		    while ((b = this.nextByte(det)) >= 0) {
		      var mb = this.byteMap[b];

		      // TODO: 0x20 might not be a space in all character sets...
		      if (mb != 0) {
		        if (!(mb == this.spaceChar && ignoreSpace)) {
		          this.addByte(mb);
		        }

		        ignoreSpace = (mb == this.spaceChar);
		      }
		    }

		    // TODO: Is this OK? The buffer could have ended in the middle of a word...
		    this.addByte(this.spaceChar);

		    var rawPercent = this.hitCount / this.ngramCount;

		    // TODO - This is a bit of a hack to take care of a case
		    // were we were getting a confidence of 135...
		    if (rawPercent > 0.33)
		      return 98;

		    return Math.floor(rawPercent * 300.0);
		  };
		}
		function NGramsPlusLang(la, ng) {
		  this.fLang = la;
		  this.fNGrams = ng;
		}
		function sbcs() {}		sbcs.prototype.spaceChar = 0x20;
		sbcs.prototype.ngrams = function() {};
		sbcs.prototype.byteMap = function() {};
		sbcs.prototype.match = function(det) {

		  var ngrams = this.ngrams();
		  var multiple = (Array.isArray(ngrams) && ngrams[0] instanceof NGramsPlusLang);

		  if (!multiple) {
		    var parser = new NGramParser(ngrams, this.byteMap());
		    var confidence = parser.parse(det, this.spaceChar);
		    return confidence <= 0 ? null : new Match(det, this, confidence);
		  }

		  var bestConfidenceSoFar = -1;
		  var lang = null;

		  for (var i = ngrams.length - 1; i >= 0; i--) {
		    var ngl = ngrams[i];

		    var parser = new NGramParser(ngl.fNGrams, this.byteMap());
		    var confidence = parser.parse(det, this.spaceChar);
		    if (confidence > bestConfidenceSoFar) {
		      bestConfidenceSoFar = confidence;
		      lang = ngl.fLang;
		    }
		  }

		  var name = this.name(det);
		  return bestConfidenceSoFar <= 0 ? null : new Match(det, this, bestConfidenceSoFar, name, lang);
		};


		module.exports.ISO_8859_1 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
		      0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      new NGramsPlusLang('da', [
		        0x206166, 0x206174, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920,
		        0x206D65, 0x206F67, 0x2070E5, 0x207369, 0x207374, 0x207469, 0x207669, 0x616620,
		        0x616E20, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646572, 0x646574,
		        0x652073, 0x656420, 0x656465, 0x656E20, 0x656E64, 0x657220, 0x657265, 0x657320,
		        0x657420, 0x666F72, 0x676520, 0x67656E, 0x676572, 0x696765, 0x696C20, 0x696E67,
		        0x6B6520, 0x6B6B65, 0x6C6572, 0x6C6967, 0x6C6C65, 0x6D6564, 0x6E6465, 0x6E6520,
		        0x6E6720, 0x6E6765, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722064, 0x722065,
		        0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696C, 0x766572
		      ]),
		      new NGramsPlusLang('de', [
		        0x20616E, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569, 0x206765,
		        0x206861, 0x20696E, 0x206D69, 0x207363, 0x207365, 0x20756E, 0x207665, 0x20766F,
		        0x207765, 0x207A75, 0x626572, 0x636820, 0x636865, 0x636874, 0x646173, 0x64656E,
		        0x646572, 0x646965, 0x652064, 0x652073, 0x65696E, 0x656974, 0x656E20, 0x657220,
		        0x657320, 0x67656E, 0x68656E, 0x687420, 0x696368, 0x696520, 0x696E20, 0x696E65,
		        0x697420, 0x6C6963, 0x6C6C65, 0x6E2061, 0x6E2064, 0x6E2073, 0x6E6420, 0x6E6465,
		        0x6E6520, 0x6E6720, 0x6E6765, 0x6E7465, 0x722064, 0x726465, 0x726569, 0x736368,
		        0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x756E64, 0x756E67, 0x766572
		      ]),
		      new NGramsPlusLang('en', [
		        0x206120, 0x20616E, 0x206265, 0x20636F, 0x20666F, 0x206861, 0x206865, 0x20696E,
		        0x206D61, 0x206F66, 0x207072, 0x207265, 0x207361, 0x207374, 0x207468, 0x20746F,
		        0x207768, 0x616964, 0x616C20, 0x616E20, 0x616E64, 0x617320, 0x617420, 0x617465,
		        0x617469, 0x642061, 0x642074, 0x652061, 0x652073, 0x652074, 0x656420, 0x656E74,
		        0x657220, 0x657320, 0x666F72, 0x686174, 0x686520, 0x686572, 0x696420, 0x696E20,
		        0x696E67, 0x696F6E, 0x697320, 0x6E2061, 0x6E2074, 0x6E6420, 0x6E6720, 0x6E7420,
		        0x6F6620, 0x6F6E20, 0x6F7220, 0x726520, 0x727320, 0x732061, 0x732074, 0x736169,
		        0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696F, 0x746F20, 0x747320
		      ]),
		      new NGramsPlusLang('es', [
		        0x206120, 0x206361, 0x20636F, 0x206465, 0x20656C, 0x20656E, 0x206573, 0x20696E,
		        0x206C61, 0x206C6F, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,
		        0x20756E, 0x207920, 0x612063, 0x612064, 0x612065, 0x61206C, 0x612070, 0x616369,
		        0x61646F, 0x616C20, 0x617220, 0x617320, 0x6369F3, 0x636F6E, 0x646520, 0x64656C,
		        0x646F20, 0x652064, 0x652065, 0x65206C, 0x656C20, 0x656E20, 0x656E74, 0x657320,
		        0x657374, 0x69656E, 0x69F36E, 0x6C6120, 0x6C6F73, 0x6E2065, 0x6E7465, 0x6F2064,
		        0x6F2065, 0x6F6E20, 0x6F7220, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573,
		        0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746F20, 0x756520, 0xF36E20
		      ]),
		      new NGramsPlusLang('fr', [
		        0x206175, 0x20636F, 0x206461, 0x206465, 0x206475, 0x20656E, 0x206574, 0x206C61,
		        0x206C65, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207365, 0x20736F, 0x20756E,
		        0x20E020, 0x616E74, 0x617469, 0x636520, 0x636F6E, 0x646520, 0x646573, 0x647520,
		        0x652061, 0x652063, 0x652064, 0x652065, 0x65206C, 0x652070, 0x652073, 0x656E20,
		        0x656E74, 0x657220, 0x657320, 0x657420, 0x657572, 0x696F6E, 0x697320, 0x697420,
		        0x6C6120, 0x6C6520, 0x6C6573, 0x6D656E, 0x6E2064, 0x6E6520, 0x6E7320, 0x6E7420,
		        0x6F6E20, 0x6F6E74, 0x6F7572, 0x717565, 0x72206C, 0x726520, 0x732061, 0x732064,
		        0x732065, 0x73206C, 0x732070, 0x742064, 0x746520, 0x74696F, 0x756520, 0x757220
		      ]),
		      new NGramsPlusLang('it', [
		        0x20616C, 0x206368, 0x20636F, 0x206465, 0x206469, 0x206520, 0x20696C, 0x20696E,
		        0x206C61, 0x207065, 0x207072, 0x20756E, 0x612063, 0x612064, 0x612070, 0x612073,
		        0x61746F, 0x636865, 0x636F6E, 0x64656C, 0x646920, 0x652061, 0x652063, 0x652064,
		        0x652069, 0x65206C, 0x652070, 0x652073, 0x656C20, 0x656C6C, 0x656E74, 0x657220,
		        0x686520, 0x692061, 0x692063, 0x692064, 0x692073, 0x696120, 0x696C20, 0x696E20,
		        0x696F6E, 0x6C6120, 0x6C6520, 0x6C6920, 0x6C6C61, 0x6E6520, 0x6E6920, 0x6E6F20,
		        0x6E7465, 0x6F2061, 0x6F2064, 0x6F2069, 0x6F2073, 0x6F6E20, 0x6F6E65, 0x706572,
		        0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746F20, 0x7A696F
		      ]),
		      new NGramsPlusLang('nl', [
		        0x20616C, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656E, 0x206765,
		        0x206865, 0x20696E, 0x206D61, 0x206D65, 0x206F70, 0x207465, 0x207661, 0x207665,
		        0x20766F, 0x207765, 0x207A69, 0x61616E, 0x616172, 0x616E20, 0x616E64, 0x617220,
		        0x617420, 0x636874, 0x646520, 0x64656E, 0x646572, 0x652062, 0x652076, 0x65656E,
		        0x656572, 0x656E20, 0x657220, 0x657273, 0x657420, 0x67656E, 0x686574, 0x696520,
		        0x696E20, 0x696E67, 0x697320, 0x6E2062, 0x6E2064, 0x6E2065, 0x6E2068, 0x6E206F,
		        0x6E2076, 0x6E6465, 0x6E6720, 0x6F6E64, 0x6F6F72, 0x6F7020, 0x6F7220, 0x736368,
		        0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x76616E, 0x766572, 0x766F6F
		      ]),
		      new NGramsPlusLang('no', [
		        0x206174, 0x206176, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920,
		        0x206D65, 0x206F67, 0x2070E5, 0x207365, 0x20736B, 0x20736F, 0x207374, 0x207469,
		        0x207669, 0x20E520, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646574,
		        0x652073, 0x656420, 0x656E20, 0x656E65, 0x657220, 0x657265, 0x657420, 0x657474,
		        0x666F72, 0x67656E, 0x696B6B, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6520,
		        0x6C6C65, 0x6D6564, 0x6D656E, 0x6E2073, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E6E65,
		        0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722073, 0x726520, 0x736F6D, 0x737465,
		        0x742073, 0x746520, 0x74656E, 0x746572, 0x74696C, 0x747420, 0x747465, 0x766572
		      ]),
		      new NGramsPlusLang('pt', [
		        0x206120, 0x20636F, 0x206461, 0x206465, 0x20646F, 0x206520, 0x206573, 0x206D61,
		        0x206E6F, 0x206F20, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,
		        0x20756D, 0x612061, 0x612063, 0x612064, 0x612070, 0x616465, 0x61646F, 0x616C20,
		        0x617220, 0x617261, 0x617320, 0x636F6D, 0x636F6E, 0x646120, 0x646520, 0x646F20,
		        0x646F73, 0x652061, 0x652064, 0x656D20, 0x656E74, 0x657320, 0x657374, 0x696120,
		        0x696361, 0x6D656E, 0x6E7465, 0x6E746F, 0x6F2061, 0x6F2063, 0x6F2064, 0x6F2065,
		        0x6F2070, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061, 0x732064,
		        0x732065, 0x732070, 0x737461, 0x746520, 0x746F20, 0x756520, 0xE36F20, 0xE7E36F
		      ]),
		      new NGramsPlusLang('sv', [
		        0x206174, 0x206176, 0x206465, 0x20656E, 0x2066F6, 0x206861, 0x206920, 0x20696E,
		        0x206B6F, 0x206D65, 0x206F63, 0x2070E5, 0x20736B, 0x20736F, 0x207374, 0x207469,
		        0x207661, 0x207669, 0x20E472, 0x616465, 0x616E20, 0x616E64, 0x617220, 0x617474,
		        0x636820, 0x646520, 0x64656E, 0x646572, 0x646574, 0x656420, 0x656E20, 0x657220,
		        0x657420, 0x66F672, 0x67656E, 0x696C6C, 0x696E67, 0x6B6120, 0x6C6C20, 0x6D6564,
		        0x6E2073, 0x6E6120, 0x6E6465, 0x6E6720, 0x6E6765, 0x6E696E, 0x6F6368, 0x6F6D20,
		        0x6F6E20, 0x70E520, 0x722061, 0x722073, 0x726120, 0x736B61, 0x736F6D, 0x742073,
		        0x746120, 0x746520, 0x746572, 0x74696C, 0x747420, 0x766172, 0xE47220, 0xF67220,
		      ])
		    ];
		  };

		  this.name = function(det) {
		    return (det && det.fC1Bytes) ? 'windows-1252' : 'ISO-8859-1';
		  };
		};
		util.inherits(module.exports.ISO_8859_1, sbcs);


		module.exports.ISO_8859_2 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0x20,
		      0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF,
		      0x20, 0xB1, 0x20, 0xB3, 0x20, 0xB5, 0xB6, 0xB7,
		      0x20, 0xB9, 0xBA, 0xBB, 0xBC, 0x20, 0xBE, 0xBF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      new NGramsPlusLang('cs', [
		        0x206120, 0x206279, 0x20646F, 0x206A65, 0x206E61, 0x206E65, 0x206F20, 0x206F64,
		        0x20706F, 0x207072, 0x2070F8, 0x20726F, 0x207365, 0x20736F, 0x207374, 0x20746F,
		        0x207620, 0x207679, 0x207A61, 0x612070, 0x636520, 0x636820, 0x652070, 0x652073,
		        0x652076, 0x656D20, 0x656EED, 0x686F20, 0x686F64, 0x697374, 0x6A6520, 0x6B7465,
		        0x6C6520, 0x6C6920, 0x6E6120, 0x6EE920, 0x6EEC20, 0x6EED20, 0x6F2070, 0x6F646E,
		        0x6F6A69, 0x6F7374, 0x6F7520, 0x6F7661, 0x706F64, 0x706F6A, 0x70726F, 0x70F865,
		        0x736520, 0x736F75, 0x737461, 0x737469, 0x73746E, 0x746572, 0x746EED, 0x746F20,
		        0x752070, 0xBE6520, 0xE16EED, 0xE9686F, 0xED2070, 0xED2073, 0xED6D20, 0xF86564,
		      ]),
		      new NGramsPlusLang('hu', [
		        0x206120, 0x20617A, 0x206265, 0x206567, 0x20656C, 0x206665, 0x206861, 0x20686F,
		        0x206973, 0x206B65, 0x206B69, 0x206BF6, 0x206C65, 0x206D61, 0x206D65, 0x206D69,
		        0x206E65, 0x20737A, 0x207465, 0x20E973, 0x612061, 0x61206B, 0x61206D, 0x612073,
		        0x616B20, 0x616E20, 0x617A20, 0x62616E, 0x62656E, 0x656779, 0x656B20, 0x656C20,
		        0x656C65, 0x656D20, 0x656E20, 0x657265, 0x657420, 0x657465, 0x657474, 0x677920,
		        0x686F67, 0x696E74, 0x697320, 0x6B2061, 0x6BF67A, 0x6D6567, 0x6D696E, 0x6E2061,
		        0x6E616B, 0x6E656B, 0x6E656D, 0x6E7420, 0x6F6779, 0x732061, 0x737A65, 0x737A74,
		        0x737AE1, 0x73E967, 0x742061, 0x747420, 0x74E173, 0x7A6572, 0xE16E20, 0xE97320,
		      ]),
		      new NGramsPlusLang('pl', [
		        0x20637A, 0x20646F, 0x206920, 0x206A65, 0x206B6F, 0x206D61, 0x206D69, 0x206E61,
		        0x206E69, 0x206F64, 0x20706F, 0x207072, 0x207369, 0x207720, 0x207769, 0x207779,
		        0x207A20, 0x207A61, 0x612070, 0x612077, 0x616E69, 0x636820, 0x637A65, 0x637A79,
		        0x646F20, 0x647A69, 0x652070, 0x652073, 0x652077, 0x65207A, 0x65676F, 0x656A20,
		        0x656D20, 0x656E69, 0x676F20, 0x696120, 0x696520, 0x69656A, 0x6B6120, 0x6B6920,
		        0x6B6965, 0x6D6965, 0x6E6120, 0x6E6961, 0x6E6965, 0x6F2070, 0x6F7761, 0x6F7769,
		        0x706F6C, 0x707261, 0x70726F, 0x70727A, 0x727A65, 0x727A79, 0x7369EA, 0x736B69,
		        0x737461, 0x776965, 0x796368, 0x796D20, 0x7A6520, 0x7A6965, 0x7A7920, 0xF37720,
		      ]),
		      new NGramsPlusLang('ro', [
		        0x206120, 0x206163, 0x206361, 0x206365, 0x20636F, 0x206375, 0x206465, 0x206469,
		        0x206C61, 0x206D61, 0x207065, 0x207072, 0x207365, 0x2073E3, 0x20756E, 0x20BA69,
		        0x20EE6E, 0x612063, 0x612064, 0x617265, 0x617420, 0x617465, 0x617520, 0x636172,
		        0x636F6E, 0x637520, 0x63E320, 0x646520, 0x652061, 0x652063, 0x652064, 0x652070,
		        0x652073, 0x656120, 0x656920, 0x656C65, 0x656E74, 0x657374, 0x692061, 0x692063,
		        0x692064, 0x692070, 0x696520, 0x696920, 0x696E20, 0x6C6120, 0x6C6520, 0x6C6F72,
		        0x6C7569, 0x6E6520, 0x6E7472, 0x6F7220, 0x70656E, 0x726520, 0x726561, 0x727520,
		        0x73E320, 0x746520, 0x747275, 0x74E320, 0x756920, 0x756C20, 0xBA6920, 0xEE6E20,
		      ])
		    ];
		  };

		  this.name = function(det) {
		    return (det && det.fC1Bytes) ? 'windows-1250' : 'ISO-8859-2';
		  };
		};
		util.inherits(module.exports.ISO_8859_2, sbcs);


		module.exports.ISO_8859_5 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
		      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
		      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0x20, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x20, 0xFE, 0xFF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20D220, 0x20D2DE, 0x20D4DE, 0x20D7D0, 0x20D820, 0x20DAD0, 0x20DADE, 0x20DDD0,
		      0x20DDD5, 0x20DED1, 0x20DFDE, 0x20DFE0, 0x20E0D0, 0x20E1DE, 0x20E1E2, 0x20E2DE,
		      0x20E7E2, 0x20EDE2, 0xD0DDD8, 0xD0E2EC, 0xD3DE20, 0xD5DBEC, 0xD5DDD8, 0xD5E1E2,
		      0xD5E220, 0xD820DF, 0xD8D520, 0xD8D820, 0xD8EF20, 0xDBD5DD, 0xDBD820, 0xDBECDD,
		      0xDDD020, 0xDDD520, 0xDDD8D5, 0xDDD8EF, 0xDDDE20, 0xDDDED2, 0xDE20D2, 0xDE20DF,
		      0xDE20E1, 0xDED220, 0xDED2D0, 0xDED3DE, 0xDED920, 0xDEDBEC, 0xDEDC20, 0xDEE1E2,
		      0xDFDEDB, 0xDFE0D5, 0xDFE0D8, 0xDFE0DE, 0xE0D0D2, 0xE0D5D4, 0xE1E2D0, 0xE1E2D2,
		      0xE1E2D8, 0xE1EF20, 0xE2D5DB, 0xE2DE20, 0xE2DEE0, 0xE2EC20, 0xE7E2DE, 0xEBE520
		    ];
		  };

		  this.name = function(det) {
		    return 'ISO-8859-5';
		  };

		  this.language = function() {
		    return 'ru';
		  };
		};
		util.inherits(module.exports.ISO_8859_5, sbcs);


		module.exports.ISO_8859_6 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
		      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
		      0xD8, 0xD9, 0xDA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20C7E4, 0x20C7E6, 0x20C8C7, 0x20D9E4, 0x20E1EA, 0x20E4E4, 0x20E5E6, 0x20E8C7,
		      0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E420, 0xC7E4C3, 0xC7E4C7, 0xC7E4C8,
		      0xC7E4CA, 0xC7E4CC, 0xC7E4CD, 0xC7E4CF, 0xC7E4D3, 0xC7E4D9, 0xC7E4E2, 0xC7E4E5,
		      0xC7E4E8, 0xC7E4EA, 0xC7E520, 0xC7E620, 0xC7E6CA, 0xC820C7, 0xC920C7, 0xC920E1,
		      0xC920E4, 0xC920E5, 0xC920E8, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920,
		      0xD320C7, 0xD920C7, 0xD9E4E9, 0xE1EA20, 0xE420C7, 0xE4C920, 0xE4E920, 0xE4EA20,
		      0xE520C7, 0xE5C720, 0xE5C920, 0xE5E620, 0xE620C7, 0xE720C7, 0xE7C720, 0xE8C7E4,
		      0xE8E620, 0xE920C7, 0xEA20C7, 0xEA20E5, 0xEA20E8, 0xEAC920, 0xEAD120, 0xEAE620
		    ];
		  };

		  this.name = function(det) {
		    return 'ISO-8859-6';
		  };

		  this.language = function() {
		    return 'ar';
		  };
		};
		util.inherits(module.exports.ISO_8859_6, sbcs);


		module.exports.ISO_8859_7 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0xA1, 0xA2, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDC, 0x20,
		      0xDD, 0xDE, 0xDF, 0x20, 0xFC, 0x20, 0xFD, 0xFE,
		      0xC0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0x20, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xDC, 0xDD, 0xDE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x20
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20E1ED, 0x20E1F0, 0x20E3E9, 0x20E4E9, 0x20E5F0, 0x20E720, 0x20EAE1, 0x20ECE5,
		      0x20EDE1, 0x20EF20, 0x20F0E1, 0x20F0EF, 0x20F0F1, 0x20F3F4, 0x20F3F5, 0x20F4E7,
		      0x20F4EF, 0xDFE120, 0xE120E1, 0xE120F4, 0xE1E920, 0xE1ED20, 0xE1F0FC, 0xE1F220,
		      0xE3E9E1, 0xE5E920, 0xE5F220, 0xE720F4, 0xE7ED20, 0xE7F220, 0xE920F4, 0xE9E120,
		      0xE9EADE, 0xE9F220, 0xEAE1E9, 0xEAE1F4, 0xECE520, 0xED20E1, 0xED20E5, 0xED20F0,
		      0xEDE120, 0xEFF220, 0xEFF520, 0xF0EFF5, 0xF0F1EF, 0xF0FC20, 0xF220E1, 0xF220E5,
		      0xF220EA, 0xF220F0, 0xF220F4, 0xF3E520, 0xF3E720, 0xF3F4EF, 0xF4E120, 0xF4E1E9,
		      0xF4E7ED, 0xF4E7F2, 0xF4E9EA, 0xF4EF20, 0xF4EFF5, 0xF4F9ED, 0xF9ED20, 0xFEED20
		    ];
		  };

		  this.name = function(det) {
		    return (det && det.fC1Bytes) ? 'windows-1253' : 'ISO-8859-7';
		  };

		  this.language = function() {
		    return 'el';
		  };
		};
		util.inherits(module.exports.ISO_8859_7, sbcs);

		module.exports.ISO_8859_8 = function() {

		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0x20, 0x20, 0x20, 0x20, 0x20
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      new NGramsPlusLang('he', [
		        0x20E0E5, 0x20E0E7, 0x20E0E9, 0x20E0FA, 0x20E1E9, 0x20E1EE, 0x20E4E0, 0x20E4E5,
		        0x20E4E9, 0x20E4EE, 0x20E4F2, 0x20E4F9, 0x20E4FA, 0x20ECE0, 0x20ECE4, 0x20EEE0,
		        0x20F2EC, 0x20F9EC, 0xE0FA20, 0xE420E0, 0xE420E1, 0xE420E4, 0xE420EC, 0xE420EE,
		        0xE420F9, 0xE4E5E0, 0xE5E020, 0xE5ED20, 0xE5EF20, 0xE5F820, 0xE5FA20, 0xE920E4,
		        0xE9E420, 0xE9E5FA, 0xE9E9ED, 0xE9ED20, 0xE9EF20, 0xE9F820, 0xE9FA20, 0xEC20E0,
		        0xEC20E4, 0xECE020, 0xECE420, 0xED20E0, 0xED20E1, 0xED20E4, 0xED20EC, 0xED20EE,
		        0xED20F9, 0xEEE420, 0xEF20E4, 0xF0E420, 0xF0E920, 0xF0E9ED, 0xF2EC20, 0xF820E4,
		        0xF8E9ED, 0xF9EC20, 0xFA20E0, 0xFA20E1, 0xFA20E4, 0xFA20EC, 0xFA20EE, 0xFA20F9,
		      ]),
		      new NGramsPlusLang('he', [
		        0x20E0E5, 0x20E0EC, 0x20E4E9, 0x20E4EC, 0x20E4EE, 0x20E4F0, 0x20E9F0, 0x20ECF2,
		        0x20ECF9, 0x20EDE5, 0x20EDE9, 0x20EFE5, 0x20EFE9, 0x20F8E5, 0x20F8E9, 0x20FAE0,
		        0x20FAE5, 0x20FAE9, 0xE020E4, 0xE020EC, 0xE020ED, 0xE020FA, 0xE0E420, 0xE0E5E4,
		        0xE0EC20, 0xE0EE20, 0xE120E4, 0xE120ED, 0xE120FA, 0xE420E4, 0xE420E9, 0xE420EC,
		        0xE420ED, 0xE420EF, 0xE420F8, 0xE420FA, 0xE4EC20, 0xE5E020, 0xE5E420, 0xE7E020,
		        0xE9E020, 0xE9E120, 0xE9E420, 0xEC20E4, 0xEC20ED, 0xEC20FA, 0xECF220, 0xECF920,
		        0xEDE9E9, 0xEDE9F0, 0xEDE9F8, 0xEE20E4, 0xEE20ED, 0xEE20FA, 0xEEE120, 0xEEE420,
		        0xF2E420, 0xF920E4, 0xF920ED, 0xF920FA, 0xF9E420, 0xFAE020, 0xFAE420, 0xFAE5E9,
		      ])
		    ];
		  };

		  this.name = function(det) {
		    return (det && det.fC1Bytes) ? 'windows-1255' : 'ISO-8859-8';
		  };

		  this.language = function() {
		    return 'he';
		  };

		};
		util.inherits(module.exports.ISO_8859_8, sbcs);


		module.exports.ISO_8859_9 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
		      0x20, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0x69, 0xFE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0x20,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861, 0x20696C,
		      0x206B61, 0x206B6F, 0x206D61, 0x206F6C, 0x207361, 0x207461, 0x207665, 0x207961,
		      0x612062, 0x616B20, 0x616C61, 0x616D61, 0x616E20, 0x616EFD, 0x617220, 0x617261,
		      0x6172FD, 0x6173FD, 0x617961, 0x626972, 0x646120, 0x646520, 0x646920, 0x652062,
		      0x65206B, 0x656469, 0x656E20, 0x657220, 0x657269, 0x657369, 0x696C65, 0x696E20,
		      0x696E69, 0x697220, 0x6C616E, 0x6C6172, 0x6C6520, 0x6C6572, 0x6E2061, 0x6E2062,
		      0x6E206B, 0x6E6461, 0x6E6465, 0x6E6520, 0x6E6920, 0x6E696E, 0x6EFD20, 0x72696E,
		      0x72FD6E, 0x766520, 0x796120, 0x796F72, 0xFD6E20, 0xFD6E64, 0xFD6EFD, 0xFDF0FD
		    ];
		  };

		  this.name = function(det) {
		    return (det && det.fC1Bytes) ? 'windows-1254' : 'ISO-8859-9';
		  };

		  this.language = function() {
		    return 'tr';
		  };
		};
		util.inherits(module.exports.ISO_8859_9, sbcs);


		module.exports.windows_1251 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x90, 0x83, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F,
		      0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x9A, 0x20, 0x9C, 0x9D, 0x9E, 0x9F,
		      0x20, 0xA2, 0xA2, 0xBC, 0x20, 0xB4, 0x20, 0x20,
		      0xB8, 0x20, 0xBA, 0x20, 0x20, 0x20, 0x20, 0xBF,
		      0x20, 0x20, 0xB3, 0xB3, 0xB4, 0xB5, 0x20, 0x20,
		      0xB8, 0x20, 0xBA, 0x20, 0xBC, 0xBE, 0xBE, 0xBF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
		      0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20E220, 0x20E2EE, 0x20E4EE, 0x20E7E0, 0x20E820, 0x20EAE0, 0x20EAEE, 0x20EDE0,
		      0x20EDE5, 0x20EEE1, 0x20EFEE, 0x20EFF0, 0x20F0E0, 0x20F1EE, 0x20F1F2, 0x20F2EE,
		      0x20F7F2, 0x20FDF2, 0xE0EDE8, 0xE0F2FC, 0xE3EE20, 0xE5EBFC, 0xE5EDE8, 0xE5F1F2,
		      0xE5F220, 0xE820EF, 0xE8E520, 0xE8E820, 0xE8FF20, 0xEBE5ED, 0xEBE820, 0xEBFCED,
		      0xEDE020, 0xEDE520, 0xEDE8E5, 0xEDE8FF, 0xEDEE20, 0xEDEEE2, 0xEE20E2, 0xEE20EF,
		      0xEE20F1, 0xEEE220, 0xEEE2E0, 0xEEE3EE, 0xEEE920, 0xEEEBFC, 0xEEEC20, 0xEEF1F2,
		      0xEFEEEB, 0xEFF0E5, 0xEFF0E8, 0xEFF0EE, 0xF0E0E2, 0xF0E5E4, 0xF1F2E0, 0xF1F2E2,
		      0xF1F2E8, 0xF1FF20, 0xF2E5EB, 0xF2EE20, 0xF2EEF0, 0xF2FC20, 0xF7F2EE, 0xFBF520
		    ];
		  };

		  this.name = function(det) {
		    return 'windows-1251';
		  };

		  this.language = function() {
		    return 'ru';
		  };
		};
		util.inherits(module.exports.windows_1251, sbcs);


		module.exports.windows_1256 = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x81, 0x20, 0x83, 0x20, 0x20, 0x20, 0x20,
		      0x88, 0x20, 0x8A, 0x20, 0x9C, 0x8D, 0x8E, 0x8F,
		      0x90, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x98, 0x20, 0x9A, 0x20, 0x9C, 0x20, 0x20, 0x9F,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0xAA, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0xB5, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
		      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0x20,
		      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
		      0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
		      0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
		      0x20, 0x20, 0x20, 0x20, 0xF4, 0x20, 0x20, 0x20,
		      0x20, 0xF9, 0x20, 0xFB, 0xFC, 0x20, 0x20, 0xFF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20C7E1, 0x20C7E4, 0x20C8C7, 0x20DAE1, 0x20DDED, 0x20E1E1, 0x20E3E4, 0x20E6C7,
		      0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E120, 0xC7E1C3, 0xC7E1C7, 0xC7E1C8,
		      0xC7E1CA, 0xC7E1CC, 0xC7E1CD, 0xC7E1CF, 0xC7E1D3, 0xC7E1DA, 0xC7E1DE, 0xC7E1E3,
		      0xC7E1E6, 0xC7E1ED, 0xC7E320, 0xC7E420, 0xC7E4CA, 0xC820C7, 0xC920C7, 0xC920DD,
		      0xC920E1, 0xC920E3, 0xC920E6, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920,
		      0xD320C7, 0xDA20C7, 0xDAE1EC, 0xDDED20, 0xE120C7, 0xE1C920, 0xE1EC20, 0xE1ED20,
		      0xE320C7, 0xE3C720, 0xE3C920, 0xE3E420, 0xE420C7, 0xE520C7, 0xE5C720, 0xE6C7E1,
		      0xE6E420, 0xEC20C7, 0xED20C7, 0xED20E3, 0xED20E6, 0xEDC920, 0xEDD120, 0xEDE420
		    ];
		  };

		  this.name = function(det) {
		    return 'windows-1256';
		  };

		  this.language = function() {
		    return 'ar';
		  };
		};
		util.inherits(module.exports.windows_1256, sbcs);


		module.exports.KOI8_R = function() {
		  this.byteMap = function() {
		    return [
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		      0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
		      0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
		      0x78, 0x79, 0x7A, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0xA3, 0x20, 0x20, 0x20, 0x20,
		      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
		      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
		      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
		      0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
		      0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
		      0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
		      0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF
		    ];
		  };

		  this.ngrams = function() {
		    return [
		      0x20C4CF, 0x20C920, 0x20CBC1, 0x20CBCF, 0x20CEC1, 0x20CEC5, 0x20CFC2, 0x20D0CF,
		      0x20D0D2, 0x20D2C1, 0x20D3CF, 0x20D3D4, 0x20D4CF, 0x20D720, 0x20D7CF, 0x20DAC1,
		      0x20DCD4, 0x20DED4, 0xC1CEC9, 0xC1D4D8, 0xC5CCD8, 0xC5CEC9, 0xC5D3D4, 0xC5D420,
		      0xC7CF20, 0xC920D0, 0xC9C520, 0xC9C920, 0xC9D120, 0xCCC5CE, 0xCCC920, 0xCCD8CE,
		      0xCEC120, 0xCEC520, 0xCEC9C5, 0xCEC9D1, 0xCECF20, 0xCECFD7, 0xCF20D0, 0xCF20D3,
		      0xCF20D7, 0xCFC7CF, 0xCFCA20, 0xCFCCD8, 0xCFCD20, 0xCFD3D4, 0xCFD720, 0xCFD7C1,
		      0xD0CFCC, 0xD0D2C5, 0xD0D2C9, 0xD0D2CF, 0xD2C1D7, 0xD2C5C4, 0xD3D120, 0xD3D4C1,
		      0xD3D4C9, 0xD3D4D7, 0xD4C5CC, 0xD4CF20, 0xD4CFD2, 0xD4D820, 0xD9C820, 0xDED4CF
		    ];
		  };

		  this.name = function(det) {
		    return 'KOI8-R';
		  };

		  this.language = function() {
		    return 'ru';
		  };
		};
		util.inherits(module.exports.KOI8_R, sbcs);


		/*
		module.exports.ISO_8859_7 = function() {
		  this.byteMap = function() {
		    return [

		    ];
		  };

		  this.ngrams = function() {
		    return [

		    ];
		  };

		  this.name = function(det) {
		    if (typeof det == 'undefined')
		      return 'ISO-8859-7';
		    return det.fC1Bytes ? 'windows-1253' : 'ISO-8859-7';
		  };

		  this.language = function() {
		    return 'el';
		  };
		};
		util.inherits(module.exports.ISO_8859_7, sbcs);
		*/ 
	} (sbcs));
	return sbcs.exports;
}

var iso2022 = {exports: {}};

var hasRequiredIso2022;

function requireIso2022 () {
	if (hasRequiredIso2022) return iso2022.exports;
	hasRequiredIso2022 = 1;
	(function (module) {
		var util = require$$0$d,
		  Match = requireMatch();


		/**
		 * This is a superclass for the individual detectors for
		 * each of the detectable members of the ISO 2022 family
		 * of encodings.
		 */

		function ISO_2022() {}

		ISO_2022.prototype.match = function(det) {

		  /**
		   * Matching function shared among the 2022 detectors JP, CN and KR
		   * Counts up the number of legal an unrecognized escape sequences in
		   * the sample of text, and computes a score based on the total number &
		   * the proportion that fit the encoding.
		   *
		   *
		   * @param text the byte buffer containing text to analyse
		   * @param textLen  the size of the text in the byte.
		   * @param escapeSequences the byte escape sequences to test for.
		   * @return match quality, in the range of 0-100.
		   */

		  var i, j;
		  var escN;
		  var hits   = 0;
		  var misses = 0;
		  var shifts = 0;
		  var quality;

		  // TODO: refactor me
		  var text = det.fInputBytes;
		  var textLen = det.fInputLen;

		  scanInput:
		    for (i = 0; i < textLen; i++) {
		      if (text[i] == 0x1b) {
		        checkEscapes:
		          for (escN = 0; escN < this.escapeSequences.length; escN++) {
		            var seq = this.escapeSequences[escN];

		            if ((textLen - i) < seq.length)
		              continue checkEscapes;

		            for (j = 1; j < seq.length; j++)
		              if (seq[j] != text[i + j])
		                continue checkEscapes;


		            hits++;
		            i += seq.length - 1;
		            continue scanInput;
		          }

		          misses++;
		      }

		      // Shift in/out
		      if (text[i] == 0x0e || text[i] == 0x0f)
		        shifts++;

		    }

		  if (hits == 0)
		    return null;

		  //
		  // Initial quality is based on relative proportion of recongized vs.
		  //   unrecognized escape sequences.
		  //   All good:  quality = 100;
		  //   half or less good: quality = 0;
		  //   linear inbetween.
		  quality = (100 * hits - 100 * misses) / (hits + misses);

		  // Back off quality if there were too few escape sequences seen.
		  //   Include shifts in this computation, so that KR does not get penalized
		  //   for having only a single Escape sequence, but many shifts.
		  if (hits + shifts < 5)
		    quality -= (5 - (hits + shifts)) * 10;

		  return quality <= 0 ? null : new Match(det, this, quality);
		};

		module.exports.ISO_2022_JP = function() {
		  this.name = function() {
		    return 'ISO-2022-JP';
		  };
		  this.escapeSequences = [
		    [ 0x1b, 0x24, 0x28, 0x43 ],   // KS X 1001:1992
		    [ 0x1b, 0x24, 0x28, 0x44 ],   // JIS X 212-1990
		    [ 0x1b, 0x24, 0x40 ],         // JIS C 6226-1978
		    [ 0x1b, 0x24, 0x41 ],         // GB 2312-80
		    [ 0x1b, 0x24, 0x42 ],         // JIS X 208-1983
		    [ 0x1b, 0x26, 0x40 ],         // JIS X 208 1990, 1997
		    [ 0x1b, 0x28, 0x42 ],         // ASCII
		    [ 0x1b, 0x28, 0x48 ],         // JIS-Roman
		    [ 0x1b, 0x28, 0x49 ],         // Half-width katakana
		    [ 0x1b, 0x28, 0x4a ],         // JIS-Roman
		    [ 0x1b, 0x2e, 0x41 ],         // ISO 8859-1
		    [ 0x1b, 0x2e, 0x46 ]          // ISO 8859-7
		  ];
		};
		util.inherits(module.exports.ISO_2022_JP, ISO_2022);



		module.exports.ISO_2022_KR = function() {
		  this.name = function() {
		    return 'ISO-2022-KR';
		  };
		  this.escapeSequences = [
		    [ 0x1b, 0x24, 0x29, 0x43 ]
		  ];
		};
		util.inherits(module.exports.ISO_2022_KR, ISO_2022);



		module.exports.ISO_2022_CN = function() {
		  this.name = function() {
		    return 'ISO-2022-CN';
		  };
		  this.escapeSequences = [
		    [ 0x1b, 0x24, 0x29, 0x41 ],   // GB 2312-80
		    [ 0x1b, 0x24, 0x29, 0x47 ],   // CNS 11643-1992 Plane 1
		    [ 0x1b, 0x24, 0x2A, 0x48 ],   // CNS 11643-1992 Plane 2
		    [ 0x1b, 0x24, 0x29, 0x45 ],   // ISO-IR-165
		    [ 0x1b, 0x24, 0x2B, 0x49 ],   // CNS 11643-1992 Plane 3
		    [ 0x1b, 0x24, 0x2B, 0x4A ],   // CNS 11643-1992 Plane 4
		    [ 0x1b, 0x24, 0x2B, 0x4B ],   // CNS 11643-1992 Plane 5
		    [ 0x1b, 0x24, 0x2B, 0x4C ],   // CNS 11643-1992 Plane 6
		    [ 0x1b, 0x24, 0x2B, 0x4D ],   // CNS 11643-1992 Plane 7
		    [ 0x1b, 0x4e ],               // SS2
		    [ 0x1b, 0x4f ]                // SS3
		  ];
		};
		util.inherits(module.exports.ISO_2022_CN, ISO_2022); 
	} (iso2022));
	return iso2022.exports;
}

var hasRequiredChardet;

function requireChardet () {
	if (hasRequiredChardet) return chardet;
	hasRequiredChardet = 1;
	var fs = require$$0$6;

	var utf8  = requireUtf8(),
	  unicode = requireUnicode(),
	  mbcs    = requireMbcs(),
	  sbcs    = requireSbcs(),
	  iso2022 = requireIso2022();

	var self = chardet;

	var recognisers = [
	  new utf8,
	  new unicode.UTF_16BE,
	  new unicode.UTF_16LE,
	  new unicode.UTF_32BE,
	  new unicode.UTF_32LE,
	  new mbcs.sjis,
	  new mbcs.big5,
	  new mbcs.euc_jp,
	  new mbcs.euc_kr,
	  new mbcs.gb_18030,
	  new iso2022.ISO_2022_JP,
	  new iso2022.ISO_2022_KR,
	  new iso2022.ISO_2022_CN,
	  new sbcs.ISO_8859_1,
	  new sbcs.ISO_8859_2,
	  new sbcs.ISO_8859_5,
	  new sbcs.ISO_8859_6,
	  new sbcs.ISO_8859_7,
	  new sbcs.ISO_8859_8,
	  new sbcs.ISO_8859_9,
	  new sbcs.windows_1251,
	  new sbcs.windows_1256,
	  new sbcs.KOI8_R
	];

	chardet.detect = function(buffer, opts) {

	  // Tally up the byte occurence statistics.
	  var fByteStats = [];
	  for (var i = 0; i < 256; i++)
	    fByteStats[i] = 0;

	  for (var i = buffer.length - 1; i >= 0; i--)
	    fByteStats[buffer[i] & 0x00ff]++;

	  var fC1Bytes = false;
	  for (var i = 0x80; i <= 0x9F; i += 1) {
	    if (fByteStats[i] != 0) {
	      fC1Bytes = true;
	      break;
	    }
	  }

	  var context = {
	    fByteStats:  fByteStats,
	    fC1Bytes:    fC1Bytes,
	    fRawInput:   buffer,
	    fRawLength:  buffer.length,
	    fInputBytes: buffer,
	    fInputLen:   buffer.length
	  };

	  var matches = recognisers.map(function(rec) {
	    return rec.match(context);
	  }).filter(function(match) {
	    return !!match;
	  }).sort(function(a, b) {
	    return b.confidence - a.confidence;
	  });

	  if (opts && opts.returnAllMatches === true) {
	    return matches;
	  }
	  else {
	    return matches.length > 0 ? matches[0].name : null;
	  }
	};

	chardet.detectFile = function(filepath, opts, cb) {
	  if (typeof opts === 'function') {
	    cb = opts;
	    opts = undefined;
	  }

	  var fd;

	  var handler = function(err, buffer) {
	    if (fd) {
	      fs.closeSync(fd);
	    }

	    if (err) return cb(err, null);
	    cb(null, self.detect(buffer, opts));
	  };

	  if (opts && opts.sampleSize) {
	    fd = fs.openSync(filepath, 'r'),
	      sample = Buffer.allocUnsafe(opts.sampleSize);

	    fs.read(fd, sample, 0, opts.sampleSize, null, function(err) {
	      handler(err, sample);
	    });
	    return;
	  }

	  fs.readFile(filepath, handler);
	};

	chardet.detectFileSync = function(filepath, opts) {
	  if (opts && opts.sampleSize) {
	    var fd = fs.openSync(filepath, 'r'),
	      sample = Buffer.allocUnsafe(opts.sampleSize);

	    fs.readSync(fd, sample, 0, opts.sampleSize);
	    fs.closeSync(fd);
	    return self.detect(sample, opts);
	  }

	  return self.detect(fs.readFileSync(filepath), opts);
	};

	// Wrappers for the previous functions to return all encodings
	chardet.detectAll = function(buffer, opts) {
	  if (typeof opts !== 'object') {
	    opts = {};
	  }
	  opts.returnAllMatches = true;
	  return self.detect(buffer, opts);
	};

	chardet.detectFileAll = function(filepath, opts, cb) {
	  if (typeof opts === 'function') {
	    cb = opts;
	    opts = undefined;
	  }
	  if (typeof opts !== 'object') {
	    opts = {};
	  }
	  opts.returnAllMatches = true;
	  self.detectFile(filepath, opts, cb);
	};

	chardet.detectFileAllSync = function(filepath, opts) {
	  if (typeof opts !== 'object') {
	    opts = {};
	  }
	  opts.returnAllMatches = true;
	  return self.detectFileSync(filepath, opts);
	};
	return chardet;
}

var lib = {exports: {}};

/* eslint-disable node/no-deprecated-api */

var safer_1;
var hasRequiredSafer;

function requireSafer () {
	if (hasRequiredSafer) return safer_1;
	hasRequiredSafer = 1;

	var buffer = require$$0$9;
	var Buffer = buffer.Buffer;

	var safer = {};

	var key;

	for (key in buffer) {
	  if (!buffer.hasOwnProperty(key)) continue
	  if (key === 'SlowBuffer' || key === 'Buffer') continue
	  safer[key] = buffer[key];
	}

	var Safer = safer.Buffer = {};
	for (key in Buffer) {
	  if (!Buffer.hasOwnProperty(key)) continue
	  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
	  Safer[key] = Buffer[key];
	}

	safer.Buffer.prototype = Buffer.prototype;

	if (!Safer.from || Safer.from === Uint8Array.from) {
	  Safer.from = function (value, encodingOrOffset, length) {
	    if (typeof value === 'number') {
	      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
	    }
	    if (value && typeof value.length === 'undefined') {
	      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
	    }
	    return Buffer(value, encodingOrOffset, length)
	  };
	}

	if (!Safer.alloc) {
	  Safer.alloc = function (size, fill, encoding) {
	    if (typeof size !== 'number') {
	      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
	    }
	    if (size < 0 || size >= 2 * (1 << 30)) {
	      throw new RangeError('The value "' + size + '" is invalid for option "size"')
	    }
	    var buf = Buffer(size);
	    if (!fill || fill.length === 0) {
	      buf.fill(0);
	    } else if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	    return buf
	  };
	}

	if (!safer.kStringMaxLength) {
	  try {
	    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
	  } catch (e) {
	    // we can't determine kStringMaxLength in environments where process.binding
	    // is unsupported, so let's not set it
	  }
	}

	if (!safer.constants) {
	  safer.constants = {
	    MAX_LENGTH: safer.kMaxLength
	  };
	  if (safer.kStringMaxLength) {
	    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	  }
	}

	safer_1 = safer;
	return safer_1;
}

var bomHandling = {};

var hasRequiredBomHandling;

function requireBomHandling () {
	if (hasRequiredBomHandling) return bomHandling;
	hasRequiredBomHandling = 1;

	var BOMChar = '\uFEFF';

	bomHandling.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
	    this.encoder = encoder;
	    this.addBOM = true;
	}

	PrependBOMWrapper.prototype.write = function(str) {
	    if (this.addBOM) {
	        str = BOMChar + str;
	        this.addBOM = false;
	    }

	    return this.encoder.write(str);
	};

	PrependBOMWrapper.prototype.end = function() {
	    return this.encoder.end();
	};


	//------------------------------------------------------------------------------

	bomHandling.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
	    this.decoder = decoder;
	    this.pass = false;
	    this.options = options || {};
	}

	StripBOMWrapper.prototype.write = function(buf) {
	    var res = this.decoder.write(buf);
	    if (this.pass || !res)
	        return res;

	    if (res[0] === BOMChar) {
	        res = res.slice(1);
	        if (typeof this.options.stripBOM === 'function')
	            this.options.stripBOM();
	    }

	    this.pass = true;
	    return res;
	};

	StripBOMWrapper.prototype.end = function() {
	    return this.decoder.end();
	};
	return bomHandling;
}

var encodings = {};

var internal;
var hasRequiredInternal;

function requireInternal () {
	if (hasRequiredInternal) return internal;
	hasRequiredInternal = 1;
	var Buffer = requireSafer().Buffer;

	// Export Node.js internal encodings.

	internal = {
	    // Encodings
	    utf8:   { type: "_internal", bomAware: true},
	    cesu8:  { type: "_internal", bomAware: true},
	    unicode11utf8: "utf8",

	    ucs2:   { type: "_internal", bomAware: true},
	    utf16le: "ucs2",

	    binary: { type: "_internal" },
	    base64: { type: "_internal" },
	    hex:    { type: "_internal" },

	    // Codec.
	    _internal: InternalCodec,
	};

	//------------------------------------------------------------------------------

	function InternalCodec(codecOptions, iconv) {
	    this.enc = codecOptions.encodingName;
	    this.bomAware = codecOptions.bomAware;

	    if (this.enc === "base64")
	        this.encoder = InternalEncoderBase64;
	    else if (this.enc === "cesu8") {
	        this.enc = "utf8"; // Use utf8 for decoding.
	        this.encoder = InternalEncoderCesu8;

	        // Add decoder for versions of Node not supporting CESU-8
	        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
	            this.decoder = InternalDecoderCesu8;
	            this.defaultCharUnicode = iconv.defaultCharUnicode;
	        }
	    }
	}

	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;

	//------------------------------------------------------------------------------

	// We use node.js internal decoder. Its signature is the same as ours.
	var StringDecoder = require$$1$4.StringDecoder;

	if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
	    StringDecoder.prototype.end = function() {};


	function InternalDecoder(options, codec) {
	    StringDecoder.call(this, codec.enc);
	}

	InternalDecoder.prototype = StringDecoder.prototype;


	//------------------------------------------------------------------------------
	// Encoder is mostly trivial

	function InternalEncoder(options, codec) {
	    this.enc = codec.enc;
	}

	InternalEncoder.prototype.write = function(str) {
	    return Buffer.from(str, this.enc);
	};

	InternalEncoder.prototype.end = function() {
	};


	//------------------------------------------------------------------------------
	// Except base64 encoder, which must keep its state.

	function InternalEncoderBase64(options, codec) {
	    this.prevStr = '';
	}

	InternalEncoderBase64.prototype.write = function(str) {
	    str = this.prevStr + str;
	    var completeQuads = str.length - (str.length % 4);
	    this.prevStr = str.slice(completeQuads);
	    str = str.slice(0, completeQuads);

	    return Buffer.from(str, "base64");
	};

	InternalEncoderBase64.prototype.end = function() {
	    return Buffer.from(this.prevStr, "base64");
	};


	//------------------------------------------------------------------------------
	// CESU-8 encoder is also special.

	function InternalEncoderCesu8(options, codec) {
	}

	InternalEncoderCesu8.prototype.write = function(str) {
	    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
	    for (var i = 0; i < str.length; i++) {
	        var charCode = str.charCodeAt(i);
	        // Naive implementation, but it works because CESU-8 is especially easy
	        // to convert from UTF-16 (which all JS strings are encoded in).
	        if (charCode < 0x80)
	            buf[bufIdx++] = charCode;
	        else if (charCode < 0x800) {
	            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	        }
	        else { // charCode will always be < 0x10000 in javascript.
	            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
	            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	        }
	    }
	    return buf.slice(0, bufIdx);
	};

	InternalEncoderCesu8.prototype.end = function() {
	};

	//------------------------------------------------------------------------------
	// CESU-8 decoder is not implemented in Node v4.0+

	function InternalDecoderCesu8(options, codec) {
	    this.acc = 0;
	    this.contBytes = 0;
	    this.accBytes = 0;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	}

	InternalDecoderCesu8.prototype.write = function(buf) {
	    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
	        res = '';
	    for (var i = 0; i < buf.length; i++) {
	        var curByte = buf[i];
	        if ((curByte & 0xC0) !== 0x80) { // Leading byte
	            if (contBytes > 0) { // Previous code is invalid
	                res += this.defaultCharUnicode;
	                contBytes = 0;
	            }

	            if (curByte < 0x80) { // Single-byte code
	                res += String.fromCharCode(curByte);
	            } else if (curByte < 0xE0) { // Two-byte code
	                acc = curByte & 0x1F;
	                contBytes = 1; accBytes = 1;
	            } else if (curByte < 0xF0) { // Three-byte code
	                acc = curByte & 0x0F;
	                contBytes = 2; accBytes = 1;
	            } else { // Four or more are not supported for CESU-8.
	                res += this.defaultCharUnicode;
	            }
	        } else { // Continuation byte
	            if (contBytes > 0) { // We're waiting for it.
	                acc = (acc << 6) | (curByte & 0x3f);
	                contBytes--; accBytes++;
	                if (contBytes === 0) {
	                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
	                    if (accBytes === 2 && acc < 0x80 && acc > 0)
	                        res += this.defaultCharUnicode;
	                    else if (accBytes === 3 && acc < 0x800)
	                        res += this.defaultCharUnicode;
	                    else
	                        // Actually add character.
	                        res += String.fromCharCode(acc);
	                }
	            } else { // Unexpected continuation byte
	                res += this.defaultCharUnicode;
	            }
	        }
	    }
	    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
	    return res;
	};

	InternalDecoderCesu8.prototype.end = function() {
	    var res = 0;
	    if (this.contBytes > 0)
	        res += this.defaultCharUnicode;
	    return res;
	};
	return internal;
}

var utf16 = {};

var hasRequiredUtf16;

function requireUtf16 () {
	if (hasRequiredUtf16) return utf16;
	hasRequiredUtf16 = 1;
	var Buffer = requireSafer().Buffer;

	// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

	// == UTF16-BE codec. ==========================================================

	utf16.utf16be = Utf16BECodec;
	function Utf16BECodec() {
	}

	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;


	// -- Encoding

	function Utf16BEEncoder() {
	}

	Utf16BEEncoder.prototype.write = function(str) {
	    var buf = Buffer.from(str, 'ucs2');
	    for (var i = 0; i < buf.length; i += 2) {
	        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
	    }
	    return buf;
	};

	Utf16BEEncoder.prototype.end = function() {
	};


	// -- Decoding

	function Utf16BEDecoder() {
	    this.overflowByte = -1;
	}

	Utf16BEDecoder.prototype.write = function(buf) {
	    if (buf.length == 0)
	        return '';

	    var buf2 = Buffer.alloc(buf.length + 1),
	        i = 0, j = 0;

	    if (this.overflowByte !== -1) {
	        buf2[0] = buf[0];
	        buf2[1] = this.overflowByte;
	        i = 1; j = 2;
	    }

	    for (; i < buf.length-1; i += 2, j+= 2) {
	        buf2[j] = buf[i+1];
	        buf2[j+1] = buf[i];
	    }

	    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

	    return buf2.slice(0, j).toString('ucs2');
	};

	Utf16BEDecoder.prototype.end = function() {
	};


	// == UTF-16 codec =============================================================
	// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
	// Defaults to UTF-16LE, as it's prevalent and default in Node.
	// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
	// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

	// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

	utf16.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	}

	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;


	// -- Encoding (pass-through)

	function Utf16Encoder(options, codec) {
	    options = options || {};
	    if (options.addBOM === undefined)
	        options.addBOM = true;
	    this.encoder = codec.iconv.getEncoder('utf-16le', options);
	}

	Utf16Encoder.prototype.write = function(str) {
	    return this.encoder.write(str);
	};

	Utf16Encoder.prototype.end = function() {
	    return this.encoder.end();
	};


	// -- Decoding

	function Utf16Decoder(options, codec) {
	    this.decoder = null;
	    this.initialBytes = [];
	    this.initialBytesLen = 0;

	    this.options = options || {};
	    this.iconv = codec.iconv;
	}

	Utf16Decoder.prototype.write = function(buf) {
	    if (!this.decoder) {
	        // Codec is not chosen yet. Accumulate initial bytes.
	        this.initialBytes.push(buf);
	        this.initialBytesLen += buf.length;
	        
	        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
	            return '';

	        // We have enough bytes -> detect endianness.
	        var buf = Buffer.concat(this.initialBytes),
	            encoding = detectEncoding(buf, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);
	        this.initialBytes.length = this.initialBytesLen = 0;
	    }

	    return this.decoder.write(buf);
	};

	Utf16Decoder.prototype.end = function() {
	    if (!this.decoder) {
	        var buf = Buffer.concat(this.initialBytes),
	            encoding = detectEncoding(buf, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);

	        var res = this.decoder.write(buf),
	            trail = this.decoder.end();

	        return trail ? (res + trail) : res;
	    }
	    return this.decoder.end();
	};

	function detectEncoding(buf, defaultEncoding) {
	    var enc = defaultEncoding || 'utf-16le';

	    if (buf.length >= 2) {
	        // Check BOM.
	        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
	            enc = 'utf-16be';
	        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
	            enc = 'utf-16le';
	        else {
	            // No BOM found. Try to deduce encoding from initial content.
	            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
	            // So, we count ASCII as if it was LE or BE, and decide from that.
	            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
	                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

	            for (var i = 0; i < _len; i += 2) {
	                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
	                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
	            }

	            if (asciiCharsBE > asciiCharsLE)
	                enc = 'utf-16be';
	            else if (asciiCharsBE < asciiCharsLE)
	                enc = 'utf-16le';
	        }
	    }

	    return enc;
	}
	return utf16;
}

var utf7 = {};

var hasRequiredUtf7;

function requireUtf7 () {
	if (hasRequiredUtf7) return utf7;
	hasRequiredUtf7 = 1;
	var Buffer = requireSafer().Buffer;

	// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
	// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

	utf7.utf7 = Utf7Codec;
	utf7.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
	function Utf7Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;


	// -- Encoding

	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

	function Utf7Encoder(options, codec) {
	    this.iconv = codec.iconv;
	}

	Utf7Encoder.prototype.write = function(str) {
	    // Naive implementation.
	    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
	    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
	        return "+" + (chunk === '+' ? '' : 
	            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
	            + "-";
	    }.bind(this)));
	};

	Utf7Encoder.prototype.end = function() {
	};


	// -- Decoding

	function Utf7Decoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	}

	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i = 0; i < 256; i++)
	    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

	var plusChar = '+'.charCodeAt(0), 
	    minusChar = '-'.charCodeAt(0),
	    andChar = '&'.charCodeAt(0);

	Utf7Decoder.prototype.write = function(buf) {
	    var res = "", lastI = 0,
	        inBase64 = this.inBase64,
	        base64Accum = this.base64Accum;

	    // The decoder is more involved as we must handle chunks in stream.

	    for (var i = 0; i < buf.length; i++) {
	        if (!inBase64) { // We're in direct mode.
	            // Write direct chars until '+'
	            if (buf[i] == plusChar) {
	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	                lastI = i+1;
	                inBase64 = true;
	            }
	        } else { // We decode base64.
	            if (!base64Chars[buf[i]]) { // Base64 ended.
	                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
	                    res += "+";
	                } else {
	                    var b64str = base64Accum + buf.slice(lastI, i).toString();
	                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	                }

	                if (buf[i] != minusChar) // Minus is absorbed after base64.
	                    i--;

	                lastI = i+1;
	                inBase64 = false;
	                base64Accum = '';
	            }
	        }
	    }

	    if (!inBase64) {
	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	        var b64str = base64Accum + buf.slice(lastI).toString();

	        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	        b64str = b64str.slice(0, canBeDecoded);

	        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	    }

	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;

	    return res;
	};

	Utf7Decoder.prototype.end = function() {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0)
	        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	};


	// UTF-7-IMAP codec.
	// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
	// Differences:
	//  * Base64 part is started by "&" instead of "+"
	//  * Direct characters are 0x20-0x7E, except "&" (0x26)
	//  * In Base64, "," is used instead of "/"
	//  * Base64 must not be used to represent direct characters.
	//  * No implicit shift back from Base64 (should always end with '-')
	//  * String must end in non-shifted position.
	//  * "-&" while in base64 is not allowed.


	utf7.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv) {
	    this.iconv = iconv;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;


	// -- Encoding

	function Utf7IMAPEncoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = Buffer.alloc(6);
	    this.base64AccumIdx = 0;
	}

	Utf7IMAPEncoder.prototype.write = function(str) {
	    var inBase64 = this.inBase64,
	        base64Accum = this.base64Accum,
	        base64AccumIdx = this.base64AccumIdx,
	        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

	    for (var i = 0; i < str.length; i++) {
	        var uChar = str.charCodeAt(i);
	        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
	            if (inBase64) {
	                if (base64AccumIdx > 0) {
	                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	                    base64AccumIdx = 0;
	                }

	                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	                inBase64 = false;
	            }

	            if (!inBase64) {
	                buf[bufIdx++] = uChar; // Write direct character

	                if (uChar === andChar)  // Ampersand -> '&-'
	                    buf[bufIdx++] = minusChar;
	            }

	        } else { // Non-direct character
	            if (!inBase64) {
	                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
	                inBase64 = true;
	            }
	            if (inBase64) {
	                base64Accum[base64AccumIdx++] = uChar >> 8;
	                base64Accum[base64AccumIdx++] = uChar & 0xFF;

	                if (base64AccumIdx == base64Accum.length) {
	                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
	                    base64AccumIdx = 0;
	                }
	            }
	        }
	    }

	    this.inBase64 = inBase64;
	    this.base64AccumIdx = base64AccumIdx;

	    return buf.slice(0, bufIdx);
	};

	Utf7IMAPEncoder.prototype.end = function() {
	    var buf = Buffer.alloc(10), bufIdx = 0;
	    if (this.inBase64) {
	        if (this.base64AccumIdx > 0) {
	            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	            this.base64AccumIdx = 0;
	        }

	        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	        this.inBase64 = false;
	    }

	    return buf.slice(0, bufIdx);
	};


	// -- Decoding

	function Utf7IMAPDecoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	}

	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[','.charCodeAt(0)] = true;

	Utf7IMAPDecoder.prototype.write = function(buf) {
	    var res = "", lastI = 0,
	        inBase64 = this.inBase64,
	        base64Accum = this.base64Accum;

	    // The decoder is more involved as we must handle chunks in stream.
	    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

	    for (var i = 0; i < buf.length; i++) {
	        if (!inBase64) { // We're in direct mode.
	            // Write direct chars until '&'
	            if (buf[i] == andChar) {
	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	                lastI = i+1;
	                inBase64 = true;
	            }
	        } else { // We decode base64.
	            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
	                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
	                    res += "&";
	                } else {
	                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
	                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	                }

	                if (buf[i] != minusChar) // Minus may be absorbed after base64.
	                    i--;

	                lastI = i+1;
	                inBase64 = false;
	                base64Accum = '';
	            }
	        }
	    }

	    if (!inBase64) {
	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

	        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	        b64str = b64str.slice(0, canBeDecoded);

	        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	    }

	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;

	    return res;
	};

	Utf7IMAPDecoder.prototype.end = function() {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0)
	        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	};
	return utf7;
}

var sbcsCodec = {};

var hasRequiredSbcsCodec;

function requireSbcsCodec () {
	if (hasRequiredSbcsCodec) return sbcsCodec;
	hasRequiredSbcsCodec = 1;
	var Buffer = requireSafer().Buffer;

	// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
	// correspond to encoded bytes (if 128 - then lower half is ASCII). 

	sbcsCodec._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv) {
	    if (!codecOptions)
	        throw new Error("SBCS codec is called without the data.")
	    
	    // Prepare char buffer for decoding.
	    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
	        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
	    
	    if (codecOptions.chars.length === 128) {
	        var asciiString = "";
	        for (var i = 0; i < 128; i++)
	            asciiString += String.fromCharCode(i);
	        codecOptions.chars = asciiString + codecOptions.chars;
	    }

	    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
	    
	    // Encoding buffer.
	    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

	    for (var i = 0; i < codecOptions.chars.length; i++)
	        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

	    this.encodeBuf = encodeBuf;
	}

	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;


	function SBCSEncoder(options, codec) {
	    this.encodeBuf = codec.encodeBuf;
	}

	SBCSEncoder.prototype.write = function(str) {
	    var buf = Buffer.alloc(str.length);
	    for (var i = 0; i < str.length; i++)
	        buf[i] = this.encodeBuf[str.charCodeAt(i)];
	    
	    return buf;
	};

	SBCSEncoder.prototype.end = function() {
	};


	function SBCSDecoder(options, codec) {
	    this.decodeBuf = codec.decodeBuf;
	}

	SBCSDecoder.prototype.write = function(buf) {
	    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
	    var decodeBuf = this.decodeBuf;
	    var newBuf = Buffer.alloc(buf.length*2);
	    var idx1 = 0, idx2 = 0;
	    for (var i = 0; i < buf.length; i++) {
	        idx1 = buf[i]*2; idx2 = i*2;
	        newBuf[idx2] = decodeBuf[idx1];
	        newBuf[idx2+1] = decodeBuf[idx1+1];
	    }
	    return newBuf.toString('ucs2');
	};

	SBCSDecoder.prototype.end = function() {
	};
	return sbcsCodec;
}

var sbcsData;
var hasRequiredSbcsData;

function requireSbcsData () {
	if (hasRequiredSbcsData) return sbcsData;
	hasRequiredSbcsData = 1;

	// Manually added data to be used by sbcs codec in addition to generated one.

	sbcsData = {
	    // Not supported by iconv, not sure why.
	    "10029": "maccenteuro",
	    "maccenteuro": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    "808": "cp808",
	    "ibm808": "cp808",
	    "cp808": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    "mik": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    // Aliases of generated encodings.
	    "ascii8bit": "ascii",
	    "usascii": "ascii",
	    "ansix34": "ascii",
	    "ansix341968": "ascii",
	    "ansix341986": "ascii",
	    "csascii": "ascii",
	    "cp367": "ascii",
	    "ibm367": "ascii",
	    "isoir6": "ascii",
	    "iso646us": "ascii",
	    "iso646irv": "ascii",
	    "us": "ascii",

	    "latin1": "iso88591",
	    "latin2": "iso88592",
	    "latin3": "iso88593",
	    "latin4": "iso88594",
	    "latin5": "iso88599",
	    "latin6": "iso885910",
	    "latin7": "iso885913",
	    "latin8": "iso885914",
	    "latin9": "iso885915",
	    "latin10": "iso885916",

	    "csisolatin1": "iso88591",
	    "csisolatin2": "iso88592",
	    "csisolatin3": "iso88593",
	    "csisolatin4": "iso88594",
	    "csisolatincyrillic": "iso88595",
	    "csisolatinarabic": "iso88596",
	    "csisolatingreek" : "iso88597",
	    "csisolatinhebrew": "iso88598",
	    "csisolatin5": "iso88599",
	    "csisolatin6": "iso885910",

	    "l1": "iso88591",
	    "l2": "iso88592",
	    "l3": "iso88593",
	    "l4": "iso88594",
	    "l5": "iso88599",
	    "l6": "iso885910",
	    "l7": "iso885913",
	    "l8": "iso885914",
	    "l9": "iso885915",
	    "l10": "iso885916",

	    "isoir14": "iso646jp",
	    "isoir57": "iso646cn",
	    "isoir100": "iso88591",
	    "isoir101": "iso88592",
	    "isoir109": "iso88593",
	    "isoir110": "iso88594",
	    "isoir144": "iso88595",
	    "isoir127": "iso88596",
	    "isoir126": "iso88597",
	    "isoir138": "iso88598",
	    "isoir148": "iso88599",
	    "isoir157": "iso885910",
	    "isoir166": "tis620",
	    "isoir179": "iso885913",
	    "isoir199": "iso885914",
	    "isoir203": "iso885915",
	    "isoir226": "iso885916",

	    "cp819": "iso88591",
	    "ibm819": "iso88591",

	    "cyrillic": "iso88595",

	    "arabic": "iso88596",
	    "arabic8": "iso88596",
	    "ecma114": "iso88596",
	    "asmo708": "iso88596",

	    "greek" : "iso88597",
	    "greek8" : "iso88597",
	    "ecma118" : "iso88597",
	    "elot928" : "iso88597",

	    "hebrew": "iso88598",
	    "hebrew8": "iso88598",

	    "turkish": "iso88599",
	    "turkish8": "iso88599",

	    "thai": "iso885911",
	    "thai8": "iso885911",

	    "celtic": "iso885914",
	    "celtic8": "iso885914",
	    "isoceltic": "iso885914",

	    "tis6200": "tis620",
	    "tis62025291": "tis620",
	    "tis62025330": "tis620",

	    "10000": "macroman",
	    "10006": "macgreek",
	    "10007": "maccyrillic",
	    "10079": "maciceland",
	    "10081": "macturkish",

	    "cspc8codepage437": "cp437",
	    "cspc775baltic": "cp775",
	    "cspc850multilingual": "cp850",
	    "cspcp852": "cp852",
	    "cspc862latinhebrew": "cp862",
	    "cpgr": "cp869",

	    "msee": "cp1250",
	    "mscyrl": "cp1251",
	    "msansi": "cp1252",
	    "msgreek": "cp1253",
	    "msturk": "cp1254",
	    "mshebr": "cp1255",
	    "msarab": "cp1256",
	    "winbaltrim": "cp1257",

	    "cp20866": "koi8r",
	    "20866": "koi8r",
	    "ibm878": "koi8r",
	    "cskoi8r": "koi8r",

	    "cp21866": "koi8u",
	    "21866": "koi8u",
	    "ibm1168": "koi8u",

	    "strk10482002": "rk1048",

	    "tcvn5712": "tcvn",
	    "tcvn57121": "tcvn",

	    "gb198880": "iso646cn",
	    "cn": "iso646cn",

	    "csiso14jisc6220ro": "iso646jp",
	    "jisc62201969ro": "iso646jp",
	    "jp": "iso646jp",

	    "cshproman8": "hproman8",
	    "r8": "hproman8",
	    "roman8": "hproman8",
	    "xroman8": "hproman8",
	    "ibm1051": "hproman8",

	    "mac": "macintosh",
	    "csmacintosh": "macintosh",
	};
	return sbcsData;
}

var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;

function requireSbcsDataGenerated () {
	if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
	hasRequiredSbcsDataGenerated = 1;

	// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
	sbcsDataGenerated = {
	  "437": "cp437",
	  "737": "cp737",
	  "775": "cp775",
	  "850": "cp850",
	  "852": "cp852",
	  "855": "cp855",
	  "856": "cp856",
	  "857": "cp857",
	  "858": "cp858",
	  "860": "cp860",
	  "861": "cp861",
	  "862": "cp862",
	  "863": "cp863",
	  "864": "cp864",
	  "865": "cp865",
	  "866": "cp866",
	  "869": "cp869",
	  "874": "windows874",
	  "922": "cp922",
	  "1046": "cp1046",
	  "1124": "cp1124",
	  "1125": "cp1125",
	  "1129": "cp1129",
	  "1133": "cp1133",
	  "1161": "cp1161",
	  "1162": "cp1162",
	  "1163": "cp1163",
	  "1250": "windows1250",
	  "1251": "windows1251",
	  "1252": "windows1252",
	  "1253": "windows1253",
	  "1254": "windows1254",
	  "1255": "windows1255",
	  "1256": "windows1256",
	  "1257": "windows1257",
	  "1258": "windows1258",
	  "28591": "iso88591",
	  "28592": "iso88592",
	  "28593": "iso88593",
	  "28594": "iso88594",
	  "28595": "iso88595",
	  "28596": "iso88596",
	  "28597": "iso88597",
	  "28598": "iso88598",
	  "28599": "iso88599",
	  "28600": "iso885910",
	  "28601": "iso885911",
	  "28603": "iso885913",
	  "28604": "iso885914",
	  "28605": "iso885915",
	  "28606": "iso885916",
	  "windows874": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win874": "windows874",
	  "cp874": "windows874",
	  "windows1250": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1250": "windows1250",
	  "cp1250": "windows1250",
	  "windows1251": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1251": "windows1251",
	  "cp1251": "windows1251",
	  "windows1252": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1252": "windows1252",
	  "cp1252": "windows1252",
	  "windows1253": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1253": "windows1253",
	  "cp1253": "windows1253",
	  "windows1254": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1254": "windows1254",
	  "cp1254": "windows1254",
	  "windows1255": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1255": "windows1255",
	  "cp1255": "windows1255",
	  "windows1256": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1256": "windows1256",
	  "cp1256": "windows1256",
	  "windows1257": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1257": "windows1257",
	  "cp1257": "windows1257",
	  "windows1258": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1258": "windows1258",
	  "cp1258": "windows1258",
	  "iso88591": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28591": "iso88591",
	  "iso88592": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28592": "iso88592",
	  "iso88593": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28593": "iso88593",
	  "iso88594": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28594": "iso88594",
	  "iso88595": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28595": "iso88595",
	  "iso88596": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28596": "iso88596",
	  "iso88597": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28597": "iso88597",
	  "iso88598": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28598": "iso88598",
	  "iso88599": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28599": "iso88599",
	  "iso885910": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28600": "iso885910",
	  "iso885911": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28601": "iso885911",
	  "iso885913": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28603": "iso885913",
	  "iso885914": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28604": "iso885914",
	  "iso885915": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28605": "iso885915",
	  "iso885916": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28606": "iso885916",
	  "cp437": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm437": "cp437",
	  "csibm437": "cp437",
	  "cp737": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm737": "cp737",
	  "csibm737": "cp737",
	  "cp775": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm775": "cp775",
	  "csibm775": "cp775",
	  "cp850": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm850": "cp850",
	  "csibm850": "cp850",
	  "cp852": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm852": "cp852",
	  "csibm852": "cp852",
	  "cp855": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm855": "cp855",
	  "csibm855": "cp855",
	  "cp856": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm856": "cp856",
	  "csibm856": "cp856",
	  "cp857": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm857": "cp857",
	  "csibm857": "cp857",
	  "cp858": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm858": "cp858",
	  "csibm858": "cp858",
	  "cp860": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm860": "cp860",
	  "csibm860": "cp860",
	  "cp861": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm861": "cp861",
	  "csibm861": "cp861",
	  "cp862": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm862": "cp862",
	  "csibm862": "cp862",
	  "cp863": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm863": "cp863",
	  "csibm863": "cp863",
	  "cp864": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "ibm864": "cp864",
	  "csibm864": "cp864",
	  "cp865": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm865": "cp865",
	  "csibm865": "cp865",
	  "cp866": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm866": "cp866",
	  "csibm866": "cp866",
	  "cp869": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm869": "cp869",
	  "csibm869": "cp869",
	  "cp922": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm922": "cp922",
	  "csibm922": "cp922",
	  "cp1046": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1046": "cp1046",
	  "csibm1046": "cp1046",
	  "cp1124": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1124": "cp1124",
	  "csibm1124": "cp1124",
	  "cp1125": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1125": "cp1125",
	  "csibm1125": "cp1125",
	  "cp1129": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1129": "cp1129",
	  "csibm1129": "cp1129",
	  "cp1133": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1133": "cp1133",
	  "csibm1133": "cp1133",
	  "cp1161": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1161": "cp1161",
	  "csibm1161": "cp1161",
	  "cp1162": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1162": "cp1162",
	  "csibm1162": "cp1162",
	  "cp1163": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1163": "cp1163",
	  "csibm1163": "cp1163",
	  "maccroatian": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maccyrillic": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macgreek": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maciceland": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macroman": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macromania": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macthai": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macturkish": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macukraine": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8r": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8u": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8ru": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8t": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "armscii8": {
	    "type": "_sbcs",
	    "chars": ")(.,-"
	  },
	  "rk1048": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tcvn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "georgianacademy": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "georgianps": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "pt154": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "viscii": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "iso646cn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "iso646jp": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "hproman8": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macintosh": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ascii": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tis620": {
	    "type": "_sbcs",
	    "chars": ""
	  }
	};
	return sbcsDataGenerated;
}

var dbcsCodec = {};

var hasRequiredDbcsCodec;

function requireDbcsCodec () {
	if (hasRequiredDbcsCodec) return dbcsCodec;
	hasRequiredDbcsCodec = 1;
	var Buffer = requireSafer().Buffer;

	// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
	// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
	// To save memory and loading time, we read table files only when requested.

	dbcsCodec._dbcs = DBCSCodec;

	var UNASSIGNED = -1,
	    GB18030_CODE = -2,
	    SEQ_START  = -10,
	    NODE_START = -1000,
	    UNASSIGNED_NODE = new Array(0x100),
	    DEF_CHAR = -1;

	for (var i = 0; i < 0x100; i++)
	    UNASSIGNED_NODE[i] = UNASSIGNED;


	// Class DBCSCodec reads and initializes mapping tables.
	function DBCSCodec(codecOptions, iconv) {
	    this.encodingName = codecOptions.encodingName;
	    if (!codecOptions)
	        throw new Error("DBCS codec is called without the data.")
	    if (!codecOptions.table)
	        throw new Error("Encoding '" + this.encodingName + "' has no data.");

	    // Load tables.
	    var mappingTable = codecOptions.table();


	    // Decode tables: MBCS -> Unicode.

	    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
	    // Trie root is decodeTables[0].
	    // Values: >=  0 -> unicode character code. can be > 0xFFFF
	    //         == UNASSIGNED -> unknown/unassigned sequence.
	    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
	    //         <= NODE_START -> index of the next node in our trie to process next byte.
	    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
	    this.decodeTables = [];
	    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

	    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
	    this.decodeTableSeq = [];

	    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
	    for (var i = 0; i < mappingTable.length; i++)
	        this._addDecodeChunk(mappingTable[i]);

	    this.defaultCharUnicode = iconv.defaultCharUnicode;

	    
	    // Encode tables: Unicode -> DBCS.

	    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
	    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
	    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
	    //         == UNASSIGNED -> no conversion found. Output a default char.
	    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
	    this.encodeTable = [];
	    
	    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
	    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
	    // means end of sequence (needed when one sequence is a strict subsequence of another).
	    // Objects are kept separately from encodeTable to increase performance.
	    this.encodeTableSeq = [];

	    // Some chars can be decoded, but need not be encoded.
	    var skipEncodeChars = {};
	    if (codecOptions.encodeSkipVals)
	        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
	            var val = codecOptions.encodeSkipVals[i];
	            if (typeof val === 'number')
	                skipEncodeChars[val] = true;
	            else
	                for (var j = val.from; j <= val.to; j++)
	                    skipEncodeChars[j] = true;
	        }
	        
	    // Use decode trie to recursively fill out encode tables.
	    this._fillEncodeTable(0, 0, skipEncodeChars);

	    // Add more encoding pairs when needed.
	    if (codecOptions.encodeAdd) {
	        for (var uChar in codecOptions.encodeAdd)
	            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
	                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
	    }

	    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


	    // Load & create GB18030 tables when needed.
	    if (typeof codecOptions.gb18030 === 'function') {
	        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

	        // Add GB18030 decode tables.
	        var thirdByteNodeIdx = this.decodeTables.length;
	        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

	        var fourthByteNodeIdx = this.decodeTables.length;
	        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

	        for (var i = 0x81; i <= 0xFE; i++) {
	            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
	            var secondByteNode = this.decodeTables[secondByteNodeIdx];
	            for (var j = 0x30; j <= 0x39; j++)
	                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
	        }
	        for (var i = 0x81; i <= 0xFE; i++)
	            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
	        for (var i = 0x30; i <= 0x39; i++)
	            fourthByteNode[i] = GB18030_CODE;
	    }        
	}

	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;

	// Decoder helpers
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
	    var bytes = [];
	    for (; addr > 0; addr >>= 8)
	        bytes.push(addr & 0xFF);
	    if (bytes.length == 0)
	        bytes.push(0);

	    var node = this.decodeTables[0];
	    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
	        var val = node[bytes[i]];

	        if (val == UNASSIGNED) { // Create new node.
	            node[bytes[i]] = NODE_START - this.decodeTables.length;
	            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
	        }
	        else if (val <= NODE_START) { // Existing node.
	            node = this.decodeTables[NODE_START - val];
	        }
	        else
	            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
	    }
	    return node;
	};


	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
	    // First element of chunk is the hex mbcs code where we start.
	    var curAddr = parseInt(chunk[0], 16);

	    // Choose the decoding node where we'll write our chars.
	    var writeTable = this._getDecodeTrieNode(curAddr);
	    curAddr = curAddr & 0xFF;

	    // Write all other elements of the chunk to the table.
	    for (var k = 1; k < chunk.length; k++) {
	        var part = chunk[k];
	        if (typeof part === "string") { // String, write as-is.
	            for (var l = 0; l < part.length;) {
	                var code = part.charCodeAt(l++);
	                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
	                    var codeTrail = part.charCodeAt(l++);
	                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
	                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
	                    else
	                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
	                }
	                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
	                    var len = 0xFFF - code + 2;
	                    var seq = [];
	                    for (var m = 0; m < len; m++)
	                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

	                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
	                    this.decodeTableSeq.push(seq);
	                }
	                else
	                    writeTable[curAddr++] = code; // Basic char
	            }
	        } 
	        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
	            var charCode = writeTable[curAddr - 1] + 1;
	            for (var l = 0; l < part; l++)
	                writeTable[curAddr++] = charCode++;
	        }
	        else
	            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
	    }
	    if (curAddr > 0xFF)
	        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};

	// Encoder helpers
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
	    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
	    if (this.encodeTable[high] === undefined)
	        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
	    return this.encodeTable[high];
	};

	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;
	    if (bucket[low] <= SEQ_START)
	        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
	    else if (bucket[low] == UNASSIGNED)
	        bucket[low] = dbcsCode;
	};

	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
	    
	    // Get the root of character tree according to first character of the sequence.
	    var uCode = seq[0];
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;

	    var node;
	    if (bucket[low] <= SEQ_START) {
	        // There's already a sequence with  - use it.
	        node = this.encodeTableSeq[SEQ_START-bucket[low]];
	    }
	    else {
	        // There was no sequence object - allocate a new one.
	        node = {};
	        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
	        bucket[low] = SEQ_START - this.encodeTableSeq.length;
	        this.encodeTableSeq.push(node);
	    }

	    // Traverse the character tree, allocating new nodes as needed.
	    for (var j = 1; j < seq.length-1; j++) {
	        var oldVal = node[uCode];
	        if (typeof oldVal === 'object')
	            node = oldVal;
	        else {
	            node = node[uCode] = {};
	            if (oldVal !== undefined)
	                node[DEF_CHAR] = oldVal;
	        }
	    }

	    // Set the leaf to given dbcsCode.
	    uCode = seq[seq.length-1];
	    node[uCode] = dbcsCode;
	};

	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
	    var node = this.decodeTables[nodeIdx];
	    for (var i = 0; i < 0x100; i++) {
	        var uCode = node[i];
	        var mbCode = prefix + i;
	        if (skipEncodeChars[mbCode])
	            continue;

	        if (uCode >= 0)
	            this._setEncodeChar(uCode, mbCode);
	        else if (uCode <= NODE_START)
	            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
	        else if (uCode <= SEQ_START)
	            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
	    }
	};



	// == Encoder ==================================================================

	function DBCSEncoder(options, codec) {
	    // Encoder state
	    this.leadSurrogate = -1;
	    this.seqObj = undefined;
	    
	    // Static data
	    this.encodeTable = codec.encodeTable;
	    this.encodeTableSeq = codec.encodeTableSeq;
	    this.defaultCharSingleByte = codec.defCharSB;
	    this.gb18030 = codec.gb18030;
	}

	DBCSEncoder.prototype.write = function(str) {
	    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
	        leadSurrogate = this.leadSurrogate,
	        seqObj = this.seqObj, nextChar = -1,
	        i = 0, j = 0;

	    while (true) {
	        // 0. Get next character.
	        if (nextChar === -1) {
	            if (i == str.length) break;
	            var uCode = str.charCodeAt(i++);
	        }
	        else {
	            var uCode = nextChar;
	            nextChar = -1;    
	        }

	        // 1. Handle surrogates.
	        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
	            if (uCode < 0xDC00) { // We've got lead surrogate.
	                if (leadSurrogate === -1) {
	                    leadSurrogate = uCode;
	                    continue;
	                } else {
	                    leadSurrogate = uCode;
	                    // Double lead surrogate found.
	                    uCode = UNASSIGNED;
	                }
	            } else { // We've got trail surrogate.
	                if (leadSurrogate !== -1) {
	                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
	                    leadSurrogate = -1;
	                } else {
	                    // Incomplete surrogate pair - only trail surrogate found.
	                    uCode = UNASSIGNED;
	                }
	                
	            }
	        }
	        else if (leadSurrogate !== -1) {
	            // Incomplete surrogate pair - only lead surrogate found.
	            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
	            leadSurrogate = -1;
	        }

	        // 2. Convert uCode character.
	        var dbcsCode = UNASSIGNED;
	        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
	            var resCode = seqObj[uCode];
	            if (typeof resCode === 'object') { // Sequence continues.
	                seqObj = resCode;
	                continue;

	            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
	                dbcsCode = resCode;

	            } else if (resCode == undefined) { // Current character is not part of the sequence.

	                // Try default character for this sequence
	                resCode = seqObj[DEF_CHAR];
	                if (resCode !== undefined) {
	                    dbcsCode = resCode; // Found. Write it.
	                    nextChar = uCode; // Current character will be written too in the next iteration.

	                }
	            }
	            seqObj = undefined;
	        }
	        else if (uCode >= 0) {  // Regular character
	            var subtable = this.encodeTable[uCode >> 8];
	            if (subtable !== undefined)
	                dbcsCode = subtable[uCode & 0xFF];
	            
	            if (dbcsCode <= SEQ_START) { // Sequence start
	                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
	                continue;
	            }

	            if (dbcsCode == UNASSIGNED && this.gb18030) {
	                // Use GB18030 algorithm to find character(s) to write.
	                var idx = findIdx(this.gb18030.uChars, uCode);
	                if (idx != -1) {
	                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
	                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
	                    newBuf[j++] = 0x30 + dbcsCode;
	                    continue;
	                }
	            }
	        }

	        // 3. Write dbcsCode character.
	        if (dbcsCode === UNASSIGNED)
	            dbcsCode = this.defaultCharSingleByte;
	        
	        if (dbcsCode < 0x100) {
	            newBuf[j++] = dbcsCode;
	        }
	        else if (dbcsCode < 0x10000) {
	            newBuf[j++] = dbcsCode >> 8;   // high byte
	            newBuf[j++] = dbcsCode & 0xFF; // low byte
	        }
	        else {
	            newBuf[j++] = dbcsCode >> 16;
	            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
	            newBuf[j++] = dbcsCode & 0xFF;
	        }
	    }

	    this.seqObj = seqObj;
	    this.leadSurrogate = leadSurrogate;
	    return newBuf.slice(0, j);
	};

	DBCSEncoder.prototype.end = function() {
	    if (this.leadSurrogate === -1 && this.seqObj === undefined)
	        return; // All clean. Most often case.

	    var newBuf = Buffer.alloc(10), j = 0;

	    if (this.seqObj) { // We're in the sequence.
	        var dbcsCode = this.seqObj[DEF_CHAR];
	        if (dbcsCode !== undefined) { // Write beginning of the sequence.
	            if (dbcsCode < 0x100) {
	                newBuf[j++] = dbcsCode;
	            }
	            else {
	                newBuf[j++] = dbcsCode >> 8;   // high byte
	                newBuf[j++] = dbcsCode & 0xFF; // low byte
	            }
	        }
	        this.seqObj = undefined;
	    }

	    if (this.leadSurrogate !== -1) {
	        // Incomplete surrogate pair - only lead surrogate found.
	        newBuf[j++] = this.defaultCharSingleByte;
	        this.leadSurrogate = -1;
	    }
	    
	    return newBuf.slice(0, j);
	};

	// Export for testing
	DBCSEncoder.prototype.findIdx = findIdx;


	// == Decoder ==================================================================

	function DBCSDecoder(options, codec) {
	    // Decoder state
	    this.nodeIdx = 0;
	    this.prevBuf = Buffer.alloc(0);

	    // Static data
	    this.decodeTables = codec.decodeTables;
	    this.decodeTableSeq = codec.decodeTableSeq;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	    this.gb18030 = codec.gb18030;
	}

	DBCSDecoder.prototype.write = function(buf) {
	    var newBuf = Buffer.alloc(buf.length*2),
	        nodeIdx = this.nodeIdx, 
	        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
	        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
	        uCode;

	    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
	        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
	    
	    for (var i = 0, j = 0; i < buf.length; i++) {
	        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

	        // Lookup in current trie node.
	        var uCode = this.decodeTables[nodeIdx][curByte];

	        if (uCode >= 0) ;
	        else if (uCode === UNASSIGNED) { // Unknown char.
	            // TODO: Callback with seq.
	            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
	            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
	            uCode = this.defaultCharUnicode.charCodeAt(0);
	        }
	        else if (uCode === GB18030_CODE) {
	            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
	            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
	            var idx = findIdx(this.gb18030.gbChars, ptr);
	            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
	        }
	        else if (uCode <= NODE_START) { // Go to next trie node.
	            nodeIdx = NODE_START - uCode;
	            continue;
	        }
	        else if (uCode <= SEQ_START) { // Output a sequence of chars.
	            var seq = this.decodeTableSeq[SEQ_START - uCode];
	            for (var k = 0; k < seq.length - 1; k++) {
	                uCode = seq[k];
	                newBuf[j++] = uCode & 0xFF;
	                newBuf[j++] = uCode >> 8;
	            }
	            uCode = seq[seq.length-1];
	        }
	        else
	            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

	        // Write the character to buffer, handling higher planes using surrogate pair.
	        if (uCode > 0xFFFF) { 
	            uCode -= 0x10000;
	            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
	            newBuf[j++] = uCodeLead & 0xFF;
	            newBuf[j++] = uCodeLead >> 8;

	            uCode = 0xDC00 + uCode % 0x400;
	        }
	        newBuf[j++] = uCode & 0xFF;
	        newBuf[j++] = uCode >> 8;

	        // Reset trie node.
	        nodeIdx = 0; seqStart = i+1;
	    }

	    this.nodeIdx = nodeIdx;
	    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
	    return newBuf.slice(0, j).toString('ucs2');
	};

	DBCSDecoder.prototype.end = function() {
	    var ret = '';

	    // Try to parse all remaining chars.
	    while (this.prevBuf.length > 0) {
	        // Skip 1 character in the buffer.
	        ret += this.defaultCharUnicode;
	        var buf = this.prevBuf.slice(1);

	        // Parse remaining as usual.
	        this.prevBuf = Buffer.alloc(0);
	        this.nodeIdx = 0;
	        if (buf.length > 0)
	            ret += this.write(buf);
	    }

	    this.nodeIdx = 0;
	    return ret;
	};

	// Binary search for GB18030. Returns largest i such that table[i] <= val.
	function findIdx(table, val) {
	    if (table[0] > val)
	        return -1;

	    var l = 0, r = table.length;
	    while (l < r-1) { // always table[l] <= val < table[r]
	        var mid = l + Math.floor((r-l+1)/2);
	        if (table[mid] <= val)
	            l = mid;
	        else
	            r = mid;
	    }
	    return l;
	}
	return dbcsCodec;
}

var require$$0 = [
	[
		"0",
		"\u0000",
		128
	],
	[
		"a1",
		"",
		62
	],
	[
		"8140",
		"",
		9,
		""
	],
	[
		"8180",
		""
	],
	[
		"81b8",
		""
	],
	[
		"81c8",
		""
	],
	[
		"81da",
		""
	],
	[
		"81f0",
		""
	],
	[
		"81fc",
		""
	],
	[
		"824f",
		"",
		9
	],
	[
		"8260",
		"",
		25
	],
	[
		"8281",
		"",
		25
	],
	[
		"829f",
		"",
		82
	],
	[
		"8340",
		"",
		62
	],
	[
		"8380",
		"",
		22
	],
	[
		"839f",
		"",
		16,
		"",
		6
	],
	[
		"83bf",
		"",
		16,
		"",
		6
	],
	[
		"8440",
		"",
		5,
		"",
		25
	],
	[
		"8470",
		"",
		5,
		"",
		7
	],
	[
		"8480",
		"",
		17
	],
	[
		"849f",
		""
	],
	[
		"8740",
		"",
		19,
		"",
		9
	],
	[
		"875f",
		""
	],
	[
		"877e",
		""
	],
	[
		"8780",
		"",
		4,
		""
	],
	[
		"889f",
		""
	],
	[
		"8940",
		""
	],
	[
		"8980",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a80",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b80",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8c80",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d80",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8e80",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8f80",
		""
	],
	[
		"9040",
		""
	],
	[
		"9080",
		""
	],
	[
		"9140",
		""
	],
	[
		"9180",
		""
	],
	[
		"9240",
		""
	],
	[
		"9280",
		""
	],
	[
		"9340",
		""
	],
	[
		"9380",
		""
	],
	[
		"9440",
		""
	],
	[
		"9480",
		""
	],
	[
		"9540",
		""
	],
	[
		"9580",
		""
	],
	[
		"9640",
		""
	],
	[
		"9680",
		""
	],
	[
		"9740",
		""
	],
	[
		"9780",
		""
	],
	[
		"9840",
		""
	],
	[
		"989f",
		""
	],
	[
		"9940",
		""
	],
	[
		"9980",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9a80",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b80",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9c80",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9d80",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9e80",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f80",
		""
	],
	[
		"e040",
		""
	],
	[
		"e080",
		""
	],
	[
		"e140",
		""
	],
	[
		"e180",
		""
	],
	[
		"e240",
		""
	],
	[
		"e280",
		""
	],
	[
		"e340",
		""
	],
	[
		"e380",
		""
	],
	[
		"e440",
		""
	],
	[
		"e480",
		""
	],
	[
		"e540",
		""
	],
	[
		"e580",
		""
	],
	[
		"e640",
		""
	],
	[
		"e680",
		""
	],
	[
		"e740",
		""
	],
	[
		"e780",
		""
	],
	[
		"e840",
		""
	],
	[
		"e880",
		""
	],
	[
		"e940",
		""
	],
	[
		"e980",
		""
	],
	[
		"ea40",
		""
	],
	[
		"ea80",
		""
	],
	[
		"ed40",
		""
	],
	[
		"ed80",
		""
	],
	[
		"ee40",
		""
	],
	[
		"ee80",
		""
	],
	[
		"eeef",
		"",
		9,
		""
	],
	[
		"f040",
		"",
		62
	],
	[
		"f080",
		"",
		124
	],
	[
		"f140",
		"",
		62
	],
	[
		"f180",
		"",
		124
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		124
	],
	[
		"f340",
		"",
		62
	],
	[
		"f380",
		"",
		124
	],
	[
		"f440",
		"",
		62
	],
	[
		"f480",
		"",
		124
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		124
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		124
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		124
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		124
	],
	[
		"f940",
		""
	],
	[
		"fa40",
		"",
		9,
		"",
		9,
		""
	],
	[
		"fa80",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fb80",
		""
	],
	[
		"fc40",
		""
	]
];

var require$$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8ea1",
		"",
		62
	],
	[
		"a1a1",
		"",
		9,
		""
	],
	[
		"a2a1",
		""
	],
	[
		"a2ba",
		""
	],
	[
		"a2ca",
		""
	],
	[
		"a2dc",
		""
	],
	[
		"a2f2",
		""
	],
	[
		"a2fe",
		""
	],
	[
		"a3b0",
		"",
		9
	],
	[
		"a3c1",
		"",
		25
	],
	[
		"a3e1",
		"",
		25
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a8a1",
		""
	],
	[
		"ada1",
		"",
		19,
		"",
		9
	],
	[
		"adc0",
		""
	],
	[
		"addf",
		"",
		4,
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bda1",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fcf1",
		"",
		9,
		""
	],
	[
		"8fa2af",
		""
	],
	[
		"8fa2c2",
		""
	],
	[
		"8fa2eb",
		""
	],
	[
		"8fa6e1",
		""
	],
	[
		"8fa6e7",
		""
	],
	[
		"8fa6e9",
		""
	],
	[
		"8fa6ec",
		""
	],
	[
		"8fa6f1",
		""
	],
	[
		"8fa7c2",
		"",
		10,
		""
	],
	[
		"8fa7f2",
		"",
		10,
		""
	],
	[
		"8fa9a1",
		""
	],
	[
		"8fa9a4",
		""
	],
	[
		"8fa9a6",
		""
	],
	[
		"8fa9a8",
		""
	],
	[
		"8fa9ab",
		""
	],
	[
		"8fa9af",
		""
	],
	[
		"8fa9c1",
		""
	],
	[
		"8faaa1",
		""
	],
	[
		"8faaba",
		""
	],
	[
		"8faba1",
		""
	],
	[
		"8fabbd",
		""
	],
	[
		"8fabc5",
		""
	],
	[
		"8fb0a1",
		""
	],
	[
		"8fb1a1",
		""
	],
	[
		"8fb2a1",
		"",
		4,
		""
	],
	[
		"8fb3a1",
		""
	],
	[
		"8fb4a1",
		""
	],
	[
		"8fb5a1",
		""
	],
	[
		"8fb6a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fb7a1",
		"",
		4,
		""
	],
	[
		"8fb8a1",
		""
	],
	[
		"8fb9a1",
		""
	],
	[
		"8fbaa1",
		"",
		4,
		""
	],
	[
		"8fbba1",
		""
	],
	[
		"8fbca1",
		"",
		4,
		""
	],
	[
		"8fbda1",
		"",
		4,
		""
	],
	[
		"8fbea1",
		"",
		4,
		""
	],
	[
		"8fbfa1",
		""
	],
	[
		"8fc0a1",
		""
	],
	[
		"8fc1a1",
		""
	],
	[
		"8fc2a1",
		""
	],
	[
		"8fc3a1",
		"",
		4,
		""
	],
	[
		"8fc4a1",
		""
	],
	[
		"8fc5a1",
		""
	],
	[
		"8fc6a1",
		""
	],
	[
		"8fc7a1",
		""
	],
	[
		"8fc8a1",
		""
	],
	[
		"8fc9a1",
		"",
		4,
		"",
		4,
		""
	],
	[
		"8fcaa1",
		""
	],
	[
		"8fcba1",
		""
	],
	[
		"8fcca1",
		"",
		9,
		""
	],
	[
		"8fcda1",
		"",
		5,
		""
	],
	[
		"8fcea1",
		"",
		6,
		""
	],
	[
		"8fcfa1",
		""
	],
	[
		"8fd0a1",
		""
	],
	[
		"8fd1a1",
		""
	],
	[
		"8fd2a1",
		"",
		5
	],
	[
		"8fd3a1",
		""
	],
	[
		"8fd4a1",
		"",
		4,
		""
	],
	[
		"8fd5a1",
		""
	],
	[
		"8fd6a1",
		""
	],
	[
		"8fd7a1",
		""
	],
	[
		"8fd8a1",
		""
	],
	[
		"8fd9a1",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8fdaa1",
		"",
		4,
		""
	],
	[
		"8fdba1",
		"",
		6,
		""
	],
	[
		"8fdca1",
		"",
		4,
		""
	],
	[
		"8fdda1",
		"",
		4,
		""
	],
	[
		"8fdea1",
		"",
		4,
		""
	],
	[
		"8fdfa1",
		""
	],
	[
		"8fe0a1",
		""
	],
	[
		"8fe1a1",
		"",
		4,
		""
	],
	[
		"8fe2a1",
		""
	],
	[
		"8fe3a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fe4a1",
		"",
		4,
		""
	],
	[
		"8fe5a1",
		"",
		4,
		""
	],
	[
		"8fe6a1",
		""
	],
	[
		"8fe7a1",
		""
	],
	[
		"8fe8a1",
		"",
		4,
		""
	],
	[
		"8fe9a1",
		"",
		4
	],
	[
		"8feaa1",
		"",
		4,
		""
	],
	[
		"8feba1",
		"",
		4,
		""
	],
	[
		"8feca1",
		""
	],
	[
		"8feda1",
		"",
		4,
		"",
		4,
		""
	]
];

var require$$2 = [
	[
		"0",
		"\u0000",
		127,
		""
	],
	[
		"8140",
		"",
		5,
		"",
		9,
		"",
		6,
		""
	],
	[
		"8180",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8240",
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		11
	],
	[
		"8280",
		"",
		10,
		"",
		4,
		"",
		7,
		"",
		5,
		"",
		8,
		"",
		20,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8340",
		"",
		17,
		"",
		5,
		"",
		10,
		"",
		4,
		"",
		9,
		""
	],
	[
		"8380",
		"",
		5,
		"",
		13,
		"",
		28,
		"",
		4,
		"",
		4,
		"",
		5
	],
	[
		"8440",
		"",
		5,
		"",
		5,
		""
	],
	[
		"8480",
		"",
		9,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		5,
		"",
		10,
		"",
		7,
		""
	],
	[
		"8540",
		"",
		9,
		""
	],
	[
		"8580",
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		""
	],
	[
		"8640",
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8680",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8740",
		"",
		7,
		"",
		11,
		"",
		4,
		"",
		4
	],
	[
		"8780",
		"",
		7,
		"",
		6,
		"",
		14,
		"",
		10,
		"",
		6,
		"",
		12,
		"",
		8,
		"",
		5,
		"",
		6
	],
	[
		"8840",
		"",
		9,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8880",
		"",
		4,
		"",
		6,
		"",
		8,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		7
	],
	[
		"8940",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		16,
		""
	],
	[
		"8980",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		17,
		"",
		10,
		"",
		13,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"8a40",
		"",
		4,
		"",
		12,
		""
	],
	[
		"8a80",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		9,
		"",
		5
	],
	[
		"8b40",
		"",
		8,
		"",
		17,
		"",
		6,
		"",
		13,
		""
	],
	[
		"8b80",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		22,
		"",
		11,
		"",
		25,
		"",
		7,
		"",
		6
	],
	[
		"8c40",
		"",
		7,
		""
	],
	[
		"8c80",
		"",
		8,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		4
	],
	[
		"8d40",
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		9,
		"",
		4
	],
	[
		"8d80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		10,
		"",
		12,
		"",
		21,
		""
	],
	[
		"8e40",
		"",
		21,
		"",
		12,
		"",
		6,
		"",
		12,
		""
	],
	[
		"8e80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		4,
		"",
		6
	],
	[
		"8f40",
		"",
		5,
		"",
		11,
		"",
		8,
		""
	],
	[
		"8f80",
		"",
		6,
		"",
		14,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9040",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9080",
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		18,
		"",
		6
	],
	[
		"9140",
		"",
		6,
		"",
		6,
		"",
		18,
		"",
		4,
		""
	],
	[
		"9180",
		"",
		6,
		"",
		8,
		"",
		9,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		16,
		"",
		13,
		"",
		8,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9280",
		"",
		5,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9340",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9380",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		9,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9440",
		"",
		24,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		8
	],
	[
		"9480",
		"",
		4,
		"",
		4,
		"",
		14,
		"",
		7,
		"",
		7,
		""
	],
	[
		"9540",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9580",
		"",
		4,
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		25,
		"",
		7,
		"",
		5,
		""
	],
	[
		"9640",
		"",
		5,
		"",
		4,
		""
	],
	[
		"9680",
		"",
		7,
		"",
		9,
		"",
		7,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		5
	],
	[
		"9740",
		"",
		7,
		"",
		8,
		"",
		7,
		"",
		9,
		""
	],
	[
		"9780",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		9,
		"",
		4,
		"",
		11,
		"",
		7,
		"",
		16,
		""
	],
	[
		"9840",
		"",
		4,
		"",
		5,
		"",
		9,
		""
	],
	[
		"9880",
		"",
		7,
		"",
		5,
		"",
		11,
		"",
		9,
		"",
		9,
		"",
		11,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9940",
		"",
		4,
		"",
		10,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		7,
		"",
		5
	],
	[
		"9980",
		"",
		114,
		"",
		6
	],
	[
		"9a40",
		"",
		11,
		"",
		7,
		"",
		13,
		""
	],
	[
		"9a80",
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"9b40",
		"",
		4,
		""
	],
	[
		"9b80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9c40",
		"",
		7,
		""
	],
	[
		"9c80",
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		14,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"9d40",
		"",
		7,
		"",
		4,
		"",
		9,
		"",
		6,
		""
	],
	[
		"9d80",
		"",
		9,
		"",
		5,
		"",
		6,
		"",
		12,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		10,
		""
	],
	[
		"9e40",
		"",
		7,
		"",
		32,
		"",
		7,
		"",
		6,
		"",
		6
	],
	[
		"9e80",
		"",
		9,
		"",
		17,
		"",
		13,
		"",
		11,
		"",
		12,
		"",
		12,
		""
	],
	[
		"9f40",
		"",
		6,
		"",
		10,
		"",
		4,
		"",
		10,
		"",
		7,
		""
	],
	[
		"9f80",
		"",
		13,
		"",
		12,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		8,
		"",
		9,
		"",
		4
	],
	[
		"a040",
		"",
		9,
		"",
		5,
		"",
		9,
		"",
		11,
		"",
		19
	],
	[
		"a080",
		"",
		9,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		11,
		"",
		6,
		""
	],
	[
		"a1a1",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9
	],
	[
		"a2b1",
		"",
		19,
		"",
		19,
		"",
		9
	],
	[
		"a2e5",
		"",
		9
	],
	[
		"a2f1",
		"",
		11
	],
	[
		"a3a1",
		"",
		88,
		""
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a6e0",
		""
	],
	[
		"a6ee",
		""
	],
	[
		"a6f4",
		""
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a840",
		"",
		35,
		"",
		6
	],
	[
		"a880",
		"",
		7,
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a8bd",
		""
	],
	[
		"a8c0",
		""
	],
	[
		"a8c5",
		"",
		36
	],
	[
		"a940",
		"",
		8,
		""
	],
	[
		"a959",
		""
	],
	[
		"a95c",
		""
	],
	[
		"a960",
		"",
		9,
		"",
		8
	],
	[
		"a980",
		"",
		4,
		""
	],
	[
		"a996",
		""
	],
	[
		"a9a4",
		"",
		75
	],
	[
		"aa40",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"aa80",
		"",
		7,
		"",
		10,
		""
	],
	[
		"ab40",
		"",
		11,
		"",
		4,
		"",
		5,
		"",
		4
	],
	[
		"ab80",
		"",
		6,
		"",
		4
	],
	[
		"ac40",
		"",
		10,
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11
	],
	[
		"ac80",
		"",
		6,
		"",
		12,
		"",
		4,
		""
	],
	[
		"ad40",
		"",
		10,
		"",
		7,
		"",
		15,
		"",
		12
	],
	[
		"ad80",
		"",
		9,
		"",
		8,
		"",
		6,
		""
	],
	[
		"ae40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"ae80",
		"",
		7,
		"",
		6,
		"",
		4,
		""
	],
	[
		"af40",
		"",
		4,
		""
	],
	[
		"af80",
		""
	],
	[
		"b040",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		7,
		""
	],
	[
		"b080",
		"",
		7,
		"",
		8,
		"",
		9,
		""
	],
	[
		"b140",
		"",
		4,
		"",
		7,
		"",
		10,
		""
	],
	[
		"b180",
		"",
		4,
		"",
		7,
		"",
		7,
		""
	],
	[
		"b240",
		"",
		11,
		"",
		5,
		"",
		11,
		"",
		4
	],
	[
		"b280",
		"",
		12,
		"",
		8,
		"",
		4,
		""
	],
	[
		"b340",
		"",
		5,
		""
	],
	[
		"b380",
		"",
		11,
		"",
		7,
		"",
		6,
		""
	],
	[
		"b440",
		"",
		7,
		"",
		9
	],
	[
		"b480",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"b540",
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		8,
		""
	],
	[
		"b580",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b640",
		"",
		6,
		"",
		11,
		"",
		10,
		"",
		4,
		"",
		5,
		""
	],
	[
		"b680",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b740",
		"",
		14,
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		16
	],
	[
		"b780",
		"",
		6,
		""
	],
	[
		"b840",
		"",
		4,
		"",
		10,
		"",
		10,
		"",
		9,
		"",
		5,
		""
	],
	[
		"b880",
		"",
		4,
		""
	],
	[
		"b940",
		"",
		5,
		"",
		10,
		"",
		6,
		""
	],
	[
		"b980",
		"",
		7,
		""
	],
	[
		"ba40",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		5,
		""
	],
	[
		"ba80",
		"",
		4,
		"",
		5,
		"",
		12,
		"",
		5,
		""
	],
	[
		"bb40",
		"",
		9,
		"",
		36,
		"",
		5,
		"",
		9
	],
	[
		"bb80",
		"",
		6,
		"",
		4,
		""
	],
	[
		"bc40",
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		13,
		"",
		5
	],
	[
		"bc80",
		"",
		14,
		"",
		6,
		""
	],
	[
		"bd40",
		"",
		54,
		"",
		7
	],
	[
		"bd80",
		"",
		32,
		""
	],
	[
		"be40",
		"",
		12,
		"",
		6,
		"",
		42
	],
	[
		"be80",
		"",
		32,
		""
	],
	[
		"bf40",
		"",
		62
	],
	[
		"bf80",
		"",
		4,
		"",
		4,
		"",
		21,
		""
	],
	[
		"c040",
		"",
		35,
		"",
		23,
		""
	],
	[
		"c080",
		"",
		6,
		"",
		9,
		""
	],
	[
		"c140",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c180",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c280",
		"",
		13,
		"",
		5,
		"",
		11,
		""
	],
	[
		"c340",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c380",
		"",
		12,
		"",
		4,
		""
	],
	[
		"c440",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"c480",
		"",
		7,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c540",
		"",
		14,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c580",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c640",
		""
	],
	[
		"c680",
		"",
		4,
		"",
		9,
		""
	],
	[
		"c740",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"c780",
		""
	],
	[
		"c840",
		"",
		4,
		"",
		5,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c880",
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"c940",
		"",
		4,
		"",
		7,
		"",
		12,
		""
	],
	[
		"c980",
		"",
		4,
		"",
		4,
		"",
		10,
		""
	],
	[
		"ca40",
		"",
		8,
		"",
		8,
		"",
		9,
		"",
		4,
		"",
		10
	],
	[
		"ca80",
		"",
		4,
		"",
		8,
		""
	],
	[
		"cb40",
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cb80",
		"",
		5,
		"",
		6,
		"",
		14,
		""
	],
	[
		"cc40",
		"",
		4,
		"",
		10,
		"",
		15,
		"",
		13,
		""
	],
	[
		"cc80",
		"",
		11,
		"",
		4,
		"",
		7,
		""
	],
	[
		"cd40",
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		""
	],
	[
		"cd80",
		""
	],
	[
		"ce40",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"ce80",
		"",
		4,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cf40",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		9
	],
	[
		"cf80",
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"d040",
		"",
		13,
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"d080",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"d140",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"d180",
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"d240",
		"",
		8,
		"",
		24,
		"",
		5,
		"",
		19,
		""
	],
	[
		"d280",
		"",
		26,
		""
	],
	[
		"d340",
		"",
		30,
		"",
		6
	],
	[
		"d380",
		"",
		4,
		"",
		5,
		"",
		21,
		""
	],
	[
		"d440",
		"",
		31,
		"",
		8,
		"",
		21
	],
	[
		"d480",
		"",
		25,
		"",
		6,
		""
	],
	[
		"d540",
		"",
		7,
		"",
		7,
		"",
		46
	],
	[
		"d580",
		"",
		32,
		""
	],
	[
		"d640",
		"",
		34,
		"",
		27
	],
	[
		"d680",
		"",
		30,
		""
	],
	[
		"d740",
		"",
		31,
		"",
		4,
		"",
		25
	],
	[
		"d780",
		"",
		24,
		""
	],
	[
		"d840",
		"",
		8,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"d880",
		"",
		6,
		"",
		20,
		""
	],
	[
		"d940",
		"",
		62
	],
	[
		"d980",
		"",
		32,
		""
	],
	[
		"da40",
		"",
		14,
		"",
		8,
		"",
		4,
		"",
		9,
		""
	],
	[
		"da80",
		"",
		12,
		""
	],
	[
		"db40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"db80",
		"",
		4,
		"",
		5,
		"",
		11,
		""
	],
	[
		"dc40",
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		11,
		"",
		6,
		"",
		7
	],
	[
		"dc80",
		"",
		10,
		"",
		21,
		""
	],
	[
		"dd40",
		"",
		62
	],
	[
		"dd80",
		"",
		32,
		""
	],
	[
		"de40",
		"",
		32,
		""
	],
	[
		"de80",
		"",
		4,
		""
	],
	[
		"df40",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"df80",
		"",
		4,
		""
	],
	[
		"e040",
		"",
		19,
		""
	],
	[
		"e080",
		"",
		10,
		"",
		6,
		"",
		8,
		""
	],
	[
		"e140",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		""
	],
	[
		"e180",
		"",
		10,
		"",
		9,
		"",
		8,
		""
	],
	[
		"e240",
		"",
		62
	],
	[
		"e280",
		"",
		32,
		"",
		5,
		""
	],
	[
		"e340",
		"",
		45,
		"",
		16
	],
	[
		"e380",
		"",
		7,
		"",
		24,
		""
	],
	[
		"e440",
		"",
		5,
		"",
		24,
		"",
		31
	],
	[
		"e480",
		"",
		32,
		""
	],
	[
		"e540",
		"",
		51,
		"",
		10
	],
	[
		"e580",
		"",
		31,
		""
	],
	[
		"e640",
		"",
		34,
		"",
		27
	],
	[
		"e680",
		"",
		29,
		""
	],
	[
		"e740",
		"",
		7,
		"",
		54
	],
	[
		"e780",
		"",
		32,
		"",
		6,
		"",
		4,
		""
	],
	[
		"e840",
		"",
		14,
		"",
		43,
		""
	],
	[
		"e880",
		"",
		20,
		""
	],
	[
		"e940",
		"",
		7,
		"",
		42
	],
	[
		"e980",
		"",
		32,
		""
	],
	[
		"ea40",
		"",
		27,
		"",
		6,
		""
	],
	[
		"ea80",
		"",
		4,
		"",
		12,
		""
	],
	[
		"eb40",
		"",
		9,
		"",
		7,
		"",
		9,
		"",
		6,
		""
	],
	[
		"eb80",
		"",
		4,
		""
	],
	[
		"ec40",
		"",
		8,
		"",
		4,
		"",
		18,
		"",
		7
	],
	[
		"ec80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ed40",
		"",
		6,
		"",
		46
	],
	[
		"ed80",
		"",
		4,
		"",
		23,
		""
	],
	[
		"ee40",
		"",
		62
	],
	[
		"ee80",
		"",
		32,
		"",
		4,
		"",
		6,
		""
	],
	[
		"ef40",
		"",
		5,
		"",
		37,
		"",
		4
	],
	[
		"ef80",
		"",
		30,
		"",
		4,
		"",
		8,
		""
	],
	[
		"f040",
		"",
		4,
		"",
		28,
		"",
		26
	],
	[
		"f080",
		"",
		9,
		"",
		12,
		"",
		4,
		"",
		6,
		""
	],
	[
		"f140",
		"",
		10,
		"",
		47
	],
	[
		"f180",
		"",
		32,
		""
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		32,
		""
	],
	[
		"f340",
		"",
		17,
		"",
		6,
		"",
		4,
		""
	],
	[
		"f380",
		"",
		8,
		"",
		6,
		""
	],
	[
		"f440",
		"",
		5,
		"",
		10,
		"",
		10,
		"",
		7,
		"",
		5
	],
	[
		"f480",
		"",
		32,
		""
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		32,
		""
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		32,
		"",
		5,
		"",
		5,
		"",
		4,
		"",
		7,
		""
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		4,
		"",
		4,
		""
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		32
	],
	[
		"f940",
		"",
		62
	],
	[
		"f980",
		"",
		32
	],
	[
		"fa40",
		"",
		62
	],
	[
		"fa80",
		"",
		32
	],
	[
		"fb40",
		"",
		27,
		"",
		9,
		""
	],
	[
		"fb80",
		"",
		5,
		"",
		8,
		"",
		5,
		""
	],
	[
		"fc40",
		"",
		8,
		"",
		4,
		"",
		8,
		"",
		6
	],
	[
		"fc80",
		"",
		4,
		"",
		5,
		"",
		8,
		""
	],
	[
		"fd40",
		"",
		4,
		"",
		4,
		"",
		10,
		"",
		38
	],
	[
		"fd80",
		"",
		5,
		"",
		11,
		"",
		4,
		""
	],
	[
		"fe40",
		""
	]
];

var require$$3 = [
	[
		"a140",
		"",
		62
	],
	[
		"a180",
		"",
		32
	],
	[
		"a240",
		"",
		62
	],
	[
		"a280",
		"",
		32
	],
	[
		"a2ab",
		"",
		5
	],
	[
		"a2e3",
		""
	],
	[
		"a2ef",
		""
	],
	[
		"a2fd",
		""
	],
	[
		"a340",
		"",
		62
	],
	[
		"a380",
		"",
		31,
		""
	],
	[
		"a440",
		"",
		62
	],
	[
		"a480",
		"",
		32
	],
	[
		"a4f4",
		"",
		10
	],
	[
		"a540",
		"",
		62
	],
	[
		"a580",
		"",
		32
	],
	[
		"a5f7",
		"",
		7
	],
	[
		"a640",
		"",
		62
	],
	[
		"a680",
		"",
		32
	],
	[
		"a6b9",
		"",
		7
	],
	[
		"a6d9",
		"",
		6
	],
	[
		"a6ec",
		""
	],
	[
		"a6f3",
		""
	],
	[
		"a6f6",
		"",
		8
	],
	[
		"a740",
		"",
		62
	],
	[
		"a780",
		"",
		32
	],
	[
		"a7c2",
		"",
		14
	],
	[
		"a7f2",
		"",
		12
	],
	[
		"a896",
		"",
		10
	],
	[
		"a8bc",
		""
	],
	[
		"a8bf",
		""
	],
	[
		"a8c1",
		""
	],
	[
		"a8ea",
		"",
		20
	],
	[
		"a958",
		""
	],
	[
		"a95b",
		""
	],
	[
		"a95d",
		""
	],
	[
		"a989",
		"",
		11
	],
	[
		"a997",
		"",
		12
	],
	[
		"a9f0",
		"",
		14
	],
	[
		"aaa1",
		"",
		93
	],
	[
		"aba1",
		"",
		93
	],
	[
		"aca1",
		"",
		93
	],
	[
		"ada1",
		"",
		93
	],
	[
		"aea1",
		"",
		93
	],
	[
		"afa1",
		"",
		93
	],
	[
		"d7fa",
		"",
		4
	],
	[
		"f8a1",
		"",
		93
	],
	[
		"f9a1",
		"",
		93
	],
	[
		"faa1",
		"",
		93
	],
	[
		"fba1",
		"",
		93
	],
	[
		"fca1",
		"",
		93
	],
	[
		"fda1",
		"",
		93
	],
	[
		"fe50",
		""
	],
	[
		"fe80",
		"",
		6,
		"",
		93
	]
];

var uChars = [
	128,
	165,
	169,
	178,
	184,
	216,
	226,
	235,
	238,
	244,
	248,
	251,
	253,
	258,
	276,
	284,
	300,
	325,
	329,
	334,
	364,
	463,
	465,
	467,
	469,
	471,
	473,
	475,
	477,
	506,
	594,
	610,
	712,
	716,
	730,
	930,
	938,
	962,
	970,
	1026,
	1104,
	1106,
	8209,
	8215,
	8218,
	8222,
	8231,
	8241,
	8244,
	8246,
	8252,
	8365,
	8452,
	8454,
	8458,
	8471,
	8482,
	8556,
	8570,
	8596,
	8602,
	8713,
	8720,
	8722,
	8726,
	8731,
	8737,
	8740,
	8742,
	8748,
	8751,
	8760,
	8766,
	8777,
	8781,
	8787,
	8802,
	8808,
	8816,
	8854,
	8858,
	8870,
	8896,
	8979,
	9322,
	9372,
	9548,
	9588,
	9616,
	9622,
	9634,
	9652,
	9662,
	9672,
	9676,
	9680,
	9702,
	9735,
	9738,
	9793,
	9795,
	11906,
	11909,
	11913,
	11917,
	11928,
	11944,
	11947,
	11951,
	11956,
	11960,
	11964,
	11979,
	12284,
	12292,
	12312,
	12319,
	12330,
	12351,
	12436,
	12447,
	12535,
	12543,
	12586,
	12842,
	12850,
	12964,
	13200,
	13215,
	13218,
	13253,
	13263,
	13267,
	13270,
	13384,
	13428,
	13727,
	13839,
	13851,
	14617,
	14703,
	14801,
	14816,
	14964,
	15183,
	15471,
	15585,
	16471,
	16736,
	17208,
	17325,
	17330,
	17374,
	17623,
	17997,
	18018,
	18212,
	18218,
	18301,
	18318,
	18760,
	18811,
	18814,
	18820,
	18823,
	18844,
	18848,
	18872,
	19576,
	19620,
	19738,
	19887,
	40870,
	59244,
	59336,
	59367,
	59413,
	59417,
	59423,
	59431,
	59437,
	59443,
	59452,
	59460,
	59478,
	59493,
	63789,
	63866,
	63894,
	63976,
	63986,
	64016,
	64018,
	64021,
	64025,
	64034,
	64037,
	64042,
	65074,
	65093,
	65107,
	65112,
	65127,
	65132,
	65375,
	65510,
	65536
];
var gbChars = [
	0,
	36,
	38,
	45,
	50,
	81,
	89,
	95,
	96,
	100,
	103,
	104,
	105,
	109,
	126,
	133,
	148,
	172,
	175,
	179,
	208,
	306,
	307,
	308,
	309,
	310,
	311,
	312,
	313,
	341,
	428,
	443,
	544,
	545,
	558,
	741,
	742,
	749,
	750,
	805,
	819,
	820,
	7922,
	7924,
	7925,
	7927,
	7934,
	7943,
	7944,
	7945,
	7950,
	8062,
	8148,
	8149,
	8152,
	8164,
	8174,
	8236,
	8240,
	8262,
	8264,
	8374,
	8380,
	8381,
	8384,
	8388,
	8390,
	8392,
	8393,
	8394,
	8396,
	8401,
	8406,
	8416,
	8419,
	8424,
	8437,
	8439,
	8445,
	8482,
	8485,
	8496,
	8521,
	8603,
	8936,
	8946,
	9046,
	9050,
	9063,
	9066,
	9076,
	9092,
	9100,
	9108,
	9111,
	9113,
	9131,
	9162,
	9164,
	9218,
	9219,
	11329,
	11331,
	11334,
	11336,
	11346,
	11361,
	11363,
	11366,
	11370,
	11372,
	11375,
	11389,
	11682,
	11686,
	11687,
	11692,
	11694,
	11714,
	11716,
	11723,
	11725,
	11730,
	11736,
	11982,
	11989,
	12102,
	12336,
	12348,
	12350,
	12384,
	12393,
	12395,
	12397,
	12510,
	12553,
	12851,
	12962,
	12973,
	13738,
	13823,
	13919,
	13933,
	14080,
	14298,
	14585,
	14698,
	15583,
	15847,
	16318,
	16434,
	16438,
	16481,
	16729,
	17102,
	17122,
	17315,
	17320,
	17402,
	17418,
	17859,
	17909,
	17911,
	17915,
	17916,
	17936,
	17939,
	17961,
	18664,
	18703,
	18814,
	18962,
	19043,
	33469,
	33470,
	33471,
	33484,
	33485,
	33490,
	33497,
	33501,
	33505,
	33513,
	33520,
	33536,
	33550,
	37845,
	37921,
	37948,
	38029,
	38038,
	38064,
	38065,
	38066,
	38069,
	38075,
	38076,
	38078,
	39108,
	39109,
	39113,
	39114,
	39115,
	39116,
	39265,
	39394,
	189000
];
var require$$4 = {
	uChars: uChars,
	gbChars: gbChars
};

var require$$5 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8141",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8161",
		"",
		9,
		"",
		5,
		""
	],
	[
		"8181",
		"",
		18,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8241",
		"",
		7,
		"",
		5
	],
	[
		"8261",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8281",
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		17,
		"",
		7,
		"",
		6,
		"",
		7,
		"",
		18
	],
	[
		"8341",
		"",
		5,
		"",
		5,
		"",
		7
	],
	[
		"8361",
		"",
		18,
		""
	],
	[
		"8381",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		46,
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8441",
		"",
		5,
		"",
		8
	],
	[
		"8461",
		"",
		18
	],
	[
		"8481",
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		18,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8541",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4
	],
	[
		"8561",
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8581",
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		29,
		"",
		6,
		"",
		5,
		""
	],
	[
		"8641",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8661",
		"",
		6,
		"",
		10
	],
	[
		"8681",
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		22,
		"",
		4,
		""
	],
	[
		"8741",
		"",
		9,
		"",
		15
	],
	[
		"8761",
		"",
		18,
		""
	],
	[
		"8781",
		"",
		5,
		"",
		7,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		4
	],
	[
		"8841",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"8861",
		"",
		4,
		""
	],
	[
		"8881",
		"",
		15,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		54,
		""
	],
	[
		"8941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8961",
		"",
		10,
		"",
		5,
		""
	],
	[
		"8981",
		"",
		21,
		"",
		18,
		"",
		18,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		15
	],
	[
		"8a41",
		"",
		10,
		"",
		6,
		""
	],
	[
		"8a61",
		"",
		4,
		"",
		18,
		""
	],
	[
		"8a81",
		"",
		4,
		"",
		19,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8b41",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8b61",
		"",
		6,
		"",
		8
	],
	[
		"8b81",
		"",
		52,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		18
	],
	[
		"8c41",
		"",
		15,
		"",
		4
	],
	[
		"8c61",
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"8c81",
		"",
		12,
		"",
		26,
		"",
		50,
		"",
		5,
		"",
		16
	],
	[
		"8d41",
		"",
		16,
		"",
		8
	],
	[
		"8d61",
		"",
		17,
		""
	],
	[
		"8d81",
		"",
		4,
		"",
		33,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		9,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8e41",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8e61",
		"",
		4,
		"",
		19
	],
	[
		"8e81",
		"",
		13,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		11,
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"8f41",
		"",
		7,
		"",
		17
	],
	[
		"8f61",
		"",
		7,
		"",
		6,
		"",
		4
	],
	[
		"8f81",
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		5
	],
	[
		"9041",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9061",
		"",
		5,
		"",
		15
	],
	[
		"9081",
		"",
		12,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		11,
		"",
		33,
		""
	],
	[
		"9141",
		"",
		6,
		"",
		5
	],
	[
		"9161",
		"",
		9,
		"",
		5
	],
	[
		"9181",
		"",
		20,
		"",
		4,
		"",
		5,
		"",
		14,
		"",
		33,
		"",
		7,
		"",
		5,
		"",
		6
	],
	[
		"9241",
		"",
		7,
		"",
		4,
		""
	],
	[
		"9261",
		"",
		7,
		"",
		7,
		"",
		4
	],
	[
		"9281",
		"",
		21,
		"",
		18,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		35,
		""
	],
	[
		"9341",
		"",
		4,
		""
	],
	[
		"9361",
		"",
		6,
		"",
		8
	],
	[
		"9381",
		"",
		37,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		22,
		""
	],
	[
		"9441",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"9461",
		"",
		5,
		"",
		6,
		"",
		12
	],
	[
		"9481",
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		24
	],
	[
		"9541",
		"",
		11,
		"",
		5,
		""
	],
	[
		"9561",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9581",
		"",
		6,
		"",
		35,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		13,
		"",
		14
	],
	[
		"9641",
		"",
		23,
		""
	],
	[
		"9661",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"9681",
		"",
		10,
		"",
		5,
		"",
		13,
		"",
		33,
		"",
		6,
		"",
		44
	],
	[
		"9741",
		"",
		16,
		"",
		8
	],
	[
		"9761",
		"",
		17,
		"",
		7
	],
	[
		"9781",
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		89,
		""
	],
	[
		"9841",
		"",
		16,
		"",
		5,
		""
	],
	[
		"9861",
		"",
		6,
		"",
		15
	],
	[
		"9881",
		"",
		21,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9961",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9981",
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9a41",
		"",
		16
	],
	[
		"9a61",
		"",
		6,
		"",
		6,
		""
	],
	[
		"9a81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		33,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9b41",
		"",
		6,
		"",
		8
	],
	[
		"9b61",
		"",
		17,
		"",
		7
	],
	[
		"9b81",
		"",
		25,
		"",
		4,
		"",
		5,
		"",
		50,
		"",
		22,
		""
	],
	[
		"9c41",
		"",
		4,
		"",
		5,
		"",
		5
	],
	[
		"9c61",
		"",
		8,
		"",
		6,
		"",
		9
	],
	[
		"9c81",
		"",
		8,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		12
	],
	[
		"9d41",
		"",
		13,
		"",
		8
	],
	[
		"9d61",
		"",
		25
	],
	[
		"9d81",
		"",
		8,
		"",
		5,
		"",
		9,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9e41",
		"",
		7,
		"",
		9,
		""
	],
	[
		"9e61",
		"",
		4,
		"",
		6,
		""
	],
	[
		"9e81",
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9f41",
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9f61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9f81",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"a041",
		"",
		5,
		"",
		6,
		""
	],
	[
		"a061",
		"",
		5,
		"",
		13
	],
	[
		"a081",
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		"",
		4,
		"",
		5,
		"",
		7,
		""
	],
	[
		"a141",
		"",
		18,
		""
	],
	[
		"a161",
		"",
		6,
		"",
		5,
		""
	],
	[
		"a181",
		"",
		14,
		"",
		5,
		"",
		4,
		"",
		9,
		""
	],
	[
		"a241",
		"",
		5,
		"",
		18
	],
	[
		"a261",
		"",
		6,
		"",
		18
	],
	[
		"a281",
		"",
		7,
		"",
		6,
		"",
		7,
		""
	],
	[
		"a341",
		"",
		6,
		"",
		10,
		""
	],
	[
		"a361",
		"",
		6,
		"",
		16
	],
	[
		"a381",
		"",
		16,
		"",
		4,
		"",
		58,
		"",
		32,
		""
	],
	[
		"a441",
		"",
		5,
		""
	],
	[
		"a461",
		"",
		5,
		"",
		12
	],
	[
		"a481",
		"",
		28,
		"",
		93
	],
	[
		"a541",
		"",
		4,
		"",
		6,
		"",
		5,
		""
	],
	[
		"a561",
		"",
		17,
		"",
		5,
		""
	],
	[
		"a581",
		"",
		16,
		"",
		14,
		"",
		9
	],
	[
		"a5b0",
		"",
		9
	],
	[
		"a5c1",
		"",
		16,
		"",
		6
	],
	[
		"a5e1",
		"",
		16,
		"",
		6
	],
	[
		"a641",
		"",
		19,
		""
	],
	[
		"a661",
		"",
		5,
		"",
		5,
		"",
		6
	],
	[
		"a681",
		"",
		6,
		"",
		18,
		"",
		7
	],
	[
		"a741",
		"",
		4,
		"",
		6,
		"",
		7
	],
	[
		"a761",
		"",
		22,
		""
	],
	[
		"a781",
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		9,
		"",
		9,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"a841",
		"",
		10,
		"",
		14
	],
	[
		"a861",
		"",
		18,
		"",
		6
	],
	[
		"a881",
		"",
		19,
		"",
		11,
		""
	],
	[
		"a8a6",
		""
	],
	[
		"a8a8",
		""
	],
	[
		"a8b1",
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"a941",
		"",
		14,
		"",
		10
	],
	[
		"a961",
		"",
		18
	],
	[
		"a981",
		"",
		14,
		"",
		6,
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"aa41",
		"",
		6,
		"",
		4,
		""
	],
	[
		"aa61",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"aa81",
		"",
		29,
		"",
		82
	],
	[
		"ab41",
		"",
		6,
		"",
		5,
		""
	],
	[
		"ab61",
		"",
		6,
		"",
		5,
		"",
		5
	],
	[
		"ab81",
		"",
		8,
		"",
		6,
		"",
		12,
		"",
		85
	],
	[
		"ac41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ac61",
		"",
		11,
		"",
		4
	],
	[
		"ac81",
		"",
		28,
		"",
		5,
		"",
		25
	],
	[
		"acd1",
		"",
		5,
		"",
		25
	],
	[
		"ad41",
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"ad61",
		"",
		6,
		"",
		10,
		""
	],
	[
		"ad81",
		"",
		5,
		"",
		18,
		""
	],
	[
		"ae41",
		"",
		5,
		"",
		16
	],
	[
		"ae61",
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"ae81",
		"",
		6,
		"",
		5,
		""
	],
	[
		"af41",
		"",
		19
	],
	[
		"af61",
		"",
		13,
		"",
		5,
		""
	],
	[
		"af81",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b041",
		"",
		5,
		"",
		5,
		"",
		12
	],
	[
		"b061",
		"",
		5,
		"",
		19
	],
	[
		"b081",
		"",
		13,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"b141",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b161",
		"",
		6,
		"",
		5,
		"",
		11
	],
	[
		"b181",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b241",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b261",
		"",
		18,
		"",
		5,
		""
	],
	[
		"b281",
		"",
		5,
		"",
		18,
		"",
		6,
		""
	],
	[
		"b341",
		"",
		19,
		""
	],
	[
		"b361",
		"",
		5,
		"",
		5,
		"",
		5
	],
	[
		"b381",
		"",
		5,
		"",
		5,
		"",
		19,
		"",
		4,
		""
	],
	[
		"b441",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"b461",
		"",
		6,
		"",
		10,
		""
	],
	[
		"b481",
		"",
		6,
		"",
		18,
		"",
		4,
		"",
		4,
		""
	],
	[
		"b541",
		"",
		14,
		"",
		5
	],
	[
		"b561",
		"",
		5,
		"",
		5,
		"",
		4
	],
	[
		"b581",
		"",
		6,
		"",
		5,
		"",
		11,
		""
	],
	[
		"b641",
		"",
		7,
		"",
		17
	],
	[
		"b661",
		"",
		15,
		""
	],
	[
		"b681",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b741",
		"",
		13,
		"",
		6,
		""
	],
	[
		"b761",
		"",
		20,
		""
	],
	[
		"b781",
		"",
		6,
		"",
		14,
		""
	],
	[
		"b841",
		"",
		7,
		"",
		17
	],
	[
		"b861",
		"",
		8,
		"",
		13
	],
	[
		"b881",
		"",
		5,
		"",
		24,
		"",
		4,
		""
	],
	[
		"b941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b961",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b981",
		"",
		22,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ba41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ba61",
		"",
		5,
		"",
		4,
		"",
		5
	],
	[
		"ba81",
		"",
		6,
		"",
		9,
		""
	],
	[
		"bb41",
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bb61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"bb81",
		"",
		31,
		""
	],
	[
		"bc41",
		"",
		17,
		""
	],
	[
		"bc61",
		"",
		5,
		"",
		6,
		""
	],
	[
		"bc81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bd41",
		"",
		7,
		"",
		7,
		""
	],
	[
		"bd61",
		"",
		5,
		"",
		13
	],
	[
		"bd81",
		"",
		5,
		"",
		25,
		""
	],
	[
		"be41",
		"",
		7,
		"",
		14
	],
	[
		"be61",
		"",
		7,
		"",
		7,
		""
	],
	[
		"be81",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		8,
		"",
		6,
		""
	],
	[
		"bf41",
		"",
		10,
		"",
		14
	],
	[
		"bf61",
		"",
		18,
		""
	],
	[
		"bf81",
		"",
		5,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"c041",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"c061",
		"",
		25
	],
	[
		"c081",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c141",
		"",
		5,
		"",
		6,
		""
	],
	[
		"c161",
		"",
		19,
		""
	],
	[
		"c181",
		"",
		31,
		""
	],
	[
		"c241",
		"",
		4,
		"",
		5,
		""
	],
	[
		"c261",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c281",
		"",
		5,
		"",
		7,
		"",
		9,
		""
	],
	[
		"c341",
		"",
		4
	],
	[
		"c361",
		"",
		4,
		"",
		5,
		"",
		11
	],
	[
		"c381",
		"",
		5,
		"",
		7,
		"",
		5,
		""
	],
	[
		"c441",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c461",
		"",
		5,
		"",
		4
	],
	[
		"c481",
		"",
		5,
		"",
		11,
		""
	],
	[
		"c541",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c561",
		"",
		6,
		"",
		5,
		"",
		4
	],
	[
		"c581",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c641",
		"",
		6,
		"",
		5
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"d2a1",
		"",
		4,
		"",
		5,
		"",
		10,
		"",
		7,
		"",
		5,
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fda1",
		""
	]
];

var require$$6 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"a140",
		""
	],
	[
		"a1a1",
		"",
		4,
		""
	],
	[
		"a240",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9,
		"",
		9,
		"",
		8,
		"",
		25,
		"",
		21
	],
	[
		"a340",
		"",
		16,
		"",
		6,
		"",
		16,
		"",
		6,
		"",
		10
	],
	[
		"a3a1",
		"",
		25,
		""
	],
	[
		"a3e1",
		""
	],
	[
		"a440",
		""
	],
	[
		"a4a1",
		""
	],
	[
		"a540",
		""
	],
	[
		"a5a1",
		""
	],
	[
		"a640",
		""
	],
	[
		"a6a1",
		""
	],
	[
		"a740",
		""
	],
	[
		"a7a1",
		""
	],
	[
		"a840",
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a940",
		""
	],
	[
		"a9a1",
		""
	],
	[
		"aa40",
		""
	],
	[
		"aaa1",
		""
	],
	[
		"ab40",
		""
	],
	[
		"aba1",
		""
	],
	[
		"ac40",
		""
	],
	[
		"aca1",
		""
	],
	[
		"ad40",
		""
	],
	[
		"ada1",
		""
	],
	[
		"ae40",
		""
	],
	[
		"aea1",
		""
	],
	[
		"af40",
		""
	],
	[
		"afa1",
		""
	],
	[
		"b040",
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b140",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b240",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b340",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b440",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b540",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b640",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b740",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b840",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b940",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"ba40",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bb40",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bc40",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bd40",
		""
	],
	[
		"bda1",
		""
	],
	[
		"be40",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bf40",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c040",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c140",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c240",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c340",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c440",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c540",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c640",
		""
	],
	[
		"c940",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"ca40",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cb40",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cc40",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cd40",
		""
	],
	[
		"cda1",
		""
	],
	[
		"ce40",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cf40",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d040",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d140",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d240",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d340",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d440",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d540",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d640",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d740",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d840",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d940",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"da40",
		""
	],
	[
		"daa1",
		""
	],
	[
		"db40",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dc40",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dd40",
		""
	],
	[
		"dda1",
		""
	],
	[
		"de40",
		""
	],
	[
		"dea1",
		""
	],
	[
		"df40",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e040",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e140",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e240",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e340",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e440",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e540",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e640",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e740",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e840",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e940",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"ea40",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eb40",
		""
	],
	[
		"eba1",
		""
	],
	[
		"ec40",
		""
	],
	[
		"eca1",
		""
	],
	[
		"ed40",
		""
	],
	[
		"eda1",
		""
	],
	[
		"ee40",
		""
	],
	[
		"eea1",
		""
	],
	[
		"ef40",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f040",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f140",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f240",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f340",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f440",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f540",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f640",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f740",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f840",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f940",
		""
	],
	[
		"f9a1",
		""
	]
];

var require$$7 = [
	[
		"8740",
		""
	],
	[
		"8767",
		""
	],
	[
		"87a1",
		""
	],
	[
		"8840",
		"",
		4,
		""
	],
	[
		"88a1",
		""
	],
	[
		"8940",
		""
	],
	[
		"8943",
		""
	],
	[
		"8946",
		""
	],
	[
		"894c",
		""
	],
	[
		"89a1",
		""
	],
	[
		"89ab",
		""
	],
	[
		"89b0",
		""
	],
	[
		"89b5",
		""
	],
	[
		"89c1",
		""
	],
	[
		"89c5",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a43",
		""
	],
	[
		"8a64",
		""
	],
	[
		"8a76",
		""
	],
	[
		"8aa1",
		""
	],
	[
		"8aac",
		""
	],
	[
		"8ab2",
		""
	],
	[
		"8abb",
		""
	],
	[
		"8ac9",
		""
	],
	[
		"8ace",
		""
	],
	[
		"8adf",
		""
	],
	[
		"8af6",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b55",
		""
	],
	[
		"8ba1",
		""
	],
	[
		"8bde",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8ca1",
		""
	],
	[
		"8ca7",
		""
	],
	[
		"8cc9",
		""
	],
	[
		"8cce",
		""
	],
	[
		"8ce6",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d42",
		""
	],
	[
		"8da1",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8ea1",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8fa1",
		""
	],
	[
		"9040",
		""
	],
	[
		"90a1",
		""
	],
	[
		"9140",
		""
	],
	[
		"91a1",
		""
	],
	[
		"9240",
		""
	],
	[
		"92a1",
		""
	],
	[
		"9340",
		""
	],
	[
		"93a1",
		""
	],
	[
		"9440",
		""
	],
	[
		"94a1",
		""
	],
	[
		"9540",
		""
	],
	[
		"95a1",
		""
	],
	[
		"9640",
		""
	],
	[
		"96a1",
		""
	],
	[
		"9740",
		""
	],
	[
		"97a1",
		""
	],
	[
		"9840",
		""
	],
	[
		"98a1",
		""
	],
	[
		"9940",
		""
	],
	[
		"99a1",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9aa1",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b62",
		""
	],
	[
		"9ba1",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9ca1",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9da1",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9ea1",
		""
	],
	[
		"9ead",
		""
	],
	[
		"9ec5",
		""
	],
	[
		"9ef5",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f4f",
		""
	],
	[
		"9fa1",
		""
	],
	[
		"9fae",
		""
	],
	[
		"9fb2",
		""
	],
	[
		"9fc1",
		""
	],
	[
		"9fc9",
		""
	],
	[
		"9fdb",
		""
	],
	[
		"9fe7",
		""
	],
	[
		"9feb",
		""
	],
	[
		"9ff0",
		""
	],
	[
		"a040",
		""
	],
	[
		"a055",
		""
	],
	[
		"a058",
		""
	],
	[
		"a05b",
		""
	],
	[
		"a063",
		""
	],
	[
		"a073",
		""
	],
	[
		"a0a1",
		""
	],
	[
		"a0a6",
		""
	],
	[
		"a0ae",
		""
	],
	[
		"a0b0",
		""
	],
	[
		"a0d4",
		""
	],
	[
		"a0e2",
		""
	],
	[
		"a3c0",
		"",
		31,
		""
	],
	[
		"c6a1",
		"",
		9,
		"",
		9,
		"",
		9,
		"",
		23
	],
	[
		"c740",
		"",
		58,
		""
	],
	[
		"c7a1",
		"",
		81,
		"",
		5,
		"",
		4
	],
	[
		"c840",
		"",
		26,
		"",
		25,
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c8cd",
		""
	],
	[
		"c8f5",
		""
	],
	[
		"f9fe",
		""
	],
	[
		"fa40",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fc40",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fd40",
		""
	],
	[
		"fda1",
		""
	],
	[
		"fe40",
		""
	],
	[
		"fea1",
		""
	]
];

var dbcsData;
var hasRequiredDbcsData;

function requireDbcsData () {
	if (hasRequiredDbcsData) return dbcsData;
	hasRequiredDbcsData = 1;

	// Description of supported double byte encodings and aliases.
	// Tables are not require()-d until they are needed to speed up library load.
	// require()-s are direct to support Browserify.

	dbcsData = {
	    
	    // == Japanese/ShiftJIS ====================================================
	    // All japanese encodings are based on JIS X set of standards:
	    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
	    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
	    //              Has several variations in 1978, 1983, 1990 and 1997.
	    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
	    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
	    //              2 planes, first is superset of 0208, second - revised 0212.
	    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

	    // Byte encodings are:
	    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
	    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
	    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
	    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
	    //               0x00-0x7F       - lower part of 0201
	    //               0x8E, 0xA1-0xDF - upper part of 0201
	    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
	    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
	    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
	    //               Used as-is in ISO2022 family.
	    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
	    //                0201-1976 Roman, 0208-1978, 0208-1983.
	    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
	    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
	    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
	    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
	    //
	    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
	    //
	    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

	    'shiftjis': {
	        type: '_dbcs',
	        table: function() { return require$$0 },
	        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
	        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
	    },
	    'csshiftjis': 'shiftjis',
	    'mskanji': 'shiftjis',
	    'sjis': 'shiftjis',
	    'windows31j': 'shiftjis',
	    'ms31j': 'shiftjis',
	    'xsjis': 'shiftjis',
	    'windows932': 'shiftjis',
	    'ms932': 'shiftjis',
	    '932': 'shiftjis',
	    'cp932': 'shiftjis',

	    'eucjp': {
	        type: '_dbcs',
	        table: function() { return require$$1 },
	        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
	    },

	    // TODO: KDDI extension to Shift_JIS
	    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
	    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


	    // == Chinese/GBK ==========================================================
	    // http://en.wikipedia.org/wiki/GBK
	    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

	    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
	    'gb2312': 'cp936',
	    'gb231280': 'cp936',
	    'gb23121980': 'cp936',
	    'csgb2312': 'cp936',
	    'csiso58gb231280': 'cp936',
	    'euccn': 'cp936',

	    // Microsoft's CP936 is a subset and approximation of GBK.
	    'windows936': 'cp936',
	    'ms936': 'cp936',
	    '936': 'cp936',
	    'cp936': {
	        type: '_dbcs',
	        table: function() { return require$$2 },
	    },

	    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
	    'gbk': {
	        type: '_dbcs',
	        table: function() { return require$$2.concat(require$$3) },
	    },
	    'xgbk': 'gbk',
	    'isoir58': 'gbk',

	    // GB18030 is an algorithmic extension of GBK.
	    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
	    // http://icu-project.org/docs/papers/gb18030.html
	    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
	    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
	    'gb18030': {
	        type: '_dbcs',
	        table: function() { return require$$2.concat(require$$3) },
	        gb18030: function() { return require$$4 },
	        encodeSkipVals: [0x80],
	        encodeAdd: {'': 0xA2E3},
	    },

	    'chinese': 'gb18030',


	    // == Korean ===============================================================
	    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
	    'windows949': 'cp949',
	    'ms949': 'cp949',
	    '949': 'cp949',
	    'cp949': {
	        type: '_dbcs',
	        table: function() { return require$$5 },
	    },

	    'cseuckr': 'cp949',
	    'csksc56011987': 'cp949',
	    'euckr': 'cp949',
	    'isoir149': 'cp949',
	    'korean': 'cp949',
	    'ksc56011987': 'cp949',
	    'ksc56011989': 'cp949',
	    'ksc5601': 'cp949',


	    // == Big5/Taiwan/Hong Kong ================================================
	    // There are lots of tables for Big5 and cp950. Please see the following links for history:
	    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
	    // Variations, in roughly number of defined chars:
	    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
	    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
	    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
	    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
	    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
	    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
	    //    Plus, it has 4 combining sequences.
	    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
	    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
	    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
	    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
	    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
	    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
	    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
	    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
	    // 
	    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
	    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

	    'windows950': 'cp950',
	    'ms950': 'cp950',
	    '950': 'cp950',
	    'cp950': {
	        type: '_dbcs',
	        table: function() { return require$$6 },
	    },

	    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
	    'big5': 'big5hkscs',
	    'big5hkscs': {
	        type: '_dbcs',
	        table: function() { return require$$6.concat(require$$7) },
	        encodeSkipVals: [0xa2cc],
	    },

	    'cnbig5': 'big5hkscs',
	    'csbig5': 'big5hkscs',
	    'xxbig5': 'big5hkscs',
	};
	return dbcsData;
}

var hasRequiredEncodings;

function requireEncodings () {
	if (hasRequiredEncodings) return encodings;
	hasRequiredEncodings = 1;
	(function (exports) {

		// Update this array if you add/rename/remove files in this directory.
		// We support Browserify by skipping automatic module discovery and requiring modules directly.
		var modules = [
		    requireInternal(),
		    requireUtf16(),
		    requireUtf7(),
		    requireSbcsCodec(),
		    requireSbcsData(),
		    requireSbcsDataGenerated(),
		    requireDbcsCodec(),
		    requireDbcsData(),
		];

		// Put all encoding/alias/codec definitions to single object and export it. 
		for (var i = 0; i < modules.length; i++) {
		    var module = modules[i];
		    for (var enc in module)
		        if (Object.prototype.hasOwnProperty.call(module, enc))
		            exports[enc] = module[enc];
		} 
	} (encodings));
	return encodings;
}

var streams;
var hasRequiredStreams;

function requireStreams () {
	if (hasRequiredStreams) return streams;
	hasRequiredStreams = 1;

	var Buffer = require$$0$9.Buffer,
	    Transform = require$$0$a.Transform;


	// == Exports ==================================================================
	streams = function(iconv) {
	    
	    // Additional Public API.
	    iconv.encodeStream = function encodeStream(encoding, options) {
	        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
	    };

	    iconv.decodeStream = function decodeStream(encoding, options) {
	        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
	    };

	    iconv.supportsStreams = true;


	    // Not published yet.
	    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
	    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
	    iconv._collect = IconvLiteDecoderStream.prototype.collect;
	};


	// == Encoder stream =======================================================
	function IconvLiteEncoderStream(conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
	    Transform.call(this, options);
	}

	IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: { value: IconvLiteEncoderStream }
	});

	IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
	    if (typeof chunk != 'string')
	        return done(new Error("Iconv encoding stream needs strings as its input."));
	    try {
	        var res = this.conv.write(chunk);
	        if (res && res.length) this.push(res);
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	};

	IconvLiteEncoderStream.prototype._flush = function(done) {
	    try {
	        var res = this.conv.end();
	        if (res && res.length) this.push(res);
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	};

	IconvLiteEncoderStream.prototype.collect = function(cb) {
	    var chunks = [];
	    this.on('error', cb);
	    this.on('data', function(chunk) { chunks.push(chunk); });
	    this.on('end', function() {
	        cb(null, Buffer.concat(chunks));
	    });
	    return this;
	};


	// == Decoder stream =======================================================
	function IconvLiteDecoderStream(conv, options) {
	    this.conv = conv;
	    options = options || {};
	    options.encoding = this.encoding = 'utf8'; // We output strings.
	    Transform.call(this, options);
	}

	IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
	    constructor: { value: IconvLiteDecoderStream }
	});

	IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
	    if (!Buffer.isBuffer(chunk))
	        return done(new Error("Iconv decoding stream needs buffers as its input."));
	    try {
	        var res = this.conv.write(chunk);
	        if (res && res.length) this.push(res, this.encoding);
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	};

	IconvLiteDecoderStream.prototype._flush = function(done) {
	    try {
	        var res = this.conv.end();
	        if (res && res.length) this.push(res, this.encoding);                
	        done();
	    }
	    catch (e) {
	        done(e);
	    }
	};

	IconvLiteDecoderStream.prototype.collect = function(cb) {
	    var res = '';
	    this.on('error', cb);
	    this.on('data', function(chunk) { res += chunk; });
	    this.on('end', function() {
	        cb(null, res);
	    });
	    return this;
	};
	return streams;
}

var extendNode;
var hasRequiredExtendNode;

function requireExtendNode () {
	if (hasRequiredExtendNode) return extendNode;
	hasRequiredExtendNode = 1;
	var Buffer = require$$0$9.Buffer;
	// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer

	// == Extend Node primitives to use iconv-lite =================================

	extendNode = function (iconv) {
	    var original = undefined; // Place to keep original methods.

	    // Node authors rewrote Buffer internals to make it compatible with
	    // Uint8Array and we cannot patch key functions since then.
	    // Note: this does use older Buffer API on a purpose
	    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);

	    iconv.extendNodeEncodings = function extendNodeEncodings() {
	        if (original) return;
	        original = {};

	        if (!iconv.supportsNodeEncodingsExtension) {
	            console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
	            console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
	            return;
	        }

	        var nodeNativeEncodings = {
	            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, 
	            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,
	        };

	        Buffer.isNativeEncoding = function(enc) {
	            return enc && nodeNativeEncodings[enc.toLowerCase()];
	        };

	        // -- SlowBuffer -----------------------------------------------------------
	        var SlowBuffer = require$$0$9.SlowBuffer;

	        original.SlowBufferToString = SlowBuffer.prototype.toString;
	        SlowBuffer.prototype.toString = function(encoding, start, end) {
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.SlowBufferToString.call(this, encoding, start, end);

	            // Otherwise, use our decoding method.
	            if (typeof start == 'undefined') start = 0;
	            if (typeof end == 'undefined') end = this.length;
	            return iconv.decode(this.slice(start, end), encoding);
	        };

	        original.SlowBufferWrite = SlowBuffer.prototype.write;
	        SlowBuffer.prototype.write = function(string, offset, length, encoding) {
	            // Support both (string, offset, length, encoding)
	            // and the legacy (string, encoding, offset, length)
	            if (isFinite(offset)) {
	                if (!isFinite(length)) {
	                    encoding = length;
	                    length = undefined;
	                }
	            } else {  // legacy
	                var swap = encoding;
	                encoding = offset;
	                offset = length;
	                length = swap;
	            }

	            offset = +offset || 0;
	            var remaining = this.length - offset;
	            if (!length) {
	                length = remaining;
	            } else {
	                length = +length;
	                if (length > remaining) {
	                    length = remaining;
	                }
	            }
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.SlowBufferWrite.call(this, string, offset, length, encoding);

	            if (string.length > 0 && (length < 0 || offset < 0))
	                throw new RangeError('attempt to write beyond buffer bounds');

	            // Otherwise, use our encoding method.
	            var buf = iconv.encode(string, encoding);
	            if (buf.length < length) length = buf.length;
	            buf.copy(this, offset, 0, length);
	            return length;
	        };

	        // -- Buffer ---------------------------------------------------------------

	        original.BufferIsEncoding = Buffer.isEncoding;
	        Buffer.isEncoding = function(encoding) {
	            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);
	        };

	        original.BufferByteLength = Buffer.byteLength;
	        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.BufferByteLength.call(this, str, encoding);

	            // Slow, I know, but we don't have a better way yet.
	            return iconv.encode(str, encoding).length;
	        };

	        original.BufferToString = Buffer.prototype.toString;
	        Buffer.prototype.toString = function(encoding, start, end) {
	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.BufferToString.call(this, encoding, start, end);

	            // Otherwise, use our decoding method.
	            if (typeof start == 'undefined') start = 0;
	            if (typeof end == 'undefined') end = this.length;
	            return iconv.decode(this.slice(start, end), encoding);
	        };

	        original.BufferWrite = Buffer.prototype.write;
	        Buffer.prototype.write = function(string, offset, length, encoding) {
	            var _offset = offset, _length = length, _encoding = encoding;
	            // Support both (string, offset, length, encoding)
	            // and the legacy (string, encoding, offset, length)
	            if (isFinite(offset)) {
	                if (!isFinite(length)) {
	                    encoding = length;
	                    length = undefined;
	                }
	            } else {  // legacy
	                var swap = encoding;
	                encoding = offset;
	                offset = length;
	                length = swap;
	            }

	            encoding = String(encoding || 'utf8').toLowerCase();

	            // Use native conversion when possible
	            if (Buffer.isNativeEncoding(encoding))
	                return original.BufferWrite.call(this, string, _offset, _length, _encoding);

	            offset = +offset || 0;
	            var remaining = this.length - offset;
	            if (!length) {
	                length = remaining;
	            } else {
	                length = +length;
	                if (length > remaining) {
	                    length = remaining;
	                }
	            }

	            if (string.length > 0 && (length < 0 || offset < 0))
	                throw new RangeError('attempt to write beyond buffer bounds');

	            // Otherwise, use our encoding method.
	            var buf = iconv.encode(string, encoding);
	            if (buf.length < length) length = buf.length;
	            buf.copy(this, offset, 0, length);
	            return length;

	            // TODO: Set _charsWritten.
	        };


	        // -- Readable -------------------------------------------------------------
	        if (iconv.supportsStreams) {
	            var Readable = require$$0$a.Readable;

	            original.ReadableSetEncoding = Readable.prototype.setEncoding;
	            Readable.prototype.setEncoding = function setEncoding(enc, options) {
	                // Use our own decoder, it has the same interface.
	                // We cannot use original function as it doesn't handle BOM-s.
	                this._readableState.decoder = iconv.getDecoder(enc, options);
	                this._readableState.encoding = enc;
	            };

	            Readable.prototype.collect = iconv._collect;
	        }
	    };

	    // Remove iconv-lite Node primitive extensions.
	    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
	        if (!iconv.supportsNodeEncodingsExtension)
	            return;
	        if (!original)
	            throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.")

	        delete Buffer.isNativeEncoding;

	        var SlowBuffer = require$$0$9.SlowBuffer;

	        SlowBuffer.prototype.toString = original.SlowBufferToString;
	        SlowBuffer.prototype.write = original.SlowBufferWrite;

	        Buffer.isEncoding = original.BufferIsEncoding;
	        Buffer.byteLength = original.BufferByteLength;
	        Buffer.prototype.toString = original.BufferToString;
	        Buffer.prototype.write = original.BufferWrite;

	        if (iconv.supportsStreams) {
	            var Readable = require$$0$a.Readable;

	            Readable.prototype.setEncoding = original.ReadableSetEncoding;
	            delete Readable.prototype.collect;
	        }

	        original = undefined;
	    };
	};
	return extendNode;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib.exports;
	hasRequiredLib = 1;
	(function (module) {

		// Some environments don't have global Buffer (e.g. React Native).
		// Solution would be installing npm modules "buffer" and "stream" explicitly.
		var Buffer = requireSafer().Buffer;

		var bomHandling = requireBomHandling(),
		    iconv = module.exports;

		// All codecs and aliases are kept here, keyed by encoding name/alias.
		// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
		iconv.encodings = null;

		// Characters emitted in case of error.
		iconv.defaultCharUnicode = '';
		iconv.defaultCharSingleByte = '?';

		// Public API.
		iconv.encode = function encode(str, encoding, options) {
		    str = "" + (str || ""); // Ensure string.

		    var encoder = iconv.getEncoder(encoding, options);

		    var res = encoder.write(str);
		    var trail = encoder.end();
		    
		    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
		};

		iconv.decode = function decode(buf, encoding, options) {
		    if (typeof buf === 'string') {
		        if (!iconv.skipDecodeWarning) {
		            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
		            iconv.skipDecodeWarning = true;
		        }

		        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
		    }

		    var decoder = iconv.getDecoder(encoding, options);

		    var res = decoder.write(buf);
		    var trail = decoder.end();

		    return trail ? (res + trail) : res;
		};

		iconv.encodingExists = function encodingExists(enc) {
		    try {
		        iconv.getCodec(enc);
		        return true;
		    } catch (e) {
		        return false;
		    }
		};

		// Legacy aliases to convert functions
		iconv.toEncoding = iconv.encode;
		iconv.fromEncoding = iconv.decode;

		// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
		iconv._codecDataCache = {};
		iconv.getCodec = function getCodec(encoding) {
		    if (!iconv.encodings)
		        iconv.encodings = requireEncodings(); // Lazy load all encoding definitions.
		    
		    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
		    var enc = iconv._canonicalizeEncoding(encoding);

		    // Traverse iconv.encodings to find actual codec.
		    var codecOptions = {};
		    while (true) {
		        var codec = iconv._codecDataCache[enc];
		        if (codec)
		            return codec;

		        var codecDef = iconv.encodings[enc];

		        switch (typeof codecDef) {
		            case "string": // Direct alias to other encoding.
		                enc = codecDef;
		                break;

		            case "object": // Alias with options. Can be layered.
		                for (var key in codecDef)
		                    codecOptions[key] = codecDef[key];

		                if (!codecOptions.encodingName)
		                    codecOptions.encodingName = enc;
		                
		                enc = codecDef.type;
		                break;

		            case "function": // Codec itself.
		                if (!codecOptions.encodingName)
		                    codecOptions.encodingName = enc;

		                // The codec function must load all tables and return object with .encoder and .decoder methods.
		                // It'll be called only once (for each different options object).
		                codec = new codecDef(codecOptions, iconv);

		                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
		                return codec;

		            default:
		                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
		        }
		    }
		};

		iconv._canonicalizeEncoding = function(encoding) {
		    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
		    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
		};

		iconv.getEncoder = function getEncoder(encoding, options) {
		    var codec = iconv.getCodec(encoding),
		        encoder = new codec.encoder(options, codec);

		    if (codec.bomAware && options && options.addBOM)
		        encoder = new bomHandling.PrependBOM(encoder, options);

		    return encoder;
		};

		iconv.getDecoder = function getDecoder(encoding, options) {
		    var codec = iconv.getCodec(encoding),
		        decoder = new codec.decoder(options, codec);

		    if (codec.bomAware && !(options && options.stripBOM === false))
		        decoder = new bomHandling.StripBOM(decoder, options);

		    return decoder;
		};


		// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
		var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
		if (nodeVer) {

		    // Load streaming support in Node v0.10+
		    var nodeVerArr = nodeVer.split(".").map(Number);
		    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
		        requireStreams()(iconv);
		    }

		    // Load Node primitive extensions.
		    requireExtendNode()(iconv);
		}
	} (lib));
	return lib.exports;
}

var tmp = {};

var osTmpdir;
var hasRequiredOsTmpdir;

function requireOsTmpdir () {
	if (hasRequiredOsTmpdir) return osTmpdir;
	hasRequiredOsTmpdir = 1;
	var isWindows = process.platform === 'win32';
	var trailingSlashRe = isWindows ? /[^:]\\$/ : /.\/$/;

	// https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43
	osTmpdir = function () {
		var path;

		if (isWindows) {
			path = process.env.TEMP ||
				process.env.TMP ||
				(process.env.SystemRoot || process.env.windir) + '\\temp';
		} else {
			path = process.env.TMPDIR ||
				process.env.TMP ||
				process.env.TEMP ||
				'/tmp';
		}

		if (trailingSlashRe.test(path)) {
			path = path.slice(0, -1);
		}

		return path;
	};
	return osTmpdir;
}

/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */

var hasRequiredTmp;

function requireTmp () {
	if (hasRequiredTmp) return tmp;
	hasRequiredTmp = 1;
	/*
	 * Module dependencies.
	 */
	const fs = require$$0$6;
	const path = require$$1$1;
	const crypto = require$$0$4;
	const osTmpDir = requireOsTmpdir();
	const _c = process.binding('constants');

	/*
	 * The working inner variables.
	 */
	const
	  /**
	   * The temporary directory.
	   * @type {string}
	   */
	  tmpDir = osTmpDir(),

	  // the random characters to choose from
	  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',

	  TEMPLATE_PATTERN = /XXXXXX/,

	  DEFAULT_TRIES = 3,

	  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),

	  EBADF = _c.EBADF || _c.os.errno.EBADF,
	  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,

	  DIR_MODE = 448 /* 0o700 */,
	  FILE_MODE = 384 /* 0o600 */,

	  // this will hold the objects need to be removed on exit
	  _removeObjects = [];

	var
	  _gracefulCleanup = false,
	  _uncaughtException = false;

	/**
	 * Random name generator based on crypto.
	 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
	 *
	 * @param {number} howMany
	 * @returns {string} the generated random name
	 * @private
	 */
	function _randomChars(howMany) {
	  var
	    value = [],
	    rnd = null;

	  // make sure that we do not fail because we ran out of entropy
	  try {
	    rnd = crypto.randomBytes(howMany);
	  } catch (e) {
	    rnd = crypto.pseudoRandomBytes(howMany);
	  }

	  for (var i = 0; i < howMany; i++) {
	    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
	  }

	  return value.join('');
	}

	/**
	 * Checks whether the `obj` parameter is defined or not.
	 *
	 * @param {Object} obj
	 * @returns {boolean} true if the object is undefined
	 * @private
	 */
	function _isUndefined(obj) {
	  return typeof obj === 'undefined';
	}

	/**
	 * Parses the function arguments.
	 *
	 * This function helps to have optional arguments.
	 *
	 * @param {(Options|Function)} options
	 * @param {Function} callback
	 * @returns {Array} parsed arguments
	 * @private
	 */
	function _parseArguments(options, callback) {
	  if (typeof options == 'function') {
	    return [callback || {}, options];
	  }

	  if (_isUndefined(options)) {
	    return [{}, callback];
	  }

	  return [options, callback];
	}

	/**
	 * Generates a new temporary name.
	 *
	 * @param {Object} opts
	 * @returns {string} the new random name according to opts
	 * @private
	 */
	function _generateTmpName(opts) {
	  if (opts.name) {
	    return path.join(opts.dir || tmpDir, opts.name);
	  }

	  // mkstemps like template
	  if (opts.template) {
	    return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));
	  }

	  // prefix and postfix
	  const name = [
	    opts.prefix || 'tmp-',
	    process.pid,
	    _randomChars(12),
	    opts.postfix || ''
	  ].join('');

	  return path.join(opts.dir || tmpDir, name);
	}

	/**
	 * Gets a temporary file name.
	 *
	 * @param {(Options|tmpNameCallback)} options options or callback
	 * @param {?tmpNameCallback} callback the callback function
	 */
	function tmpName(options, callback) {
	  var
	    args = _parseArguments(options, callback),
	    opts = args[0],
	    cb = args[1],
	    tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;

	  if (isNaN(tries) || tries < 0)
	    return cb(new Error('Invalid tries'));

	  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
	    return cb(new Error('Invalid template provided'));

	  (function _getUniqueName() {
	    const name = _generateTmpName(opts);

	    // check whether the path exists then retry if needed
	    fs.stat(name, function (err) {
	      if (!err) {
	        if (tries-- > 0) return _getUniqueName();

	        return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
	      }

	      cb(null, name);
	    });
	  }());
	}

	/**
	 * Synchronous version of tmpName.
	 *
	 * @param {Object} options
	 * @returns {string} the generated random name
	 * @throws {Error} if the options are invalid or could not generate a filename
	 */
	function tmpNameSync(options) {
	  var
	    args = _parseArguments(options),
	    opts = args[0],
	    tries = opts.name ? 1 : opts.tries || DEFAULT_TRIES;

	  if (isNaN(tries) || tries < 0)
	    throw new Error('Invalid tries');

	  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
	    throw new Error('Invalid template provided');

	  do {
	    const name = _generateTmpName(opts);
	    try {
	      fs.statSync(name);
	    } catch (e) {
	      return name;
	    }
	  } while (tries-- > 0);

	  throw new Error('Could not get a unique tmp filename, max tries reached');
	}

	/**
	 * Creates and opens a temporary file.
	 *
	 * @param {(Options|fileCallback)} options the config options or the callback function
	 * @param {?fileCallback} callback
	 */
	function file(options, callback) {
	  var
	    args = _parseArguments(options, callback),
	    opts = args[0],
	    cb = args[1];

	  opts.postfix = (_isUndefined(opts.postfix)) ? '.tmp' : opts.postfix;

	  // gets a temporary filename
	  tmpName(opts, function _tmpNameCreated(err, name) {
	    if (err) return cb(err);

	    // create and open the file
	    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
	      if (err) return cb(err);

	      if (opts.discardDescriptor) {
	        return fs.close(fd, function _discardCallback(err) {
	          if (err) {
	            // Low probability, and the file exists, so this could be
	            // ignored.  If it isn't we certainly need to unlink the
	            // file, and if that fails too its error is more
	            // important.
	            try {
	              fs.unlinkSync(name);
	            } catch (e) {
	              if (!isENOENT(e)) {
	                err = e;
	              }
	            }
	            return cb(err);
	          }
	          cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));
	        });
	      }
	      if (opts.detachDescriptor) {
	        return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));
	      }
	      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));
	    });
	  });
	}

	/**
	 * Synchronous version of file.
	 *
	 * @param {Options} options
	 * @returns {FileSyncObject} object consists of name, fd and removeCallback
	 * @throws {Error} if cannot create a file
	 */
	function fileSync(options) {
	  var
	    args = _parseArguments(options),
	    opts = args[0];

	  opts.postfix = opts.postfix || '.tmp';

	  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
	  const name = tmpNameSync(opts);
	  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
	  if (opts.discardDescriptor) {
	    fs.closeSync(fd); 
	    fd = undefined;
	  }

	  return {
	    name: name,
	    fd: fd,
	    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)
	  };
	}

	/**
	 * Removes files and folders in a directory recursively.
	 *
	 * @param {string} root
	 * @private
	 */
	function _rmdirRecursiveSync(root) {
	  const dirs = [root];

	  do {
	    var
	      dir = dirs.pop(),
	      deferred = false,
	      files = fs.readdirSync(dir);

	    for (var i = 0, length = files.length; i < length; i++) {
	      var
	        file = path.join(dir, files[i]),
	        stat = fs.lstatSync(file); // lstat so we don't recurse into symlinked directories

	      if (stat.isDirectory()) {
	        if (!deferred) {
	          deferred = true;
	          dirs.push(dir);
	        }
	        dirs.push(file);
	      } else {
	        fs.unlinkSync(file);
	      }
	    }

	    if (!deferred) {
	      fs.rmdirSync(dir);
	    }
	  } while (dirs.length !== 0);
	}

	/**
	 * Creates a temporary directory.
	 *
	 * @param {(Options|dirCallback)} options the options or the callback function
	 * @param {?dirCallback} callback
	 */
	function dir(options, callback) {
	  var
	    args = _parseArguments(options, callback),
	    opts = args[0],
	    cb = args[1];

	  // gets a temporary filename
	  tmpName(opts, function _tmpNameCreated(err, name) {
	    if (err) return cb(err);

	    // create the directory
	    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
	      if (err) return cb(err);

	      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));
	    });
	  });
	}

	/**
	 * Synchronous version of dir.
	 *
	 * @param {Options} options
	 * @returns {DirSyncObject} object consists of name and removeCallback
	 * @throws {Error} if it cannot create a directory
	 */
	function dirSync(options) {
	  var
	    args = _parseArguments(options),
	    opts = args[0];

	  const name = tmpNameSync(opts);
	  fs.mkdirSync(name, opts.mode || DIR_MODE);

	  return {
	    name: name,
	    removeCallback: _prepareTmpDirRemoveCallback(name, opts)
	  };
	}

	/**
	 * Prepares the callback for removal of the temporary file.
	 *
	 * @param {string} name the path of the file
	 * @param {number} fd file descriptor
	 * @param {Object} opts
	 * @returns {fileCallback}
	 * @private
	 */
	function _prepareTmpFileRemoveCallback(name, fd, opts) {
	  const removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {
	    try {
	      if (0 <= fdPath[0]) {
	        fs.closeSync(fdPath[0]);
	      }
	    }
	    catch (e) {
	      // under some node/windows related circumstances, a temporary file
	      // may have not be created as expected or the file was already closed
	      // by the user, in which case we will simply ignore the error
	      if (!isEBADF(e) && !isENOENT(e)) {
	        // reraise any unanticipated error
	        throw e;
	      }
	    }
	    try {
	      fs.unlinkSync(fdPath[1]);
	    }
	    catch (e) {
	      if (!isENOENT(e)) {
	        // reraise any unanticipated error
	        throw e;
	      }
	    }
	  }, [fd, name]);

	  if (!opts.keep) {
	    _removeObjects.unshift(removeCallback);
	  }

	  return removeCallback;
	}

	/**
	 * Prepares the callback for removal of the temporary directory.
	 *
	 * @param {string} name
	 * @param {Object} opts
	 * @returns {Function} the callback
	 * @private
	 */
	function _prepareTmpDirRemoveCallback(name, opts) {
	  const removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs);
	  const removeCallback = _prepareRemoveCallback(removeFunction, name);

	  if (!opts.keep) {
	    _removeObjects.unshift(removeCallback);
	  }

	  return removeCallback;
	}

	/**
	 * Creates a guarded function wrapping the removeFunction call.
	 *
	 * @param {Function} removeFunction
	 * @param {Object} arg
	 * @returns {Function}
	 * @private
	 */
	function _prepareRemoveCallback(removeFunction, arg) {
	  var called = false;

	  return function _cleanupCallback(next) {
	    if (!called) {
	      const index = _removeObjects.indexOf(_cleanupCallback);
	      if (index >= 0) {
	        _removeObjects.splice(index, 1);
	      }

	      called = true;
	      removeFunction(arg);
	    }

	    if (next) next(null);
	  };
	}

	/**
	 * The garbage collector.
	 *
	 * @private
	 */
	function _garbageCollector() {
	  if (_uncaughtException && !_gracefulCleanup) {
	    return;
	  }

	  // the function being called removes itself from _removeObjects,
	  // loop until _removeObjects is empty
	  while (_removeObjects.length) {
	    try {
	      _removeObjects[0].call(null);
	    } catch (e) {
	      // already removed?
	    }
	  }
	}

	/**
	 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
	 */
	function isEBADF(error) {
	  return isExpectedError(error, -EBADF, 'EBADF');
	}

	/**
	 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
	 */
	function isENOENT(error) {
	  return isExpectedError(error, -ENOENT, 'ENOENT');
	}

	/**
	 * Helper to determine whether the expected error code matches the actual code and errno,
	 * which will differ between the supported node versions.
	 *
	 * - Node >= 7.0:
	 *   error.code {String}
	 *   error.errno {String|Number} any numerical value will be negated
	 *
	 * - Node >= 6.0 < 7.0:
	 *   error.code {String}
	 *   error.errno {Number} negated
	 *
	 * - Node >= 4.0 < 6.0: introduces SystemError
	 *   error.code {String}
	 *   error.errno {Number} negated
	 *
	 * - Node >= 0.10 < 4.0:
	 *   error.code {Number} negated
	 *   error.errno n/a
	 */
	function isExpectedError(error, code, errno) {
	  return error.code == code || error.code == errno;
	}

	/**
	 * Sets the graceful cleanup.
	 *
	 * Also removes the created files and directories when an uncaught exception occurs.
	 */
	function setGracefulCleanup() {
	  _gracefulCleanup = true;
	}

	const version = process.versions.node.split('.').map(function (value) {
	  return parseInt(value, 10);
	});

	if (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {
	  process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {
	    _uncaughtException = true;
	    _garbageCollector();

	    throw err;
	  });
	}

	process.addListener('exit', function _exit(code) {
	  if (code) _uncaughtException = true;
	  _garbageCollector();
	});

	/**
	 * Configuration options.
	 *
	 * @typedef {Object} Options
	 * @property {?number} tries the number of tries before give up the name generation
	 * @property {?string} template the "mkstemp" like filename template
	 * @property {?string} name fix name
	 * @property {?string} dir the tmp directory to use
	 * @property {?string} prefix prefix for the generated name
	 * @property {?string} postfix postfix for the generated name
	 */

	/**
	 * @typedef {Object} FileSyncObject
	 * @property {string} name the name of the file
	 * @property {string} fd the file descriptor
	 * @property {fileCallback} removeCallback the callback function to remove the file
	 */

	/**
	 * @typedef {Object} DirSyncObject
	 * @property {string} name the name of the directory
	 * @property {fileCallback} removeCallback the callback function to remove the directory
	 */

	/**
	 * @callback tmpNameCallback
	 * @param {?Error} err the error object if anything goes wrong
	 * @param {string} name the temporary file name
	 */

	/**
	 * @callback fileCallback
	 * @param {?Error} err the error object if anything goes wrong
	 * @param {string} name the temporary file name
	 * @param {number} fd the file descriptor
	 * @param {cleanupCallback} fn the cleanup callback function
	 */

	/**
	 * @callback dirCallback
	 * @param {?Error} err the error object if anything goes wrong
	 * @param {string} name the temporary file name
	 * @param {cleanupCallback} fn the cleanup callback function
	 */

	/**
	 * Removes the temporary created file or directory.
	 *
	 * @callback cleanupCallback
	 * @param {simpleCallback} [next] function to call after entry was removed
	 */

	/**
	 * Callback function for function composition.
	 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
	 *
	 * @callback simpleCallback
	 */

	// exporting all the needed methods
	tmp.tmpdir = tmpDir;

	tmp.dir = dir;
	tmp.dirSync = dirSync;

	tmp.file = file;
	tmp.fileSync = fileSync;

	tmp.tmpName = tmpName;
	tmp.tmpNameSync = tmpNameSync;

	tmp.setGracefulCleanup = setGracefulCleanup;
	return tmp;
}

var CreateFileError = {};

var hasRequiredCreateFileError;

function requireCreateFileError () {
	if (hasRequiredCreateFileError) return CreateFileError;
	hasRequiredCreateFileError = 1;
	/***
	 * Node External Editor
	 *
	 * Kevin Gravier <kevin@mrkmg.com>
	 * MIT 2018
	 */
	var __extends = (CreateFileError && CreateFileError.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(CreateFileError, "__esModule", { value: true });
	var CreateFileError$1 = /** @class */ (function (_super) {
	    __extends(CreateFileError, _super);
	    function CreateFileError(originalError) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, "Failed to create temporary file for editor") || this;
	        _this.originalError = originalError;
	        var proto = _newTarget.prototype;
	        if (Object.setPrototypeOf) {
	            Object.setPrototypeOf(_this, proto);
	        }
	        else {
	            _this.__proto__ = _newTarget.prototype;
	        }
	        return _this;
	    }
	    return CreateFileError;
	}(Error));
	CreateFileError.CreateFileError = CreateFileError$1;
	return CreateFileError;
}

var LaunchEditorError = {};

var hasRequiredLaunchEditorError;

function requireLaunchEditorError () {
	if (hasRequiredLaunchEditorError) return LaunchEditorError;
	hasRequiredLaunchEditorError = 1;
	/***
	 * Node External Editor
	 *
	 * Kevin Gravier <kevin@mrkmg.com>
	 * MIT 2018
	 */
	var __extends = (LaunchEditorError && LaunchEditorError.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(LaunchEditorError, "__esModule", { value: true });
	var LaunchEditorError$1 = /** @class */ (function (_super) {
	    __extends(LaunchEditorError, _super);
	    function LaunchEditorError(originalError) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, "Failed launch editor") || this;
	        _this.originalError = originalError;
	        var proto = _newTarget.prototype;
	        if (Object.setPrototypeOf) {
	            Object.setPrototypeOf(_this, proto);
	        }
	        else {
	            _this.__proto__ = _newTarget.prototype;
	        }
	        return _this;
	    }
	    return LaunchEditorError;
	}(Error));
	LaunchEditorError.LaunchEditorError = LaunchEditorError$1;
	return LaunchEditorError;
}

var ReadFileError = {};

var hasRequiredReadFileError;

function requireReadFileError () {
	if (hasRequiredReadFileError) return ReadFileError;
	hasRequiredReadFileError = 1;
	/***
	 * Node External Editor
	 *
	 * Kevin Gravier <kevin@mrkmg.com>
	 * MIT 2018
	 */
	var __extends = (ReadFileError && ReadFileError.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(ReadFileError, "__esModule", { value: true });
	var ReadFileError$1 = /** @class */ (function (_super) {
	    __extends(ReadFileError, _super);
	    function ReadFileError(originalError) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, "Failed to read temporary file") || this;
	        _this.originalError = originalError;
	        var proto = _newTarget.prototype;
	        if (Object.setPrototypeOf) {
	            Object.setPrototypeOf(_this, proto);
	        }
	        else {
	            _this.__proto__ = _newTarget.prototype;
	        }
	        return _this;
	    }
	    return ReadFileError;
	}(Error));
	ReadFileError.ReadFileError = ReadFileError$1;
	return ReadFileError;
}

var RemoveFileError = {};

var hasRequiredRemoveFileError;

function requireRemoveFileError () {
	if (hasRequiredRemoveFileError) return RemoveFileError;
	hasRequiredRemoveFileError = 1;
	/***
	 * Node External Editor
	 *
	 * Kevin Gravier <kevin@mrkmg.com>
	 * MIT 2018
	 */
	var __extends = (RemoveFileError && RemoveFileError.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(RemoveFileError, "__esModule", { value: true });
	var RemoveFileError$1 = /** @class */ (function (_super) {
	    __extends(RemoveFileError, _super);
	    function RemoveFileError(originalError) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, "Failed to cleanup temporary file") || this;
	        _this.originalError = originalError;
	        var proto = _newTarget.prototype;
	        if (Object.setPrototypeOf) {
	            Object.setPrototypeOf(_this, proto);
	        }
	        else {
	            _this.__proto__ = _newTarget.prototype;
	        }
	        return _this;
	    }
	    return RemoveFileError;
	}(Error));
	RemoveFileError.RemoveFileError = RemoveFileError$1;
	return RemoveFileError;
}

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main;
	hasRequiredMain = 1;
	/***
	 * Node External Editor
	 *
	 * Kevin Gravier <kevin@mrkmg.com>
	 * MIT 2019
	 */
	Object.defineProperty(main, "__esModule", { value: true });
	var chardet_1 = requireChardet();
	var child_process_1 = require$$0$7;
	var fs_1 = require$$0$6;
	var iconv_lite_1 = requireLib();
	var tmp_1 = requireTmp();
	var CreateFileError_1 = requireCreateFileError();
	main.CreateFileError = CreateFileError_1.CreateFileError;
	var LaunchEditorError_1 = requireLaunchEditorError();
	main.LaunchEditorError = LaunchEditorError_1.LaunchEditorError;
	var ReadFileError_1 = requireReadFileError();
	main.ReadFileError = ReadFileError_1.ReadFileError;
	var RemoveFileError_1 = requireRemoveFileError();
	main.RemoveFileError = RemoveFileError_1.RemoveFileError;
	function edit(text, fileOptions) {
	    if (text === void 0) { text = ""; }
	    var editor = new ExternalEditor(text, fileOptions);
	    editor.run();
	    editor.cleanup();
	    return editor.text;
	}
	main.edit = edit;
	function editAsync(text, callback, fileOptions) {
	    if (text === void 0) { text = ""; }
	    var editor = new ExternalEditor(text, fileOptions);
	    editor.runAsync(function (err, result) {
	        if (err) {
	            setImmediate(callback, err, null);
	        }
	        else {
	            try {
	                editor.cleanup();
	                setImmediate(callback, null, result);
	            }
	            catch (cleanupError) {
	                setImmediate(callback, cleanupError, null);
	            }
	        }
	    });
	}
	main.editAsync = editAsync;
	var ExternalEditor = /** @class */ (function () {
	    function ExternalEditor(text, fileOptions) {
	        if (text === void 0) { text = ""; }
	        this.text = "";
	        this.fileOptions = {};
	        this.text = text;
	        if (fileOptions) {
	            this.fileOptions = fileOptions;
	        }
	        this.determineEditor();
	        this.createTemporaryFile();
	    }
	    ExternalEditor.splitStringBySpace = function (str) {
	        var pieces = [];
	        var currentString = "";
	        for (var strIndex = 0; strIndex < str.length; strIndex++) {
	            var currentLetter = str[strIndex];
	            if (strIndex > 0 && currentLetter === " " && str[strIndex - 1] !== "\\" && currentString.length > 0) {
	                pieces.push(currentString);
	                currentString = "";
	            }
	            else {
	                currentString += currentLetter;
	            }
	        }
	        if (currentString.length > 0) {
	            pieces.push(currentString);
	        }
	        return pieces;
	    };
	    Object.defineProperty(ExternalEditor.prototype, "temp_file", {
	        get: function () {
	            console.log("DEPRECATED: temp_file. Use tempFile moving forward.");
	            return this.tempFile;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ExternalEditor.prototype, "last_exit_status", {
	        get: function () {
	            console.log("DEPRECATED: last_exit_status. Use lastExitStatus moving forward.");
	            return this.lastExitStatus;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ExternalEditor.prototype.run = function () {
	        this.launchEditor();
	        this.readTemporaryFile();
	        return this.text;
	    };
	    ExternalEditor.prototype.runAsync = function (callback) {
	        var _this = this;
	        try {
	            this.launchEditorAsync(function () {
	                try {
	                    _this.readTemporaryFile();
	                    setImmediate(callback, null, _this.text);
	                }
	                catch (readError) {
	                    setImmediate(callback, readError, null);
	                }
	            });
	        }
	        catch (launchError) {
	            setImmediate(callback, launchError, null);
	        }
	    };
	    ExternalEditor.prototype.cleanup = function () {
	        this.removeTemporaryFile();
	    };
	    ExternalEditor.prototype.determineEditor = function () {
	        var editor = process.env.VISUAL ? process.env.VISUAL :
	            process.env.EDITOR ? process.env.EDITOR :
	                /^win/.test(process.platform) ? "notepad" :
	                    "vim";
	        var editorOpts = ExternalEditor.splitStringBySpace(editor).map(function (piece) { return piece.replace("\\ ", " "); });
	        var bin = editorOpts.shift();
	        this.editor = { args: editorOpts, bin: bin };
	    };
	    ExternalEditor.prototype.createTemporaryFile = function () {
	        try {
	            this.tempFile = tmp_1.tmpNameSync(this.fileOptions);
	            var opt = { encoding: "utf8" };
	            if (this.fileOptions.hasOwnProperty("mode")) {
	                opt.mode = this.fileOptions.mode;
	            }
	            fs_1.writeFileSync(this.tempFile, this.text, opt);
	        }
	        catch (createFileError) {
	            throw new CreateFileError_1.CreateFileError(createFileError);
	        }
	    };
	    ExternalEditor.prototype.readTemporaryFile = function () {
	        try {
	            var tempFileBuffer = fs_1.readFileSync(this.tempFile);
	            if (tempFileBuffer.length === 0) {
	                this.text = "";
	            }
	            else {
	                var encoding = chardet_1.detect(tempFileBuffer).toString();
	                if (!iconv_lite_1.encodingExists(encoding)) {
	                    // Probably a bad idea, but will at least prevent crashing
	                    encoding = "utf8";
	                }
	                this.text = iconv_lite_1.decode(tempFileBuffer, encoding);
	            }
	        }
	        catch (readFileError) {
	            throw new ReadFileError_1.ReadFileError(readFileError);
	        }
	    };
	    ExternalEditor.prototype.removeTemporaryFile = function () {
	        try {
	            fs_1.unlinkSync(this.tempFile);
	        }
	        catch (removeFileError) {
	            throw new RemoveFileError_1.RemoveFileError(removeFileError);
	        }
	    };
	    ExternalEditor.prototype.launchEditor = function () {
	        try {
	            var editorProcess = child_process_1.spawnSync(this.editor.bin, this.editor.args.concat([this.tempFile]), { stdio: "inherit" });
	            this.lastExitStatus = editorProcess.status;
	        }
	        catch (launchError) {
	            throw new LaunchEditorError_1.LaunchEditorError(launchError);
	        }
	    };
	    ExternalEditor.prototype.launchEditorAsync = function (callback) {
	        var _this = this;
	        try {
	            var editorProcess = child_process_1.spawn(this.editor.bin, this.editor.args.concat([this.tempFile]), { stdio: "inherit" });
	            editorProcess.on("exit", function (code) {
	                _this.lastExitStatus = code;
	                setImmediate(callback);
	            });
	        }
	        catch (launchError) {
	            throw new LaunchEditorError_1.LaunchEditorError(launchError);
	        }
	    };
	    return ExternalEditor;
	}());
	main.ExternalEditor = ExternalEditor;
	return main;
}

var editor;
var hasRequiredEditor;

function requireEditor () {
	if (hasRequiredEditor) return editor;
	hasRequiredEditor = 1;
	/**
	 * `editor` type prompt
	 */

	const chalk = requireSource();
	const { editAsync } = requireMain();
	const Base = requireBase();
	const observe = requireEvents();
	const { Subject } = /*@__PURE__*/ requireCjs$1();

	class EditorPrompt extends Base {
	  /**
	   * Start the Inquiry session
	   * @param  {Function} cb      Callback when prompt is done
	   * @return {this}
	   */

	  _run(cb) {
	    this.done = cb;

	    this.editorResult = new Subject();

	    // Open Editor on "line" (Enter Key)
	    const events = observe(this.rl);
	    this.lineSubscription = events.line.subscribe(this.startExternalEditor.bind(this));

	    // Trigger Validation when editor closes
	    const validation = this.handleSubmitEvents(this.editorResult);
	    validation.success.forEach(this.onEnd.bind(this));
	    validation.error.forEach(this.onError.bind(this));

	    // Prevents default from being printed on screen (can look weird with multiple lines)
	    this.currentText = this.opt.default;
	    this.opt.default = null;

	    // Init
	    this.render();

	    return this;
	  }

	  /**
	   * Render the prompt to screen
	   * @return {EditorPrompt} self
	   */

	  render(error) {
	    let bottomContent = '';
	    let message = this.getQuestion();

	    if (this.status === 'answered') {
	      message += chalk.dim('Received');
	    } else {
	      message += chalk.dim('Press <enter> to launch your preferred editor.');
	    }

	    if (error) {
	      bottomContent = chalk.red('>> ') + error;
	    }

	    this.screen.render(message, bottomContent);
	  }

	  /**
	   * Launch $EDITOR on user press enter
	   */

	  startExternalEditor() {
	    // Pause Readline to prevent stdin and stdout from being modified while the editor is showing
	    this.rl.pause();
	    editAsync(this.currentText, this.endExternalEditor.bind(this));
	  }

	  endExternalEditor(error, result) {
	    this.rl.resume();
	    if (error) {
	      this.editorResult.error(error);
	    } else {
	      this.editorResult.next(result);
	    }
	  }

	  onEnd(state) {
	    this.editorResult.unsubscribe();
	    this.lineSubscription.unsubscribe();
	    this.answer = state.value;
	    this.status = 'answered';
	    // Re-render prompt
	    this.render();
	    this.screen.done();
	    this.done(this.answer);
	  }

	  onError(state) {
	    this.render(state.isValid);
	  }
	}

	editor = EditorPrompt;
	return editor;
}

var hasRequiredInquirer;

function requireInquirer () {
	if (hasRequiredInquirer) return inquirer.exports;
	hasRequiredInquirer = 1;
	(function (module) {
		/**
		 * Inquirer.js
		 * A collection of common interactive command line user interfaces.
		 */

		const inquirer = module.exports;

		/**
		 * Client interfaces
		 */

		inquirer.prompts = {};

		inquirer.Separator = requireSeparator();

		inquirer.ui = {
		  BottomBar: requireBottomBar(),
		  Prompt: requirePrompt(),
		};

		/**
		 * Create a new self-contained prompt module.
		 */
		inquirer.createPromptModule = function (opt) {
		  const promptModule = function (questions, answers) {
		    let ui;
		    try {
		      ui = new inquirer.ui.Prompt(promptModule.prompts, opt);
		    } catch (error) {
		      return Promise.reject(error);
		    }
		    const promise = ui.run(questions, answers);

		    // Monkey patch the UI on the promise object so
		    // that it remains publicly accessible.
		    promise.ui = ui;

		    return promise;
		  };

		  promptModule.prompts = {};

		  /**
		   * Register a prompt type
		   * @param {String} name     Prompt type name
		   * @param {Function} prompt Prompt constructor
		   * @return {inquirer}
		   */

		  promptModule.registerPrompt = function (name, prompt) {
		    promptModule.prompts[name] = prompt;
		    return this;
		  };

		  /**
		   * Register the defaults provider prompts
		   */

		  promptModule.restoreDefaultPrompts = function () {
		    this.registerPrompt('list', requireList());
		    this.registerPrompt('input', requireInput());
		    this.registerPrompt('number', requireNumber());
		    this.registerPrompt('confirm', requireConfirm());
		    this.registerPrompt('rawlist', requireRawlist());
		    this.registerPrompt('expand', requireExpand());
		    this.registerPrompt('checkbox', requireCheckbox());
		    this.registerPrompt('password', requirePassword());
		    this.registerPrompt('editor', requireEditor());
		  };

		  promptModule.restoreDefaultPrompts();

		  return promptModule;
		};

		/**
		 * Public CLI helper interface
		 * @param  {Array|Object|Rx.Observable} questions - Questions settings array
		 * @param  {Function} cb - Callback being passed the user answers
		 * @return {inquirer.ui.Prompt}
		 */

		inquirer.prompt = inquirer.createPromptModule();

		// Expose helper functions on the top level for easiest usage by common users
		inquirer.registerPrompt = function (name, prompt) {
		  inquirer.prompt.registerPrompt(name, prompt);
		};

		inquirer.restoreDefaultPrompts = function () {
		  inquirer.prompt.restoreDefaultPrompts();
		}; 
	} (inquirer));
	return inquirer.exports;
}

var hasRequiredDarwinOrLinux;

function requireDarwinOrLinux () {
	if (hasRequiredDarwinOrLinux) return darwinOrLinux;
	hasRequiredDarwinOrLinux = 1;
	var __importDefault = (darwinOrLinux && darwinOrLinux.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(darwinOrLinux, "__esModule", { value: true });
	darwinOrLinux.installCliDarwinOrLinux = installCliDarwinOrLinux;
	const lms_common_1 = /*@__PURE__*/ requireCjs$3();
	const boxen_1 = __importDefault(requireBoxen());
	const chalk_1 = __importDefault(requireSource());
	// import inquirer from "inquirer";
	const inquirer_1 = __importDefault(requireInquirer());
	const node_child_process_1 = require$$4$2;
	const promises_1 = require$$5$1;
	const node_os_1 = __importDefault(require$$6$1);
	const node_path_1 = require$$7$2;
	const shellInstallationInfo = [
	    {
	        shellName: "sh",
	        configFileName: ".profile",
	        commandToAddComment: "echo '' >> ~/.profile && echo '# Added by LM Studio CLI tool (lms)' >> ~/.profile",
	        commandToAddPath: "echo 'export PATH=\"$PATH:<TARGET>\"' >> ~/.profile",
	    },
	    {
	        shellName: "bash",
	        configFileName: ".bashrc",
	        commandToAddComment: "echo '' >> ~/.bashrc && echo '# Added by LM Studio CLI tool (lms)' >> ~/.bashrc",
	        commandToAddPath: "echo 'export PATH=\"$PATH:<TARGET>\"' >> ~/.bashrc",
	    },
	    {
	        shellName: "bash",
	        configFileName: ".bash_profile",
	        commandToAddComment: "echo '' >> ~/.bash_profile && echo '# Added by LM Studio CLI tool (lms)' >> ~/.bash_profile",
	        commandToAddPath: "echo 'export PATH=\"$PATH:<TARGET>\"' >> ~/.bash_profile",
	    },
	    {
	        shellName: "zsh",
	        configFileName: ".zshrc",
	        commandToAddComment: "echo '' >> ~/.zshrc && echo '# Added by LM Studio CLI tool (lms)' >> ~/.zshrc",
	        commandToAddPath: "echo 'export PATH=\"$PATH:<TARGET>\"' >> ~/.zshrc",
	    },
	    {
	        shellName: "fish",
	        configFileName: ".config/fish/config.fish",
	        commandToAddComment: "echo '' >> ~/.config/fish/config.fish && echo '# Added by LM Studio CLI tool (lms)' >> ~/.config/fish/config.fish",
	        commandToAddPath: "echo 'set -gx PATH $PATH <TARGET>' >> ~/.config/fish/config.fish",
	    },
	    {
	        shellName: "csh",
	        configFileName: ".cshrc",
	        commandToAddComment: "echo '' >> ~/.cshrc && echo '# Added by LM Studio CLI tool (lms)' >> ~/.cshrc",
	        commandToAddPath: "echo 'setenv PATH \"$PATH:<TARGET>\"' >> ~/.cshrc",
	    },
	    {
	        shellName: "tcsh",
	        configFileName: ".tcshrc",
	        commandToAddComment: "echo '' >> ~/.tcshrc && echo '# Added by LM Studio CLI tool (lms)' >> ~/.tcshrc",
	        commandToAddPath: "echo 'setenv PATH \"$PATH:<TARGET>\"' >> ~/.tcshrc",
	    },
	];
	async function installCliDarwinOrLinux(path, { skipConfirmation }) {
	    const detectedShells = [];
	    const detectedAlreadyInstalledShells = [];
	    for (const shell of shellInstallationInfo) {
	        const configPath = (0, node_path_1.join)(node_os_1.default.homedir(), shell.configFileName);
	        try {
	            await (0, promises_1.access)(configPath);
	        }
	        catch (e) {
	            continue;
	        }
	        const content = await (0, promises_1.readFile)(configPath, { encoding: "utf8" });
	        if (content.includes(path)) {
	            detectedAlreadyInstalledShells.push(shell);
	        }
	        else {
	            detectedShells.push(shell);
	        }
	    }
	    if (detectedShells.length === 0) {
	        if (detectedAlreadyInstalledShells.length === 0) {
	            throw (0, lms_common_1.makeTitledPrettyError)("Unable to find any shell configuration files", (0, lms_common_1.text) `
          We couldn't find any shell configuration file in your home directory.

          To complete the installation manually, please try to add the following directory to the
          PATH environment variable:

              ${chalk_1.default.yellowBright(path)}
        `);
	        }
	        else {
	            console.info((0, boxen_1.default)((0, lms_common_1.text) `
            ${chalk_1.default.bgGreenBright.black("   Already Installed  ")}

            LM Studio CLI tool is already installed for the following shells:

            ${detectedAlreadyInstalledShells
	                .map(shell => chalk_1.default.cyanBright(`     ${shell.shellName} ${chalk_1.default.gray(`(~/${shell.configFileName})`)}`))
	                .join("\n")}

            If your shell is not listed above, please try to add the following directory to the PATH
            environment variable:

                ${chalk_1.default.yellowBright(path)}

              ${chalk_1.default.gray((0, lms_common_1.text) `
                (i) If you are having trouble running the CLI tool, please open a new terminal. and
                try again.
              `)}
          `, {
	                padding: 1,
	                margin: 1,
	                title: "LM Studio CLI Installation",
	                borderColor: "greenBright",
	            }));
	            return;
	        }
	    }
	    const commandsToRun = [];
	    const commandsToRunFormatted = [];
	    for (const shell of detectedShells) {
	        const command = shell.commandToAddPath.replace("<TARGET>", path);
	        commandsToRun.push(shell.commandToAddComment);
	        commandsToRun.push(command);
	        commandsToRunFormatted.push(`    ${command} ${chalk_1.default.gray(`# for ${shell.shellName}`)}`);
	    }
	    if (!skipConfirmation) {
	        console.info((0, boxen_1.default)((0, lms_common_1.text) `
          We are about to run the following commands to install the LM Studio CLI tool
          (lms).

          ${chalk_1.default.cyanBright(commandsToRunFormatted.join("\n"))}

          It will add the path ${chalk_1.default.greenBright(path)} to the PATH environment variable.
        `, {
	            padding: 1,
	            margin: 1,
	            title: "LM Studio CLI Installation",
	            borderColor: "greenBright",
	        }));
	        const { cont } = await inquirer_1.default.createPromptModule({
	            output: process.stderr,
	        })([
	            {
	                type: "confirm",
	                name: "cont",
	                message: chalk_1.default.yellowBright("Do you want to continue?"),
	                default: false,
	            },
	        ]);
	        if (!cont) {
	            console.info(chalk_1.default.greenBright("Installation aborted. No changes were made."));
	            return;
	        }
	    }
	    (0, node_child_process_1.execSync)(commandsToRun.join(" && "));
	    console.info((0, boxen_1.default)((0, lms_common_1.text) `
        ${chalk_1.default.bgGreenBright.black("   Installation Completed  ")}

          ${chalk_1.default.cyanBright((0, lms_common_1.text) `
            (i) You need to open a new terminal window for these changes to take effect.
          `)}

        The LM Studio CLI tool (lms) has been successfully installed. To test it, run the following
        command in a new terminal window:

            ${chalk_1.default.yellowBright("lms")}
      `, {
	        padding: 1,
	        margin: 1,
	        title: "LM Studio CLI Installation",
	        borderColor: "greenBright",
	    }));
	}
	
	return darwinOrLinux;
}

var win32 = {};

var hasRequiredWin32;

function requireWin32 () {
	if (hasRequiredWin32) return win32;
	hasRequiredWin32 = 1;
	var __importDefault = (win32 && win32.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(win32, "__esModule", { value: true });
	win32.installCliWin32 = installCliWin32;
	const lms_common_1 = /*@__PURE__*/ requireCjs$3();
	const boxen_1 = __importDefault(requireBoxen());
	const chalk_1 = __importDefault(requireSource());
	// import inquirer from "inquirer";
	const inquirer_1 = __importDefault(requireInquirer());
	const node_child_process_1 = require$$4$2;
	const promises_1 = require$$5$1;
	async function getPowershellPath() {
	    // Common PowerShell paths on Windows
	    const possiblePaths = [
	        "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe",
	        "C:\\Windows\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell.exe",
	    ];
	    // Check if PowerShell exists in common paths
	    for (const p of possiblePaths) {
	        try {
	            await (0, promises_1.access)(p);
	            return p; // Return the valid path
	        }
	        catch (e) {
	            continue; // Check the next path
	        }
	    }
	    return "powershell"; // Default to PATH
	}
	async function installCliWin32(path, { skipConfirmation }) {
	    const powershellPath = await getPowershellPath();
	    const previousPath = (0, node_child_process_1.execSync)(`[Environment]::GetEnvironmentVariable('PATH', 'User')`, {
	        shell: powershellPath,
	        encoding: "utf8", // Ensure the output is a string
	    }).trimEnd();
	    if (previousPath.includes(path)) {
	        console.info((0, boxen_1.default)((0, lms_common_1.text) `
          ${chalk_1.default.bgGreenBright.black("   Already Installed  ")}

          The path ${chalk_1.default.greenBright(path)} is already in the PATH environment variable.

            ${chalk_1.default.cyanBright((0, lms_common_1.text) `
              (i) If Windows cannot find the CLI tool, please try again in a new terminal window.
            `)}

            ${chalk_1.default.cyanBright((0, lms_common_1.text) `
              (i) If you are using an integrated terminal in an editor (such as VS Code), please try
              to restart the editor.
            `)}
        `, {
	            padding: 1,
	            margin: 1,
	            title: "LM Studio CLI Installation",
	            borderColor: "greenBright",
	        }));
	        return;
	    }
	    const command = `$path = [Environment]::GetEnvironmentVariable('PATH', 'User');
$path += ";${path}";
[Environment]::SetEnvironmentVariable('PATH', $path, 'User');`;
	    if (!skipConfirmation) {
	        console.info((0, boxen_1.default)((0, lms_common_1.text) `
          We are about to run the following powershell commands to install the LM Studio CLI tool
          (lms).

          ${chalk_1.default.cyanBright("    " + command.split("\n").join("\n    "))}

          It will add the path ${chalk_1.default.greenBright(path)} to the PATH environment variable.
        `, {
	            padding: 1,
	            margin: 1,
	            title: "LM Studio CLI Installation",
	            borderColor: "greenBright",
	        }));
	        const { cont } = await inquirer_1.default.createPromptModule({
	            output: process.stderr,
	        })([
	            {
	                type: "confirm",
	                name: "cont",
	                message: chalk_1.default.yellowBright("Do you want to continue?"),
	                default: false,
	            },
	        ]);
	        if (!cont) {
	            console.info(chalk_1.default.greenBright("Installation aborted. No changes were made."));
	            return;
	        }
	    }
	    (0, node_child_process_1.execSync)(command, { shell: powershellPath });
	    console.info((0, boxen_1.default)((0, lms_common_1.text) `
        ${chalk_1.default.bgGreenBright.black("   Installation Completed  ")}

          ${chalk_1.default.cyanBright((0, lms_common_1.text) `
            (i) You need to open a new terminal window for these changes to take effect.
          `)}

          ${chalk_1.default.cyanBright((0, lms_common_1.text) `
            (i) If you are using an integrated terminal in an editor (such as VS Code), please try
            to restart the editor.
          `)}

        The LM Studio CLI tool (lms) has been successfully installed. To test it, run the following
        command in a new terminal window:

            ${chalk_1.default.yellowBright("lms")}
      `, {
	        padding: 1,
	        margin: 1,
	        title: "LM Studio CLI Installation",
	        borderColor: "greenBright",
	    }));
	}
	
	return win32;
}

var hasRequiredInstallCli;

function requireInstallCli () {
	if (hasRequiredInstallCli) return installCli;
	hasRequiredInstallCli = 1;
	var __importDefault = (installCli && installCli.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(installCli, "__esModule", { value: true });
	installCli.installCli = installCli$1;
	const lms_common_1 = /*@__PURE__*/ requireCjs$3();
	const lms_common_server_1 = /*@__PURE__*/ requireCjs$2();
	const chalk_1 = __importDefault(requireSource());
	const promises_1 = require$$5$1;
	const node_path_1 = require$$7$2;
	const node_process_1 = require$$5$2;
	const darwinOrLinux_js_1 = requireDarwinOrLinux();
	const win32_js_1 = requireWin32();
	async function installCli$1(opts = {}) {
	    const targetPath = (0, node_path_1.join)(`${(0, lms_common_server_1.findLMStudioHome)()}`, `bin`);
	    const pathStat = await (0, promises_1.stat)(targetPath).catch(() => null);
	    if (pathStat === null || pathStat.isDirectory() === false) {
	        throw (0, lms_common_1.makeTitledPrettyError)("Cannot find LM Studio installation", (0, lms_common_1.text) `
        LM Studio CLI (lms) is shipped with the latest version of LM Studio. Please install LM
        Studio first. You can download it from:

            ${chalk_1.default.cyanBright("https://lmstudio.ai/")}

        If you have just installed LM Studio, please run it at least once before running this tool
        again.
      `);
	    }
	    if (node_process_1.platform === "win32") {
	        await (0, win32_js_1.installCliWin32)(targetPath, opts);
	        // await installCliWin32(targetPath);
	    }
	    else if (node_process_1.platform === "linux" || node_process_1.platform === "darwin") {
	        await (0, darwinOrLinux_js_1.installCliDarwinOrLinux)(targetPath, opts);
	    }
	    else {
	        throw (0, lms_common_1.makeTitledPrettyError)(`Your platform (${chalk_1.default.yellowBright(node_process_1.platform)}) is not support by this tool`, (0, lms_common_1.text) `
        To complete the setup manually, please try to add the following directory to the PATH
        environment variable:

            ${chalk_1.default.yellowBright(targetPath)}
      `);
	    }
	}
	
	return installCli;
}

var hasRequiredCjs;

function requireCjs () {
	if (hasRequiredCjs) return cjs$6;
	hasRequiredCjs = 1;
	var __importDefault = (cjs$6 && cjs$6.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(cjs$6, "__esModule", { value: true });
	const lms_common_1 = /*@__PURE__*/ requireCjs$3();
	const chalk_1 = __importDefault(requireSource());
	const index_js_1 = requireInstallCli();
	async function main() {
	    if (process.argv.length !== 3 && process.argv[2] !== "install-cli") {
	        throw (0, lms_common_1.makeTitledPrettyError)("Invalid usage, only the following is supported:", `    ${chalk_1.default.yellowBright("npx lmstudio install-cli")}`);
	    }
	    await (0, index_js_1.installCli)();
	}
	main().catch(e => {
	    if (typeof e.message === "string") {
	        console.error(e.message);
	        return;
	    }
	    throw e;
	});
	
	return cjs$6;
}

var cjsExports = requireCjs();
var index = /*@__PURE__*/getDefaultExportFromCjs(cjsExports);

module.exports = index;
