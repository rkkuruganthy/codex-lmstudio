import { roundTo } from 'round-to';
/**
 * Get the angle in radians between two points
 */
export const getAngle = (origin, target) => {
    const { x: x1, y: y1 } = target;
    const { x: x2, y: y2 } = origin;
    const xDistance = x2 - x1;
    const yDistance = y2 - y1;
    const angle = Math.atan(yDistance / xDistance);
    if (x1 - x2 < 0) {
        return angle + Math.PI;
    }
    return angle;
};
/**
 * Get the distance between two points
 */
export const getDistance = ({ x: x1, y: y1 }, { x: x2, y: y2 }) => Math.hypot(Math.abs(x2 - x1), Math.abs(y2 - y1));
/**
 * Generate a grid
 */
export const grid = ({ x, y, marginX, marginY, breakAt, vertical = false, }) => {
    if (breakAt <= 0) {
        throw new Error('tiny-toolkit - grid - breakAt: Needs to be a positive integer');
    }
    return (index) => {
        const row = Math.floor(index / breakAt);
        const column = index % breakAt;
        return {
            x: x + (vertical ? row : column) * marginX,
            y: y + (vertical ? column : row) * marginY,
            // If vertical, it's not possible to know if the column is the final one since the grid is potentially infinite
            isFinalColumn: vertical ? false : (index + 1) % breakAt === 0,
        };
    };
};
/**
 * Create a function to place items on a line
 */
export const line = ({ start, margin }) => (index) => {
    return start + margin * index;
};
/**
 * Normalize range
 */
export const normalizeRange = (minimum, maximum) => {
    const delta = maximum - minimum;
    return (inRange) => (inRange - minimum) / delta;
};
/**
 * Returns a function that takes a 0-1 range and transforms it to a value between startValue and endValue
 */
export function deNormalizeRange(startValue, endValue) {
    const delta = startValue - endValue;
    /**
     * Value should be between 0 and 1
     */
    return (value) => {
        return startValue - value * delta;
    };
}
/**
 * Convert degrees to radians
 */
export const toRadians = (degrees) => degrees * (Math.PI / 180);
/**
 * Convert radians to degrees
 */
export const toDegrees = (radians) => radians * (180 / Math.PI);
/**
 * Check if two rectangles are overlapping.
 */
export const isColliding = (rectangle1, rectangle2) => {
    if (rectangle1.x > rectangle2.x + rectangle2.width ||
        rectangle2.x > rectangle1.x + rectangle1.width)
        return false;
    if (rectangle1.y > rectangle2.y + rectangle2.height ||
        rectangle2.y > rectangle1.y + rectangle1.height)
        return false;
    return true;
};
/**
 * Check how much two rectangles are overlapping
 */
export const getOverlappingArea = (rectangle1, rectangle2) => {
    if (!isColliding(rectangle1, rectangle2)) {
        return 0;
    }
    const minX = Math.max(rectangle1.x, rectangle2.x);
    const maxX = Math.min(rectangle1.x + rectangle1.width, rectangle2.x + rectangle2.width);
    const dX = maxX - minX;
    const minY = Math.max(rectangle1.y, rectangle2.y);
    const maxY = Math.min(rectangle1.y + rectangle1.height, rectangle2.y + rectangle2.height);
    const dY = maxY - minY;
    return dX * dY;
};
/**
 * Convert a tree structure into a flat list
 * @param childrenField The field on the `node` that contains the child nodes
 */
export const treeToList = (node, childrenField = 'children') => {
    if (!node[childrenField]) {
        return [node];
    }
    return node[childrenField]
        .flatMap((childNode) => treeToList(childNode, childrenField))
        .concat(node);
};
/**
 * Make the first letter in a string uppercase.
 *
 * Note: Doesn't handle internationalization
 */
export const capitalize = (string) => {
    return string.charAt(0).toUpperCase() + string.slice(1);
};
export const getDirection = (origin, target) => {
    return getDirectionFromAngle(getAngle(origin, target));
};
/**
 * Capped at 5 decimal points
 *
 * @param angle - In radians
 */
export const getDirectionFromAngle = (angle) => {
    const x = roundTo(Math.cos(angle), 5);
    const y = roundTo(Math.sin(angle), 5);
    return { x, y };
};
/*
const noDiagonals = [
  // { x: x - 1, y: y + 1 },
  { x, y: y + 1 },
  // { x: x + 1, y: y + 1 },
  { x: x - 1, y },
  { x: x + 1, y },
  // { x: x - 1, y: y - 1 },
  { x, y: y - 1 },
  // { x: x + 1, y: y - 1 },
]
*/
/*
  [4][0][5],
  [3][x][1],
  [7][2][6],
*/
export const getBorderingPoints = ({ x, y }) => [
    { x, y: y - 1 },
    { x: x + 1, y },
    { x, y: y + 1 },
    { x: x - 1, y },
    { x: x - 1, y: y - 1 },
    { x: x + 1, y: y - 1 },
    { x: x + 1, y: y + 1 },
    { x: x - 1, y: y + 1 },
];
/**
 * Get the next item in a list. Loops back to the first item after the last one.
 * @param currentItem - An item in the list
 * @param list
 */
export const getNextItem = (currentItem, list) => {
    const currentIndex = list.indexOf(currentItem);
    if (currentIndex === -1) {
        throw new Error('getNextItem: Item does not exist in the list!');
    }
    const nextIndex = (currentIndex + 1) % list.length;
    return list[nextIndex];
};
export const getPreviousItem = (currentItem, list) => {
    const currentIndex = list.indexOf(currentItem);
    if (currentIndex === -1) {
        throw new Error('getPreviousItem: Item does not exist in the list!');
    }
    const previousIndex = currentIndex - 1 < 0 ? list.length - 1 : currentIndex - 1;
    return list[previousIndex];
};
export const useIndex = (maximum, options = {}) => {
    const { loop = true } = options;
    const minimum = 0;
    return (currentIndex, value) => {
        if (currentIndex > maximum - 1 || currentIndex < 0) {
            console.warn(`useIndex: currentIndex: "${currentIndex}" passed is out of bounds`);
            return currentIndex;
        }
        const newValue = currentIndex + value;
        if (newValue > maximum - 1) {
            return loop ? Math.abs(newValue - maximum) : currentIndex;
        }
        if (newValue < minimum) {
            return loop ? maximum + newValue : currentIndex;
        }
        return newValue;
    };
};
export const create2dArrayWithDistanceToCenter = (width, height) => {
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const coordinates = [];
    for (let x = 0; x < width; x += 1) {
        for (let y = 0; y < height; y += 1) {
            const xDistance = Math.abs(x - halfWidth);
            const yDistance = Math.abs(y - halfHeight);
            const distanceToCenter = Math.sqrt(xDistance ** 2 + yDistance ** 2);
            coordinates.push({ distanceToCenter, x, y });
        }
    }
    return coordinates;
};
/**
 * Remove an item from a list by mutating the list
 *
 * @param item
 * @param list
 */
export const removeFromList = (item, list) => {
    const index = list.indexOf(item);
    list.splice(index, 1);
};
export const times2d = (xTimes, yTimes, callback) => {
    const result = [];
    let index = 0;
    for (let x = 0; x < xTimes; x++) {
        for (let y = 0; y < yTimes; y++) {
            result.push(callback(x, y, index));
            index += 1;
        }
    }
    return result;
};
/**
 * Based on a point, get a surrounding rectangle with the point in the middle
 */
export const getSurroundingRectangle = ({ point, width, height, }) => {
    const x = point.x - Math.floor(width / 2);
    const y = point.y - Math.floor(height / 2);
    return {
        x,
        y,
        width,
        height,
    };
};
/**
 * Clamp a value to a target value
 *
 * clampToTarget(63, )
 */
export const clampToTarget = (value, target) => Math.floor(value / target);
/**
 * Get the average of a list of numbers
 */
export const getAverage = (values) => {
    if (values.length === 0) {
        return 0;
    }
    let sum = 0;
    for (const value of values) {
        sum += value;
    }
    return sum / values.length;
};
export const getNameFromFilename = (fileName) => fileName.slice(0, fileName.lastIndexOf('.'));
export const insertString = (string, toInsert, position) => `${string.slice(0, position)}${toInsert}${string.slice(position, string.length)}`;
const MAX_INT32 = 2_147_483_647;
export const getRandomInt = () => Math.floor(Math.random() * MAX_INT32);
export const findDuplicates = (list) => {
    const visited = new Set();
    const duplicates = new Set();
    for (const item of list) {
        if (visited.has(item)) {
            duplicates.add(item);
        }
        else {
            visited.add(item);
        }
    }
    return Array.from(duplicates);
};
/**
 * Convert map to a list of key value pairs
 */
export function mapToEntries(map) {
    return Array.from(map, ([key, value]) => [key, value]);
}
